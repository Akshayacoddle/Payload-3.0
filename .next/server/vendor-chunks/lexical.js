"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lexical";
exports.ids = ["vendor-chunks/lexical"];
exports.modules = {

/***/ "(ssr)/./node_modules/lexical/Lexical.dev.mjs":
/*!**********************************************!*\
  !*** ./node_modules/lexical/Lexical.dev.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addUpdateTag: () => (/* binding */ $addUpdateTag),\n/* harmony export */   $applyNodeReplacement: () => (/* binding */ $applyNodeReplacement),\n/* harmony export */   $copyNode: () => (/* binding */ $copyNode),\n/* harmony export */   $createLineBreakNode: () => (/* binding */ $createLineBreakNode),\n/* harmony export */   $createNodeSelection: () => (/* binding */ $createNodeSelection),\n/* harmony export */   $createParagraphNode: () => (/* binding */ $createParagraphNode),\n/* harmony export */   $createPoint: () => (/* binding */ $createPoint),\n/* harmony export */   $createRangeSelection: () => (/* binding */ $createRangeSelection),\n/* harmony export */   $createRangeSelectionFromDom: () => (/* binding */ $createRangeSelectionFromDom),\n/* harmony export */   $createTabNode: () => (/* binding */ $createTabNode),\n/* harmony export */   $createTextNode: () => (/* binding */ $createTextNode),\n/* harmony export */   $getAdjacentNode: () => (/* binding */ $getAdjacentNode),\n/* harmony export */   $getCharacterOffsets: () => (/* binding */ $getCharacterOffsets),\n/* harmony export */   $getEditor: () => (/* binding */ $getEditor),\n/* harmony export */   $getNearestNodeFromDOMNode: () => (/* binding */ $getNearestNodeFromDOMNode),\n/* harmony export */   $getNearestRootOrShadowRoot: () => (/* binding */ $getNearestRootOrShadowRoot),\n/* harmony export */   $getNodeByKey: () => (/* binding */ $getNodeByKey),\n/* harmony export */   $getPreviousSelection: () => (/* binding */ $getPreviousSelection),\n/* harmony export */   $getRoot: () => (/* binding */ $getRoot),\n/* harmony export */   $getSelection: () => (/* binding */ $getSelection),\n/* harmony export */   $getTextContent: () => (/* binding */ $getTextContent),\n/* harmony export */   $hasAncestor: () => (/* binding */ $hasAncestor),\n/* harmony export */   $hasUpdateTag: () => (/* binding */ $hasUpdateTag),\n/* harmony export */   $insertNodes: () => (/* binding */ $insertNodes),\n/* harmony export */   $isBlockElementNode: () => (/* binding */ $isBlockElementNode),\n/* harmony export */   $isDecoratorNode: () => (/* binding */ $isDecoratorNode),\n/* harmony export */   $isElementNode: () => (/* binding */ $isElementNode),\n/* harmony export */   $isInlineElementOrDecoratorNode: () => (/* binding */ $isInlineElementOrDecoratorNode),\n/* harmony export */   $isLeafNode: () => (/* binding */ $isLeafNode),\n/* harmony export */   $isLineBreakNode: () => (/* binding */ $isLineBreakNode),\n/* harmony export */   $isNodeSelection: () => (/* binding */ $isNodeSelection),\n/* harmony export */   $isParagraphNode: () => (/* binding */ $isParagraphNode),\n/* harmony export */   $isRangeSelection: () => (/* binding */ $isRangeSelection),\n/* harmony export */   $isRootNode: () => (/* binding */ $isRootNode),\n/* harmony export */   $isRootOrShadowRoot: () => (/* binding */ $isRootOrShadowRoot),\n/* harmony export */   $isTabNode: () => (/* binding */ $isTabNode),\n/* harmony export */   $isTextNode: () => (/* binding */ $isTextNode),\n/* harmony export */   $nodesOfType: () => (/* binding */ $nodesOfType),\n/* harmony export */   $normalizeSelection__EXPERIMENTAL: () => (/* binding */ $normalizeSelection),\n/* harmony export */   $parseSerializedNode: () => (/* binding */ $parseSerializedNode),\n/* harmony export */   $selectAll: () => (/* binding */ $selectAll),\n/* harmony export */   $setCompositionKey: () => (/* binding */ $setCompositionKey),\n/* harmony export */   $setSelection: () => (/* binding */ $setSelection),\n/* harmony export */   $splitNode: () => (/* binding */ $splitNode),\n/* harmony export */   ArtificialNode__DO_NOT_USE: () => (/* binding */ ArtificialNode__DO_NOT_USE),\n/* harmony export */   BLUR_COMMAND: () => (/* binding */ BLUR_COMMAND),\n/* harmony export */   CAN_REDO_COMMAND: () => (/* binding */ CAN_REDO_COMMAND),\n/* harmony export */   CAN_UNDO_COMMAND: () => (/* binding */ CAN_UNDO_COMMAND),\n/* harmony export */   CLEAR_EDITOR_COMMAND: () => (/* binding */ CLEAR_EDITOR_COMMAND),\n/* harmony export */   CLEAR_HISTORY_COMMAND: () => (/* binding */ CLEAR_HISTORY_COMMAND),\n/* harmony export */   CLICK_COMMAND: () => (/* binding */ CLICK_COMMAND),\n/* harmony export */   COMMAND_PRIORITY_CRITICAL: () => (/* binding */ COMMAND_PRIORITY_CRITICAL),\n/* harmony export */   COMMAND_PRIORITY_EDITOR: () => (/* binding */ COMMAND_PRIORITY_EDITOR),\n/* harmony export */   COMMAND_PRIORITY_HIGH: () => (/* binding */ COMMAND_PRIORITY_HIGH),\n/* harmony export */   COMMAND_PRIORITY_LOW: () => (/* binding */ COMMAND_PRIORITY_LOW),\n/* harmony export */   COMMAND_PRIORITY_NORMAL: () => (/* binding */ COMMAND_PRIORITY_NORMAL),\n/* harmony export */   CONTROLLED_TEXT_INSERTION_COMMAND: () => (/* binding */ CONTROLLED_TEXT_INSERTION_COMMAND),\n/* harmony export */   COPY_COMMAND: () => (/* binding */ COPY_COMMAND),\n/* harmony export */   CUT_COMMAND: () => (/* binding */ CUT_COMMAND),\n/* harmony export */   DELETE_CHARACTER_COMMAND: () => (/* binding */ DELETE_CHARACTER_COMMAND),\n/* harmony export */   DELETE_LINE_COMMAND: () => (/* binding */ DELETE_LINE_COMMAND),\n/* harmony export */   DELETE_WORD_COMMAND: () => (/* binding */ DELETE_WORD_COMMAND),\n/* harmony export */   DRAGEND_COMMAND: () => (/* binding */ DRAGEND_COMMAND),\n/* harmony export */   DRAGOVER_COMMAND: () => (/* binding */ DRAGOVER_COMMAND),\n/* harmony export */   DRAGSTART_COMMAND: () => (/* binding */ DRAGSTART_COMMAND),\n/* harmony export */   DROP_COMMAND: () => (/* binding */ DROP_COMMAND),\n/* harmony export */   DecoratorNode: () => (/* binding */ DecoratorNode),\n/* harmony export */   ElementNode: () => (/* binding */ ElementNode),\n/* harmony export */   FOCUS_COMMAND: () => (/* binding */ FOCUS_COMMAND),\n/* harmony export */   FORMAT_ELEMENT_COMMAND: () => (/* binding */ FORMAT_ELEMENT_COMMAND),\n/* harmony export */   FORMAT_TEXT_COMMAND: () => (/* binding */ FORMAT_TEXT_COMMAND),\n/* harmony export */   INDENT_CONTENT_COMMAND: () => (/* binding */ INDENT_CONTENT_COMMAND),\n/* harmony export */   INSERT_LINE_BREAK_COMMAND: () => (/* binding */ INSERT_LINE_BREAK_COMMAND),\n/* harmony export */   INSERT_PARAGRAPH_COMMAND: () => (/* binding */ INSERT_PARAGRAPH_COMMAND),\n/* harmony export */   INSERT_TAB_COMMAND: () => (/* binding */ INSERT_TAB_COMMAND),\n/* harmony export */   KEY_ARROW_DOWN_COMMAND: () => (/* binding */ KEY_ARROW_DOWN_COMMAND),\n/* harmony export */   KEY_ARROW_LEFT_COMMAND: () => (/* binding */ KEY_ARROW_LEFT_COMMAND),\n/* harmony export */   KEY_ARROW_RIGHT_COMMAND: () => (/* binding */ KEY_ARROW_RIGHT_COMMAND),\n/* harmony export */   KEY_ARROW_UP_COMMAND: () => (/* binding */ KEY_ARROW_UP_COMMAND),\n/* harmony export */   KEY_BACKSPACE_COMMAND: () => (/* binding */ KEY_BACKSPACE_COMMAND),\n/* harmony export */   KEY_DELETE_COMMAND: () => (/* binding */ KEY_DELETE_COMMAND),\n/* harmony export */   KEY_DOWN_COMMAND: () => (/* binding */ KEY_DOWN_COMMAND),\n/* harmony export */   KEY_ENTER_COMMAND: () => (/* binding */ KEY_ENTER_COMMAND),\n/* harmony export */   KEY_ESCAPE_COMMAND: () => (/* binding */ KEY_ESCAPE_COMMAND),\n/* harmony export */   KEY_MODIFIER_COMMAND: () => (/* binding */ KEY_MODIFIER_COMMAND),\n/* harmony export */   KEY_SPACE_COMMAND: () => (/* binding */ KEY_SPACE_COMMAND),\n/* harmony export */   KEY_TAB_COMMAND: () => (/* binding */ KEY_TAB_COMMAND),\n/* harmony export */   LineBreakNode: () => (/* binding */ LineBreakNode),\n/* harmony export */   MOVE_TO_END: () => (/* binding */ MOVE_TO_END),\n/* harmony export */   MOVE_TO_START: () => (/* binding */ MOVE_TO_START),\n/* harmony export */   OUTDENT_CONTENT_COMMAND: () => (/* binding */ OUTDENT_CONTENT_COMMAND),\n/* harmony export */   PASTE_COMMAND: () => (/* binding */ PASTE_COMMAND),\n/* harmony export */   ParagraphNode: () => (/* binding */ ParagraphNode),\n/* harmony export */   REDO_COMMAND: () => (/* binding */ REDO_COMMAND),\n/* harmony export */   REMOVE_TEXT_COMMAND: () => (/* binding */ REMOVE_TEXT_COMMAND),\n/* harmony export */   RootNode: () => (/* binding */ RootNode),\n/* harmony export */   SELECTION_CHANGE_COMMAND: () => (/* binding */ SELECTION_CHANGE_COMMAND),\n/* harmony export */   SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => (/* binding */ SELECTION_INSERT_CLIPBOARD_NODES_COMMAND),\n/* harmony export */   SELECT_ALL_COMMAND: () => (/* binding */ SELECT_ALL_COMMAND),\n/* harmony export */   TabNode: () => (/* binding */ TabNode),\n/* harmony export */   TextNode: () => (/* binding */ TextNode),\n/* harmony export */   UNDO_COMMAND: () => (/* binding */ UNDO_COMMAND),\n/* harmony export */   createCommand: () => (/* binding */ createCommand),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   getNearestEditorFromDOMNode: () => (/* binding */ getNearestEditorFromDOMNode),\n/* harmony export */   isBlockDomNode: () => (/* binding */ isBlockDomNode),\n/* harmony export */   isCurrentlyReadOnlyMode: () => (/* binding */ isCurrentlyReadOnlyMode),\n/* harmony export */   isHTMLAnchorElement: () => (/* binding */ isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* binding */ isInlineDomNode),\n/* harmony export */   isSelectionCapturedInDecoratorInput: () => (/* binding */ isSelectionCapturedInDecoratorInput),\n/* harmony export */   isSelectionWithinEditor: () => (/* binding */ isSelectionWithinEditor)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction $flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore internal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  $flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(key, altKey, ctrlKey, metaKey) {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(key, shiftKey) {\n  return isReturn(key) && !shiftKey;\n}\nfunction isLineBreak(key, shiftKey) {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(key, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\nfunction isDeleteWordBackward(key, altKey, ctrlKey) {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(key, altKey, ctrlKey) {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(key, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\nfunction isDeleteLineForward(key, metaKey) {\n  return IS_APPLE && metaKey && isDelete(key);\n}\nfunction isDeleteBackward(key, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || key.toLowerCase() === 'h' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\nfunction isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || key.toLowerCase() === 'd' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\nfunction isUndo(key, shiftKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(key, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return key.toLowerCase() === 'y' && ctrlKey || key.toLowerCase() === 'z' && ctrlKey && shiftKey;\n}\nfunction isCopy(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(key) {\n  return key === 'ArrowLeft';\n}\nfunction isArrowRight(key) {\n  return key === 'ArrowRight';\n}\nfunction isArrowUp(key) {\n  return key === 'ArrowUp';\n}\nfunction isArrowDown(key) {\n  return key === 'ArrowDown';\n}\nfunction isMoveBackward(key, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(key, ctrlKey, altKey, metaKey) {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(key, ctrlKey, metaKey) {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(key, ctrlKey, metaKey) {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(key) {\n  return key === ' ';\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(key) {\n  return key === 'Enter';\n}\nfunction isBackspace(key) {\n  return key === 'Backspace';\n}\nfunction isEscape(key) {\n  return key === 'Escape';\n}\nfunction isDelete(key) {\n  return key === 'Delete';\n}\nfunction isSelectAll(key, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  // @ts-expect-error\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isRootNode(node) || $isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], dom, insertDOM);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {\n      subTreeTextFormat = node.getFormat();\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileParagraphFormat(element) {\n  if ($isParagraphNode(element) && subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat) {\n    element.setTextFormat(subTreeTextFormat);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  $reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  reconcileParagraphFormat(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n  subTreeTextFormat = null;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFrstChildKey);\n    if (subTreeTextFormat === null && $isTextNode(nextChildNode)) {\n      subTreeTextFormat = nextChildNode.getFormat();\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          $reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {\n      subTreeTextFormat = node.getFormat();\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            const lastNode = anchor.getNode();\n            if (lastNode instanceof ParagraphNode && lastNode.getChildrenSize() === 0) {\n              selection.format = lastNode.getTextFormat();\n            } else {\n              selection.format = 0;\n            }\n            selection.style = '';\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType;\n          // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNodeText = selection.anchor.getNode().getTextContent();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    key,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    throw Error(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  // @ts-expect-error: internal field\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!$isElementNode(node)) {\n          throw Error(`Children of root nodes must be elements`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor;\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      if ($isParagraphNode(latestNode) && $isParagraphNode(mutableNode)) {\n        mutableNode.__textFormat = latestNode.__textFormat;\n      }\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n\n    // @ts-expect-error\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChild(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChild(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n/** @noInheritDoc */\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style !== undefined && node.style.whiteSpace !== undefined && node.style.whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    const newNode = new TabNode(node.__key);\n    // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    this.insertText('');\n  }\n\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ('__language' in firstBlock && $isElementNode(firstBlock)) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isLI = node => '__value' in node && '__checked' in node;\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || isLI(firstBlock));\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (isLI(insertedParagraph) || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be an ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset);\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    throw Error(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = $splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @noInheritDoc */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__textFormat = 0;\n  }\n  static getType() {\n    return 'paragraph';\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    node.setTextFormat(serializedNode.textFormat);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      textFormat: this.getTextFormat(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType = Object.prototype.hasOwnProperty.call(klass, 'getType') && klass.getType();\n        const name = klass.name;\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener) {\n    let registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    let klassToMutate = klass;\n    let replaceKlass = null;\n    while (replaceKlass = registeredNode.replaceWithKlass) {\n      klassToMutate = replaceKlass;\n      registeredNode = this._nodes.get(replaceKlass.getType());\n      if (registeredNode === undefined) {\n        {\n          throw Error(`Node ${replaceKlass.name} has not been registered. Ensure node has been passed to createEditor.`);\n        }\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    $flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    $commitPendingUpdates(this);\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVCQUF1Qiw0RUFBNEUsOEJBQThCO0FBQ3RMO0FBQ0EsTUFBTTtBQUNOO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsUUFBUSxJQUFJLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJDQUEyQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQ0FBMkM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsd0JBQXdCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTSxVQUFVLFlBQVksaUNBQWlDLGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUIscUJBQXFCLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTSx5QkFBeUIsT0FBTztBQUNwRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQ0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Qsb0NBQW9DO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkYsaUVBQWlFLG1DQUFtQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlxRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5tanM/YzYwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWFuZCh0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZVxuICB9IDtcbn1cbmNvbnN0IFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVElPTl9DSEFOR0VfQ09NTUFORCcpO1xuY29uc3QgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQnKTtcbmNvbnN0IENMSUNLX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTElDS19DT01NQU5EJyk7XG5jb25zdCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfTElORV9CUkVBS19DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQnKTtcbmNvbnN0IENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCcpO1xuY29uc3QgUEFTVEVfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1BBU1RFX0NPTU1BTkQnKTtcbmNvbnN0IFJFTU9WRV9URVhUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRU1PVkVfVEVYVF9DT01NQU5EJyk7XG5jb25zdCBERUxFVEVfV09SRF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnREVMRVRFX1dPUkRfQ09NTUFORCcpO1xuY29uc3QgREVMRVRFX0xJTkVfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RFTEVURV9MSU5FX0NPTU1BTkQnKTtcbmNvbnN0IEZPUk1BVF9URVhUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT1JNQVRfVEVYVF9DT01NQU5EJyk7XG5jb25zdCBVTkRPX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdVTkRPX0NPTU1BTkQnKTtcbmNvbnN0IFJFRE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1JFRE9fQ09NTUFORCcpO1xuY29uc3QgS0VZX0RPV05fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWURPV05fQ09NTUFORCcpO1xuY29uc3QgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQVJST1dfUklHSFRfQ09NTUFORCcpO1xuY29uc3QgTU9WRV9UT19FTkQgPSBjcmVhdGVDb21tYW5kKCdNT1ZFX1RPX0VORCcpO1xuY29uc3QgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19MRUZUX0NPTU1BTkQnKTtcbmNvbnN0IE1PVkVfVE9fU1RBUlQgPSBjcmVhdGVDb21tYW5kKCdNT1ZFX1RPX1NUQVJUJyk7XG5jb25zdCBLRVlfQVJST1dfVVBfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19VUF9DT01NQU5EJyk7XG5jb25zdCBLRVlfQVJST1dfRE9XTl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0FSUk9XX0RPV05fQ09NTUFORCcpO1xuY29uc3QgS0VZX0VOVEVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfRU5URVJfQ09NTUFORCcpO1xuY29uc3QgS0VZX1NQQUNFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfU1BBQ0VfQ09NTUFORCcpO1xuY29uc3QgS0VZX0JBQ0tTUEFDRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0JBQ0tTUEFDRV9DT01NQU5EJyk7XG5jb25zdCBLRVlfRVNDQVBFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfRVNDQVBFX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9ERUxFVEVfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9ERUxFVEVfQ09NTUFORCcpO1xuY29uc3QgS0VZX1RBQl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX1RBQl9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfVEFCX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfVEFCX0NPTU1BTkQnKTtcbmNvbnN0IElOREVOVF9DT05URU5UX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTkRFTlRfQ09OVEVOVF9DT01NQU5EJyk7XG5jb25zdCBPVVRERU5UX0NPTlRFTlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ09VVERFTlRfQ09OVEVOVF9DT01NQU5EJyk7XG5jb25zdCBEUk9QX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUk9QX0NPTU1BTkQnKTtcbmNvbnN0IEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT1JNQVRfRUxFTUVOVF9DT01NQU5EJyk7XG5jb25zdCBEUkFHU1RBUlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RSQUdTVEFSVF9DT01NQU5EJyk7XG5jb25zdCBEUkFHT1ZFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJBR09WRVJfQ09NTUFORCcpO1xuY29uc3QgRFJBR0VORF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJBR0VORF9DT01NQU5EJyk7XG5jb25zdCBDT1BZX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDT1BZX0NPTU1BTkQnKTtcbmNvbnN0IENVVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ1VUX0NPTU1BTkQnKTtcbmNvbnN0IFNFTEVDVF9BTExfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVF9BTExfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfRURJVE9SX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTEVBUl9FRElUT1JfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfSElTVE9SWV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0xFQVJfSElTVE9SWV9DT01NQU5EJyk7XG5jb25zdCBDQU5fUkVET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0FOX1JFRE9fQ09NTUFORCcpO1xuY29uc3QgQ0FOX1VORE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NBTl9VTkRPX0NPTU1BTkQnKTtcbmNvbnN0IEZPQ1VTX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT0NVU19DT01NQU5EJyk7XG5jb25zdCBCTFVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdCTFVSX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9NT0RJRklFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX01PRElGSUVSX0NPTU1BTkQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuY29uc3QgSVNfQVBQTEUgPSBDQU5fVVNFX0RPTSAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0ZJUkVGT1ggPSBDQU5fVVNFX0RPTSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCA9IENBTl9VU0VfRE9NICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIGV4cG9ydCBjb25zdCBjYW5Vc2VUZXh0SW5wdXRFdmVudDogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlO1xuXG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IENBTl9VU0VfRE9NICYmIElTX0FORFJPSUQgJiYgSVNfQ0hST01FO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUID0gQ0FOX1VTRV9ET00gJiYgL0FwcGxlV2ViS2l0XFwvW1xcZC5dKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhSVNfQ0hST01FO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gRE9NXG5jb25zdCBET01fRUxFTUVOVF9UWVBFID0gMTtcbmNvbnN0IERPTV9URVhUX1RZUEUgPSAzO1xuXG4vLyBSZWNvbmNpbGluZ1xuY29uc3QgTk9fRElSVFlfTk9ERVMgPSAwO1xuY29uc3QgSEFTX0RJUlRZX05PREVTID0gMTtcbmNvbnN0IEZVTExfUkVDT05DSUxFID0gMjtcblxuLy8gVGV4dCBub2RlIG1vZGVzXG5jb25zdCBJU19OT1JNQUwgPSAwO1xuY29uc3QgSVNfVE9LRU4gPSAxO1xuY29uc3QgSVNfU0VHTUVOVEVEID0gMjtcbi8vIElTX0lORVJUID0gM1xuXG4vLyBUZXh0IG5vZGUgZm9ybWF0dGluZ1xuY29uc3QgSVNfQk9MRCA9IDE7XG5jb25zdCBJU19JVEFMSUMgPSAxIDw8IDE7XG5jb25zdCBJU19TVFJJS0VUSFJPVUdIID0gMSA8PCAyO1xuY29uc3QgSVNfVU5ERVJMSU5FID0gMSA8PCAzO1xuY29uc3QgSVNfQ09ERSA9IDEgPDwgNDtcbmNvbnN0IElTX1NVQlNDUklQVCA9IDEgPDwgNTtcbmNvbnN0IElTX1NVUEVSU0NSSVBUID0gMSA8PCA2O1xuY29uc3QgSVNfSElHSExJR0hUID0gMSA8PCA3O1xuY29uc3QgSVNfQUxMX0ZPUk1BVFRJTkcgPSBJU19CT0xEIHwgSVNfSVRBTElDIHwgSVNfU1RSSUtFVEhST1VHSCB8IElTX1VOREVSTElORSB8IElTX0NPREUgfCBJU19TVUJTQ1JJUFQgfCBJU19TVVBFUlNDUklQVCB8IElTX0hJR0hMSUdIVDtcblxuLy8gVGV4dCBub2RlIGRldGFpbHNcbmNvbnN0IElTX0RJUkVDVElPTkxFU1MgPSAxO1xuY29uc3QgSVNfVU5NRVJHRUFCTEUgPSAxIDw8IDE7XG5cbi8vIEVsZW1lbnQgbm9kZSBmb3JtYXR0aW5nXG5jb25zdCBJU19BTElHTl9MRUZUID0gMTtcbmNvbnN0IElTX0FMSUdOX0NFTlRFUiA9IDI7XG5jb25zdCBJU19BTElHTl9SSUdIVCA9IDM7XG5jb25zdCBJU19BTElHTl9KVVNUSUZZID0gNDtcbmNvbnN0IElTX0FMSUdOX1NUQVJUID0gNTtcbmNvbnN0IElTX0FMSUdOX0VORCA9IDY7XG5cbi8vIFJlY29uY2lsaWF0aW9uXG5jb25zdCBOT05fQlJFQUtJTkdfU1BBQ0UgPSAnXFx1MDBBMCc7XG5jb25zdCBaRVJPX1dJRFRIX1NQQUNFID0gJ1xcdTIwMGInO1xuXG4vLyBGb3IgaU9TL1NhZmFyaSB3ZSB1c2UgYSBub24gYnJlYWtpbmcgc3BhY2UsIG90aGVyd2lzZSB0aGUgY3Vyc29yIGFwcGVhcnNcbi8vIG92ZXJsYXBwaW5nIHRoZSBjb21wb3NlZCB0ZXh0LlxuY29uc3QgQ09NUE9TSVRJT05fU1VGRklYID0gSVNfU0FGQVJJIHx8IElTX0lPUyB8fCBJU19BUFBMRV9XRUJLSVQgPyBOT05fQlJFQUtJTkdfU1BBQ0UgOiBaRVJPX1dJRFRIX1NQQUNFO1xuY29uc3QgRE9VQkxFX0xJTkVfQlJFQUsgPSAnXFxuXFxuJztcblxuLy8gRm9yIEZGLCB3ZSBuZWVkIHRvIHVzZSBhIG5vbi1icmVha2luZyBzcGFjZSwgb3IgaXQgZ2V0cyBjb21wb3NpdGlvblxuLy8gaW4gYSBzdHVjayBzdGF0ZS5cbmNvbnN0IENPTVBPU0lUSU9OX1NUQVJUX0NIQVIgPSBJU19GSVJFRk9YID8gTk9OX0JSRUFLSU5HX1NQQUNFIDogQ09NUE9TSVRJT05fU1VGRklYO1xuY29uc3QgUlRMID0gJ1xcdTA1OTEtXFx1MDdGRlxcdUZCMUQtXFx1RkRGRFxcdUZFNzAtXFx1RkVGQyc7XG5jb25zdCBMVFIgPSAnQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2JyArICdcXHUwMEY4LVxcdTAyQjhcXHUwMzAwLVxcdTA1OTBcXHUwODAwLVxcdTFGRkZcXHUyMDBFXFx1MkMwMC1cXHVGQjFDJyArICdcXHVGRTAwLVxcdUZFNkZcXHVGRUZELVxcdUZGRkYnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcbmNvbnN0IFJUTF9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bXicgKyBMVFIgKyAnXSpbJyArIFJUTCArICddJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcbmNvbnN0IExUUl9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bXicgKyBSVEwgKyAnXSpbJyArIExUUiArICddJyk7XG5jb25zdCBURVhUX1RZUEVfVE9fRk9STUFUID0ge1xuICBib2xkOiBJU19CT0xELFxuICBjb2RlOiBJU19DT0RFLFxuICBoaWdobGlnaHQ6IElTX0hJR0hMSUdIVCxcbiAgaXRhbGljOiBJU19JVEFMSUMsXG4gIHN0cmlrZXRocm91Z2g6IElTX1NUUklLRVRIUk9VR0gsXG4gIHN1YnNjcmlwdDogSVNfU1VCU0NSSVBULFxuICBzdXBlcnNjcmlwdDogSVNfU1VQRVJTQ1JJUFQsXG4gIHVuZGVybGluZTogSVNfVU5ERVJMSU5FXG59O1xuY29uc3QgREVUQUlMX1RZUEVfVE9fREVUQUlMID0ge1xuICBkaXJlY3Rpb25sZXNzOiBJU19ESVJFQ1RJT05MRVNTLFxuICB1bm1lcmdlYWJsZTogSVNfVU5NRVJHRUFCTEVcbn07XG5jb25zdCBFTEVNRU5UX1RZUEVfVE9fRk9STUFUID0ge1xuICBjZW50ZXI6IElTX0FMSUdOX0NFTlRFUixcbiAgZW5kOiBJU19BTElHTl9FTkQsXG4gIGp1c3RpZnk6IElTX0FMSUdOX0pVU1RJRlksXG4gIGxlZnQ6IElTX0FMSUdOX0xFRlQsXG4gIHJpZ2h0OiBJU19BTElHTl9SSUdIVCxcbiAgc3RhcnQ6IElTX0FMSUdOX1NUQVJUXG59O1xuY29uc3QgRUxFTUVOVF9GT1JNQVRfVE9fVFlQRSA9IHtcbiAgW0lTX0FMSUdOX0NFTlRFUl06ICdjZW50ZXInLFxuICBbSVNfQUxJR05fRU5EXTogJ2VuZCcsXG4gIFtJU19BTElHTl9KVVNUSUZZXTogJ2p1c3RpZnknLFxuICBbSVNfQUxJR05fTEVGVF06ICdsZWZ0JyxcbiAgW0lTX0FMSUdOX1JJR0hUXTogJ3JpZ2h0JyxcbiAgW0lTX0FMSUdOX1NUQVJUXTogJ3N0YXJ0J1xufTtcbmNvbnN0IFRFWFRfTU9ERV9UT19UWVBFID0ge1xuICBub3JtYWw6IElTX05PUk1BTCxcbiAgc2VnbWVudGVkOiBJU19TRUdNRU5URUQsXG4gIHRva2VuOiBJU19UT0tFTlxufTtcbmNvbnN0IFRFWFRfVFlQRV9UT19NT0RFID0ge1xuICBbSVNfTk9STUFMXTogJ25vcm1hbCcsXG4gIFtJU19TRUdNRU5URURdOiAnc2VnbWVudGVkJyxcbiAgW0lTX1RPS0VOXTogJ3Rva2VuJ1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gVGhlIHRpbWUgYmV0d2VlbiBhIHRleHQgZW50cnkgZXZlbnQgYW5kIHRoZSBtdXRhdGlvbiBvYnNlcnZlciBmaXJpbmcuXG5jb25zdCBURVhUX01VVEFUSU9OX1ZBUklBTkNFID0gMTAwO1xubGV0IGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IGZhbHNlO1xubGV0IGxhc3RUZXh0RW50cnlUaW1lU3RhbXAgPSAwO1xuZnVuY3Rpb24gZ2V0SXNQcm9jZXNzaW5nTXV0YXRpb25zKCkge1xuICByZXR1cm4gaXNQcm9jZXNzaW5nTXV0YXRpb25zO1xufVxuZnVuY3Rpb24gdXBkYXRlVGltZVN0YW1wKGV2ZW50KSB7XG4gIGxhc3RUZXh0RW50cnlUaW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG59XG5mdW5jdGlvbiBpbml0VGV4dEVudHJ5TGlzdGVuZXIoZWRpdG9yKSB7XG4gIGlmIChsYXN0VGV4dEVudHJ5VGltZVN0YW1wID09PSAwKSB7XG4gICAgZ2V0V2luZG93KGVkaXRvcikuYWRkRXZlbnRMaXN0ZW5lcigndGV4dElucHV0JywgdXBkYXRlVGltZVN0YW1wLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYW5hZ2VkTGluZUJyZWFrKGRvbSwgdGFyZ2V0LCBlZGl0b3IpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIHRhcmdldC5fX2xleGljYWxMaW5lQnJlYWsgPT09IGRvbSB8fFxuICAgIC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cbiAgICBkb21bYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWBdICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldExhc3RTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiAhPT0gbnVsbCA/IHNlbGVjdGlvbi5jbG9uZSgpIDogbnVsbDtcbiAgfSk7XG59XG5mdW5jdGlvbiAkaGFuZGxlVGV4dE11dGF0aW9uKHRhcmdldCwgbm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBudWxsO1xuICBsZXQgZm9jdXNPZmZzZXQgPSBudWxsO1xuICBpZiAoZG9tU2VsZWN0aW9uICE9PSBudWxsICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSB0YXJnZXQpIHtcbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICB9XG4gIGNvbnN0IHRleHQgPSB0YXJnZXQubm9kZVZhbHVlO1xuICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgaWYgKGFuY2hvck5vZGUuaXModGFyZ2V0Tm9kZSkgJiYgc2VsZWN0aW9uLmZvcm1hdCAhPT0gYW5jaG9yTm9kZS5nZXRGb3JtYXQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0RE9NLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFICYmIHRhcmdldE5vZGUuaXNBdHRhY2hlZCgpO1xufVxuZnVuY3Rpb24gJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKSB7XG4gIGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IHRydWU7XG4gIGNvbnN0IHNob3VsZEZsdXNoVGV4dE11dGF0aW9ucyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdFRleHRFbnRyeVRpbWVTdGFtcCA+IFRFWFRfTVVUQVRJT05fVkFSSUFOQ0U7XG4gIHRyeSB7XG4gICAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8IGdldExhc3RTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgIGNvbnN0IGJhZERPTVRhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgICAgLy8gV2UgdXNlIHRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZSwgYXMgdGhhdCByZWZsZWN0cyB3aGF0IGlzXG4gICAgICAvLyBhY3R1YWxseSBcIm9uIHNjcmVlblwiLlxuICAgICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgICAgbGV0IHNob3VsZFJldmVydFNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgbGV0IHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSBtdXRhdGlvbi50eXBlO1xuICAgICAgICBjb25zdCB0YXJnZXRET00gPSBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUodGFyZ2V0RE9NLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICBpZiAodGFyZ2V0Tm9kZSA9PT0gbnVsbCAmJiB0YXJnZXRET00gIT09IHJvb3RFbGVtZW50IHx8ICRpc0RlY29yYXRvck5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnKSB7XG4gICAgICAgICAgLy8gVGV4dCBtdXRhdGlvbnMgYXJlIGRlZmVycmVkIGFuZCBwYXNzZWQgdG8gbXV0YXRpb24gbGlzdGVuZXJzIHRvIGJlXG4gICAgICAgICAgLy8gcHJvY2Vzc2VkIG91dHNpZGUgb2YgdGhlIExleGljYWwgZW5naW5lLlxuICAgICAgICAgIGlmIChzaG91bGRGbHVzaFRleHRNdXRhdGlvbnMgJiYgJGlzVGV4dE5vZGUodGFyZ2V0Tm9kZSkgJiYgc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICAkaGFuZGxlVGV4dE11dGF0aW9uKFxuICAgICAgICAgICAgLy8gbm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUgaXMgYSBUZXh0IERPTSBub2RlXG4gICAgICAgICAgICB0YXJnZXRET00sIHRhcmdldE5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgc2hvdWxkUmV2ZXJ0U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAvLyBXZSBhdHRlbXB0IHRvIFwidW5kb1wiIGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBvY2N1cnJlZCBvdXRzaWRlXG4gICAgICAgICAgLy8gb2YgTGV4aWNhbC4gV2Ugd2FudCBMZXhpY2FsJ3MgZWRpdG9yIHN0YXRlIHRvIGJlIHNvdXJjZSBvZiB0cnV0aC5cbiAgICAgICAgICAvLyBUbyB0aGUgdXNlciwgdGhlc2Ugd2lsbCBsb29rIGxpa2Ugbm8tb3BzLlxuICAgICAgICAgIGNvbnN0IGFkZGVkRE9NcyA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBhZGRlZERPTXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkRE9NID0gYWRkZWRET01zW3NdO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlRnJvbURPTU5vZGUoYWRkZWRET00pO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RE9NID0gYWRkZWRET00ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRET00gIT0gbnVsbCAmJiBhZGRlZERPTSAhPT0gYmxvY2tDdXJzb3JFbGVtZW50ICYmIG5vZGUgPT09IG51bGwgJiYgKGFkZGVkRE9NLm5vZGVOYW1lICE9PSAnQlInIHx8ICFpc01hbmFnZWRMaW5lQnJlYWsoYWRkZWRET00sIHBhcmVudERPTSwgZWRpdG9yKSkpIHtcbiAgICAgICAgICAgICAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZVRleHQgPSBhZGRlZERPTS5pbm5lclRleHQgfHwgYWRkZWRET00ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSArPSBwb3NzaWJsZVRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudERPTS5yZW1vdmVDaGlsZChhZGRlZERPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlbW92ZWRET01zID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzO1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWRET01zTGVuZ3RoID0gcmVtb3ZlZERPTXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChyZW1vdmVkRE9Nc0xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCB1bnJlbW92ZWRCUnMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCByZW1vdmVkRE9Nc0xlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRET00gPSByZW1vdmVkRE9Nc1tzXTtcbiAgICAgICAgICAgICAgaWYgKHJlbW92ZWRET00ubm9kZU5hbWUgPT09ICdCUicgJiYgaXNNYW5hZ2VkTGluZUJyZWFrKHJlbW92ZWRET00sIHRhcmdldERPTSwgZWRpdG9yKSB8fCBibG9ja0N1cnNvckVsZW1lbnQgPT09IHJlbW92ZWRET00pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRET00uYXBwZW5kQ2hpbGQocmVtb3ZlZERPTSk7XG4gICAgICAgICAgICAgICAgdW5yZW1vdmVkQlJzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW1vdmVkRE9Nc0xlbmd0aCAhPT0gdW5yZW1vdmVkQlJzKSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRET00gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGludGVybmFsR2V0Um9vdChjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJhZERPTVRhcmdldHMuc2V0KHRhcmdldERPTSwgdGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyB3ZSBwcm9jZXNzIGVhY2ggb2YgdGhlIHVuaXF1ZSB0YXJnZXQgbm9kZXMsIGF0dGVtcHRpbmdcbiAgICAgIC8vIHRvIHJlc3RvcmUgdGhlaXIgY29udGVudHMgYmFjayB0byB0aGUgc291cmNlIG9mIHRydXRoLCB3aGljaFxuICAgICAgLy8gaXMgTGV4aWNhbCdzIFwiY3VycmVudFwiIGVkaXRvciBzdGF0ZS4gVGhpcyBpcyBiYXNpY2FsbHkgbGlrZVxuICAgICAgLy8gYW4gaW50ZXJuYWwgcmV2ZXJ0IG9uIHRoZSBET00uXG4gICAgICBpZiAoYmFkRE9NVGFyZ2V0cy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXRET00sIHRhcmdldE5vZGVdIG9mIGJhZERPTVRhcmdldHMpIHtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5cyA9IHRhcmdldE5vZGUuZ2V0Q2hpbGRyZW5LZXlzKCk7XG4gICAgICAgICAgICBsZXQgY3VycmVudERPTSA9IHRhcmdldERPTS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjaGlsZEtleXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGRLZXlzW3NdO1xuICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0RE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShrZXkpO1xuICAgICAgICAgICAgICBpZiAoY29ycmVjdERPTSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50RE9NID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRET00uYXBwZW5kQ2hpbGQoY29ycmVjdERPTSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERPTSA9IGNvcnJlY3RET007XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudERPTSAhPT0gY29ycmVjdERPTSkge1xuICAgICAgICAgICAgICAgIHRhcmdldERPTS5yZXBsYWNlQ2hpbGQoY29ycmVjdERPTSwgY3VycmVudERPTSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudERPTSA9IGN1cnJlbnRET00ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXROb2RlKSkge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5tYXJrRGlydHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FwdHVyZSBhbGwgdGhlIG11dGF0aW9ucyBtYWRlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLiBUaGlzXG4gICAgICAvLyBhbHNvIHByZXZlbnRzIHVzIGhhdmluZyB0byBwcm9jZXNzIHRoZW0gb24gdGhlIG5leHQgY3ljbGVcbiAgICAgIC8vIG9mIG9uTXV0YXRpb24sIGFzIHRoZXNlIG11dGF0aW9ucyB3ZXJlIG1hZGUgYnkgdXMuXG4gICAgICBjb25zdCByZWNvcmRzID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGFueSByYW5kb20gYXV0by1hZGRlZCA8YnI+IGVsZW1lbnRzLCBhbmQgcmVtb3ZlIHRoZW0uXG4gICAgICAvLyBUaGVzZSBnZXQgYWRkZWQgYnkgdGhlIGJyb3dzZXIgd2hlbiB3ZSB1bmRvIHRoZSBhYm92ZSBtdXRhdGlvbnNcbiAgICAgIC8vIGFuZCB0aGlzIGNhbiBsZWFkIHRvIGEgYnJva2VuIFVJLlxuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IGFkZGVkTm9kZXMgPSByZWNvcmQuYWRkZWROb2RlcztcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSByZWNvcmQudGFyZ2V0O1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYWRkZWROb2Rlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkZWRET00gPSBhZGRlZE5vZGVzW3NdO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RE9NID0gYWRkZWRET00ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRET00gIT0gbnVsbCAmJiBhZGRlZERPTS5ub2RlTmFtZSA9PT0gJ0JSJyAmJiAhaXNNYW5hZ2VkTGluZUJyZWFrKGFkZGVkRE9NLCB0YXJnZXQsIGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgcGFyZW50RE9NLnJlbW92ZUNoaWxkKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciBhbnkgb2YgdGhvc2UgcmVtb3ZhbCBtdXRhdGlvbnNcbiAgICAgICAgb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFJldmVydFNlbGVjdGlvbikge1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQocG9zc2libGVUZXh0Rm9yRmlyZWZveFBhc3RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkZmx1c2hSb290TXV0YXRpb25zKGVkaXRvcikge1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoZWRpdG9yKSB7XG4gIGluaXRUZXh0RW50cnlMaXN0ZW5lcihlZGl0b3IpO1xuICBlZGl0b3IuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucywgb2JzZXJ2ZXIpID0+IHtcbiAgICAkZmx1c2hNdXRhdGlvbnMkMShlZGl0b3IsIG11dGF0aW9ucywgb2JzZXJ2ZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkY2FuU2ltcGxlVGV4dE5vZGVzQmVNZXJnZWQobm9kZTEsIG5vZGUyKSB7XG4gIGNvbnN0IG5vZGUxTW9kZSA9IG5vZGUxLl9fbW9kZTtcbiAgY29uc3Qgbm9kZTFGb3JtYXQgPSBub2RlMS5fX2Zvcm1hdDtcbiAgY29uc3Qgbm9kZTFTdHlsZSA9IG5vZGUxLl9fc3R5bGU7XG4gIGNvbnN0IG5vZGUyTW9kZSA9IG5vZGUyLl9fbW9kZTtcbiAgY29uc3Qgbm9kZTJGb3JtYXQgPSBub2RlMi5fX2Zvcm1hdDtcbiAgY29uc3Qgbm9kZTJTdHlsZSA9IG5vZGUyLl9fc3R5bGU7XG4gIHJldHVybiAobm9kZTFNb2RlID09PSBudWxsIHx8IG5vZGUxTW9kZSA9PT0gbm9kZTJNb2RlKSAmJiAobm9kZTFGb3JtYXQgPT09IG51bGwgfHwgbm9kZTFGb3JtYXQgPT09IG5vZGUyRm9ybWF0KSAmJiAobm9kZTFTdHlsZSA9PT0gbnVsbCB8fCBub2RlMVN0eWxlID09PSBub2RlMlN0eWxlKTtcbn1cbmZ1bmN0aW9uICRtZXJnZVRleHROb2Rlcyhub2RlMSwgbm9kZTIpIHtcbiAgY29uc3Qgd3JpdGFibGVOb2RlMSA9IG5vZGUxLm1lcmdlV2l0aFNpYmxpbmcobm9kZTIpO1xuICBjb25zdCBub3JtYWxpemVkTm9kZXMgPSBnZXRBY3RpdmVFZGl0b3IoKS5fbm9ybWFsaXplZE5vZGVzO1xuICBub3JtYWxpemVkTm9kZXMuYWRkKG5vZGUxLl9fa2V5KTtcbiAgbm9ybWFsaXplZE5vZGVzLmFkZChub2RlMi5fX2tleSk7XG4gIHJldHVybiB3cml0YWJsZU5vZGUxO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVRleHROb2RlKHRleHROb2RlKSB7XG4gIGxldCBub2RlID0gdGV4dE5vZGU7XG4gIGlmIChub2RlLl9fdGV4dCA9PT0gJycgJiYgbm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEJhY2t3YXJkXG4gIGxldCBwcmV2aW91c05vZGU7XG4gIHdoaWxlICgocHJldmlvdXNOb2RlID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSkgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUocHJldmlvdXNOb2RlKSAmJiBwcmV2aW91c05vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIXByZXZpb3VzTm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICBpZiAocHJldmlvdXNOb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIHByZXZpb3VzTm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRjYW5TaW1wbGVUZXh0Tm9kZXNCZU1lcmdlZChwcmV2aW91c05vZGUsIG5vZGUpKSB7XG4gICAgICBub2RlID0gJG1lcmdlVGV4dE5vZGVzKHByZXZpb3VzTm9kZSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gRm9yd2FyZFxuICBsZXQgbmV4dE5vZGU7XG4gIHdoaWxlICgobmV4dE5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCkpICE9PSBudWxsICYmICRpc1RleHROb2RlKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbmV4dE5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgaWYgKG5leHROb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIG5leHROb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKG5vZGUsIG5leHROb2RlKSkge1xuICAgICAgbm9kZSA9ICRtZXJnZVRleHROb2Rlcyhub2RlLCBuZXh0Tm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAkbm9ybWFsaXplUG9pbnQoc2VsZWN0aW9uLmFuY2hvcik7XG4gICRub3JtYWxpemVQb2ludChzZWxlY3Rpb24uZm9jdXMpO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVBvaW50KHBvaW50KSB7XG4gIHdoaWxlIChwb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgICBsZXQgbmV4dE5vZGU7XG4gICAgbGV0IG5leHRPZmZzZXRBdEVuZDtcbiAgICBpZiAob2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpKSB7XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUuZ2V0Q2hpbGRBdEluZGV4KG9mZnNldCAtIDEpO1xuICAgICAgbmV4dE9mZnNldEF0RW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuICAgICAgbmV4dE9mZnNldEF0RW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIHBvaW50LnNldChuZXh0Tm9kZS5fX2tleSwgbmV4dE9mZnNldEF0RW5kID8gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgOiAwLCAndGV4dCcpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobmV4dE5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcG9pbnQuc2V0KG5leHROb2RlLl9fa2V5LCBuZXh0T2Zmc2V0QXRFbmQgPyBuZXh0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA6IDAsICdlbGVtZW50Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5sZXQga2V5Q291bnRlciA9IDE7XG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUtleSgpIHtcbiAgcmV0dXJuICcnICsga2V5Q291bnRlcisrO1xufVxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZE5vZGVPclRocm93KGVkaXRvciwgbm9kZVR5cGUpIHtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldChub2RlVHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHJlZ2lzdGVyZWROb2RlOiBUeXBlICR7bm9kZVR5cGV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVnaXN0ZXJlZE5vZGU7XG59XG5jb25zdCBzY2hlZHVsZU1pY3JvVGFzayA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrIDogZm4gPT4ge1xuICAvLyBObyB3aW5kb3cgcHJlZml4IGludGVuZGVkICgjMTQwMClcbiAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbik7XG59O1xuZnVuY3Rpb24gJGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcihub2RlKSB7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKCRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0KGFuY2hvckRPTSkge1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgbm9kZU5hbWUgPSBhY3RpdmVFbGVtZW50Lm5vZGVOYW1lO1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZSgkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhbmNob3JET00pKSAmJiAobm9kZU5hbWUgPT09ICdJTlBVVCcgfHwgbm9kZU5hbWUgPT09ICdURVhUQVJFQScgfHwgYWN0aXZlRWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyAmJlxuICAvLyBAdHMtaWdub3JlIGludGVybmFsIGZpZWxkXG4gIGFjdGl2ZUVsZW1lbnQuX19sZXhpY2FsRWRpdG9yID09IG51bGwpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSB7XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJvb3RFbGVtZW50ICE9PSBudWxsICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGFuY2hvckRPTSkgJiYgcm9vdEVsZW1lbnQuY29udGFpbnMoZm9jdXNET00pICYmXG4gICAgLy8gSWdub3JlIGlmIHNlbGVjdGlvbiBpcyB3aXRoaW4gbmVzdGVkIGVkaXRvclxuICAgIGFuY2hvckRPTSAhPT0gbnVsbCAmJiAhaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoYW5jaG9yRE9NKSAmJiBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUoYW5jaG9yRE9NKSA9PT0gZWRpdG9yO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKG5vZGUpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIGNvbnN0IGVkaXRvciA9IGN1cnJlbnROb2RlLl9fbGV4aWNhbEVkaXRvcjtcbiAgICBpZiAoZWRpdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50RWxlbWVudChjdXJyZW50Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uKHRleHQpIHtcbiAgaWYgKFJUTF9SRUdFWC50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuICdydGwnO1xuICB9XG4gIGlmIChMVFJfUkVHRVgudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiAnbHRyJztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRpc1Rva2VuT3JTZWdtZW50ZWQobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc1Rva2VuKCkgfHwgbm9kZS5pc1NlZ21lbnRlZCgpO1xufVxuZnVuY3Rpb24gaXNET01Ob2RlTGV4aWNhbFRleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBnZXRET01UZXh0Tm9kZShlbGVtZW50KSB7XG4gIGxldCBub2RlID0gZWxlbWVudDtcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChpc0RPTU5vZGVMZXhpY2FsVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBhbGlnbldpdGhGb3JtYXQpIHtcbiAgY29uc3QgYWN0aXZlRm9ybWF0ID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgaWYgKGFsaWduV2l0aEZvcm1hdCAhPT0gbnVsbCAmJiAoZm9ybWF0ICYgYWN0aXZlRm9ybWF0KSA9PT0gKGFsaWduV2l0aEZvcm1hdCAmIGFjdGl2ZUZvcm1hdCkpIHtcbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG4gIGxldCBuZXdGb3JtYXQgPSBmb3JtYXQgXiBhY3RpdmVGb3JtYXQ7XG4gIGlmICh0eXBlID09PSAnc3Vic2NyaXB0Jykge1xuICAgIG5ld0Zvcm1hdCAmPSB+VEVYVF9UWVBFX1RPX0ZPUk1BVC5zdXBlcnNjcmlwdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VwZXJzY3JpcHQnKSB7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULnN1YnNjcmlwdDtcbiAgfVxuICByZXR1cm4gbmV3Rm9ybWF0O1xufVxuZnVuY3Rpb24gJGlzTGVhZk5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzVGV4dE5vZGUobm9kZSkgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gJHNldE5vZGVLZXkobm9kZSwgZXhpc3RpbmdLZXkpIHtcbiAgaWYgKGV4aXN0aW5nS2V5ICE9IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvck9uTm9kZUtleUNvbnN0cnVjdG9yTWlzbWF0Y2gobm9kZSwgZXhpc3RpbmdLZXkpO1xuICAgIH1cbiAgICBub2RlLl9fa2V5ID0gZXhpc3RpbmdLZXk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IGtleSA9IGdlbmVyYXRlUmFuZG9tS2V5KCk7XG4gIGVkaXRvclN0YXRlLl9ub2RlTWFwLnNldChrZXksIG5vZGUpO1xuICAvLyBUT0RPIFNwbGl0IHRoaXMgZnVuY3Rpb24gaW50byBsZWFmL2VsZW1lbnRcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzLnNldChrZXksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBIQVNfRElSVFlfTk9ERVM7XG4gIG5vZGUuX19rZXkgPSBrZXk7XG59XG5mdW5jdGlvbiBlcnJvck9uTm9kZUtleUNvbnN0cnVjdG9yTWlzbWF0Y2gobm9kZSwgZXhpc3RpbmdLZXkpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBpbnRlcm5hbEdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGlmICghZWRpdG9yU3RhdGUpIHtcbiAgICAvLyB0ZXN0cyBleHBlY3QgdG8gYmUgYWJsZSB0byBkbyB0aGlzIGtpbmQgb2YgY2xvbmUgd2l0aG91dCBhbiBhY3RpdmUgZWRpdG9yIHN0YXRlXG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nTm9kZSA9IGVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChleGlzdGluZ0tleSk7XG4gIGlmIChleGlzdGluZ05vZGUgJiYgZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yICE9PSBub2RlLmNvbnN0cnVjdG9yKSB7XG4gICAgLy8gTGlmdGVkIGNvbmRpdGlvbiB0byBpZiBzdGF0ZW1lbnQgYmVjYXVzZSB0aGUgaW52ZXJ0ZWQgbG9naWMgaXMgYSBiaXQgY29uZnVzaW5nXG4gICAgaWYgKG5vZGUuY29uc3RydWN0b3IubmFtZSAhPT0gZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYExleGljYWwgbm9kZSB3aXRoIGNvbnN0cnVjdG9yICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSBhdHRlbXB0ZWQgdG8gcmUtdXNlIGtleSBmcm9tIG5vZGUgaW4gYWN0aXZlIGVkaXRvciBzdGF0ZSB3aXRoIGNvbnN0cnVjdG9yICR7ZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yLm5hbWV9LiBLZXlzIG11c3Qgbm90IGJlIHJlLXVzZWQgd2hlbiB0aGUgdHlwZSBpcyBjaGFuZ2VkLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsIG5vZGUgd2l0aCBjb25zdHJ1Y3RvciAke25vZGUuY29uc3RydWN0b3IubmFtZX0gYXR0ZW1wdGVkIHRvIHJlLXVzZSBrZXkgZnJvbSBub2RlIGluIGFjdGl2ZSBlZGl0b3Igc3RhdGUgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3Igd2l0aCB0aGUgc2FtZSBuYW1lIChwb3NzaWJseSBkdWUgdG8gaW52YWxpZCBIb3QgTW9kdWxlIFJlcGxhY2VtZW50KS4gS2V5cyBtdXN0IG5vdCBiZSByZS11c2VkIHdoZW4gdGhlIHR5cGUgaXMgY2hhbmdlZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVybmFsTWFya1BhcmVudEVsZW1lbnRzQXNEaXJ0eShwYXJlbnRLZXksIG5vZGVNYXAsIGRpcnR5RWxlbWVudHMpIHtcbiAgbGV0IG5leHRQYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gIHdoaWxlIChuZXh0UGFyZW50S2V5ICE9PSBudWxsKSB7XG4gICAgaWYgKGRpcnR5RWxlbWVudHMuaGFzKG5leHRQYXJlbnRLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChuZXh0UGFyZW50S2V5KTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGlydHlFbGVtZW50cy5zZXQobmV4dFBhcmVudEtleSwgZmFsc2UpO1xuICAgIG5leHRQYXJlbnRLZXkgPSBub2RlLl9fcGFyZW50O1xuICB9XG59XG5cbi8vIFRPRE8gIzYwMzEgdGhpcyBmdW5jdGlvbiBvciB0aGVpciBjYWxsZXJzIGhhdmUgdG8gYWRqdXN0IHNlbGVjdGlvbiAoaS5lLiBpbnNlcnRCZWZvcmUpXG5mdW5jdGlvbiByZW1vdmVGcm9tUGFyZW50KG5vZGUpIHtcbiAgY29uc3Qgb2xkUGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZSA9IG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IG9sZFBhcmVudC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGR1cGxpY2F0ZXMgYSBidW5jaCBvZiBvcGVyYXRpb25zLCBjYW4gYmUgc2ltcGxpZmllZC5cbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gd3JpdGFibGVQcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSB3cml0YWJsZU5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgd3JpdGFibGVOb2RlLl9fcHJldiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSB3cml0YWJsZVByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBudWxsO1xuICAgICAgfVxuICAgICAgd3JpdGFibGVOb2RlLl9fbmV4dCA9IG51bGw7XG4gICAgfVxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZS0tO1xuICAgIHdyaXRhYmxlTm9kZS5fX3BhcmVudCA9IG51bGw7XG4gIH1cbn1cblxuLy8gTmV2ZXIgdXNlIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHkhIEl0IHdpbGwgYnJlYWtcbi8vIHRoZSBjbG9uaW5nIGhldXJpc3RpYy4gSW5zdGVhZCB1c2Ugbm9kZS5nZXRXcml0YWJsZSgpLlxuZnVuY3Rpb24gaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobm9kZSkge1xuICBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCk7XG4gIGNvbnN0IGxhdGVzdCA9IG5vZGUuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IHBhcmVudCA9IGxhdGVzdC5fX3BhcmVudDtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrUGFyZW50RWxlbWVudHNBc0RpcnR5KHBhcmVudCwgbm9kZU1hcCwgZGlydHlFbGVtZW50cyk7XG4gIH1cbiAgY29uc3Qga2V5ID0gbGF0ZXN0Ll9fa2V5O1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEhBU19ESVJUWV9OT0RFUztcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZGlydHlFbGVtZW50cy5zZXQoa2V5LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPIHNwbGl0IGludGVybmFsbHkgTWFya05vZGVBc0RpcnR5IGludG8gdHdvIGRlZGljYXRlZCBFbGVtZW50L2xlYXZlIGZ1bmN0aW9uc1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVybmFsTWFya1NpYmxpbmdzQXNEaXJ0eShub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIGNvbnN0IG5leHROb2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICBpZiAocHJldmlvdXNOb2RlICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkocHJldmlvdXNOb2RlKTtcbiAgfVxuICBpZiAobmV4dE5vZGUgIT09IG51bGwpIHtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShuZXh0Tm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRDb21wb3NpdGlvbktleShjb21wb3NpdGlvbktleSkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHByZXZpb3VzQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IHByZXZpb3VzQ29tcG9zaXRpb25LZXkpIHtcbiAgICBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ID0gY29tcG9zaXRpb25LZXk7XG4gICAgaWYgKHByZXZpb3VzQ29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHByZXZpb3VzQ29tcG9zaXRpb25LZXkpO1xuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGNvbXBvc2l0aW9uS2V5KTtcbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRDb21wb3NpdGlvbktleSgpIHtcbiAgaWYgKGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZUJ5S2V5KGtleSwgX2VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gX2VkaXRvclN0YXRlIHx8IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IG5vZGUgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gJGdldE5vZGVGcm9tRE9NTm9kZShkb20sIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAvLyBAdHMtaWdub3JlIFdlIGludGVudGlvbmFsbHkgYWRkIHRoaXMgdG8gdGhlIE5vZGUuXG4gIGNvbnN0IGtleSA9IGRvbVtgX19sZXhpY2FsS2V5XyR7ZWRpdG9yLl9rZXl9YF07XG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAkZ2V0Tm9kZUJ5S2V5KGtleSwgZWRpdG9yU3RhdGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoc3RhcnRpbmdET00sIGVkaXRvclN0YXRlKSB7XG4gIGxldCBkb20gPSBzdGFydGluZ0RPTTtcbiAgd2hpbGUgKGRvbSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlRnJvbURPTU5vZGUoZG9tLCBlZGl0b3JTdGF0ZSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBkb20gPSBnZXRQYXJlbnRFbGVtZW50KGRvbSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9uZURlY29yYXRvcnMoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gZWRpdG9yLl9kZWNvcmF0b3JzO1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnREZWNvcmF0b3JzKTtcbiAgZWRpdG9yLl9wZW5kaW5nRGVjb3JhdG9ycyA9IHBlbmRpbmdEZWNvcmF0b3JzO1xuICByZXR1cm4gcGVuZGluZ0RlY29yYXRvcnM7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JTdGF0ZVRleHRDb250ZW50KGVkaXRvclN0YXRlKSB7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+ICRnZXRSb290KCkuZ2V0VGV4dENvbnRlbnQoKSk7XG59XG5mdW5jdGlvbiBtYXJrQWxsTm9kZXNBc0RpcnR5KGVkaXRvciwgdHlwZSkge1xuICAvLyBNYXJrIGFsbCBleGlzdGluZyB0ZXh0IG5vZGVzIGFzIGRpcnR5XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gICAgaWYgKGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAkZ2V0Um9vdCgpLm1hcmtEaXJ0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2RlTWFwKSB7XG4gICAgICBub2RlLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfSwgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwgPyB7XG4gICAgdGFnOiAnaGlzdG9yeS1tZXJnZSdcbiAgfSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiAkZ2V0Um9vdCgpIHtcbiAgcmV0dXJuIGludGVybmFsR2V0Um9vdChnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpKTtcbn1cbmZ1bmN0aW9uIGludGVybmFsR2V0Um9vdChlZGl0b3JTdGF0ZSkge1xuICByZXR1cm4gZWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KCdyb290Jyk7XG59XG5mdW5jdGlvbiAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgJHNldFNlbGVjdGlvbiBjYWxsZWQgb24gZnJvemVuIHNlbGVjdGlvbiBvYmplY3QuIEVuc3VyZSBzZWxlY3Rpb24gaXMgY2xvbmVkIGJlZm9yZSBwYXNzaW5nIGluLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgc2VsZWN0aW9uLnNldENhY2hlZE5vZGVzKG51bGwpO1xuICB9XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkZmx1c2hNdXRhdGlvbnMoKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgJGZsdXNoUm9vdE11dGF0aW9ucyhlZGl0b3IpO1xufVxuZnVuY3Rpb24gJGdldE5vZGVGcm9tRE9NKGRvbSkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZUtleSA9IGdldE5vZGVLZXlGcm9tRE9NKGRvbSwgZWRpdG9yKTtcbiAgaWYgKG5vZGVLZXkgPT09IG51bGwpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChkb20gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm4gJGdldE5vZGVCeUtleSgncm9vdCcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbn1cbmZ1bmN0aW9uIGdldFRleHROb2RlT2Zmc2V0KG5vZGUsIG1vdmVTZWxlY3Rpb25Ub0VuZCkge1xuICByZXR1cm4gbW92ZVNlbGVjdGlvblRvRW5kID8gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG59XG5mdW5jdGlvbiBnZXROb2RlS2V5RnJvbURPTShcbi8vIE5vdGUgdGhhdCBub2RlIGhlcmUgcmVmZXJzIHRvIGEgRE9NIE5vZGUsIG5vdCBhbiBMZXhpY2FsIE5vZGVcbmRvbSwgZWRpdG9yKSB7XG4gIGxldCBub2RlID0gZG9tO1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBXZSBpbnRlbnRpb25hbGx5IGFkZCB0aGlzIHRvIHRoZSBOb2RlLlxuICAgIGNvbnN0IGtleSA9IG5vZGVbYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWBdO1xuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgbm9kZSA9IGdldFBhcmVudEVsZW1lbnQobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkb2VzQ29udGFpbkdyYXBoZW1lKHN0cikge1xuICByZXR1cm4gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JzVG9Qcm9wYWdhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGVkaXRvcnNUb1Byb3BhZ2F0ZSA9IFtdO1xuICBsZXQgY3VycmVudEVkaXRvciA9IGVkaXRvcjtcbiAgd2hpbGUgKGN1cnJlbnRFZGl0b3IgIT09IG51bGwpIHtcbiAgICBlZGl0b3JzVG9Qcm9wYWdhdGUucHVzaChjdXJyZW50RWRpdG9yKTtcbiAgICBjdXJyZW50RWRpdG9yID0gY3VycmVudEVkaXRvci5fcGFyZW50RWRpdG9yO1xuICB9XG4gIHJldHVybiBlZGl0b3JzVG9Qcm9wYWdhdGU7XG59XG5mdW5jdGlvbiBjcmVhdGVVSUQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5yZXBsYWNlKC9bXmEtel0rL2csICcnKS5zdWJzdHIoMCwgNSk7XG59XG5mdW5jdGlvbiBnZXRBbmNob3JUZXh0RnJvbURPTShhbmNob3JOb2RlKSB7XG4gIGlmIChhbmNob3JOb2RlLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFKSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVZhbHVlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oaXNDb21wb3NpdGlvbkVuZCwgZWRpdG9yLCBkYXRhKSB7XG4gIC8vIFVwZGF0ZSB0aGUgdGV4dCBjb250ZW50IHdpdGggdGhlIGxhdGVzdCBjb21wb3NpdGlvbiB0ZXh0XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBsZXQge1xuICAgIGFuY2hvck9mZnNldCxcbiAgICBmb2N1c09mZnNldFxuICB9ID0gZG9tU2VsZWN0aW9uO1xuICBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCkge1xuICAgIGxldCB0ZXh0Q29udGVudCA9IGdldEFuY2hvclRleHRGcm9tRE9NKGFuY2hvck5vZGUpO1xuICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhbmNob3JOb2RlKTtcbiAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIC8vIERhdGEgaXMgaW50ZW50aW9uYWxseSB0cnV0aHksIGFzIHdlIGNoZWNrIGZvciBib29sZWFuLCBudWxsIGFuZCBlbXB0eSBzdHJpbmcuXG4gICAgICBpZiAodGV4dENvbnRlbnQgPT09IENPTVBPU0lUSU9OX1NVRkZJWCAmJiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0ZXh0Q29udGVudCA9IGRhdGE7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQobm9kZSwgdGV4dENvbnRlbnQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIGlzQ29tcG9zaXRpb25FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQodGV4dE5vZGUsIHRleHRDb250ZW50LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBjb21wb3NpdGlvbkVuZCkge1xuICBsZXQgbm9kZSA9IHRleHROb2RlO1xuICBpZiAobm9kZS5pc0F0dGFjaGVkKCkgJiYgKGNvbXBvc2l0aW9uRW5kIHx8ICFub2RlLmlzRGlydHkoKSkpIHtcbiAgICBjb25zdCBpc0NvbXBvc2luZyA9IG5vZGUuaXNDb21wb3NpbmcoKTtcbiAgICBsZXQgbm9ybWFsaXplZFRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG4gICAgaWYgKChpc0NvbXBvc2luZyB8fCBjb21wb3NpdGlvbkVuZCkgJiYgdGV4dENvbnRlbnRbdGV4dENvbnRlbnQubGVuZ3RoIC0gMV0gPT09IENPTVBPU0lUSU9OX1NVRkZJWCkge1xuICAgICAgbm9ybWFsaXplZFRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2VGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgaWYgKGNvbXBvc2l0aW9uRW5kIHx8IG5vcm1hbGl6ZWRUZXh0Q29udGVudCAhPT0gcHJldlRleHRDb250ZW50KSB7XG4gICAgICBpZiAobm9ybWFsaXplZFRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19JT1MgJiYgIUlTX0FQUExFX1dFQktJVCkge1xuICAgICAgICAgIC8vIEZvciBjb21wb3NpdGlvbiAobWFpbmx5IEFuZHJvaWQpLCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgbm9kZSBvbiBhIGxhdGVyIHVwZGF0ZVxuICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBwcmV2VGV4dENvbnRlbnRTaXplID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICAgIGlmIChub2RlLmlzVG9rZW4oKSB8fCBjb21wb3NpdGlvbktleSAhPT0gbnVsbCAmJiBub2RlS2V5ID09PSBjb21wb3NpdGlvbktleSAmJiAhaXNDb21wb3NpbmcgfHxcbiAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB3YXMgYWRkZWQgYXQgdGhlIHN0YXJ0IG9yIGJvdW5kYXJpZXMgd2hlbiBub3QgaW5zZXJ0YWJsZSwgYW5kIHdlIG5lZWRcbiAgICAgIC8vIHRvIGNsZWFyIHRoaXMgaW5wdXQgZnJvbSBvY2N1cnJpbmcgYXMgdGhhdCBhY3Rpb24gd2Fzbid0IHBlcm1pdHRlZC5cbiAgICAgICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIChwYXJlbnQgIT09IG51bGwgJiYgIXBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgJiYgcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwIHx8IHByZXZTZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gdGV4dE5vZGUuX19rZXkgJiYgcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwICYmICFub2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSAmJiAhaXNDb21wb3NpbmcgfHwgcHJldlNlbGVjdGlvbi5mb2N1cy5rZXkgPT09IHRleHROb2RlLl9fa2V5ICYmIHByZXZTZWxlY3Rpb24uZm9jdXMub2Zmc2V0ID09PSBwcmV2VGV4dENvbnRlbnRTaXplICYmICFub2RlLmNhbkluc2VydFRleHRBZnRlcigpICYmICFpc0NvbXBvc2luZykpIHtcbiAgICAgICAgbm9kZS5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGFuY2hvck9mZnNldCA9PT0gbnVsbCB8fCBmb2N1c09mZnNldCA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnNldFRleHRDb250ZW50KG5vcm1hbGl6ZWRUZXh0Q29udGVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKG5vZGUsIGFuY2hvck9mZnNldCwgbm9kZSwgZm9jdXNPZmZzZXQpO1xuICAgICAgaWYgKG5vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9ICRjcmVhdGVUZXh0Tm9kZShvcmlnaW5hbFRleHRDb250ZW50KTtcbiAgICAgICAgbm9kZS5yZXBsYWNlKHJlcGxhY2VtZW50KTtcbiAgICAgICAgbm9kZSA9IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgICAgbm9kZS5zZXRUZXh0Q29udGVudChub3JtYWxpemVkVGV4dENvbnRlbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHByZXZpb3VzU2libGluZ0RvZXNOb3RBY2NlcHRUZXh0KG5vZGUpIHtcbiAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgcmV0dXJuICgkaXNUZXh0Tm9kZShwcmV2aW91c1NpYmxpbmcpIHx8ICRpc0VsZW1lbnROb2RlKHByZXZpb3VzU2libGluZykgJiYgcHJldmlvdXNTaWJsaW5nLmlzSW5saW5lKCkpICYmICFwcmV2aW91c1NpYmxpbmcuY2FuSW5zZXJ0VGV4dEFmdGVyKCk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgY29ubmVjdGVkIHRvICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGVcbi8vIFRleHROb2RlIGJvdW5kYXJpZXMgYXJlIHdyaXRhYmxlIG9yIHdlIHNob3VsZCB1c2UgdGhlIHByZXZpb3VzL25leHQgc2libGluZyBpbnN0ZWFkLiBGb3IgZXhhbXBsZSxcbi8vIGluIHRoZSBjYXNlIG9mIGEgTGlua05vZGUsIGJvdW5kYXJpZXMgYXJlIG5vdCB3cml0YWJsZS5cbmZ1bmN0aW9uICRzaG91bGRJbnNlcnRUZXh0QWZ0ZXJPckJlZm9yZVRleHROb2RlKHNlbGVjdGlvbiwgbm9kZSkge1xuICBpZiAobm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIGNvbnN0IGlzVG9rZW4gPSBub2RlLmlzVG9rZW4oKTtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiAhbm9kZS5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgIXBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgJiYgIW5vZGUuaXNDb21wb3NpbmcoKSB8fCBpc1Rva2VuIHx8ICRwcmV2aW91c1NpYmxpbmdEb2VzTm90QWNjZXB0VGV4dChub2RlKTtcbiAgfSBlbHNlIGlmIChvZmZzZXQgPT09IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICByZXR1cm4gIW5vZGUuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgfHwgIXBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSAmJiAhbm9kZS5pc0NvbXBvc2luZygpIHx8IGlzVG9rZW47XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1RhYihrZXksIGFsdEtleSwgY3RybEtleSwgbWV0YUtleSkge1xuICByZXR1cm4ga2V5ID09PSAnVGFiJyAmJiAhYWx0S2V5ICYmICFjdHJsS2V5ICYmICFtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNCb2xkKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2InICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzSXRhbGljKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2knICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVW5kZXJsaW5lKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3UnICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoKGtleSwgc2hpZnRLZXkpIHtcbiAgcmV0dXJuIGlzUmV0dXJuKGtleSkgJiYgIXNoaWZ0S2V5O1xufVxuZnVuY3Rpb24gaXNMaW5lQnJlYWsoa2V5LCBzaGlmdEtleSkge1xuICByZXR1cm4gaXNSZXR1cm4oa2V5KSAmJiBzaGlmdEtleTtcbn1cblxuLy8gSW5zZXJ0cyBhIG5ldyBsaW5lIGFmdGVyIHRoZSBzZWxlY3Rpb25cblxuZnVuY3Rpb24gaXNPcGVuTGluZUJyZWFrKGtleSwgY3RybEtleSkge1xuICAvLyA3OSA9IEtleU9cbiAgcmV0dXJuIElTX0FQUExFICYmIGN0cmxLZXkgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdvJztcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlV29yZEJhY2t3YXJkKGtleSwgYWx0S2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBpc0JhY2tzcGFjZShrZXkpICYmIChJU19BUFBMRSA/IGFsdEtleSA6IGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVXb3JkRm9yd2FyZChrZXksIGFsdEtleSwgY3RybEtleSkge1xuICByZXR1cm4gaXNEZWxldGUoa2V5KSAmJiAoSVNfQVBQTEUgPyBhbHRLZXkgOiBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlTGluZUJhY2t3YXJkKGtleSwgbWV0YUtleSkge1xuICByZXR1cm4gSVNfQVBQTEUgJiYgbWV0YUtleSAmJiBpc0JhY2tzcGFjZShrZXkpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVMaW5lRm9yd2FyZChrZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIElTX0FQUExFICYmIG1ldGFLZXkgJiYgaXNEZWxldGUoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlQmFja3dhcmQoa2V5LCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgaWYgKGFsdEtleSB8fCBtZXRhS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0JhY2tzcGFjZShrZXkpIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnaCcgJiYgY3RybEtleTtcbiAgfVxuICBpZiAoY3RybEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNCYWNrc3BhY2Uoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlRm9yd2FyZChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgaWYgKHNoaWZ0S2V5IHx8IGFsdEtleSB8fCBtZXRhS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0RlbGV0ZShrZXkpIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnZCcgJiYgY3RybEtleTtcbiAgfVxuICBpZiAoY3RybEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNEZWxldGUoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzVW5kbyhrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3onICYmICFzaGlmdEtleSAmJiBjb250cm9sT3JNZXRhKG1ldGFLZXksIGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gaXNSZWRvKGtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSAneicgJiYgbWV0YUtleSAmJiBzaGlmdEtleTtcbiAgfVxuICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICd5JyAmJiBjdHJsS2V5IHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAneicgJiYgY3RybEtleSAmJiBzaGlmdEtleTtcbn1cbmZ1bmN0aW9uIGlzQ29weShrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChzaGlmdEtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjJykge1xuICAgIHJldHVybiBJU19BUFBMRSA/IG1ldGFLZXkgOiBjdHJsS2V5O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ3V0KGtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnKSB7XG4gICAgcmV0dXJuIElTX0FQUExFID8gbWV0YUtleSA6IGN0cmxLZXk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNBcnJvd0xlZnQoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdBcnJvd0xlZnQnO1xufVxuZnVuY3Rpb24gaXNBcnJvd1JpZ2h0KGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnQXJyb3dSaWdodCc7XG59XG5mdW5jdGlvbiBpc0Fycm93VXAoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdBcnJvd1VwJztcbn1cbmZ1bmN0aW9uIGlzQXJyb3dEb3duKGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnQXJyb3dEb3duJztcbn1cbmZ1bmN0aW9uIGlzTW92ZUJhY2t3YXJkKGtleSwgY3RybEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93TGVmdChrZXkpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5ICYmICFhbHRLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVUb1N0YXJ0KGtleSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd0xlZnQoa2V5KSAmJiAhYWx0S2V5ICYmICFzaGlmdEtleSAmJiAoY3RybEtleSB8fCBtZXRhS2V5KTtcbn1cbmZ1bmN0aW9uIGlzTW92ZUZvcndhcmQoa2V5LCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dSaWdodChrZXkpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5ICYmICFhbHRLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVUb0VuZChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dSaWdodChrZXkpICYmICFhbHRLZXkgJiYgIXNoaWZ0S2V5ICYmIChjdHJsS2V5IHx8IG1ldGFLZXkpO1xufVxuZnVuY3Rpb24gaXNNb3ZlVXAoa2V5LCBjdHJsS2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93VXAoa2V5KSAmJiAhY3RybEtleSAmJiAhbWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzTW92ZURvd24oa2V5LCBjdHJsS2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93RG93bihrZXkpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNNb2RpZmllcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBjdHJsS2V5IHx8IHNoaWZ0S2V5IHx8IGFsdEtleSB8fCBtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNTcGFjZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJyAnO1xufVxuZnVuY3Rpb24gY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChJU19BUFBMRSkge1xuICAgIHJldHVybiBtZXRhS2V5O1xuICB9XG4gIHJldHVybiBjdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNSZXR1cm4oa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdFbnRlcic7XG59XG5mdW5jdGlvbiBpc0JhY2tzcGFjZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0JhY2tzcGFjZSc7XG59XG5mdW5jdGlvbiBpc0VzY2FwZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0VzY2FwZSc7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0RlbGV0ZSc7XG59XG5mdW5jdGlvbiBpc1NlbGVjdEFsbChrZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uICRzZWxlY3RBbGwoKSB7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCBzZWxlY3Rpb24gPSByb290LnNlbGVjdCgwLCByb290LmdldENoaWxkcmVuU2l6ZSgpKTtcbiAgJHNldFNlbGVjdGlvbigkbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbikpO1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkoY2xhc3NOYW1lc1RoZW1lLCBjbGFzc05hbWVUaGVtZVR5cGUpIHtcbiAgaWYgKGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xhc3NOYW1lc1RoZW1lLl9fbGV4aWNhbENsYXNzTmFtZUNhY2hlID0ge307XG4gIH1cbiAgY29uc3QgY2xhc3NOYW1lc0NhY2hlID0gY2xhc3NOYW1lc1RoZW1lLl9fbGV4aWNhbENsYXNzTmFtZUNhY2hlO1xuICBjb25zdCBjYWNoZWRDbGFzc05hbWVzID0gY2xhc3NOYW1lc0NhY2hlW2NsYXNzTmFtZVRoZW1lVHlwZV07XG4gIGlmIChjYWNoZWRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkQ2xhc3NOYW1lcztcbiAgfVxuICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NOYW1lc1RoZW1lW2NsYXNzTmFtZVRoZW1lVHlwZV07XG4gIC8vIEFzIHdlJ3JlIHVzaW5nIGNsYXNzTGlzdCwgd2UgbmVlZFxuICAvLyB0byBoYW5kbGUgY2xhc3NOYW1lIHRva2VucyB0aGF0IGhhdmUgc3BhY2VzLlxuICAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gZG8gdGhpcyB0byBjb252ZXJ0IHRoZVxuICAvLyBjbGFzc05hbWUgdG9rZW5zIHRvIGFuIGFycmF5IHRoYXQgY2FuIGJlXG4gIC8vIGFwcGxpZWQgdG8gY2xhc3NMaXN0LmFkZCgpL3JlbW92ZSgpLlxuICBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG4gICAgY2xhc3NOYW1lc0NhY2hlW2NsYXNzTmFtZVRoZW1lVHlwZV0gPSBjbGFzc05hbWVzQXJyO1xuICAgIHJldHVybiBjbGFzc05hbWVzQXJyO1xuICB9XG4gIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCByZWdpc3RlcmVkTm9kZXMsIG11dGF0aW9uTGlzdGVuZXJzLCBub2RlLCBtdXRhdGlvbikge1xuICBpZiAobXV0YXRpb25MaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub2RlVHlwZSA9IG5vZGUuX190eXBlO1xuICBjb25zdCBub2RlS2V5ID0gbm9kZS5fX2tleTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSByZWdpc3RlcmVkTm9kZXMuZ2V0KG5vZGVUeXBlKTtcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVHlwZSAke25vZGVUeXBlfSBub3QgaW4gcmVnaXN0ZXJlZE5vZGVzYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtsYXNzID0gcmVnaXN0ZXJlZE5vZGUua2xhc3M7XG4gIGxldCBtdXRhdGVkTm9kZXNCeVR5cGUgPSBtdXRhdGVkTm9kZXMuZ2V0KGtsYXNzKTtcbiAgaWYgKG11dGF0ZWROb2Rlc0J5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbXV0YXRlZE5vZGVzQnlUeXBlID0gbmV3IE1hcCgpO1xuICAgIG11dGF0ZWROb2Rlcy5zZXQoa2xhc3MsIG11dGF0ZWROb2Rlc0J5VHlwZSk7XG4gIH1cbiAgY29uc3QgcHJldk11dGF0aW9uID0gbXV0YXRlZE5vZGVzQnlUeXBlLmdldChub2RlS2V5KTtcbiAgLy8gSWYgdGhlIG5vZGUgaGFzIGFscmVhZHkgYmVlbiBcImRlc3Ryb3llZFwiLCB5ZXQgd2UgYXJlXG4gIC8vIHJlLW1ha2luZyBpdCwgdGhlbiB0aGlzIG1lYW5zIGEgbW92ZSBsaWtlbHkgaGFwcGVuZWQuXG4gIC8vIFdlIHNob3VsZCBjaGFuZ2UgdGhlIG11dGF0aW9uIHRvIGJlIHRoYXQgb2YgXCJ1cGRhdGVkXCJcbiAgLy8gaW5zdGVhZC5cbiAgY29uc3QgaXNNb3ZlID0gcHJldk11dGF0aW9uID09PSAnZGVzdHJveWVkJyAmJiBtdXRhdGlvbiA9PT0gJ2NyZWF0ZWQnO1xuICBpZiAocHJldk11dGF0aW9uID09PSB1bmRlZmluZWQgfHwgaXNNb3ZlKSB7XG4gICAgbXV0YXRlZE5vZGVzQnlUeXBlLnNldChub2RlS2V5LCBpc01vdmUgPyAndXBkYXRlZCcgOiBtdXRhdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uICRub2Rlc09mVHlwZShrbGFzcykge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHJlYWRPbmx5ID0gZWRpdG9yU3RhdGUuX3JlYWRPbmx5O1xuICBjb25zdCBrbGFzc1R5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gIGNvbnN0IG5vZGVzID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVzT2ZUeXBlID0gW107XG4gIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygbm9kZXMpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGtsYXNzICYmIG5vZGUuX190eXBlID09PSBrbGFzc1R5cGUgJiYgKHJlYWRPbmx5IHx8IG5vZGUuaXNBdHRhY2hlZCgpKSkge1xuICAgICAgbm9kZXNPZlR5cGUucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVzT2ZUeXBlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCwgaXNCYWNrd2FyZCwgZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5nZXRQYXJlbnQoKTtcbiAgbGV0IG9mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICBsZXQgYmxvY2sgPSBlbGVtZW50O1xuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcbiAgICAgIG9mZnNldCA9IGJsb2NrLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKCFpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSBibG9jay5nZXRDaGlsZHJlblNpemUoKSkge1xuICAgICAgb2Zmc2V0ID0gYmxvY2suZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrLmdldENoaWxkQXRJbmRleChpc0JhY2t3YXJkID8gb2Zmc2V0IC0gMSA6IG9mZnNldCk7XG59XG5mdW5jdGlvbiAkZ2V0QWRqYWNlbnROb2RlKGZvY3VzLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYmxvY2sgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGJsb2NrLCBpc0JhY2t3YXJkLCBmb2N1c09mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmIChpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSAwIHx8ICFpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSBmb2N1c05vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1c05vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBmb2N1c05vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmIChwb3NzaWJsZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCksIGlzQmFja3dhcmQsIGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgKGlzQmFja3dhcmQgPyAwIDogMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3NpYmxlTm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpcmVmb3hDbGlwYm9hcmRFdmVudHMoZWRpdG9yKSB7XG4gIGNvbnN0IGV2ZW50ID0gZ2V0V2luZG93KGVkaXRvcikuZXZlbnQ7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGV2ZW50ICYmIGV2ZW50LmlucHV0VHlwZTtcbiAgcmV0dXJuIGlucHV0VHlwZSA9PT0gJ2luc2VydEZyb21QYXN0ZScgfHwgaW5wdXRUeXBlID09PSAnaW5zZXJ0RnJvbVBhc3RlQXNRdW90YXRpb24nO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgY29tbWFuZCwgcGF5bG9hZCkge1xuICByZXR1cm4gdHJpZ2dlckNvbW1hbmRMaXN0ZW5lcnMoZWRpdG9yLCBjb21tYW5kLCBwYXlsb2FkKTtcbn1cbmZ1bmN0aW9uICR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQobm9kZSkge1xuICByZXR1cm4gISRpc1Jvb3ROb2RlKG5vZGUpICYmICFub2RlLmlzTGFzdENoaWxkKCkgJiYgIW5vZGUuaXNJbmxpbmUoKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCBrZXkpIHtcbiAgY29uc3QgZWxlbWVudCA9IGVkaXRvci5fa2V5VG9ET01NYXAuZ2V0KGtleSk7XG4gIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgUmVjb25jaWxpYXRpb246IGNvdWxkIG5vdCBmaW5kIERPTSBlbGVtZW50IGZvciBub2RlIGtleSAke2tleX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRFbGVtZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50RWxlbWVudDtcbiAgcmV0dXJuIHBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgcGFyZW50RWxlbWVudC5ub2RlVHlwZSA9PT0gMTEgPyBwYXJlbnRFbGVtZW50Lmhvc3QgOiBwYXJlbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlZGl0b3IsIHNlbGVjdGlvblJlY3QsIHJvb3RFbGVtZW50KSB7XG4gIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoZGVmYXVsdFZpZXcgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHtcbiAgICB0b3A6IGN1cnJlbnRUb3AsXG4gICAgYm90dG9tOiBjdXJyZW50Qm90dG9tXG4gIH0gPSBzZWxlY3Rpb25SZWN0O1xuICBsZXQgdGFyZ2V0VG9wID0gMDtcbiAgbGV0IHRhcmdldEJvdHRvbSA9IDA7XG4gIGxldCBlbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG4gIHdoaWxlIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3QgaXNCb2R5RWxlbWVudCA9IGVsZW1lbnQgPT09IGRvYy5ib2R5O1xuICAgIGlmIChpc0JvZHlFbGVtZW50KSB7XG4gICAgICB0YXJnZXRUb3AgPSAwO1xuICAgICAgdGFyZ2V0Qm90dG9tID0gZ2V0V2luZG93KGVkaXRvcikuaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGFyZ2V0VG9wID0gdGFyZ2V0UmVjdC50b3A7XG4gICAgICB0YXJnZXRCb3R0b20gPSB0YXJnZXRSZWN0LmJvdHRvbTtcbiAgICB9XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGlmIChjdXJyZW50VG9wIDwgdGFyZ2V0VG9wKSB7XG4gICAgICBkaWZmID0gLSh0YXJnZXRUb3AgLSBjdXJyZW50VG9wKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCb3R0b20gPiB0YXJnZXRCb3R0b20pIHtcbiAgICAgIGRpZmYgPSBjdXJyZW50Qm90dG9tIC0gdGFyZ2V0Qm90dG9tO1xuICAgIH1cbiAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgICAgLy8gT25seSBoYW5kbGVzIHNjcm9sbGluZyBvZiBZIGF4aXNcbiAgICAgICAgZGVmYXVsdFZpZXcuc2Nyb2xsQnkoMCwgZGlmZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgKz0gZGlmZjtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gc2Nyb2xsVG9wO1xuICAgICAgICBjdXJyZW50VG9wIC09IHlPZmZzZXQ7XG4gICAgICAgIGN1cnJlbnRCb3R0b20gLT0geU9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbGVtZW50ID0gZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gJGhhc1VwZGF0ZVRhZyh0YWcpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIHJldHVybiBlZGl0b3IuX3VwZGF0ZVRhZ3MuaGFzKHRhZyk7XG59XG5mdW5jdGlvbiAkYWRkVXBkYXRlVGFnKHRhZykge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGVkaXRvci5fdXBkYXRlVGFncy5hZGQodGFnKTtcbn1cbmZ1bmN0aW9uICRtYXliZU1vdmVDaGlsZHJlblNlbGVjdGlvblRvUGFyZW50KHBhcmVudE5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc0VsZW1lbnROb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGlmICgkaGFzQW5jZXN0b3IoYW5jaG9yTm9kZSwgcGFyZW50Tm9kZSkpIHtcbiAgICBhbmNob3Iuc2V0KHBhcmVudE5vZGUuX19rZXksIDAsICdlbGVtZW50Jyk7XG4gIH1cbiAgaWYgKCRoYXNBbmNlc3Rvcihmb2N1c05vZGUsIHBhcmVudE5vZGUpKSB7XG4gICAgZm9jdXMuc2V0KHBhcmVudE5vZGUuX19rZXksIDAsICdlbGVtZW50Jyk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRoYXNBbmNlc3RvcihjaGlsZCwgdGFyZ2V0Tm9kZSkge1xuICBsZXQgcGFyZW50ID0gY2hpbGQuZ2V0UGFyZW50KCk7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAocGFyZW50LmlzKHRhcmdldE5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRWaWV3KGRvbUVsZW0pIHtcbiAgY29uc3Qgb3duZXJEb2MgPSBkb21FbGVtLm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvYyAmJiBvd25lckRvYy5kZWZhdWx0VmlldyB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KGVkaXRvcikge1xuICBjb25zdCB3aW5kb3dPYmogPSBlZGl0b3IuX3dpbmRvdztcbiAgaWYgKHdpbmRvd09iaiA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGB3aW5kb3cgb2JqZWN0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gd2luZG93T2JqO1xufVxuZnVuY3Rpb24gJGlzSW5saW5lRWxlbWVudE9yRGVjb3JhdG9yTm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCk7XG59XG5mdW5jdGlvbiAkZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3Qobm9kZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiAkaXNSb290T3JTaGFkb3dSb290KG5vZGUpIHtcbiAgcmV0dXJuICRpc1Jvb3ROb2RlKG5vZGUpIHx8ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuaXNTaGFkb3dSb290KCk7XG59XG5mdW5jdGlvbiAkY29weU5vZGUobm9kZSkge1xuICBjb25zdCBjb3B5ID0gbm9kZS5jb25zdHJ1Y3Rvci5jbG9uZShub2RlKTtcbiAgJHNldE5vZGVLZXkoY29weSwgbnVsbCk7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobm9kZSkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLmNvbnN0cnVjdG9yLmdldFR5cGUoKTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldChub2RlVHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYCRpbml0aWFsaXplTm9kZSBmYWlsZWQuIEVuc3VyZSBub2RlIGhhcyBiZWVuIHJlZ2lzdGVyZWQgdG8gdGhlIGVkaXRvci4gWW91IGNhbiBkbyB0aGlzIGJ5IHBhc3NpbmcgdGhlIG5vZGUgY2xhc3MgdmlhIHRoZSBcIm5vZGVzXCIgYXJyYXkgaW4gdGhlIGVkaXRvciBjb25maWcuYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcGxhY2VGdW5jID0gcmVnaXN0ZXJlZE5vZGUucmVwbGFjZTtcbiAgaWYgKHJlcGxhY2VGdW5jICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gcmVwbGFjZUZ1bmMobm9kZSk7XG4gICAgaWYgKCEocmVwbGFjZW1lbnROb2RlIGluc3RhbmNlb2Ygbm9kZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCRpbml0aWFsaXplTm9kZSBmYWlsZWQuIEVuc3VyZSByZXBsYWNlbWVudCBub2RlIGlzIGEgc3ViY2xhc3Mgb2YgdGhlIG9yaWdpbmFsIG5vZGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlbWVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3Qobm9kZSwgaW5zZXJ0Tm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKCRpc1Jvb3ROb2RlKHBhcmVudE5vZGUpICYmICEkaXNFbGVtZW50Tm9kZShpbnNlcnROb2RlKSAmJiAhJGlzRGVjb3JhdG9yTm9kZShpbnNlcnROb2RlKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBPbmx5IGVsZW1lbnQgb3IgZGVjb3JhdG9yIG5vZGVzIGNhbiBiZSBpbnNlcnRlZCBpbiB0byB0aGUgcm9vdCBub2RlYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yQ29uZmlnKSB7XG4gIGNvbnN0IHRoZW1lID0gZWRpdG9yQ29uZmlnLnRoZW1lO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1jdXJzb3InLCAndHJ1ZScpO1xuICBsZXQgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yO1xuICBpZiAoYmxvY2tDdXJzb3JUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBibG9ja0N1cnNvclRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoYmxvY2tDdXJzb3JUaGVtZSk7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbFxuICAgICAgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yID0gY2xhc3NOYW1lc0FycjtcbiAgICB9XG4gICAgaWYgKGJsb2NrQ3Vyc29yVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmJsb2NrQ3Vyc29yVGhlbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIG5lZWRzQmxvY2tDdXJzb3Iobm9kZSkge1xuICByZXR1cm4gKCRpc0RlY29yYXRvck5vZGUobm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuY2FuQmVFbXB0eSgpKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCkge1xuICByb290RWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY2FyZXQtY29sb3InKTtcbiAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gYmxvY2tDdXJzb3JFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChibG9ja0N1cnNvckVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgbmV4dFNlbGVjdGlvbikge1xuICBsZXQgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSAmJiBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZWxlbWVudE5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgZWxlbWVudE5vZGVTaXplID0gZWxlbWVudE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IGlzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBsZXQgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKG9mZnNldCA9PT0gZWxlbWVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnROb2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQgLSAxKTtcbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50Tm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmIChzaWJsaW5nID09PSBudWxsIHx8IG5lZWRzQmxvY2tDdXJzb3Ioc2libGluZykpIHtcbiAgICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICBpbnNlcnRCZWZvcmVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShjaGlsZC5fX2tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQmxvY2tDdXJzb3IpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnROb2RlLl9fa2V5KTtcbiAgICAgIGlmIChibG9ja0N1cnNvckVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBibG9ja0N1cnNvckVsZW1lbnQgPSBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLl9jb25maWcpO1xuICAgICAgfVxuICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuY2FyZXRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICBpZiAoaW5zZXJ0QmVmb3JlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50RE9NLmFwcGVuZENoaWxkKGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50RE9NLmluc2VydEJlZm9yZShibG9ja0N1cnNvckVsZW1lbnQsIGluc2VydEJlZm9yZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmUgY3Vyc29yXG4gIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RE9NU2VsZWN0aW9uKHRhcmdldFdpbmRvdykge1xuICByZXR1cm4gIUNBTl9VU0VfRE9NID8gbnVsbCA6ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBzdGFydE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuICBpZiAoc3RhcnROb2RlID09IG51bGwpIHtcbiAgICBzdGFydE5vZGUgPSBub2RlO1xuICB9XG4gIGlmICghISRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2FuIG5vdCBjYWxsICRzcGxpdE5vZGUoKSBvbiByb290IGVsZW1lbnRgKTtcbiAgfVxuICBjb25zdCByZWN1cnNlID0gY3VycmVudE5vZGUgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBpc1BhcmVudFJvb3QgPSAkaXNSb290T3JTaGFkb3dSb290KHBhcmVudCk7XG4gICAgLy8gVGhlIG5vZGUgd2Ugc3RhcnQgc3BsaXQgZnJvbSAobGVhZikgaXMgbW92ZWQsIGJ1dCBpdHMgcmVjdXJzaXZlXG4gICAgLy8gcGFyZW50cyBhcmUgY29waWVkIHRvIGNyZWF0ZSBzZXBhcmF0ZSB0cmVlXG4gICAgY29uc3Qgbm9kZVRvTW92ZSA9IGN1cnJlbnROb2RlID09PSBzdGFydE5vZGUgJiYgIWlzUGFyZW50Um9vdCA/IGN1cnJlbnROb2RlIDogJGNvcHlOb2RlKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoaXNQYXJlbnRSb290KSB7XG4gICAgICBpZiAoISgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgJGlzRWxlbWVudE5vZGUobm9kZVRvTW92ZSkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBDaGlsZHJlbiBvZiBhIHJvb3QgbXVzdCBiZSBFbGVtZW50Tm9kZWApO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZVRvTW92ZSk7XG4gICAgICByZXR1cm4gW2N1cnJlbnROb2RlLCBub2RlVG9Nb3ZlLCBub2RlVG9Nb3ZlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW2xlZnRUcmVlLCByaWdodFRyZWUsIG5ld1BhcmVudF0gPSByZWN1cnNlKHBhcmVudCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgIG5ld1BhcmVudC5hcHBlbmQobm9kZVRvTW92ZSwgLi4ubmV4dFNpYmxpbmdzKTtcbiAgICAgIHJldHVybiBbbGVmdFRyZWUsIHJpZ2h0VHJlZSwgbm9kZVRvTW92ZV07XG4gICAgfVxuICB9O1xuICBjb25zdCBbbGVmdFRyZWUsIHJpZ2h0VHJlZV0gPSByZWN1cnNlKHN0YXJ0Tm9kZSk7XG4gIHJldHVybiBbbGVmdFRyZWUsIHJpZ2h0VHJlZV07XG59XG5cbi8qKlxuICogQHBhcmFtIHggLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0ZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGFuIEhUTUwgYW5jaG9yIHRhZywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzSFRNTEFuY2hvckVsZW1lbnQoeCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudCh4KSAmJiB4LnRhZ05hbWUgPT09ICdBJztcbn1cblxuLyoqXG4gKiBAcGFyYW0geCAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RpbmdcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGFuIEhUTUwgZWxlbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHgpIHtcbiAgLy8gQHRzLWlnbm9yZS1uZXh0LWxpbmUgLSBzdHJpY3QgY2hlY2sgb24gbm9kZVR5cGUgaGVyZSBzaG91bGQgZmlsdGVyIG91dCBub24tRWxlbWVudCBFdmVudFRhcmdldCBpbXBsZW1lbnRvcnNcbiAgcmV0dXJuIHgubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBub2RlIC0gdGhlIERvbSBOb2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBpZiB0aGUgRG9tIE5vZGUgaXMgYW4gaW5saW5lIG5vZGVcbiAqL1xuZnVuY3Rpb24gaXNJbmxpbmVEb21Ob2RlKG5vZGUpIHtcbiAgY29uc3QgaW5saW5lTm9kZXMgPSBuZXcgUmVnRXhwKC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyfCN0ZXh0KSQvLCAnaScpO1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZS5tYXRjaChpbmxpbmVOb2RlcykgIT09IG51bGw7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBub2RlIC0gdGhlIERvbSBOb2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBpZiB0aGUgRG9tIE5vZGUgaXMgYSBibG9jayBub2RlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvY2tEb21Ob2RlKG5vZGUpIHtcbiAgY29uc3QgYmxvY2tOb2RlcyA9IG5ldyBSZWdFeHAoL14oYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJsb2NrcXVvdGV8Y2FudmFzfGRkfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxoMXxoMnxoM3xoNHxoNXxoNnxoZWFkZXJ8aHJ8bGl8bWFpbnxuYXZ8bm9zY3JpcHR8b2x8cHxwcmV8c2VjdGlvbnx0YWJsZXx0ZHx0Zm9vdHx1bHx2aWRlbykkLywgJ2knKTtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUubWF0Y2goYmxvY2tOb2RlcykgIT09IG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9mIHRoZSBsaWJyYXJ5LlxuICogUGxlYXNlIGRvIG5vdCB1c2UgaXQgYXMgaXQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5mdW5jdGlvbiBJTlRFUk5BTF8kaXNCbG9jayhub2RlKSB7XG4gIGlmICgkaXNSb290Tm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpIHx8ICRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICBjb25zdCBpc0xlYWZFbGVtZW50ID0gZmlyc3RDaGlsZCA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8IGZpcnN0Q2hpbGQuaXNJbmxpbmUoKTtcbiAgcmV0dXJuICFub2RlLmlzSW5saW5lKCkgJiYgbm9kZS5jYW5CZUVtcHR5KCkgIT09IGZhbHNlICYmIGlzTGVhZkVsZW1lbnQ7XG59XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYWNjZXNzaW5nIGN1cnJlbnQgYWN0aXZlIGVkaXRvciBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIEN1cnJlbnQgYWN0aXZlIGVkaXRvclxuICovXG5mdW5jdGlvbiAkZ2V0RWRpdG9yKCkge1xuICByZXR1cm4gZ2V0QWN0aXZlRWRpdG9yKCk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gZWRpdG9yLl9kZWNvcmF0b3JzO1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IGVkaXRvci5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGxldCBkZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnMgfHwgY3VycmVudERlY29yYXRvcnM7XG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoIW5vZGVNYXAuaGFzKGtleSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzID09PSBjdXJyZW50RGVjb3JhdG9ycykge1xuICAgICAgICBkZWNvcmF0b3JzID0gY2xvbmVEZWNvcmF0b3JzKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBkZWxldGUgZGVjb3JhdG9yc1trZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBwYXJlbnRLZXksIHByZXZOb2RlTWFwLCBub2RlTWFwLCBub2RlTWFwRGVsZXRlLCBkaXJ0eU5vZGVzKSB7XG4gIGxldCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBjb25zdCBjaGlsZEtleSA9IGNoaWxkLl9fa2V5O1xuICAgIC8vIFRPRE8gUmV2aXNlIGNvbmRpdGlvbiBiZWxvdywgcmVkdW5kYW50PyBMZXhpY2FsTm9kZSBhbHJlYWR5IGNsZWFucyB1cCBjaGlsZHJlbiB3aGVuIG1vdmluZyBOb2Rlc1xuICAgIGlmIChjaGlsZC5fX3BhcmVudCA9PT0gcGFyZW50S2V5KSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVlcENoaWxkTm9kZXMoY2hpbGQsIGNoaWxkS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlOb2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgY3JlYXRlZCBhIG5vZGUgYW5kIGl0IHdhcyBkZXJlZmVyZW5jZWQsIHRoZW4gYWxzb1xuICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gb3V0IGRpcnR5IG5vZGVzIFNldC5cbiAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKGNoaWxkS2V5KSkge1xuICAgICAgICBkaXJ0eU5vZGVzLmRlbGV0ZShjaGlsZEtleSk7XG4gICAgICB9XG4gICAgICBub2RlTWFwRGVsZXRlLnB1c2goY2hpbGRLZXkpO1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRnYXJiYWdlQ29sbGVjdERldGFjaGVkTm9kZXMocHJldkVkaXRvclN0YXRlLCBlZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMpIHtcbiAgY29uc3QgcHJldk5vZGVNYXAgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgLy8gU3RvcmUgZGlydHlFbGVtZW50cyBpbiBhIHF1ZXVlIGZvciBsYXRlciBkZWxldGlvbjsgZGVsZXRpbmcgZGlydHkgc3VidHJlZXMgdG9vIGVhcmx5IHdpbGxcbiAgLy8gaGluZGVyIGFjY2Vzc2luZyAuX19uZXh0IG9uIGNoaWxkIG5vZGVzXG4gIGNvbnN0IG5vZGVNYXBEZWxldGUgPSBbXTtcbiAgZm9yIChjb25zdCBbbm9kZUtleV0gb2YgZGlydHlFbGVtZW50cykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBHYXJiYWdlIGNvbGxlY3Qgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGlmIHRoZXkgZXhpc3RcbiAgICAgIGlmICghbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBub2RlS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlFbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjcmVhdGVkIGEgbm9kZSBhbmQgaXQgd2FzIGRlcmVmZXJlbmNlZCwgdGhlbiBhbHNvXG4gICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIG91dCBkaXJ0eSBub2RlcyBTZXQuXG4gICAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgZGlydHlFbGVtZW50cy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZU1hcERlbGV0ZS5wdXNoKG5vZGVLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IG5vZGVLZXkgb2Ygbm9kZU1hcERlbGV0ZSkge1xuICAgIG5vZGVNYXAuZGVsZXRlKG5vZGVLZXkpO1xuICB9XG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgaWYgKCFwcmV2Tm9kZU1hcC5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgZGlydHlMZWF2ZXMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgfVxuICAgICAgbm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxubGV0IHN1YlRyZWVUZXh0Q29udGVudCA9ICcnO1xubGV0IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG5sZXQgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xubGV0IGVkaXRvclRleHRDb250ZW50ID0gJyc7XG5sZXQgYWN0aXZlRWRpdG9yQ29uZmlnO1xubGV0IGFjdGl2ZUVkaXRvciQxO1xubGV0IGFjdGl2ZUVkaXRvck5vZGVzO1xubGV0IHRyZWF0QWxsTm9kZXNBc0RpcnR5ID0gZmFsc2U7XG5sZXQgYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSA9IGZhbHNlO1xubGV0IGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzO1xubGV0IGFjdGl2ZVRleHREaXJlY3Rpb24gPSBudWxsO1xubGV0IGFjdGl2ZURpcnR5RWxlbWVudHM7XG5sZXQgYWN0aXZlRGlydHlMZWF2ZXM7XG5sZXQgYWN0aXZlUHJldk5vZGVNYXA7XG5sZXQgYWN0aXZlTmV4dE5vZGVNYXA7XG5sZXQgYWN0aXZlUHJldktleVRvRE9NTWFwO1xubGV0IG11dGF0ZWROb2RlcztcbmZ1bmN0aW9uIGRlc3Ryb3lOb2RlKGtleSwgcGFyZW50RE9NKSB7XG4gIGNvbnN0IG5vZGUgPSBhY3RpdmVQcmV2Tm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKHBhcmVudERPTSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRvbSA9IGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSk7XG4gICAgaWYgKGRvbS5wYXJlbnROb2RlID09PSBwYXJlbnRET00pIHtcbiAgICAgIHBhcmVudERPTS5yZW1vdmVDaGlsZChkb20pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbG9naWMgaXMgcmVhbGx5IGltcG9ydGFudCwgb3RoZXJ3aXNlIHdlIHdpbGwgbGVhayBET00gbm9kZXNcbiAgLy8gd2hlbiB0aGVpciBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gIGlmICghYWN0aXZlTmV4dE5vZGVNYXAuaGFzKGtleSkpIHtcbiAgICBhY3RpdmVFZGl0b3IkMS5fa2V5VG9ET01NYXAuZGVsZXRlKGtleSk7XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5vZGUsIGFjdGl2ZVByZXZOb2RlTWFwKTtcbiAgICBkZXN0cm95Q2hpbGRyZW4oY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCAtIDEsIG51bGwpO1xuICB9XG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIGFjdGl2ZUVkaXRvck5vZGVzLCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgJ2Rlc3Ryb3llZCcpO1xuICB9XG59XG5mdW5jdGlvbiBkZXN0cm95Q2hpbGRyZW4oY2hpbGRyZW4sIF9zdGFydEluZGV4LCBlbmRJbmRleCwgZG9tKSB7XG4gIGxldCBzdGFydEluZGV4ID0gX3N0YXJ0SW5kZXg7XG4gIGZvciAoOyBzdGFydEluZGV4IDw9IGVuZEluZGV4OyArK3N0YXJ0SW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW3N0YXJ0SW5kZXhdO1xuICAgIGlmIChjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0cm95Tm9kZShjaGlsZCwgZG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRleHRBbGlnbihkb21TdHlsZSwgdmFsdWUpIHtcbiAgZG9tU3R5bGUuc2V0UHJvcGVydHkoJ3RleHQtYWxpZ24nLCB2YWx1ZSk7XG59XG5jb25zdCBERUZBVUxUX0lOREVOVF9WQUxVRSA9ICc0MHB4JztcbmZ1bmN0aW9uIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBpbmRlbnQpIHtcbiAgY29uc3QgaW5kZW50Q2xhc3NOYW1lID0gYWN0aXZlRWRpdG9yQ29uZmlnLnRoZW1lLmluZGVudDtcbiAgaWYgKHR5cGVvZiBpbmRlbnRDbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZWxlbWVudEhhc0NsYXNzTmFtZSA9IGRvbS5jbGFzc0xpc3QuY29udGFpbnMoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICBpZiAoaW5kZW50ID4gMCAmJiAhZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGluZGVudCA8IDEgJiYgZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5yZW1vdmUoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaW5kZW50YXRpb25CYXNlVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKGRvbSkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1sZXhpY2FsLWluZGVudC1iYXNlLXZhbHVlJykgfHwgREVGQVVMVF9JTkRFTlRfVkFMVUU7XG4gIGRvbS5zdHlsZS5zZXRQcm9wZXJ0eSgncGFkZGluZy1pbmxpbmUtc3RhcnQnLCBpbmRlbnQgPT09IDAgPyAnJyA6IGBjYWxjKCR7aW5kZW50fSAqICR7aW5kZW50YXRpb25CYXNlVmFsdWV9KWApO1xufVxuZnVuY3Rpb24gc2V0RWxlbWVudEZvcm1hdChkb20sIGZvcm1hdCkge1xuICBjb25zdCBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJycpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fTEVGVCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2xlZnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0NFTlRFUikge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2NlbnRlcicpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fUklHSFQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdyaWdodCcpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fSlVTVElGWSkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2p1c3RpZnknKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX1NUQVJUKSB7XG4gICAgc2V0VGV4dEFsaWduKGRvbVN0eWxlLCAnc3RhcnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0VORCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2VuZCcpO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlTm9kZShrZXksIHBhcmVudERPTSwgaW5zZXJ0RE9NKSB7XG4gIGNvbnN0IG5vZGUgPSBhY3RpdmVOZXh0Tm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBjcmVhdGVOb2RlOiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZG9tID0gbm9kZS5jcmVhdGVET00oYWN0aXZlRWRpdG9yQ29uZmlnLCBhY3RpdmVFZGl0b3IkMSk7XG4gIHN0b3JlRE9NV2l0aEtleShrZXksIGRvbSwgYWN0aXZlRWRpdG9yJDEpO1xuXG4gIC8vIFRoaXMgaGVscHMgcHJlc2VydmUgdGhlIHRleHQsIGFuZCBzdG9wcyBzcGVsbCBjaGVjayB0b29scyBmcm9tXG4gIC8vIG1lcmdpbmcgb3IgYnJlYWsgdGhlIHNwYW5zICh3aGljaCBoYXBwZW5zIGlmIHRoZXkgYXJlIG1pc3NpbmdcbiAgLy8gdGhpcyBhdHRyaWJ1dGUpLlxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtdGV4dCcsICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1kZWNvcmF0b3InLCAndHJ1ZScpO1xuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IGluZGVudCA9IG5vZGUuX19pbmRlbnQ7XG4gICAgY29uc3QgY2hpbGRyZW5TaXplID0gbm9kZS5fX3NpemU7XG4gICAgaWYgKGluZGVudCAhPT0gMCkge1xuICAgICAgc2V0RWxlbWVudEluZGVudChkb20sIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlblNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGVuZEluZGV4ID0gY2hpbGRyZW5TaXplIC0gMTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShub2RlLCBhY3RpdmVOZXh0Tm9kZU1hcCk7XG4gICAgICAkY3JlYXRlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKGNoaWxkcmVuLCBlbmRJbmRleCwgbm9kZSwgZG9tKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybWF0ID0gbm9kZS5fX2Zvcm1hdDtcbiAgICBpZiAoZm9ybWF0ICE9PSAwKSB7XG4gICAgICBzZXRFbGVtZW50Rm9ybWF0KGRvbSwgZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIHJlY29uY2lsZUVsZW1lbnRUZXJtaW5hdGluZ0xpbmVCcmVhayhudWxsLCBub2RlLCBkb20pO1xuICAgIH1cbiAgICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChub2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IG5vZGUuZGVjb3JhdGUoYWN0aXZlRWRpdG9yJDEsIGFjdGl2ZUVkaXRvckNvbmZpZyk7XG4gICAgICBpZiAoZGVjb3JhdG9yICE9PSBudWxsKSB7XG4gICAgICAgIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcik7XG4gICAgICB9XG4gICAgICAvLyBEZWNvcmF0b3JzIGFyZSBhbHdheXMgbm9uIGVkaXRhYmxlXG4gICAgICBkb20uY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBpZiAoIW5vZGUuaXNEaXJlY3Rpb25sZXNzKCkpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgfVxuICBpZiAocGFyZW50RE9NICE9PSBudWxsKSB7XG4gICAgaWYgKGluc2VydERPTSAhPSBudWxsKSB7XG4gICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGRvbSwgaW5zZXJ0RE9NKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IHBvc3NpYmxlTGluZUJyZWFrID0gcGFyZW50RE9NLl9fbGV4aWNhbExpbmVCcmVhaztcbiAgICAgIGlmIChwb3NzaWJsZUxpbmVCcmVhayAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudERPTS5pbnNlcnRCZWZvcmUoZG9tLCBwb3NzaWJsZUxpbmVCcmVhayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRET00uYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIC8vIEZyZWV6ZSB0aGUgbm9kZSBpbiBERVYgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uc1xuICAgIE9iamVjdC5mcmVlemUobm9kZSk7XG4gIH1cbiAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5vZGUsICdjcmVhdGVkJyk7XG4gIHJldHVybiBkb207XG59XG5mdW5jdGlvbiAkY3JlYXRlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKGNoaWxkcmVuLCBlbmRJbmRleCwgZWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgJGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCAwLCBlbmRJbmRleCwgZG9tLCBudWxsKTtcbiAgcmVjb25jaWxlQmxvY2tEaXJlY3Rpb24oZWxlbWVudCwgZG9tKTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCBfc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRvbSwgaW5zZXJ0RE9NKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgbGV0IHN0YXJ0SW5kZXggPSBfc3RhcnRJbmRleDtcbiAgZm9yICg7IHN0YXJ0SW5kZXggPD0gZW5kSW5kZXg7ICsrc3RhcnRJbmRleCkge1xuICAgICRjcmVhdGVOb2RlKGNoaWxkcmVuW3N0YXJ0SW5kZXhdLCBkb20sIGluc2VydERPTSk7XG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5leHROb2RlTWFwLmdldChjaGlsZHJlbltzdGFydEluZGV4XSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwgJiYgc3ViVHJlZVRleHRGb3JtYXQgPT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Rm9ybWF0ID0gbm9kZS5nZXRGb3JtYXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQoZWxlbWVudCkpIHtcbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gIH1cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgZG9tLl9fbGV4aWNhbFRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCArIHN1YlRyZWVUZXh0Q29udGVudDtcbn1cbmZ1bmN0aW9uIGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IoY2hpbGRLZXksIG5vZGVNYXApIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KGNoaWxkS2V5KTtcbiAgcmV0dXJuICRpc0xpbmVCcmVha05vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCk7XG59XG5cbi8vIElmIHdlIGVuZCBhbiBlbGVtZW50IHdpdGggYSBMaW5lQnJlYWtOb2RlLCB0aGVuIHdlIG5lZWQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgPGJyPlxuZnVuY3Rpb24gcmVjb25jaWxlRWxlbWVudFRlcm1pbmF0aW5nTGluZUJyZWFrKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZMaW5lQnJlYWsgPSBwcmV2RWxlbWVudCAhPT0gbnVsbCAmJiAocHJldkVsZW1lbnQuX19zaXplID09PSAwIHx8IGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IocHJldkVsZW1lbnQuX19sYXN0LCBhY3RpdmVQcmV2Tm9kZU1hcCkpO1xuICBjb25zdCBuZXh0TGluZUJyZWFrID0gbmV4dEVsZW1lbnQuX19zaXplID09PSAwIHx8IGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IobmV4dEVsZW1lbnQuX19sYXN0LCBhY3RpdmVOZXh0Tm9kZU1hcCk7XG4gIGlmIChwcmV2TGluZUJyZWFrKSB7XG4gICAgaWYgKCFuZXh0TGluZUJyZWFrKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY29uc3QgZWxlbWVudCA9IGRvbS5fX2xleGljYWxMaW5lQnJlYWs7XG4gICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGRvbS5fX2xleGljYWxMaW5lQnJlYWsgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0TGluZUJyZWFrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICBkb20uX19sZXhpY2FsTGluZUJyZWFrID0gZWxlbWVudDtcbiAgICBkb20uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29uY2lsZVBhcmFncmFwaEZvcm1hdChlbGVtZW50KSB7XG4gIGlmICgkaXNQYXJhZ3JhcGhOb2RlKGVsZW1lbnQpICYmIHN1YlRyZWVUZXh0Rm9ybWF0ICE9IG51bGwgJiYgc3ViVHJlZVRleHRGb3JtYXQgIT09IGVsZW1lbnQuX190ZXh0Rm9ybWF0KSB7XG4gICAgZWxlbWVudC5zZXRUZXh0Rm9ybWF0KHN1YlRyZWVUZXh0Rm9ybWF0KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb25jaWxlQmxvY2tEaXJlY3Rpb24oZWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ID1cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgZG9tLl9fbGV4aWNhbERpclRleHRDb250ZW50O1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICBjb25zdCBwcmV2aW91c0RpcmVjdGlvbiA9IGRvbS5fX2xleGljYWxEaXI7XG4gIGlmIChwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCAhPT0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgfHwgcHJldmlvdXNEaXJlY3Rpb24gIT09IGFjdGl2ZVRleHREaXJlY3Rpb24pIHtcbiAgICBjb25zdCBoYXNFbXB0eURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9PT0gJyc7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gaGFzRW1wdHlEaXJlY3Rpb25lZFRleHRDb250ZW50ID8gYWN0aXZlVGV4dERpcmVjdGlvbiA6IGdldFRleHREaXJlY3Rpb24oc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQpO1xuICAgIGlmIChkaXJlY3Rpb24gIT09IHByZXZpb3VzRGlyZWN0aW9uKSB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBkb20uY2xhc3NMaXN0O1xuICAgICAgY29uc3QgdGhlbWUgPSBhY3RpdmVFZGl0b3JDb25maWcudGhlbWU7XG4gICAgICBsZXQgcHJldmlvdXNEaXJlY3Rpb25UaGVtZSA9IHByZXZpb3VzRGlyZWN0aW9uICE9PSBudWxsID8gdGhlbWVbcHJldmlvdXNEaXJlY3Rpb25dIDogdW5kZWZpbmVkO1xuICAgICAgbGV0IG5leHREaXJlY3Rpb25UaGVtZSA9IGRpcmVjdGlvbiAhPT0gbnVsbCA/IHRoZW1lW2RpcmVjdGlvbl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIHRoZW1lIGNsYXNzZXMgaWYgdGhleSBleGlzdFxuICAgICAgaWYgKHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMocHJldmlvdXNEaXJlY3Rpb25UaGVtZSk7XG4gICAgICAgICAgcHJldmlvdXNEaXJlY3Rpb25UaGVtZSA9IHRoZW1lW3ByZXZpb3VzRGlyZWN0aW9uXSA9IGNsYXNzTmFtZXNBcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlOiBpbnRlbnRpb25hbFxuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKC4uLnByZXZpb3VzRGlyZWN0aW9uVGhlbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gbnVsbCB8fCBoYXNFbXB0eURpcmVjdGlvbmVkVGV4dENvbnRlbnQgJiYgZGlyZWN0aW9uID09PSAnbHRyJykge1xuICAgICAgICAvLyBSZW1vdmUgZGlyZWN0aW9uXG4gICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2RpcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXBwbHkgdGhlIG5ldyB0aGVtZSBjbGFzc2VzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgaWYgKG5leHREaXJlY3Rpb25UaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0RGlyZWN0aW9uVGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzQXJyID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhuZXh0RGlyZWN0aW9uVGhlbWUpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcbiAgICAgICAgICAgIG5leHREaXJlY3Rpb25UaGVtZSA9IHRoZW1lW2RpcmVjdGlvbl0gPSBjbGFzc05hbWVzQXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dERpcmVjdGlvblRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoLi4ubmV4dERpcmVjdGlvblRoZW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aW9uXG4gICAgICAgIGRvbS5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOb2RlID0gZWxlbWVudC5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZU5vZGUuX19kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZVRleHREaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICBkb20uX19sZXhpY2FsRGlyVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIGRvbS5fX2xleGljYWxEaXIgPSBkaXJlY3Rpb247XG4gIH1cbn1cbmZ1bmN0aW9uICRyZWNvbmNpbGVDaGlsZHJlbldpdGhEaXJlY3Rpb24ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xuICAkcmVjb25jaWxlQ2hpbGRyZW4ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pO1xuICByZWNvbmNpbGVCbG9ja0RpcmVjdGlvbihuZXh0RWxlbWVudCwgZG9tKTtcbiAgcmVjb25jaWxlUGFyYWdyYXBoRm9ybWF0KG5leHRFbGVtZW50KTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudDtcbiAgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5BcnJheShlbGVtZW50LCBub2RlTWFwKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG4gIGxldCBub2RlS2V5ID0gZWxlbWVudC5fX2ZpcnN0O1xuICB3aGlsZSAobm9kZUtleSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBjcmVhdGVDaGlsZHJlbkFycmF5OiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGRyZW4ucHVzaChub2RlS2V5KTtcbiAgICBub2RlS2V5ID0gbm9kZS5fX25leHQ7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gJHJlY29uY2lsZUNoaWxkcmVuKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBjb25zdCBwcmV2Q2hpbGRyZW5TaXplID0gcHJldkVsZW1lbnQuX19zaXplO1xuICBjb25zdCBuZXh0Q2hpbGRyZW5TaXplID0gbmV4dEVsZW1lbnQuX19zaXplO1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKHByZXZDaGlsZHJlblNpemUgPT09IDEgJiYgbmV4dENoaWxkcmVuU2l6ZSA9PT0gMSkge1xuICAgIGNvbnN0IHByZXZGaXJzdENoaWxkS2V5ID0gcHJldkVsZW1lbnQuX19maXJzdDtcbiAgICBjb25zdCBuZXh0RnJzdENoaWxkS2V5ID0gbmV4dEVsZW1lbnQuX19maXJzdDtcbiAgICBpZiAocHJldkZpcnN0Q2hpbGRLZXkgPT09IG5leHRGcnN0Q2hpbGRLZXkpIHtcbiAgICAgICRyZWNvbmNpbGVOb2RlKHByZXZGaXJzdENoaWxkS2V5LCBkb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0RE9NID0gZ2V0UHJldkVsZW1lbnRCeUtleU9yVGhyb3cocHJldkZpcnN0Q2hpbGRLZXkpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRET00gPSAkY3JlYXRlTm9kZShuZXh0RnJzdENoaWxkS2V5LCBudWxsLCBudWxsKTtcbiAgICAgIGRvbS5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnRET00sIGxhc3RET00pO1xuICAgICAgZGVzdHJveU5vZGUocHJldkZpcnN0Q2hpbGRLZXksIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Q2hpbGROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KG5leHRGcnN0Q2hpbGRLZXkpO1xuICAgIGlmIChzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShuZXh0Q2hpbGROb2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRGb3JtYXQgPSBuZXh0Q2hpbGROb2RlLmdldEZvcm1hdCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmV2Q2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KHByZXZFbGVtZW50LCBhY3RpdmVQcmV2Tm9kZU1hcCk7XG4gICAgY29uc3QgbmV4dENoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShuZXh0RWxlbWVudCwgYWN0aXZlTmV4dE5vZGVNYXApO1xuICAgIGlmIChwcmV2Q2hpbGRyZW5TaXplID09PSAwKSB7XG4gICAgICBpZiAobmV4dENoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgICAkY3JlYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCBuZXh0RWxlbWVudCwgMCwgbmV4dENoaWxkcmVuU2l6ZSAtIDEsIGRvbSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW5TaXplID09PSAwKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgICBjb25zdCBsZXhpY2FsTGluZUJyZWFrID0gZG9tLl9fbGV4aWNhbExpbmVCcmVhaztcbiAgICAgICAgY29uc3QgY2FuVXNlRmFzdFBhdGggPSBsZXhpY2FsTGluZUJyZWFrID09IG51bGw7XG4gICAgICAgIGRlc3Ryb3lDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIDAsIHByZXZDaGlsZHJlblNpemUgLSAxLCBjYW5Vc2VGYXN0UGF0aCA/IG51bGwgOiBkb20pO1xuICAgICAgICBpZiAoY2FuVXNlRmFzdFBhdGgpIHtcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIHJlbW92aW5nIERPTSBub2Rlc1xuICAgICAgICAgIGRvbS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyZWNvbmNpbGVOb2RlQ2hpbGRyZW4obmV4dEVsZW1lbnQsIHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBwcmV2Q2hpbGRyZW5TaXplLCBuZXh0Q2hpbGRyZW5TaXplLCBkb20pO1xuICAgIH1cbiAgfVxuICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChuZXh0RWxlbWVudCkpIHtcbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICBkb20uX19sZXhpY2FsVGV4dENvbnRlbnQgPSBzdWJUcmVlVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICsgc3ViVHJlZVRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gJHJlY29uY2lsZU5vZGUoa2V5LCBwYXJlbnRET00pIHtcbiAgY29uc3QgcHJldk5vZGUgPSBhY3RpdmVQcmV2Tm9kZU1hcC5nZXQoa2V5KTtcbiAgbGV0IG5leHROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KGtleSk7XG4gIGlmIChwcmV2Tm9kZSA9PT0gdW5kZWZpbmVkIHx8IG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcmVjb25jaWxlTm9kZTogcHJldk5vZGUgb3IgbmV4dE5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc0RpcnR5ID0gdHJlYXRBbGxOb2Rlc0FzRGlydHkgfHwgYWN0aXZlRGlydHlMZWF2ZXMuaGFzKGtleSkgfHwgYWN0aXZlRGlydHlFbGVtZW50cy5oYXMoa2V5KTtcbiAgY29uc3QgZG9tID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhhY3RpdmVFZGl0b3IkMSwga2V5KTtcblxuICAvLyBJZiB0aGUgbm9kZSBrZXkgcG9pbnRzIHRvIHRoZSBzYW1lIGluc3RhbmNlIGluIGJvdGggc3RhdGVzXG4gIC8vIGFuZCBpc24ndCBkaXJ0eSwgd2UganVzdCB1cGRhdGUgdGhlIHRleHQgY29udGVudCBjYWNoZVxuICAvLyBhbmQgcmV0dXJuIHRoZSBleGlzdGluZyBET00gTm9kZS5cbiAgaWYgKHByZXZOb2RlID09PSBuZXh0Tm9kZSAmJiAhaXNEaXJ0eSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2Tm9kZSkpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCA9IGRvbS5fX2xleGljYWxUZXh0Q29udGVudDtcbiAgICAgIGlmIChwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudDtcbiAgICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCA9IGRvbS5fX2xleGljYWxEaXJUZXh0Q29udGVudDtcbiAgICAgIGlmIChwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ZXh0ID0gcHJldk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgIXByZXZOb2RlLmlzRGlyZWN0aW9ubGVzcygpKSB7XG4gICAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICB9XG4gICAgICBlZGl0b3JUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH1cbiAgLy8gSWYgdGhlIG5vZGUga2V5IGRvZXNuJ3QgcG9pbnQgdG8gdGhlIHNhbWUgaW5zdGFuY2UgaW4gYm90aCBtYXBzLFxuICAvLyBpdCBtZWFucyBpdCB3ZXJlIGNsb25lZC4gSWYgdGhleSdyZSBhbHNvIGRpcnR5LCB3ZSBtYXJrIHRoZW0gYXMgbXV0YXRlZC5cbiAgaWYgKHByZXZOb2RlICE9PSBuZXh0Tm9kZSAmJiBpc0RpcnR5KSB7XG4gICAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5leHROb2RlLCAndXBkYXRlZCcpO1xuICB9XG5cbiAgLy8gVXBkYXRlIG5vZGUuIElmIGl0IHJldHVybnMgdHJ1ZSwgd2UgbmVlZCB0byB1bm1vdW50IGFuZCByZS1jcmVhdGUgdGhlIG5vZGVcbiAgaWYgKG5leHROb2RlLnVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBhY3RpdmVFZGl0b3JDb25maWcpKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRET00gPSAkY3JlYXRlTm9kZShrZXksIG51bGwsIG51bGwpO1xuICAgIGlmIChwYXJlbnRET00gPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHJlY29uY2lsZU5vZGU6IHBhcmVudERPTSBpcyBudWxsYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcmVudERPTS5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnRET00sIGRvbSk7XG4gICAgZGVzdHJveU5vZGUoa2V5LCBudWxsKTtcbiAgICByZXR1cm4gcmVwbGFjZW1lbnRET007XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZOb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICAvLyBSZWNvbmNpbGUgZWxlbWVudCBjaGlsZHJlblxuICAgIGNvbnN0IG5leHRJbmRlbnQgPSBuZXh0Tm9kZS5fX2luZGVudDtcbiAgICBpZiAobmV4dEluZGVudCAhPT0gcHJldk5vZGUuX19pbmRlbnQpIHtcbiAgICAgIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBuZXh0SW5kZW50KTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IG5leHROb2RlLl9fZm9ybWF0O1xuICAgIGlmIChuZXh0Rm9ybWF0ICE9PSBwcmV2Tm9kZS5fX2Zvcm1hdCkge1xuICAgICAgc2V0RWxlbWVudEZvcm1hdChkb20sIG5leHRGb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoaXNEaXJ0eSkge1xuICAgICAgJHJlY29uY2lsZUNoaWxkcmVuV2l0aERpcmVjdGlvbihwcmV2Tm9kZSwgbmV4dE5vZGUsIGRvbSk7XG4gICAgICBpZiAoISRpc1Jvb3ROb2RlKG5leHROb2RlKSAmJiAhbmV4dE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICByZWNvbmNpbGVFbGVtZW50VGVybWluYXRpbmdMaW5lQnJlYWsocHJldk5vZGUsIG5leHROb2RlLCBkb20pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChuZXh0Tm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IG5leHROb2RlLmRlY29yYXRlKGFjdGl2ZUVkaXRvciQxLCBhY3RpdmVFZGl0b3JDb25maWcpO1xuICAgICAgaWYgKGRlY29yYXRvciAhPT0gbnVsbCkge1xuICAgICAgICByZWNvbmNpbGVEZWNvcmF0b3Ioa2V5LCBkZWNvcmF0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobmV4dE5vZGUpICYmICFuZXh0Tm9kZS5pc0RpcmVjdGlvbmxlc3MoKSkge1xuICAgICAgLy8gSGFuZGxlIHRleHQgY29udGVudCwgZm9yIExUUiwgTFRSIGNhc2VzLlxuICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICB9XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgfVxuICBpZiAoIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkgJiYgJGlzUm9vdE5vZGUobmV4dE5vZGUpICYmIG5leHROb2RlLl9fY2FjaGVkVGV4dCAhPT0gZWRpdG9yVGV4dENvbnRlbnQpIHtcbiAgICAvLyBDYWNoZSB0aGUgbGF0ZXN0IHRleHQgY29udGVudC5cbiAgICBjb25zdCBuZXh0Um9vdE5vZGUgPSBuZXh0Tm9kZS5nZXRXcml0YWJsZSgpO1xuICAgIG5leHRSb290Tm9kZS5fX2NhY2hlZFRleHQgPSBlZGl0b3JUZXh0Q29udGVudDtcbiAgICBuZXh0Tm9kZSA9IG5leHRSb290Tm9kZTtcbiAgfVxuICB7XG4gICAgLy8gRnJlZXplIHRoZSBub2RlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZShuZXh0Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcikge1xuICBsZXQgcGVuZGluZ0RlY29yYXRvcnMgPSBhY3RpdmVFZGl0b3IkMS5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gYWN0aXZlRWRpdG9yJDEuX2RlY29yYXRvcnM7XG4gIGlmIChwZW5kaW5nRGVjb3JhdG9ycyA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50RGVjb3JhdG9yc1trZXldID09PSBkZWNvcmF0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ0RlY29yYXRvcnMgPSBjbG9uZURlY29yYXRvcnMoYWN0aXZlRWRpdG9yJDEpO1xuICB9XG4gIHBlbmRpbmdEZWNvcmF0b3JzW2tleV0gPSBkZWNvcmF0b3I7XG59XG5mdW5jdGlvbiBnZXRGaXJzdENoaWxkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKGVsZW1lbnQpIHtcbiAgbGV0IG5leHRTaWJsaW5nID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsICYmIG5leHRTaWJsaW5nID09PSBhY3RpdmVFZGl0b3IkMS5fYmxvY2tDdXJzb3JFbGVtZW50KSB7XG4gICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcbiAgfVxuICByZXR1cm4gbmV4dFNpYmxpbmc7XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlTm9kZUNoaWxkcmVuKG5leHRFbGVtZW50LCBwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcHJldkNoaWxkcmVuTGVuZ3RoLCBuZXh0Q2hpbGRyZW5MZW5ndGgsIGRvbSkge1xuICBjb25zdCBwcmV2RW5kSW5kZXggPSBwcmV2Q2hpbGRyZW5MZW5ndGggLSAxO1xuICBjb25zdCBuZXh0RW5kSW5kZXggPSBuZXh0Q2hpbGRyZW5MZW5ndGggLSAxO1xuICBsZXQgcHJldkNoaWxkcmVuU2V0O1xuICBsZXQgbmV4dENoaWxkcmVuU2V0O1xuICBsZXQgc2libGluZ0RPTSA9IGdldEZpcnN0Q2hpbGQoZG9tKTtcbiAgbGV0IHByZXZJbmRleCA9IDA7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICB3aGlsZSAocHJldkluZGV4IDw9IHByZXZFbmRJbmRleCAmJiBuZXh0SW5kZXggPD0gbmV4dEVuZEluZGV4KSB7XG4gICAgY29uc3QgcHJldktleSA9IHByZXZDaGlsZHJlbltwcmV2SW5kZXhdO1xuICAgIGNvbnN0IG5leHRLZXkgPSBuZXh0Q2hpbGRyZW5bbmV4dEluZGV4XTtcbiAgICBpZiAocHJldktleSA9PT0gbmV4dEtleSkge1xuICAgICAgc2libGluZ0RPTSA9IGdldE5leHRTaWJsaW5nKCRyZWNvbmNpbGVOb2RlKG5leHRLZXksIGRvbSkpO1xuICAgICAgcHJldkluZGV4Kys7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZDaGlsZHJlblNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZXZDaGlsZHJlblNldCA9IG5ldyBTZXQocHJldkNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW5TZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW5TZXQgPSBuZXcgU2V0KG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0SGFzUHJldktleSA9IG5leHRDaGlsZHJlblNldC5oYXMocHJldktleSk7XG4gICAgICBjb25zdCBwcmV2SGFzTmV4dEtleSA9IHByZXZDaGlsZHJlblNldC5oYXMobmV4dEtleSk7XG4gICAgICBpZiAoIW5leHRIYXNQcmV2S2V5KSB7XG4gICAgICAgIC8vIFJlbW92ZSBwcmV2XG4gICAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZyhnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhwcmV2S2V5KSk7XG4gICAgICAgIGRlc3Ryb3lOb2RlKHByZXZLZXksIGRvbSk7XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgfSBlbHNlIGlmICghcHJldkhhc05leHRLZXkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5leHRcbiAgICAgICAgJGNyZWF0ZU5vZGUobmV4dEtleSwgZG9tLCBzaWJsaW5nRE9NKTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3ZlIG5leHRcbiAgICAgICAgY29uc3QgY2hpbGRET00gPSBnZXRFbGVtZW50QnlLZXlPclRocm93KGFjdGl2ZUVkaXRvciQxLCBuZXh0S2V5KTtcbiAgICAgICAgaWYgKGNoaWxkRE9NID09PSBzaWJsaW5nRE9NKSB7XG4gICAgICAgICAgc2libGluZ0RPTSA9IGdldE5leHRTaWJsaW5nKCRyZWNvbmNpbGVOb2RlKG5leHRLZXksIGRvbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaWJsaW5nRE9NICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvbS5pbnNlcnRCZWZvcmUoY2hpbGRET00sIHNpYmxpbmdET00pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY2hpbGRET00pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkcmVjb25jaWxlTm9kZShuZXh0S2V5LCBkb20pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5leHROb2RlTWFwLmdldChuZXh0S2V5KTtcbiAgICBpZiAobm9kZSAhPT0gbnVsbCAmJiBzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRGb3JtYXQgPSBub2RlLmdldEZvcm1hdCgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBhcHBlbmROZXdDaGlsZHJlbiA9IHByZXZJbmRleCA+IHByZXZFbmRJbmRleDtcbiAgY29uc3QgcmVtb3ZlT2xkQ2hpbGRyZW4gPSBuZXh0SW5kZXggPiBuZXh0RW5kSW5kZXg7XG4gIGlmIChhcHBlbmROZXdDaGlsZHJlbiAmJiAhcmVtb3ZlT2xkQ2hpbGRyZW4pIHtcbiAgICBjb25zdCBwcmV2aW91c05vZGUgPSBuZXh0Q2hpbGRyZW5bbmV4dEVuZEluZGV4ICsgMV07XG4gICAgY29uc3QgaW5zZXJ0RE9NID0gcHJldmlvdXNOb2RlID09PSB1bmRlZmluZWQgPyBudWxsIDogYWN0aXZlRWRpdG9yJDEuZ2V0RWxlbWVudEJ5S2V5KHByZXZpb3VzTm9kZSk7XG4gICAgJGNyZWF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgbmV4dEVsZW1lbnQsIG5leHRJbmRleCwgbmV4dEVuZEluZGV4LCBkb20sIGluc2VydERPTSk7XG4gIH0gZWxzZSBpZiAocmVtb3ZlT2xkQ2hpbGRyZW4gJiYgIWFwcGVuZE5ld0NoaWxkcmVuKSB7XG4gICAgZGVzdHJveUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgcHJldkluZGV4LCBwcmV2RW5kSW5kZXgsIGRvbSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRyZWNvbmNpbGVSb290KHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBlZGl0b3IsIGRpcnR5VHlwZSwgZGlydHlFbGVtZW50cywgZGlydHlMZWF2ZXMpIHtcbiAgLy8gV2UgY2FjaGUgdGV4dCBjb250ZW50IHRvIG1ha2UgcmV0cmlldmFsIG1vcmUgZWZmaWNpZW50LlxuICAvLyBUaGUgY2FjaGUgbXVzdCBiZSByZWJ1aWx0IGR1cmluZyByZWNvbmNpbGlhdGlvbiB0byBhY2NvdW50IGZvciBhbnkgY2hhbmdlcy5cbiAgc3ViVHJlZVRleHRDb250ZW50ID0gJyc7XG4gIGVkaXRvclRleHRDb250ZW50ID0gJyc7XG4gIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG4gIC8vIFJhdGhlciB0aGFuIHBhc3MgYXJvdW5kIGEgbG9hZCBvZiBhcmd1bWVudHMgdGhyb3VnaCB0aGUgc3RhY2sgcmVjdXJzaXZlbHlcbiAgLy8gd2UgaW5zdGVhZCBzZXQgdGhlbSBhcyBiaW5kaW5ncyB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBtb2R1bGUuXG4gIHRyZWF0QWxsTm9kZXNBc0RpcnR5ID0gZGlydHlUeXBlID09PSBGVUxMX1JFQ09OQ0lMRTtcbiAgYWN0aXZlVGV4dERpcmVjdGlvbiA9IG51bGw7XG4gIGFjdGl2ZUVkaXRvciQxID0gZWRpdG9yO1xuICBhY3RpdmVFZGl0b3JDb25maWcgPSBlZGl0b3IuX2NvbmZpZztcbiAgYWN0aXZlRWRpdG9yTm9kZXMgPSBlZGl0b3IuX25vZGVzO1xuICBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycyA9IGFjdGl2ZUVkaXRvciQxLl9saXN0ZW5lcnMubXV0YXRpb247XG4gIGFjdGl2ZURpcnR5RWxlbWVudHMgPSBkaXJ0eUVsZW1lbnRzO1xuICBhY3RpdmVEaXJ0eUxlYXZlcyA9IGRpcnR5TGVhdmVzO1xuICBhY3RpdmVQcmV2Tm9kZU1hcCA9IHByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgYWN0aXZlTmV4dE5vZGVNYXAgPSBuZXh0RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkgPSBuZXh0RWRpdG9yU3RhdGUuX3JlYWRPbmx5O1xuICBhY3RpdmVQcmV2S2V5VG9ET01NYXAgPSBuZXcgTWFwKGVkaXRvci5fa2V5VG9ET01NYXApO1xuICAvLyBXZSBrZWVwIHRyYWNrIG9mIG11dGF0ZWQgbm9kZXMgc28gd2UgY2FuIHRyaWdnZXIgbXV0YXRpb25cbiAgLy8gbGlzdGVuZXJzIGxhdGVyIGluIHRoZSB1cGRhdGUgY3ljbGUuXG4gIGNvbnN0IGN1cnJlbnRNdXRhdGVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gIG11dGF0ZWROb2RlcyA9IGN1cnJlbnRNdXRhdGVkTm9kZXM7XG4gICRyZWNvbmNpbGVOb2RlKCdyb290JywgbnVsbCk7XG4gIC8vIFdlIGRvbid0IHdhbnQgYSBidW5jaCBvZiB2b2lkIGNoZWNrcyB0aHJvdWdob3V0IHRoZSBzY29wZVxuICAvLyBzbyBpbnN0ZWFkIHdlIG1ha2UgaXQgc2VlbSB0aGF0IHRoZXNlIHZhbHVlcyBhcmUgYWx3YXlzIHNldC5cbiAgLy8gV2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBjbGVhciB0aGVtIGRvd24sIG90aGVyd2lzZSB3ZVxuICAvLyBjYW4gbGVhayBtZW1vcnkuXG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRWRpdG9yJDEgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRWRpdG9yTm9kZXMgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRGlydHlFbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVEaXJ0eUxlYXZlcyA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVQcmV2Tm9kZU1hcCA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVOZXh0Tm9kZU1hcCA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVFZGl0b3JDb25maWcgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlUHJldktleVRvRE9NTWFwID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIG11dGF0ZWROb2RlcyA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGN1cnJlbnRNdXRhdGVkTm9kZXM7XG59XG5mdW5jdGlvbiBzdG9yZURPTVdpdGhLZXkoa2V5LCBkb20sIGVkaXRvcikge1xuICBjb25zdCBrZXlUb0RPTU1hcCA9IGVkaXRvci5fa2V5VG9ET01NYXA7XG4gIC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cbiAgZG9tWydfX2xleGljYWxLZXlfJyArIGVkaXRvci5fa2V5XSA9IGtleTtcbiAga2V5VG9ET01NYXAuc2V0KGtleSwgZG9tKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSkge1xuICBjb25zdCBlbGVtZW50ID0gYWN0aXZlUHJldktleVRvRE9NTWFwLmdldChrZXkpO1xuICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFJlY29uY2lsaWF0aW9uOiBjb3VsZCBub3QgZmluZCBET00gZWxlbWVudCBmb3Igbm9kZSBrZXkgJHtrZXl9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFBBU1NfVEhST1VHSF9DT01NQU5EID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5jb25zdCBBTkRST0lEX0NPTVBPU0lUSU9OX0xBVEVOQ1kgPSAzMDtcbmNvbnN0IHJvb3RFbGVtZW50RXZlbnRzID0gW1sna2V5ZG93bicsIG9uS2V5RG93bl0sIFsncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duXSwgWydjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0XSwgWydjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmRdLCBbJ2lucHV0Jywgb25JbnB1dF0sIFsnY2xpY2snLCBvbkNsaWNrXSwgWydjdXQnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnY29weScsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcmFnc3RhcnQnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJhZ292ZXInLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJhZ2VuZCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydwYXN0ZScsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydmb2N1cycsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydibHVyJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2Ryb3AnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF1dO1xuaWYgKENBTl9VU0VfQkVGT1JFX0lOUFVUKSB7XG4gIHJvb3RFbGVtZW50RXZlbnRzLnB1c2goWydiZWZvcmVpbnB1dCcsIChldmVudCwgZWRpdG9yKSA9PiBvbkJlZm9yZUlucHV0KGV2ZW50LCBlZGl0b3IpXSk7XG59XG5sZXQgbGFzdEtleURvd25UaW1lU3RhbXAgPSAwO1xubGV0IGxhc3RLZXlDb2RlID0gbnVsbDtcbmxldCBsYXN0QmVmb3JlSW5wdXRJbnNlcnRUZXh0VGltZVN0YW1wID0gMDtcbmxldCB1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSA9IG51bGw7XG5jb25zdCByb290RWxlbWVudHNSZWdpc3RlcmVkID0gbmV3IFdlYWtNYXAoKTtcbmxldCBpc1NlbGVjdGlvbkNoYW5nZUZyb21ET01VcGRhdGUgPSBmYWxzZTtcbmxldCBpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24gPSBmYWxzZTtcbmxldCBpc0luc2VydExpbmVCcmVhayA9IGZhbHNlO1xubGV0IGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG5sZXQgY29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0ID0gWzAsICcnLCAwLCAncm9vdCcsIDBdO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIExleGljYWwgc2hvdWxkIGF0dGVtcHQgdG8gb3ZlcnJpZGVcbi8vIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgZm9yIGluc2VydGlvbiBvZiB0ZXh0IGFuZCB1c2UgaXRzIG93biBpbnRlcm5hbFxuLy8gaGV1cmlzdGljcy4gVGhpcyBpcyBhbiBleHRyZW1lbHkgaW1wb3J0YW50IGZ1bmN0aW9uLCBhbmQgbWFrZXMgbXVjaCBvZiBMZXhpY2FsXG4vLyB3b3JrIGFzIGludGVuZGVkIGJldHdlZW4gZGlmZmVyZW50IGJyb3dzZXJzIGFuZCBhY3Jvc3Mgd29yZCwgbGluZSBhbmQgY2hhcmFjdGVyXG4vLyBib3VuZGFyeS9mb3JtYXRzLiBJdCBhbHNvIGlzIGltcG9ydGFudCBmb3IgdGV4dCByZXBsYWNlbWVudCwgbm9kZSBzY2hlbWFzIGFuZFxuLy8gY29tcG9zaXRpb24gbWVjaGFuaWNzLlxuXG5mdW5jdGlvbiAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0KHNlbGVjdGlvbiwgZG9tVGFyZ2V0UmFuZ2UsIHRleHQsIHRpbWVTdGFtcCwgaXNCZWZvcmVJbnB1dCkge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uICE9PSBudWxsID8gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgOiBudWxsO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBiYWNraW5nQW5jaG9yRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICByZXR1cm4gYW5jaG9yS2V5ICE9PSBmb2N1cy5rZXkgfHxcbiAgLy8gSWYgd2UncmUgd29ya2luZyB3aXRoIGEgbm9uLXRleHQgbm9kZS5cbiAgISRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8XG4gIC8vIElmIHdlIGFyZSByZXBsYWNpbmcgYSByYW5nZSB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBvciBncmFwaGVtZSwgYW5kIG5vdCBjb21wb3NpbmcuXG4gICghaXNCZWZvcmVJbnB1dCAmJiAoIUNBTl9VU0VfQkVGT1JFX0lOUFVUIHx8XG4gIC8vIFdlIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBoYXMgYmVlblxuICAvLyBhIHJlY2VudCBiZWZvcmVpbnB1dCBldmVudCBmb3IgXCJ0ZXh0SW5wdXRcIi4gSWYgdGhlcmUgaGFzIGJlZW4gb25lIGluIHRoZSBsYXN0XG4gIC8vIDUwbXMgdGhlbiB3ZSBwcm9jZWVkIGFzIG5vcm1hbC4gSG93ZXZlciwgaWYgdGhlcmUgaXMgbm90LCB0aGVuIHRoaXMgaXMgbGlrZWx5XG4gIC8vIGEgZGFuZ2xpbmcgYGlucHV0YCBldmVudCBjYXVzZWQgYnkgZXhlY0NvbW1hbmQoJ2luc2VydFRleHQnKS5cbiAgbGFzdEJlZm9yZUlucHV0SW5zZXJ0VGV4dFRpbWVTdGFtcCA8IHRpbWVTdGFtcCArIDUwKSB8fCBhbmNob3JOb2RlLmlzRGlydHkoKSAmJiB0ZXh0TGVuZ3RoIDwgMiB8fCBkb2VzQ29udGFpbkdyYXBoZW1lKHRleHQpKSAmJiBhbmNob3Iub2Zmc2V0ICE9PSBmb2N1cy5vZmZzZXQgJiYgIWFuY2hvck5vZGUuaXNDb21wb3NpbmcoKSB8fFxuICAvLyBBbnkgbm9uIHN0YW5kYXJkIHRleHQgbm9kZS5cbiAgJGlzVG9rZW5PclNlZ21lbnRlZChhbmNob3JOb2RlKSB8fFxuICAvLyBJZiB0aGUgdGV4dCBsZW5ndGggaXMgbW9yZSB0aGFuIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgd2UncmUgZWl0aGVyXG4gIC8vIGRlYWxpbmcgd2l0aCB0aGlzIGluIFwiYmVmb3JlaW5wdXRcIiBvciB3aGVyZSB0aGUgbm9kZSBoYXMgYWxyZWFkeSByZWNlbnRseVxuICAvLyBiZWVuIGNoYW5nZWQgKHRodXMgaXMgZGlydHkpLlxuICBhbmNob3JOb2RlLmlzRGlydHkoKSAmJiB0ZXh0TGVuZ3RoID4gMSB8fFxuICAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBlbGVtZW50IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgYmFja2luZyBub2RlIGR1cmluZyBiZWZvcmVpbnB1dC5cbiAgKGlzQmVmb3JlSW5wdXQgfHwgIUNBTl9VU0VfQkVGT1JFX0lOUFVUKSAmJiBiYWNraW5nQW5jaG9yRWxlbWVudCAhPT0gbnVsbCAmJiAhYW5jaG9yTm9kZS5pc0NvbXBvc2luZygpICYmIGRvbUFuY2hvck5vZGUgIT09IGdldERPTVRleHROb2RlKGJhY2tpbmdBbmNob3JFbGVtZW50KSB8fFxuICAvLyBJZiBUYXJnZXRSYW5nZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIERPTSBzZWxlY3Rpb247IGJyb3dzZXIgdHJ5aW5nIHRvIGVkaXQgcmFuZG9tIHBhcnRzXG4gIC8vIG9mIHRoZSBlZGl0b3IuXG4gIGRvbVNlbGVjdGlvbiAhPT0gbnVsbCAmJiBkb21UYXJnZXRSYW5nZSAhPT0gbnVsbCAmJiAoIWRvbVRhcmdldFJhbmdlLmNvbGxhcHNlZCB8fCBkb21UYXJnZXRSYW5nZS5zdGFydENvbnRhaW5lciAhPT0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgfHwgZG9tVGFyZ2V0UmFuZ2Uuc3RhcnRPZmZzZXQgIT09IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQpIHx8XG4gIC8vIENoZWNrIGlmIHdlJ3JlIGNoYW5naW5nIGZyb20gYm9sZCB0byBpdGFsaWNzLCBvciBzb21lIG90aGVyIGZvcm1hdC5cbiAgYW5jaG9yTm9kZS5nZXRGb3JtYXQoKSAhPT0gc2VsZWN0aW9uLmZvcm1hdCB8fCBhbmNob3JOb2RlLmdldFN0eWxlKCkgIT09IHNlbGVjdGlvbi5zdHlsZSB8fFxuICAvLyBPbmUgbGFzdCBzZXQgb2YgaGV1cmlzdGljcyB0byBjaGVjayBhZ2FpbnN0LlxuICAkc2hvdWxkSW5zZXJ0VGV4dEFmdGVyT3JCZWZvcmVUZXh0Tm9kZShzZWxlY3Rpb24sIGFuY2hvck5vZGUpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2tpcFNlbGVjdGlvbkNoYW5nZShkb21Ob2RlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRvbU5vZGUgIT09IG51bGwgJiYgZG9tTm9kZS5ub2RlVmFsdWUgIT09IG51bGwgJiYgZG9tTm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSAmJiBvZmZzZXQgIT09IDAgJiYgb2Zmc2V0ICE9PSBkb21Ob2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIGVkaXRvciwgaXNBY3RpdmUpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvck5vZGU6IGFuY2hvckRPTSxcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNOb2RlOiBmb2N1c0RPTSxcbiAgICBmb2N1c09mZnNldFxuICB9ID0gZG9tU2VsZWN0aW9uO1xuICBpZiAoaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlKSB7XG4gICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gZmFsc2U7XG5cbiAgICAvLyBJZiBuYXRpdmUgRE9NIHNlbGVjdGlvbiBpcyBvbiBhIERPTSBlbGVtZW50LCB0aGVuXG4gICAgLy8gd2Ugc2hvdWxkIGNvbnRpbnVlIGFzIHVzdWFsLCBhcyBMZXhpY2FsJ3Mgc2VsZWN0aW9uXG4gICAgLy8gbWF5IGhhdmUgbm9ybWFsaXplZCB0byBhIGJldHRlciBjaGlsZC4gSWYgdGhlIERPTVxuICAgIC8vIGVsZW1lbnQgaXMgYSB0ZXh0IG5vZGUsIHdlIGNhbiBzYWZlbHkgYXBwbHkgdGhpc1xuICAgIC8vIG9wdGltaXphdGlvbiBhbmQgc2tpcCB0aGUgc2VsZWN0aW9uIGNoYW5nZSBlbnRpcmVseS5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG9mZnNldCBpcyBhdCB0aGUgYm91bmRhcnksXG4gICAgLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UsIHdlIG1pZ2h0IG5lZWQgdG8gbm9ybWFsaXplIHRvIGFcbiAgICAvLyBzaWJsaW5nIGluc3RlYWQuXG4gICAgaWYgKHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpICYmIHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoZm9jdXNET00sIGZvY3VzT2Zmc2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgLy8gTm9uLWFjdGl2ZSBlZGl0b3IgZG9uJ3QgbmVlZCBhbnkgZXh0cmEgbG9naWMgZm9yIHNlbGVjdGlvbiwgaXQgb25seSBuZWVkcyB1cGRhdGVcbiAgICAvLyB0byByZWNvbmNpbGUgc2VsZWN0aW9uIChzZXQgaXQgdG8gbnVsbCkgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgZWRpdG9yIGhhcyBub24tbnVsbCBzZWxlY3Rpb24uXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgJHNldFNlbGVjdGlvbihudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uIGZvcm1hdFxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgLy8gQmFkbHkgaW50ZXJwcmV0ZWQgcmFuZ2Ugc2VsZWN0aW9uIHdoZW4gY29sbGFwc2VkIC0gIzE0ODJcbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbi50eXBlID09PSAnUmFuZ2UnICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbWFya2VkIGEgY29sbGFwc2VkIHNlbGVjdGlvbiBmb3JtYXQsIGFuZCB3ZSdyZVxuICAgICAgICAvLyB3aXRoaW4gdGhlIGdpdmVuIHRpbWUgcmFuZ2Ug4oCTIHRoZW4gYXR0ZW1wdCB0byB1c2UgdGhhdCBmb3JtYXRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBnZXR0aW5nIHRoZSBmb3JtYXQgZnJvbSB0aGUgYW5jaG9yIG5vZGUuXG4gICAgICAgIGNvbnN0IHdpbmRvd0V2ZW50ID0gZ2V0V2luZG93KGVkaXRvcikuZXZlbnQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lU3RhbXAgPSB3aW5kb3dFdmVudCA/IHdpbmRvd0V2ZW50LnRpbWVTdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBbbGFzdEZvcm1hdCwgbGFzdFN0eWxlLCBsYXN0T2Zmc2V0LCBsYXN0S2V5LCB0aW1lU3RhbXBdID0gY29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0O1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgY29uc3QgaXNSb290VGV4dENvbnRlbnRFbXB0eSA9IGVkaXRvci5pc0NvbXBvc2luZygpID09PSBmYWxzZSAmJiByb290LmdldFRleHRDb250ZW50KCkgPT09ICcnO1xuICAgICAgICBpZiAoY3VycmVudFRpbWVTdGFtcCA8IHRpbWVTdGFtcCArIDIwMCAmJiBhbmNob3Iub2Zmc2V0ID09PSBsYXN0T2Zmc2V0ICYmIGFuY2hvci5rZXkgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gbGFzdEZvcm1hdDtcbiAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBsYXN0U3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGlmICghJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBvaW50LmdldE5vZGUoKSBtdXN0IHJldHVybiBUZXh0Tm9kZSB3aGVuIHR5cGUgaXMgdGV4dGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBhbmNob3JOb2RlLmdldFN0eWxlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmICFpc1Jvb3RUZXh0Q29udGVudEVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUgaW5zdGFuY2VvZiBQYXJhZ3JhcGhOb2RlICYmIGxhc3ROb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBsYXN0Tm9kZS5nZXRUZXh0Rm9ybWF0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbi5zdHlsZSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXMua2V5O1xuICAgICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0S2V5ID0gaXNCYWNrd2FyZCA/IGZvY3VzS2V5IDogYW5jaG9yS2V5O1xuICAgICAgICBjb25zdCBlbmRLZXkgPSBpc0JhY2t3YXJkID8gYW5jaG9yS2V5IDogZm9jdXNLZXk7XG4gICAgICAgIGxldCBjb21iaW5lZEZvcm1hdCA9IElTX0FMTF9GT1JNQVRUSU5HO1xuICAgICAgICBsZXQgaGFzVGV4dE5vZGVzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiB0ZXh0Q29udGVudFNpemUgIT09IDAgJiZcbiAgICAgICAgICAvLyBFeGNsdWRlIGVtcHR5IHRleHQgbm9kZXMgYXQgYm91bmRhcmllcyByZXN1bHRpbmcgZnJvbSB1c2VyJ3Mgc2VsZWN0aW9uXG4gICAgICAgICAgIShpID09PSAwICYmIG5vZGUuX19rZXkgPT09IHN0YXJ0S2V5ICYmIHN0YXJ0T2Zmc2V0ID09PSB0ZXh0Q29udGVudFNpemUgfHwgaSA9PT0gbm9kZXNMZW5ndGggLSAxICYmIG5vZGUuX19rZXkgPT09IGVuZEtleSAmJiBlbmRPZmZzZXQgPT09IDApKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHN0eWxlP1xuICAgICAgICAgICAgaGFzVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbWJpbmVkRm9ybWF0ICY9IG5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoY29tYmluZWRGb3JtYXQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBoYXNUZXh0Tm9kZXMgPyBjb21iaW5lZEZvcm1hdCA6IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSk7XG59XG5cbi8vIFRoaXMgaXMgYSB3b3JrLWFyb3VuZCBpcyBtYWlubHkgQ2hyb21lIHNwZWNpZmljIGJ1ZyB3aGVyZSBpZiB5b3Ugc2VsZWN0XG4vLyB0aGUgY29udGVudHMgb2YgYW4gZW1wdHkgYmxvY2ssIHlvdSBjYW5ub3QgZWFzaWx5IHVuc2VsZWN0IGFueXRoaW5nLlxuLy8gVGhpcyByZXN1bHRzIGluIGEgdGlueSBzZWxlY3Rpb24gYm94IHRoYXQgbG9va3MgYnVnZ3kvYnJva2VuLiBUaGlzIGNhblxuLy8gYWxzbyBoZWxwIG90aGVyIGJyb3dzZXJzIHdoZW4gc2VsZWN0aW9uIG1pZ2h0IFwiYXBwZWFyXCIgbG9zdCwgd2hlbiBpdFxuLy8gcmVhbGx5IGlzbid0LlxuZnVuY3Rpb24gb25DbGljayhldmVudCwgZWRpdG9yKSB7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbikge1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgISRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpICYmICRnZXRSb290KCkuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaXNFbXB0eSgpICYmIGxhc3RTZWxlY3Rpb24gIT09IG51bGwgJiYgc2VsZWN0aW9uLmlzKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsID09PSAzICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIC8vIFRyaXBwbGUgY2xpY2sgY2F1c2luZyBzZWxlY3Rpb24gdG8gb3ZlcmZsb3cgaW50byB0aGUgbmVhcmVzdCBlbGVtZW50LiBJbiB0aGF0XG4gICAgICAgICAgLy8gY2FzZSB2aXN1YWxseSBpdCBsb29rcyBsaWtlIGEgc2luZ2xlIGVsZW1lbnQgY29udGVudCBpcyBzZWxlY3RlZCwgZm9jdXMgbm9kZVxuICAgICAgICAgIC8vIGlzIGFjdHVhbGx5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZWxlbWVudCAoaWYgcHJlc2VudCkgYW5kIGFueSBtYW5pcHVsYXRpb25zXG4gICAgICAgICAgLy8gd2l0aCBzZWxlY3Rpb24gKGZvcm1hdHRpbmcpIGFyZSBhZmZlY3Rpbmcgc2Vjb25kIGVsZW1lbnQgYXMgd2VsbFxuICAgICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgICAgICBpZiAoYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZS5zZWxlY3QoMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3QoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byB1cGRhdGUgdGhlIHNlbGVjdGlvbiBvbiB0b3VjaCBkZXZpY2VzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRleHQgYWZ0ZXIgYVxuICAgICAgICAvLyBub2RlIHNlbGVjdGlvbi4gU2VlIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biBmb3IgdGhlIGludmVyc2VcbiAgICAgICAgY29uc3QgZG9tQW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgICBpZiAoZG9tQW5jaG9yTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gZG9tQW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIGNsaWNrIHNlbGVjdGlvbiBiYWNrIG9udG8gdGV4dCwgdGhlblxuICAgICAgICAgIC8vIHdlIHNob3VsZCBhdHRlbXB0IGNyZWF0ZSBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgICAgICAvLyBXaGVuIHdlIGNsaWNrIG9uIGFuIGVtcHR5IHBhcmFncmFwaCBub2RlIG9yIHRoZSBlbmQgb2YgYSBwYXJhZ3JhcGggdGhhdCBlbmRzXG4gICAgICAgICAgLy8gd2l0aCBhbiBpbWFnZS9wb2xsLCB0aGUgbm9kZVR5cGUgd2lsbCBiZSBFTEVNRU5UX05PREVcbiAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUgfHwgbm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9ICRpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yLCBldmVudCk7XG4gICAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENMSUNLX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gVE9ETyBpbXBsZW1lbnQgdGV4dCBkcmFnICYgZHJvcFxuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIHBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgICAgLy8gRHJhZyAmIGRyb3Agc2hvdWxkIG5vdCByZWNvbXB1dGUgc2VsZWN0aW9uIHVudGlsIG1vdXNlIHVwOyBvdGhlcndpc2UgdGhlIGluaXRpYWxseVxuICAgICAgLy8gc2VsZWN0ZWQgY29udGVudCBpcyBsb3N0LlxuICAgICAgaWYgKCEkaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9yKHRhcmdldCkpIHtcbiAgICAgICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0UmFuZ2UoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5nZXRUYXJnZXRSYW5nZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0YXJnZXRSYW5nZXMgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcbiAgaWYgKHRhcmdldFJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0UmFuZ2VzWzBdO1xufVxuZnVuY3Rpb24gJGNhblJlbW92ZVRleHQoYW5jaG9yTm9kZSwgZm9jdXNOb2RlKSB7XG4gIHJldHVybiBhbmNob3JOb2RlICE9PSBmb2N1c05vZGUgfHwgJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkgfHwgJGlzRWxlbWVudE5vZGUoZm9jdXNOb2RlKSB8fCAhYW5jaG9yTm9kZS5pc1Rva2VuKCkgfHwgIWZvY3VzTm9kZS5pc1Rva2VuKCk7XG59XG5mdW5jdGlvbiBpc1Bvc3NpYmx5QW5kcm9pZEtleVByZXNzKHRpbWVTdGFtcCkge1xuICByZXR1cm4gbGFzdEtleUNvZGUgPT09ICdNZWRpYUxhc3QnICYmIHRpbWVTdGFtcCA8IGxhc3RLZXlEb3duVGltZVN0YW1wICsgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZO1xufVxuZnVuY3Rpb24gb25CZWZvcmVJbnB1dChldmVudCwgZWRpdG9yKSB7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGV2ZW50LmlucHV0VHlwZTtcbiAgY29uc3QgdGFyZ2V0UmFuZ2UgPSBnZXRUYXJnZXRSYW5nZShldmVudCk7XG5cbiAgLy8gV2UgbGV0IHRoZSBicm93c2VyIGRvIGl0cyBvd24gdGhpbmcgZm9yIGNvbXBvc2l0aW9uLlxuICBpZiAoaW5wdXRUeXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JyB8fFxuICAvLyBJZiB3ZSdyZSBwYXN0aW5nIGluIEZGLCB3ZSBzaG91bGRuJ3QgZ2V0IHRoaXMgZXZlbnRcbiAgLy8gYXMgdGhlIGBwYXN0ZWAgZXZlbnQgc2hvdWxkIGhhdmUgdHJpZ2dlcmVkLCB1bmxlc3MgdGhlXG4gIC8vIHVzZXIgaGFzIGRvbS5ldmVudC5jbGlwYm9hcmRldmVudHMuZW5hYmxlZCBkaXNhYmxlZCBpblxuICAvLyBhYm91dDpjb25maWcuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBwcm9jZXNzIHRoZVxuICAvLyBwYXN0ZWQgY29udGVudCBpbiB0aGUgRE9NIG11dGF0aW9uIHBoYXNlLlxuICBJU19GSVJFRk9YICYmIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlucHV0VHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoaW5wdXRUeXBlID09PSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJykge1xuICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBVc2UgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkc2V0U2VsZWN0aW9uKHByZXZTZWxlY3Rpb24uY2xvbmUoKSk7XG4gICAgICB9XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBpc1NlbGVjdGlvbkFuY2hvclNhbWVBc0ZvY3VzID0gc2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHNlbGVjdGlvbi5mb2N1cy5rZXk7XG4gICAgICAgIGlmIChpc1Bvc3NpYmx5QW5kcm9pZEtleVByZXNzKGV2ZW50LnRpbWVTdGFtcCkgJiYgZWRpdG9yLmlzQ29tcG9zaW5nKCkgJiYgaXNTZWxlY3Rpb25BbmNob3JTYW1lQXNGb2N1cykge1xuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7XG4gICAgICAgICAgLy8gRml4ZXMgYW4gQW5kcm9pZCBidWcgd2hlcmUgc2VsZWN0aW9uIGZsaWNrZXJzIHdoZW4gYmFja3NwYWNpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZKTtcbiAgICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgYW5jaG9yTm9kZS5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBhbmNob3JOb2RlLmdldEZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKCEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgQW5jaG9yIG5vZGUgbXVzdCBiZSBhIFRleHROb2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBhbmNob3JOb2RlLmdldFN0eWxlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8vIENocm9taXVtIEFuZHJvaWQgYXQgdGhlIG1vbWVudCBzZWVtcyB0byBpZ25vcmUgdGhlIHByZXZlbnREZWZhdWx0XG4gICAgICAgICAgLy8gb24gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcgYW5kIHN0aWxsIGRlbGV0ZXMgdGhlIGNvbnRlbnQuIFdoaWNoIGxlYWRzXG4gICAgICAgICAgLy8gdG8gbXVsdGlwbGUgZGVsZXRpb25zLiBTbyB3ZSBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIHRoZSBkZWxldGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlVGV4dCA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgaGFzU2VsZWN0ZWRBbGxUZXh0SW5Ob2RlID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gc2VsZWN0ZWROb2RlVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkTGV0QnJvd3NlckhhbmRsZURlbGV0ZSA9IElTX0FORFJPSURfQ0hST01FICYmIGlzU2VsZWN0aW9uQW5jaG9yU2FtZUFzRm9jdXMgJiYgIWhhc1NlbGVjdGVkQWxsVGV4dEluTm9kZTtcbiAgICAgICAgICBpZiAoIXNob3VsZExldEJyb3dzZXJIYW5kbGVEZWxldGUpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgLy8gVGhpcyByZXByZXNlbnRzIHRoZSBjYXNlIHdoZW4gdHdvIGJlZm9yZWlucHV0IGV2ZW50cyBhcmUgdHJpZ2dlcmVkIGF0IHRoZSBzYW1lIHRpbWUgKHdpdGhvdXQgYVxuICAgIC8vIGZ1bGwgZXZlbnQgbG9vcCBlbmRpbmcgYXQgaW5wdXQpLiBUaGlzIGhhcHBlbnMgd2l0aCBNYWNPUyB3aXRoIHRoZSBkZWZhdWx0IGtleWJvYXJkIHNldHRpbmdzLFxuICAgIC8vIGEgY29tYmluYXRpb24gb2YgYXV0b2NvcnJlY3Rpb24gKyBhdXRvY2FwaXRhbGl6YXRpb24uXG4gICAgLy8gSGF2aW5nIExleGljYWwgcnVuIGV2ZXJ5dGhpbmcgaW4gY29udHJvbGxlZCBtb2RlIHdvdWxkIGZpeCB0aGUgaXNzdWUgd2l0aG91dCBhZGRpdGlvbmFsIGNvZGVcbiAgICAvLyBidXQgdGhpcyB3b3VsZCBraWxsIHRoZSBtYXNzaXZlIHBlcmZvcm1hbmNlIHdpbiBmcm9tIHRoZSBtb3N0IGNvbW1vbiB0eXBpbmcgZXZlbnQuXG4gICAgLy8gQWx0ZXJuYXRpdmVseSwgd2hlbiB0aGlzIGhhcHBlbnMgd2UgY2FuIHByZW1hdHVyZWx5IHVwZGF0ZSBvdXIgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIERPTVxuICAgIC8vIGNvbnRlbnQsIGEgam9iIHRoYXQgd291bGQgdXN1YWxseSBiZSB0aGUgaW5wdXQgZXZlbnQncyByZXNwb25zaWJpbGl0eS5cbiAgICBpZiAodW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgIT09IG51bGwpIHtcbiAgICAgICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKGZhbHNlLCBlZGl0b3IsIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhKTtcbiAgICB9XG4gICAgaWYgKCghc2VsZWN0aW9uLmRpcnR5IHx8IHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhICE9PSBudWxsKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAhJGlzUm9vdE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpICYmIHRhcmdldFJhbmdlICE9PSBudWxsKSB7XG4gICAgICBzZWxlY3Rpb24uYXBwbHlET01SYW5nZSh0YXJnZXRSYW5nZSk7XG4gICAgfVxuICAgIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gbnVsbDtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoaW5wdXRUeXBlID09PSAnaW5zZXJ0VGV4dCcgfHwgaW5wdXRUeXBlID09PSAnaW5zZXJ0VHJhbnNwb3NlJykge1xuICAgICAgaWYgKGRhdGEgPT09ICdcXG4nKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gRE9VQkxFX0xJTkVfQlJFQUspIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09IG51bGwgJiYgZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIC8vIEdldHMgYXJvdW5kIGEgU2FmYXJpIHRleHQgcmVwbGFjZW1lbnQgYnVnLlxuICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT0gbnVsbCAmJiAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0KHNlbGVjdGlvbiwgdGFyZ2V0UmFuZ2UsIGRhdGEsIGV2ZW50LnRpbWVTdGFtcCwgdHJ1ZSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gZGF0YTtcbiAgICAgIH1cbiAgICAgIGxhc3RCZWZvcmVJbnB1dEluc2VydFRleHRUaW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGNhcnJ5aW5nIG91dFxuICAgIC8vIHRoZSBpbnB1dCBldmVudCwgc28gd2UgY2FuIGNvbnRyb2wgdGhlXG4gICAgLy8gb3V0cHV0LlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvblxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFVzZWQgZm9yIEFuZHJvaWRcbiAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVXNlZCBmb3IgQW5kcm9pZFxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcblxuICAgICAgICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBwcm92aWRlIHRoZSB0eXBlIFwiaW5zZXJ0TGluZUJyZWFrXCIuXG4gICAgICAgICAgLy8gU28gaW5zdGVhZCwgd2UgbmVlZCB0byBpbmZlciBpdCBmcm9tIHRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgICAgICAvLyBXZSBkbyBub3QgYXBwbHkgdGhpcyBsb2dpYyB0byBpT1MgdG8gYWxsb3cgbmV3bGluZSBhdXRvLWNhcGl0YWxpemF0aW9uXG4gICAgICAgICAgLy8gd29yayB3aXRob3V0IGNyZWF0aW5nIGxpbmVicmVha3Mgd2hlbiBwcmVzc2luZyBFbnRlclxuICAgICAgICAgIGlmIChpc0luc2VydExpbmVCcmVhayAmJiAhSVNfSU9TKSB7XG4gICAgICAgICAgICBpc0luc2VydExpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlQXNRdW90YXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUEFTVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkY2FuUmVtb3ZlVGV4dChhbmNob3JOb2RlLCBmb2N1c05vZGUpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBSRU1PVkVfVEVYVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVNT1ZFX1RFWFRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0U3RyaWtlVGhyb3VnaCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnc3RyaWtldGhyb3VnaCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmb3JtYXRCb2xkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdib2xkJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Zvcm1hdEl0YWxpYyc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnaXRhbGljJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Zvcm1hdFVuZGVybGluZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAndW5kZXJsaW5lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2hpc3RvcnlVbmRvJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFVORE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaGlzdG9yeVJlZG8nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBOTy1PUFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvbklucHV0KGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgb25JbnB1dCB0byBidWJibGUsIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBlZGl0b3JzLlxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IGdldFRhcmdldFJhbmdlKGV2ZW50KTtcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgJHNob3VsZFByZXZlbnREZWZhdWx0QW5kSW5zZXJ0VGV4dChzZWxlY3Rpb24sIHRhcmdldFJhbmdlLCBkYXRhLCBldmVudC50aW1lU3RhbXAsIGZhbHNlKSkge1xuICAgICAgLy8gR2l2ZW4gd2UncmUgb3Zlci1yaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIHdlIHdpbGwgbmVlZFxuICAgICAgLy8gdG8gZW5zdXJlIHRvIGRpc2FibGUgY29tcG9zaXRpb24gYmVmb3JlIGRpc3BhdGNoaW5nIHRoZVxuICAgICAgLy8gaW5zZXJ0VGV4dCBjb21tYW5kIGZvciB3aGVuIGNoYW5naW5nIHRoZSBzZXF1ZW5jZSBmb3IgRkYuXG4gICAgICBpZiAoaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICAgICAgJG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZGF0YSk7XG4gICAgICAgIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICAgICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCYWNrd2FyZCA/IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0IDogc2VsZWN0aW9uLmZvY3VzLm9mZnNldDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmFja3dhcmQgPyBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0IDogc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgICAvLyBJZiB0aGUgY29udGVudCBpcyB0aGUgc2FtZSBhcyBpbnNlcnRlZCwgdGhlbiBkb24ndCBkaXNwYXRjaCBhbiBpbnNlcnRpb24uXG4gICAgICAvLyBHaXZlbiBvbklucHV0IGRvZXNuJ3QgdGFrZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGl0IHVzZXMgdGhlIHByZXZpb3VzKVxuICAgICAgLy8gd2UgY2FuIGNvbXBhcmUgdGhhdCBhZ2FpbnN0IHdoYXQgdGhlIERPTSBjdXJyZW50bHkgc2F5cy5cbiAgICAgIGlmICghQ0FOX1VTRV9CRUZPUkVfSU5QVVQgfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBudWxsIHx8IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZSgwLCBzdGFydE9mZnNldCkgKyBkYXRhICsgYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpLnNsaWNlKHN0YXJ0T2Zmc2V0ICsgZW5kT2Zmc2V0KSAhPT0gZ2V0QW5jaG9yVGV4dEZyb21ET00oZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZGF0YSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIEFub3RoZXIgaGFjayBmb3IgRkYsIGFzIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgSU1FIGlzIHN0aWxsXG4gICAgICAvLyBvcGVuLCBldmVuIHRob3VnaCBjb21wb3NpdGlvbmVuZCBoYXMgYWxyZWFkeSBmaXJlZCAoc2lnaCkuXG4gICAgICBpZiAoSVNfRklSRUZPWCAmJiB0ZXh0TGVuZ3RoID4gMSAmJiBldmVudC5pbnB1dFR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnICYmICFlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCAtPSB0ZXh0TGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgY29uc2lzdGVuY3kgb24gQW5kcm9pZC5cbiAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19JT1MgJiYgIUlTX0FQUExFX1dFQktJVCAmJiBlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhcmFjdGVyRGF0YSA9IGRhdGEgIT09IG51bGwgPyBkYXRhIDogdW5kZWZpbmVkO1xuICAgICAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oZmFsc2UsIGVkaXRvciwgY2hhcmFjdGVyRGF0YSk7XG5cbiAgICAgIC8vIG9uSW5wdXQgYWx3YXlzIGZpcmVzIGFmdGVyIG9uQ29tcG9zaXRpb25FbmQgZm9yIEZGLlxuICAgICAgaWYgKGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICRvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHNvIGZsdXNoIGFueSBvdGhlciBtdXRhdGlvbnMgdGhhdCBtaWdodCBoYXZlIG9jY3VycmVkXG4gICAgLy8gc2luY2UgdGhlIGNoYW5nZS5cbiAgICAkZmx1c2hNdXRhdGlvbnMoKTtcbiAgfSk7XG4gIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChldmVudCwgZWRpdG9yKSB7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgIWVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3Qgbm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGFuY2hvci5rZXkpO1xuICAgICAgaWYgKFxuICAgICAgLy8gSWYgaXQgaGFzIGJlZW4gMzBtcyBzaW5jZSB0aGUgbGFzdCBrZXlkb3duLCB0aGVuIHdlIHNob3VsZFxuICAgICAgLy8gYXBwbHkgdGhlIGVtcHR5IHNwYWNlIGhldXJpc3RpYy4gV2UgY2FuJ3QgZG8gdGhpcyBmb3IgU2FmYXJpLFxuICAgICAgLy8gYXMgdGhlIGtleWRvd24gZmlyZXMgYWZ0ZXIgY29tcG9zaXRpb24gc3RhcnQuXG4gICAgICBldmVudC50aW1lU3RhbXAgPCBsYXN0S2V5RG93blRpbWVTdGFtcCArIEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWSB8fFxuICAgICAgLy8gRkYgaGFzIGlzc3VlcyBhcm91bmQgY29tcG9zaW5nIG11bHRpYnl0ZSBjaGFyYWN0ZXJzLCBzbyB3ZSBhbHNvXG4gICAgICAvLyBuZWVkIHRvIGludm9rZSB0aGUgZW1wdHkgc3BhY2UgaGV1cmlzdGljIGJlbG93LlxuICAgICAgYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgbm9kZS5nZXRGb3JtYXQoKSAhPT0gc2VsZWN0aW9uLmZvcm1hdCB8fCAkaXNUZXh0Tm9kZShub2RlKSAmJiBub2RlLmdldFN0eWxlKCkgIT09IHNlbGVjdGlvbi5zdHlsZSkge1xuICAgICAgICAvLyBXZSBpbnNlcnQgYSB6ZXJvIHdpZHRoIGNoYXJhY3RlciwgcmVhZHkgZm9yIHRoZSBjb21wb3NpdGlvblxuICAgICAgICAvLyB0byBnZXQgaW5zZXJ0ZWQgaW50byB0aGUgbmV3IG5vZGUgd2UgY3JlYXRlLiBJZlxuICAgICAgICAvLyB3ZSBkb24ndCBkbyB0aGlzLCBTYWZhcmkgd2lsbCBmYWlsIG9uIHVzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gdGV4dCBub2RlIG1hdGNoaW5nIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgQ09NUE9TSVRJT05fU1RBUlRfQ0hBUik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uICRvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEpIHtcbiAgY29uc3QgY29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG5cbiAgLy8gSGFuZGxlIHRlcm1pbmF0aW9uIG9mIGNvbXBvc2l0aW9uLlxuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwgJiYgZGF0YSAhPSBudWxsKSB7XG4gICAgLy8gQ29tcG9zaXRpb24gY2FuIHNvbWV0aW1lcyBtb3ZlIHRvIGFuIGFkamFjZW50IERPTSBub2RlIHdoZW4gYmFja3NwYWNpbmcuXG4gICAgLy8gU28gY2hlY2sgZm9yIHRoZSBlbXB0eSBjYXNlLlxuICAgIGlmIChkYXRhID09PSAnJykge1xuICAgICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkoY29tcG9zaXRpb25LZXkpO1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBnZXRET01UZXh0Tm9kZShlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGNvbXBvc2l0aW9uS2V5KSk7XG4gICAgICBpZiAodGV4dE5vZGUgIT09IG51bGwgJiYgdGV4dE5vZGUubm9kZVZhbHVlICE9PSBudWxsICYmICRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHROb2RlLm5vZGVWYWx1ZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcG9zaXRpb24gY2FuIHNvbWV0aW1lcyBiZSB0aGF0IG9mIGEgbmV3IGxpbmUuIEluIHdoaWNoIGNhc2UsIHdlIG5lZWQgdG9cbiAgICAvLyBoYW5kbGUgdGhhdCBhY2NvcmRpbmdseS5cbiAgICBpZiAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgbGluZSBicmVhaywgd2UgYWxzbyBuZWVkIHRvIGluc2VydFxuICAgICAgICAvLyBhIGxpbmUgYnJlYWsuXG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChmb2N1cy5rZXksIGZvY3VzLm9mZnNldCwgZm9jdXMudHlwZSk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9FTlRFUl9DT01NQU5ELCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAkdXBkYXRlU2VsZWN0ZWRUZXh0RnJvbURPTSh0cnVlLCBlZGl0b3IsIGRhdGEpO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChldmVudCwgZWRpdG9yKSB7XG4gIC8vIEZpcmVmb3ggZmlyZXMgb25Db21wb3NpdGlvbkVuZCBiZWZvcmUgb25JbnB1dCwgYnV0IENocm9tZS9XZWJraXQsXG4gIC8vIGZpcmUgb25JbnB1dCBiZWZvcmUgb25Db21wb3NpdGlvbkVuZC4gVG8gZW5zdXJlIHRoZSBzZXF1ZW5jZSB3b3Jrc1xuICAvLyBsaWtlIENocm9tZS9XZWJraXQgd2UgdXNlIHRoZSBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiBmbGFnIHRvXG4gIC8vIGRlZmVyIGhhbmRsaW5nIG9mIG9uQ29tcG9zaXRpb25FbmQgaW4gRmlyZWZveCB0aWxsIHdlIGhhdmUgcHJvY2Vzc2VkXG4gIC8vIHRoZSBsb2dpYyBpbiBvbklucHV0LlxuICBpZiAoSVNfRklSRUZPWCkge1xuICAgIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAkb25Db21wb3NpdGlvbkVuZEltcGwoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50LCBlZGl0b3IpIHtcbiAgbGFzdEtleURvd25UaW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gIGxhc3RLZXlDb2RlID0gZXZlbnQua2V5O1xuICBpZiAoZWRpdG9yLmlzQ29tcG9zaW5nKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIGtleSxcbiAgICBzaGlmdEtleSxcbiAgICBjdHJsS2V5LFxuICAgIG1ldGFLZXksXG4gICAgYWx0S2V5XG4gIH0gPSBldmVudDtcbiAgaWYgKGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9ET1dOX0NPTU1BTkQsIGV2ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzTW92ZUZvcndhcmQoa2V5LCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVUb0VuZChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgTU9WRV9UT19FTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVCYWNrd2FyZChrZXksIGN0cmxLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlVG9TdGFydChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgTU9WRV9UT19TVEFSVCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZVVwKGtleSwgY3RybEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZURvd24oa2V5LCBjdHJsS2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0xpbmVCcmVhayhrZXksIHNoaWZ0S2V5KSkge1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gdHJ1ZTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzU3BhY2Uoa2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9TUEFDRV9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNPcGVuTGluZUJyZWFrKGtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gdHJ1ZTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCB0cnVlKTtcbiAgfSBlbHNlIGlmIChpc1BhcmFncmFwaChrZXksIHNoaWZ0S2V5KSkge1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUJhY2t3YXJkKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGlmIChpc0JhY2tzcGFjZShrZXkpKSB7XG4gICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRXNjYXBlKGtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRVNDQVBFX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUZvcndhcmQoa2V5LCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGlmIChpc0RlbGV0ZShrZXkpKSB7XG4gICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfREVMRVRFX0NPTU1BTkQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0RlbGV0ZVdvcmRCYWNrd2FyZChrZXksIGFsdEtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlV29yZEZvcndhcmQoa2V5LCBhbHRLZXksIGN0cmxLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfV09SRF9DT01NQU5ELCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVMaW5lQmFja3dhcmQoa2V5LCBtZXRhS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0xJTkVfQ09NTUFORCwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVMaW5lRm9yd2FyZChrZXksIG1ldGFLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNCb2xkKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2JvbGQnKTtcbiAgfSBlbHNlIGlmIChpc1VuZGVybGluZShrZXksIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICd1bmRlcmxpbmUnKTtcbiAgfSBlbHNlIGlmIChpc0l0YWxpYyhrZXksIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdpdGFsaWMnKTtcbiAgfSBlbHNlIGlmIChpc1RhYihrZXksIGFsdEtleSwgY3RybEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfVEFCX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc1VuZG8oa2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFVORE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSBlbHNlIGlmIChpc1JlZG8oa2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFJFRE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gZWRpdG9yLl9lZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoaXNDb3B5KGtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPUFlfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0N1dChrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDVVRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc1NlbGVjdEFsbChrZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVF9BTExfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfVxuICAgICAgLy8gRkYgZG9lcyBpdCB3ZWxsIChubyBuZWVkIHRvIG92ZXJyaWRlIGJlaGF2aW9yKVxuICAgIH0gZWxzZSBpZiAoIUlTX0ZJUkVGT1ggJiYgaXNTZWxlY3RBbGwoa2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVF9BTExfQ09NTUFORCwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNNb2RpZmllcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9NT0RJRklFUl9DT01NQU5ELCBldmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJvb3RFbGVtZW50UmVtb3ZlSGFuZGxlcyhyb290RWxlbWVudCkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICBsZXQgZXZlbnRIYW5kbGVzID0gcm9vdEVsZW1lbnQuX19sZXhpY2FsRXZlbnRIYW5kbGVzO1xuICBpZiAoZXZlbnRIYW5kbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudEhhbmRsZXMgPSBbXTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIHJvb3RFbGVtZW50Ll9fbGV4aWNhbEV2ZW50SGFuZGxlcyA9IGV2ZW50SGFuZGxlcztcbiAgfVxuICByZXR1cm4gZXZlbnRIYW5kbGVzO1xufVxuXG4vLyBNYXBwaW5nIHJvb3QgZWRpdG9ycyB0byB0aGVpciBhY3RpdmUgbmVzdGVkIGVkaXRvcnMsIGNvbnRhaW5zIG5lc3RlZCBlZGl0b3JzXG4vLyBtYXBwaW5nIG9ubHksIHNvIGlmIHJvb3QgZWRpdG9yIGlzIHNlbGVjdGVkIG1hcCB3aWxsIGhhdmUgbm8gcmVmZXJlbmNlIHRvIGZyZWUgdXAgbWVtb3J5XG5jb25zdCBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IHRhcmdldCA9PSBudWxsID8gbnVsbCA6IHRhcmdldC5ub2RlVHlwZSA9PT0gOSA/IHRhcmdldC5kZWZhdWx0VmlldyA6IHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24odGFyZ2V0V2luZG93KTtcbiAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuZXh0QWN0aXZlRWRpdG9yID0gZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgaWYgKG5leHRBY3RpdmVFZGl0b3IgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93bikge1xuICAgIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biA9IGZhbHNlO1xuICAgIHVwZGF0ZUVkaXRvcihuZXh0QWN0aXZlRWRpdG9yLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgICBpZiAoZG9tQW5jaG9yTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlVHlwZSA9IGRvbUFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgICAvLyBJZiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIGNsaWNrIHNlbGVjdGlvbiBiYWNrIG9udG8gdGV4dCwgdGhlblxuICAgICAgLy8gd2Ugc2hvdWxkIGF0dGVtcHQgY3JlYXRlIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgLy8gV2hlbiB3ZSBjbGljayBvbiBhbiBlbXB0eSBwYXJhZ3JhcGggbm9kZSBvciB0aGUgZW5kIG9mIGEgcGFyYWdyYXBoIHRoYXQgZW5kc1xuICAgICAgLy8gd2l0aCBhbiBpbWFnZS9wb2xsLCB0aGUgbm9kZVR5cGUgd2lsbCBiZSBFTEVNRU5UX05PREVcbiAgICAgIGlmIChub2RlVHlwZSAhPT0gRE9NX0VMRU1FTlRfVFlQRSAmJiBub2RlVHlwZSAhPT0gRE9NX1RFWFRfVFlQRSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIG5leHRBY3RpdmVFZGl0b3IsIGV2ZW50KTtcbiAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdoZW4gZWRpdG9yIHJlY2VpdmVzIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQsIHdlJ3JlIGNoZWNraW5nIGlmXG4gIC8vIGl0IGhhcyBhbnkgc2libGluZyBlZGl0b3JzICh3aXRoaW4gc2FtZSBwYXJlbnQgZWRpdG9yKSB0aGF0IHdlcmUgYWN0aXZlXG4gIC8vIGJlZm9yZSwgYW5kIHRyaWdnZXIgc2VsZWN0aW9uIGNoYW5nZSBvbiBpdCB0byBudWxsaWZ5IHNlbGVjdGlvbi5cbiAgY29uc3QgZWRpdG9ycyA9IGdldEVkaXRvcnNUb1Byb3BhZ2F0ZShuZXh0QWN0aXZlRWRpdG9yKTtcbiAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgcm9vdEVkaXRvcktleSA9IHJvb3RFZGl0b3IuX2tleTtcbiAgY29uc3QgYWN0aXZlTmVzdGVkRWRpdG9yID0gYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5nZXQocm9vdEVkaXRvcktleSk7XG4gIGNvbnN0IHByZXZBY3RpdmVFZGl0b3IgPSBhY3RpdmVOZXN0ZWRFZGl0b3IgfHwgcm9vdEVkaXRvcjtcbiAgaWYgKHByZXZBY3RpdmVFZGl0b3IgIT09IG5leHRBY3RpdmVFZGl0b3IpIHtcbiAgICBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIHByZXZBY3RpdmVFZGl0b3IsIGZhbHNlKTtcbiAgfVxuICBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIG5leHRBY3RpdmVFZGl0b3IsIHRydWUpO1xuXG4gIC8vIElmIG5ld2x5IHNlbGVjdGVkIGVkaXRvciBpcyBuZXN0ZWQsIHRoZW4gYWRkIGl0IHRvIHRoZSBtYXAsIGNsZWFuIG1hcCBvdGhlcndpc2VcbiAgaWYgKG5leHRBY3RpdmVFZGl0b3IgIT09IHJvb3RFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLnNldChyb290RWRpdG9yS2V5LCBuZXh0QWN0aXZlRWRpdG9yKTtcbiAgfSBlbHNlIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCkge1xuICAvLyBXZSBhdHRhY2ggYSBzcGVjaWFsIHByb3BlcnR5IHRvIGVuc3VyZSB0aGUgc2FtZSBldmVudCBkb2Vzbid0IHJlLWZpcmVcbiAgLy8gZm9yIHBhcmVudCBlZGl0b3JzLlxuICAvLyBAdHMtaWdub3JlXG4gIGV2ZW50Ll9sZXhpY2FsSGFuZGxlZCA9IHRydWU7XG59XG5mdW5jdGlvbiBoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgc3RvcHBlZCA9IGV2ZW50Ll9sZXhpY2FsSGFuZGxlZCA9PT0gdHJ1ZTtcbiAgcmV0dXJuIHN0b3BwZWQ7XG59XG5mdW5jdGlvbiBhZGRSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCwgZWRpdG9yKSB7XG4gIC8vIFdlIG9ubHkgd2FudCB0byBoYXZlIGEgc2luZ2xlIGdsb2JhbCBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQgaGFuZGxlciwgc2hhcmVkXG4gIC8vIGJldHdlZW4gYWxsIGVkaXRvciBpbnN0YW5jZXMuXG4gIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgPSByb290RWxlbWVudHNSZWdpc3RlcmVkLmdldChkb2MpO1xuICBpZiAoZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCA9PT0gdW5kZWZpbmVkIHx8IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgPCAxKSB7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG4gIHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQuc2V0KGRvYywgKGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgfHwgMCkgKyAxKTtcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICByb290RWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBlZGl0b3I7XG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvb3RFbGVtZW50RXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2V2ZW50TmFtZSwgb25FdmVudF0gPSByb290RWxlbWVudEV2ZW50c1tpXTtcbiAgICBjb25zdCBldmVudEhhbmRsZXIgPSB0eXBlb2Ygb25FdmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50ID0+IHtcbiAgICAgIGlmIChoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgIGlmIChlZGl0b3IuaXNFZGl0YWJsZSgpIHx8IGV2ZW50TmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICBvbkV2ZW50KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgfVxuICAgIH0gOiBldmVudCA9PiB7XG4gICAgICBpZiAoaGFzU3RvcHBlZExleGljYWxQcm9wYWdhdGlvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCk7XG4gICAgICBjb25zdCBpc0VkaXRhYmxlID0gZWRpdG9yLmlzRWRpdGFibGUoKTtcbiAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2N1dCc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ1VUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgY2FzZSAnY29weSc6XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPUFlfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdwYXN0ZSc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUEFTVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdTVEFSVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBEUkFHT1ZFUl9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdFTkRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9DVVNfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBCTFVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERST1BfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgcmVtb3ZlSGFuZGxlcy5wdXNoKCgpID0+IHtcbiAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCkge1xuICBjb25zdCBkb2MgPSByb290RWxlbWVudC5vd25lckRvY3VtZW50O1xuICBjb25zdCBkb2N1bWVudFJvb3RFbGVtZW50c0NvdW50ID0gcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZC5nZXQoZG9jKTtcbiAgaWYgKCEoZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHRocm93IEVycm9yKGBSb290IGVsZW1lbnQgbm90IHJlZ2lzdGVyZWRgKTtcbiAgfSAvLyBXZSBvbmx5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSBnbG9iYWwgc2VsZWN0aW9uY2hhbmdlIGV2ZW50IGhhbmRsZXIsIHNoYXJlZFxuICAvLyBiZXR3ZWVuIGFsbCBlZGl0b3IgaW5zdGFuY2VzLlxuICBjb25zdCBuZXdDb3VudCA9IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgLSAxO1xuICBpZiAoIShuZXdDb3VudCA+PSAwKSkge1xuICAgIHRocm93IEVycm9yKGBSb290IGVsZW1lbnQgY291bnQgbGVzcyB0aGFuIDBgKTtcbiAgfVxuICByb290RWxlbWVudHNSZWdpc3RlcmVkLnNldChkb2MsIG5ld0NvdW50KTtcbiAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgY29uc3QgZWRpdG9yID0gcm9vdEVsZW1lbnQuX19sZXhpY2FsRWRpdG9yO1xuICBpZiAoZWRpdG9yICE9PSBudWxsICYmIGVkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xlYW5BY3RpdmVOZXN0ZWRFZGl0b3JzTWFwKGVkaXRvcik7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICByb290RWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBudWxsO1xuICB9XG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZUhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZW1vdmVIYW5kbGVzW2ldKCk7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXMgPSBbXTtcbn1cbmZ1bmN0aW9uIGNsZWFuQWN0aXZlTmVzdGVkRWRpdG9yc01hcChlZGl0b3IpIHtcbiAgaWYgKGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIG5lc3RlZCBlZGl0b3IgY2xlYW51cCBtYXAgaWYgdGhpcyBlZGl0b3Igd2FzIG1hcmtlZCBhcyBhY3RpdmVcbiAgICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcik7XG4gICAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCByb290RWRpdG9yS2V5ID0gcm9vdEVkaXRvci5fa2V5O1xuICAgIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmdldChyb290RWRpdG9yS2V5KSA9PT0gZWRpdG9yKSB7XG4gICAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIHRvcC1sZXZlbCBlZGl0b3JzIGNsZWFudXAgbWFwXG4gICAgYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5kZWxldGUoZWRpdG9yLl9rZXkpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpIHtcbiAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcmtDb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQoZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcCkge1xuICBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQgPSBbZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcF07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJHJlbW92ZU5vZGUobm9kZVRvUmVtb3ZlLCByZXN0b3JlU2VsZWN0aW9uLCBwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBrZXkgPSBub2RlVG9SZW1vdmUuX19rZXk7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGVUb1JlbW92ZS5nZXRQYXJlbnQoKTtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSAkbWF5YmVNb3ZlQ2hpbGRyZW5TZWxlY3Rpb25Ub1BhcmVudChub2RlVG9SZW1vdmUpO1xuICBsZXQgc2VsZWN0aW9uTW92ZWQgPSBmYWxzZTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSkge1xuICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgbm9kZVRvUmVtb3ZlLCBwYXJlbnQsIG5vZGVUb1JlbW92ZS5nZXRQcmV2aW91c1NpYmxpbmcoKSwgbm9kZVRvUmVtb3ZlLmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgc2VsZWN0aW9uTW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZm9jdXMua2V5ID09PSBrZXkpIHtcbiAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhmb2N1cywgbm9kZVRvUmVtb3ZlLCBwYXJlbnQsIG5vZGVUb1JlbW92ZS5nZXRQcmV2aW91c1NpYmxpbmcoKSwgbm9kZVRvUmVtb3ZlLmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgc2VsZWN0aW9uTW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbiAmJiBub2RlVG9SZW1vdmUuaXNTZWxlY3RlZCgpKSB7XG4gICAgbm9kZVRvUmVtb3ZlLnNlbGVjdFByZXZpb3VzKCk7XG4gIH1cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uTW92ZWQpIHtcbiAgICAvLyBEb2luZyB0aGlzIGlzIE8obikgc28gbGV0cyBhdm9pZCBpdCB1bmxlc3Mgd2UgbmVlZCB0byBkbyBpdFxuICAgIGNvbnN0IGluZGV4ID0gbm9kZVRvUmVtb3ZlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgcmVtb3ZlRnJvbVBhcmVudChub2RlVG9SZW1vdmUpO1xuICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50LCBpbmRleCwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUZyb21QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgfVxuICBpZiAoIXByZXNlcnZlRW1wdHlQYXJlbnQgJiYgISRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSAmJiAhcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuaXNFbXB0eSgpKSB7XG4gICAgJHJlbW92ZU5vZGUocGFyZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgfVxuICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSb290Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0VtcHR5KCkpIHtcbiAgICBwYXJlbnQuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmNsYXNzIExleGljYWxOb2RlIHtcbiAgLy8gQWxsb3cgdXMgdG8gbG9vayB1cCB0aGUgdHlwZSBpbmNsdWRpbmcgc3RhdGljIHByb3BzXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgLy9AdHMtaWdub3JlIFdlIHNldCB0aGUga2V5IGluIHRoZSBjb25zdHJ1Y3Rvci5cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCBhYnN0cmFjdCBjbGFzc2VzIHVuZm9ydHVuYXRlbHksIHNvIHdlIGNhbid0IF9mb3JjZV9cbiAgLy8gc3ViY2xhc3NlcyBvZiBOb2RlIHRvIGltcGxlbWVudCBzdGF0aWNzLiBBbGwgc3ViY2xhc3NlcyBvZiBOb2RlIHNob3VsZCBoYXZlXG4gIC8vIGEgc3RhdGljIGdldFR5cGUgYW5kIGNsb25lIG1ldGhvZCB0aG91Z2guIFdlIGRlZmluZSBnZXRUeXBlIGFuZCBjbG9uZSBoZXJlIHNvIHdlIGNhbiBjYWxsIGl0XG4gIC8vIG9uIGFueSAgTm9kZSwgYW5kIHdlIHRocm93IHRoaXMgZXJyb3IgYnkgZGVmYXVsdCBzaW5jZSB0aGUgc3ViY2xhc3Mgc2hvdWxkIHByb3ZpZGVcbiAgLy8gdGhlaXIgb3duIGltcGxlbWVudGF0aW9uLlxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHR5cGUgb2YgdGhpcyBub2RlLiBFdmVyeSBub2RlIG11c3RcbiAgICogaW1wbGVtZW50IHRoaXMgYW5kIGl0IE1VU1QgQkUgVU5JUVVFIGFtb25nc3Qgbm9kZXMgcmVnaXN0ZXJlZFxuICAgKiBvbiB0aGUgZWRpdG9yLlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmdldFR5cGUoKS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoaXMgbm9kZSwgY3JlYXRpbmcgYSBuZXcgbm9kZSB3aXRoIGEgZGlmZmVyZW50IGtleVxuICAgKiBhbmQgYWRkaW5nIGl0IHRvIHRoZSBFZGl0b3JTdGF0ZSAoYnV0IG5vdCBhdHRhY2hpbmcgaXQgYW55d2hlcmUhKS4gQWxsIG5vZGVzIG11c3RcbiAgICogaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGNsb25lKF9kYXRhKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmNsb25lKCkuYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICB0aGlzLl9fdHlwZSA9IHRoaXMuY29uc3RydWN0b3IuZ2V0VHlwZSgpO1xuICAgIHRoaXMuX19wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX19wcmV2ID0gbnVsbDtcbiAgICB0aGlzLl9fbmV4dCA9IG51bGw7XG4gICAgJHNldE5vZGVLZXkodGhpcywga2V5KTtcbiAgICB7XG4gICAgICBpZiAodGhpcy5fX3R5cGUgIT09ICdyb290Jykge1xuICAgICAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICAgICAgZXJyb3JPblR5cGVLbGFzc01pc21hdGNoKHRoaXMuX190eXBlLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gR2V0dGVycyBhbmQgVHJhdmVyc2Vyc1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdHlwZSBvZiB0aGlzIG5vZGUuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9fdHlwZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaXNJbmxpbmUoKS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgcGF0aCBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgdGhlIFJvb3ROb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIFRoaXMgaXMgYSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgdGhlIG5vZGUgaXMgXCJhdHRhY2hlZFwiIEVkaXRvclN0YXRlLiBVbmF0dGFjaGVkIG5vZGVzXG4gICAqIHdvbid0IGJlIHJlY29uY2lsZWQgYW5kIHdpbGwgdWx0aW1hdGVsdCBiZSBjbGVhbmVkIHVwIGJ5IHRoZSBMZXhpY2FsIEdDLlxuICAgKi9cbiAgaXNBdHRhY2hlZCgpIHtcbiAgICBsZXQgbm9kZUtleSA9IHRoaXMuX19rZXk7XG4gICAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlS2V5ID09PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZUtleSA9IG5vZGUuX19wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi4sIGZhbHNlIG90aGVyd2lzZS5cbiAgICogUmVsaWVzIG9uIHRoZSBhbGdvcml0aG1zIGltcGxlbWVudGVkIGluIHtAbGluayBCYXNlU2VsZWN0aW9uLmdldE5vZGVzfSB0byBkZXRlcm1pbmVcbiAgICogd2hhdCdzIGluY2x1ZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0aGF0IHdlIHdhbnQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBub2RlIGlzIGluLlxuICAgKi9cbiAgaXNTZWxlY3RlZChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICh0YXJnZXRTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gdGFyZ2V0U2VsZWN0aW9uLmdldE5vZGVzKCkuc29tZShuID0+IG4uX19rZXkgPT09IHRoaXMuX19rZXkpO1xuICAgIGlmICgkaXNUZXh0Tm9kZSh0aGlzKSkge1xuICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8vIEZvciBpbmxpbmUgaW1hZ2VzIGluc2lkZSBvZiBlbGVtZW50IG5vZGVzLlxuICAgIC8vIFdpdGhvdXQgdGhpcyBjaGFuZ2UgdGhlIGltYWdlIHdpbGwgYmUgc2VsZWN0ZWQgaWYgdGhlIGN1cnNvciBpcyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHRhcmdldFNlbGVjdGlvbikgJiYgdGFyZ2V0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiB0YXJnZXRTZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLmtleSAmJiB0YXJnZXRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLm9mZnNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgbm9kZXMga2V5LlxuICAgKi9cbiAgZ2V0S2V5KCkge1xuICAgIC8vIEtleSBpcyBzdGFibGUgYmV0d2VlbiBjb3BpZXNcbiAgICByZXR1cm4gdGhpcy5fX2tleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoaXMgbm9kZSB3aXRoaW4gdGhlIHBhcmVudC5cbiAgICovXG4gIGdldEluZGV4V2l0aGluUGFyZW50KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuaXMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgaW5kZXgrKztcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuXG4gICAqL1xuICBnZXRQYXJlbnQoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRMYXRlc3QoKS5fX3BhcmVudDtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICRnZXROb2RlQnlLZXkocGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLCBvciB0aHJvd3MgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICovXG4gIGdldFBhcmVudE9yVGhyb3coKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIHBhcmVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IChpbiB0aGUgRWRpdG9yU3RhdGUgdHJlZSlcbiAgICogbm9uLXJvb3QgYW5jZXN0b3Igb2YgdGhpcyBub2RlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuIFNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGljaCBFbGVtZW50cyBjb21wcmlzZSBcInJvb3RzXCIuXG4gICAqL1xuICBnZXRUb3BMZXZlbEVsZW1lbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSkge1xuICAgICAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYENoaWxkcmVuIG9mIHJvb3Qgbm9kZXMgbXVzdCBiZSBlbGVtZW50c2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaGVzdCAoaW4gdGhlIEVkaXRvclN0YXRlIHRyZWUpXG4gICAqIG5vbi1yb290IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSwgb3IgdGhyb3dzIGlmIG5vbmUgaXMgZm91bmQuIFNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGljaCBFbGVtZW50cyBjb21wcmlzZSBcInJvb3RzXCIuXG4gICAqL1xuICBnZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0VG9wTGV2ZWxFbGVtZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSB0b3AgcGFyZW50IGVsZW1lbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGV2ZXJ5IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSxcbiAgICogYWxsIHRoZSB3YXkgdXAgdG8gdGhlIFJvb3ROb2RlLlxuICAgKlxuICAgKi9cbiAgZ2V0UGFyZW50cygpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGtleXMgb2YgZXZlcnkgYW5jZXN0b3Igb2YgdGhpcyBub2RlLFxuICAgKiBhbGwgdGhlIHdheSB1cCB0byB0aGUgUm9vdE5vZGUuXG4gICAqXG4gICAqL1xuICBnZXRQYXJlbnRLZXlzKCkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudHMucHVzaChub2RlLl9fa2V5KTtcbiAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBcInByZXZpb3VzXCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZSB0aGF0IGNvbWVzXG4gICAqIGJlZm9yZSB0aGlzIG9uZSBpbiB0aGUgc2FtZSBwYXJlbnQuXG4gICAqXG4gICAqL1xuICBnZXRQcmV2aW91c1NpYmxpbmcoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgcHJldktleSA9IHNlbGYuX19wcmV2O1xuICAgIHJldHVybiBwcmV2S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkocHJldktleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJwcmV2aW91c1wiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGVzIHRoYXQgY29tZSBiZXR3ZWVuXG4gICAqIHRoaXMgb25lIGFuZCB0aGUgZmlyc3QgY2hpbGQgb2YgaXQncyBwYXJlbnQsIGluY2x1c2l2ZS5cbiAgICpcbiAgICovXG4gIGdldFByZXZpb3VzU2libGluZ3MoKSB7XG4gICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5pcyh0aGlzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gc2libGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJuZXh0XCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZSB0aGF0IGNvbWVzXG4gICAqIGFmdGVyIHRoaXMgb25lIGluIHRoZSBzYW1lIHBhcmVudFxuICAgKlxuICAgKi9cbiAgZ2V0TmV4dFNpYmxpbmcoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgbmV4dEtleSA9IHNlbGYuX19uZXh0O1xuICAgIHJldHVybiBuZXh0S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkobmV4dEtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgXCJuZXh0XCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZXMgdGhhdCBjb21lIGJldHdlZW4gdGhpc1xuICAgKiBvbmUgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGl0J3MgcGFyZW50LCBpbmNsdXNpdmUuXG4gICAqXG4gICAqL1xuICBnZXROZXh0U2libGluZ3MoKSB7XG4gICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgc2libGluZ3MucHVzaChub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBzaWJsaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbG9zZXN0IGNvbW1vbiBhbmNlc3RvciBvZiB0aGlzIG5vZGUgYW5kIHRoZSBwcm92aWRlZCBvbmUgb3IgbnVsbFxuICAgKiBpZiBvbmUgY2Fubm90IGJlIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAtIHRoZSBvdGhlciBub2RlIHRvIGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RvciBvZi5cbiAgICovXG4gIGdldENvbW1vbkFuY2VzdG9yKG5vZGUpIHtcbiAgICBjb25zdCBhID0gdGhpcy5nZXRQYXJlbnRzKCk7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0UGFyZW50cygpO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0aGlzKSkge1xuICAgICAgYS51bnNoaWZ0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGIudW5zaGlmdChub2RlKTtcbiAgICB9XG4gICAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgICBpZiAoYUxlbmd0aCA9PT0gMCB8fCBiTGVuZ3RoID09PSAwIHx8IGFbYUxlbmd0aCAtIDFdICE9PSBiW2JMZW5ndGggLSAxXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGJTZXQgPSBuZXcgU2V0KGIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhbmNlc3RvciA9IGFbaV07XG4gICAgICBpZiAoYlNldC5oYXMoYW5jZXN0b3IpKSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBub2RlIGlzIHRoZSBleGFjdCBzYW1lIG9uZSBhcyB0aGlzIG5vZGUsIGZyb20gTGV4aWNhbCdzIHBlcnNwZWN0aXZlLlxuICAgKiBBbHdheXMgdXNlIHRoaXMgaW5zdGVhZCBvZiByZWZlcmVudGlhbCBlcXVhbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIG9iamVjdCAtIHRoZSBub2RlIHRvIHBlcmZvcm0gdGhlIGVxdWFsaXR5IGNvbXBhcmlzb24gb24uXG4gICAqL1xuICBpcyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19rZXkgPT09IG9iamVjdC5fX2tleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGxvZ2ljYWwgcHJlY2VkZXMgdGhlIHRhcmdldCBub2RlIGluIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIG5vZGUgd2UncmUgdGVzdGluZyB0byBzZWUgaWYgaXQncyBhZnRlciB0aGlzIG9uZS5cbiAgICovXG4gIGlzQmVmb3JlKHRhcmdldE5vZGUpIHtcbiAgICBpZiAodGhpcyA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Tm9kZS5pc1BhcmVudE9mKHRoaXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNQYXJlbnRPZih0YXJnZXROb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25BbmNlc3RvciA9IHRoaXMuZ2V0Q29tbW9uQW5jZXN0b3IodGFyZ2V0Tm9kZSk7XG4gICAgbGV0IGluZGV4QSA9IDA7XG4gICAgbGV0IGluZGV4QiA9IDA7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGlmIChwYXJlbnQgPT09IGNvbW1vbkFuY2VzdG9yKSB7XG4gICAgICAgIGluZGV4QSA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBub2RlID0gdGFyZ2V0Tm9kZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBpZiAocGFyZW50ID09PSBjb21tb25BbmNlc3Rvcikge1xuICAgICAgICBpbmRleEIgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4QSA8IGluZGV4QjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIHRoZSBwYXJlbnQgb2YgdGhlIHRhcmdldCBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIHdvdWxkLWJlIGNoaWxkIG5vZGUuXG4gICAqL1xuICBpc1BhcmVudE9mKHRhcmdldE5vZGUpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGlmIChrZXkgPT09IHRhcmdldE5vZGUuX19rZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSB0YXJnZXROb2RlO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5fX2tleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRPLURPOiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBzaW1wbGlmaWVkIGEgbG90XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBiZXR3ZWVuIHRoaXMgbm9kZSBhbmRcbiAgICogdGhlIHRhcmdldCBub2RlIGluIHRoZSBFZGl0b3JTdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRhcmdldE5vZGUgLSB0aGUgbm9kZSB0aGF0IG1hcmtzIHRoZSBvdGhlciBlbmQgb2YgdGhlIHJhbmdlIG9mIG5vZGVzIHRvIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0Tm9kZXNCZXR3ZWVuKHRhcmdldE5vZGUpIHtcbiAgICBjb25zdCBpc0JlZm9yZSA9IHRoaXMuaXNCZWZvcmUodGFyZ2V0Tm9kZSk7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIGxldCBub2RlID0gdGhpcztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBub2RlLl9fa2V5O1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhrZXkpKSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKGtleSk7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gJGlzRWxlbWVudE5vZGUobm9kZSkgPyBpc0JlZm9yZSA/IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpIDogbm9kZS5nZXRMYXN0Q2hpbGQoKSA6IG51bGw7XG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gaXNCZWZvcmUgPyBub2RlLmdldE5leHRTaWJsaW5nKCkgOiBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBuZXh0U2libGluZztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMocGFyZW50Ll9fa2V5KSkge1xuICAgICAgICBub2Rlcy5wdXNoKHBhcmVudCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IHBhcmVudFNpYmxpbmcgPSBudWxsO1xuICAgICAgbGV0IGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoYW5jZXN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXNCZXR3ZWVuOiBhbmNlc3RvciBpcyBudWxsYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBpc0JlZm9yZSA/IGFuY2VzdG9yLmdldE5leHRTaWJsaW5nKCkgOiBhbmNlc3Rvci5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKGFuY2VzdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT09IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGFuY2VzdG9yLl9fa2V5KSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChhbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChwYXJlbnRTaWJsaW5nID09PSBudWxsKTtcbiAgICAgIG5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgICBpZiAoIWlzQmVmb3JlKSB7XG4gICAgICBub2Rlcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGhhcyBiZWVuIG1hcmtlZCBkaXJ0eSBkdXJpbmcgdGhpcyB1cGRhdGUgY3ljbGUuXG4gICAqXG4gICAqL1xuICBpc0RpcnR5KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGRpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgICByZXR1cm4gZGlydHlMZWF2ZXMgIT09IG51bGwgJiYgZGlydHlMZWF2ZXMuaGFzKHRoaXMuX19rZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBub2RlIGZyb20gdGhlIGFjdGl2ZSBFZGl0b3JTdGF0ZS5cbiAgICogVGhpcyBpcyB1c2VkIHRvIGF2b2lkIGdldHRpbmcgdmFsdWVzIGZyb20gc3RhbGUgbm9kZSByZWZlcmVuY2VzLlxuICAgKlxuICAgKi9cbiAgZ2V0TGF0ZXN0KCkge1xuICAgIGNvbnN0IGxhdGVzdCA9ICRnZXROb2RlQnlLZXkodGhpcy5fX2tleSk7XG4gICAgaWYgKGxhdGVzdCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbCBub2RlIGRvZXMgbm90IGV4aXN0IGluIGFjdGl2ZSBlZGl0b3Igc3RhdGUuIEF2b2lkIHVzaW5nIHRoZSBzYW1lIG5vZGUgcmVmZXJlbmNlcyBiZXR3ZWVuIG5lc3RlZCBjbG9zdXJlcyBmcm9tIGVkaXRvclN0YXRlLnJlYWQvZWRpdG9yLnVwZGF0ZS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhdGVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbXV0YWJsZSB2ZXJzaW9uIG9mIHRoZSBub2RlLiBXaWxsIHRocm93IGFuIGVycm9yIGlmXG4gICAqIGNhbGxlZCBvdXRzaWRlIG9mIGEgTGV4aWNhbCBFZGl0b3Ige0BsaW5rIExleGljYWxFZGl0b3IudXBkYXRlfSBjYWxsYmFjay5cbiAgICpcbiAgICovXG4gIGdldFdyaXRhYmxlKCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcbiAgICAvLyBFbnN1cmUgd2UgZ2V0IHRoZSBsYXRlc3Qgbm9kZSBmcm9tIHBlbmRpbmcgc3RhdGVcbiAgICBjb25zdCBsYXRlc3ROb2RlID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBsYXRlc3ROb2RlLl9fcGFyZW50O1xuICAgIGNvbnN0IGNsb25lTm90TmVlZGVkID0gZWRpdG9yLl9jbG9uZU5vdE5lZWRlZDtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgc2VsZWN0aW9uLnNldENhY2hlZE5vZGVzKG51bGwpO1xuICAgIH1cbiAgICBpZiAoY2xvbmVOb3ROZWVkZWQuaGFzKGtleSkpIHtcbiAgICAgIC8vIFRyYW5zZm9ybXMgY2xlYXIgdGhlIGRpcnR5IG5vZGUgc2V0IG9uIGVhY2ggaXRlcmF0aW9uIHRvIGtlZXAgdHJhY2sgb24gbmV3bHkgZGlydHkgbm9kZXNcbiAgICAgIGludGVybmFsTWFya05vZGVBc0RpcnR5KGxhdGVzdE5vZGUpO1xuICAgICAgcmV0dXJuIGxhdGVzdE5vZGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gbGF0ZXN0Tm9kZS5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBtdXRhYmxlTm9kZSA9IGNvbnN0cnVjdG9yLmNsb25lKGxhdGVzdE5vZGUpO1xuICAgIG11dGFibGVOb2RlLl9fcGFyZW50ID0gcGFyZW50O1xuICAgIG11dGFibGVOb2RlLl9fbmV4dCA9IGxhdGVzdE5vZGUuX19uZXh0O1xuICAgIG11dGFibGVOb2RlLl9fcHJldiA9IGxhdGVzdE5vZGUuX19wcmV2O1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXRlc3ROb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShtdXRhYmxlTm9kZSkpIHtcbiAgICAgIGlmICgkaXNQYXJhZ3JhcGhOb2RlKGxhdGVzdE5vZGUpICYmICRpc1BhcmFncmFwaE5vZGUobXV0YWJsZU5vZGUpKSB7XG4gICAgICAgIG11dGFibGVOb2RlLl9fdGV4dEZvcm1hdCA9IGxhdGVzdE5vZGUuX190ZXh0Rm9ybWF0O1xuICAgICAgfVxuICAgICAgbXV0YWJsZU5vZGUuX19maXJzdCA9IGxhdGVzdE5vZGUuX19maXJzdDtcbiAgICAgIG11dGFibGVOb2RlLl9fbGFzdCA9IGxhdGVzdE5vZGUuX19sYXN0O1xuICAgICAgbXV0YWJsZU5vZGUuX19zaXplID0gbGF0ZXN0Tm9kZS5fX3NpemU7XG4gICAgICBtdXRhYmxlTm9kZS5fX2luZGVudCA9IGxhdGVzdE5vZGUuX19pbmRlbnQ7XG4gICAgICBtdXRhYmxlTm9kZS5fX2Zvcm1hdCA9IGxhdGVzdE5vZGUuX19mb3JtYXQ7XG4gICAgICBtdXRhYmxlTm9kZS5fX2RpciA9IGxhdGVzdE5vZGUuX19kaXI7XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShsYXRlc3ROb2RlKSAmJiAkaXNUZXh0Tm9kZShtdXRhYmxlTm9kZSkpIHtcbiAgICAgIG11dGFibGVOb2RlLl9fZm9ybWF0ID0gbGF0ZXN0Tm9kZS5fX2Zvcm1hdDtcbiAgICAgIG11dGFibGVOb2RlLl9fc3R5bGUgPSBsYXRlc3ROb2RlLl9fc3R5bGU7XG4gICAgICBtdXRhYmxlTm9kZS5fX21vZGUgPSBsYXRlc3ROb2RlLl9fbW9kZTtcbiAgICAgIG11dGFibGVOb2RlLl9fZGV0YWlsID0gbGF0ZXN0Tm9kZS5fX2RldGFpbDtcbiAgICB9XG4gICAgY2xvbmVOb3ROZWVkZWQuYWRkKGtleSk7XG4gICAgbXV0YWJsZU5vZGUuX19rZXkgPSBrZXk7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobXV0YWJsZU5vZGUpO1xuICAgIC8vIFVwZGF0ZSByZWZlcmVuY2UgaW4gbm9kZSBtYXBcbiAgICBub2RlTWFwLnNldChrZXksIG11dGFibGVOb2RlKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gbXV0YWJsZU5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlLiBPdmVycmlkZSB0aGlzIGZvclxuICAgKiBjdXN0b20gbm9kZXMgdGhhdCBzaG91bGQgaGF2ZSBhIHJlcHJlc2VudGF0aW9uIGluIHBsYWluIHRleHRcbiAgICogZm9ybWF0IChmb3IgY29weSArIHBhc3RlLCBmb3IgZXhhbXBsZSlcbiAgICpcbiAgICovXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBwcm9kdWNlZCBieSBjYWxsaW5nIGdldFRleHRDb250ZW50IG9uIHRoaXMgbm9kZS5cbiAgICpcbiAgICovXG4gIGdldFRleHRDb250ZW50U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgfVxuXG4gIC8vIFZpZXdcblxuICAvKipcbiAgICogQ2FsbGVkIGR1cmluZyB0aGUgcmVjb25jaWxpYXRpb24gcHJvY2VzcyB0byBkZXRlcm1pbmUgd2hpY2ggbm9kZXNcbiAgICogdG8gaW5zZXJ0IGludG8gdGhlIERPTSBmb3IgdGhpcyBMZXhpY2FsIE5vZGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIG11c3QgcmV0dXJuIGV4YWN0bHkgb25lIEhUTUxFbGVtZW50LiBOZXN0ZWQgZWxlbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIERvIG5vdCBhdHRlbXB0IHRvIHVwZGF0ZSB0aGUgTGV4aWNhbCBFZGl0b3JTdGF0ZSBkdXJpbmcgdGhpcyBwaGFzZSBvZiB0aGUgdXBkYXRlIGxpZmVjeWxlLlxuICAgKlxuICAgKiBAcGFyYW0gX2NvbmZpZyAtIGFsbG93cyBhY2Nlc3MgdG8gdGhpbmdzIGxpa2UgdGhlIEVkaXRvclRoZW1lICh0byBhcHBseSBjbGFzc2VzKSBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gICAqIEBwYXJhbSBfZWRpdG9yIC0gYWxsb3dzIGFjY2VzcyB0byB0aGUgZWRpdG9yIGZvciBjb250ZXh0IGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAgICpcbiAgICogKi9cbiAgY3JlYXRlRE9NKF9jb25maWcsIF9lZGl0b3IpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgY3JlYXRlRE9NOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBub2RlIGNoYW5nZXMgYW5kIHNob3VsZCB1cGRhdGUgdGhlIERPTVxuICAgKiBpbiB3aGF0ZXZlciB3YXkgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaXQgYWxpZ24gd2l0aCBhbnkgY2hhbmdlcyB0aGF0IG1pZ2h0XG4gICAqIGhhdmUgaGFwcGVuZWQgZHVyaW5nIHRoZSB1cGRhdGUuXG4gICAqXG4gICAqIFJldHVybmluZyBcInRydWVcIiBoZXJlIHdpbGwgY2F1c2UgbGV4aWNhbCB0byB1bm1vdW50IGFuZCByZWNyZWF0ZSB0aGUgRE9NIG5vZGVcbiAgICogKGJ5IGNhbGxpbmcgY3JlYXRlRE9NKS4gWW91IHdvdWxkIG5lZWQgdG8gZG8gdGhpcyBpZiB0aGUgZWxlbWVudCB0YWcgY2hhbmdlcyxcbiAgICogZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiAqL1xuICB1cGRhdGVET00oX3ByZXZOb2RlLCBfZG9tLCBfY29uZmlnKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHVwZGF0ZURPTTogYmFzZSBtZXRob2Qgbm90IGV4dGVuZGVkYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyB0aGUgdGhpcyBub2RlIGlzIHNlcmlhbGl6ZWQgdG8gSFRNTC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yXG4gICAqIGNvcHkgYW5kIHBhc3RlIGJldHdlZW4gTGV4aWNhbCBhbmQgbm9uLUxleGljYWwgZWRpdG9ycywgb3IgTGV4aWNhbCBlZGl0b3JzIHdpdGggZGlmZmVyZW50IG5hbWVzcGFjZXMsXG4gICAqIGluIHdoaWNoIGNhc2UgdGhlIHByaW1hcnkgdHJhbnNmZXIgZm9ybWF0IGlzIEhUTUwuIEl0J3MgYWxzbyBpbXBvcnRhbnQgaWYgeW91J3JlIHNlcmlhbGl6aW5nXG4gICAqIHRvIEhUTUwgZm9yIGFueSBvdGhlciByZWFzb24gdmlhIHtAbGluayBAbGV4aWNhbC9odG1sISRnZW5lcmF0ZUh0bWxGcm9tTm9kZXN9LiBZb3UgY291bGRcbiAgICogYWxzbyB1c2UgdGhpcyBtZXRob2QgdG8gYnVpbGQgeW91ciBvd24gSFRNTCByZW5kZXJlci5cbiAgICpcbiAgICogKi9cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZURPTShlZGl0b3IuX2NvbmZpZywgZWRpdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgc2VyaWFsaXplZCB0byBKU09OLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgICogY29weSBhbmQgcGFzdGUgYmV0d2VlbiBMZXhpY2FsIGVkaXRvcnMgc2hhcmluZyB0aGUgc2FtZSBuYW1lc3BhY2UuIEl0J3MgYWxzbyBpbXBvcnRhbnRcbiAgICogaWYgeW91J3JlIHNlcmlhbGl6aW5nIHRvIEpTT04gZm9yIHBlcnNpc3RlbnQgc3RvcmFnZSBzb21ld2hlcmUuXG4gICAqIFNlZSBbU2VyaWFsaXphdGlvbiAmIERlc2VyaWFsaXphdGlvbl0oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3NlcmlhbGl6YXRpb24jbGV4aWNhbC0tLWh0bWwpLlxuICAgKlxuICAgKiAqL1xuICBleHBvcnRKU09OKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBleHBvcnRKU09OOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgZGVzZXJpYWxpemVkIGZyb20gSlNPTi4gVGhpcyBpcyB1c3VhbGx5IGJvaWxlcnBsYXRlLFxuICAgKiBidXQgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gYmV0d2VlbiB0aGUgbm9kZSBpbXBsZW1lbnRhdGlvbiBhbmQgc2VyaWFsaXplZCBpbnRlcmZhY2UgdGhhdCBjYW5cbiAgICogYmUgaW1wb3J0YW50IGlmIHlvdSBldmVyIG1ha2UgYnJlYWtpbmcgY2hhbmdlcyB0byBhIG5vZGUgc2NoZW1hIChieSBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJvcGVydGllcykuXG4gICAqIFNlZSBbU2VyaWFsaXphdGlvbiAmIERlc2VyaWFsaXphdGlvbl0oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3NlcmlhbGl6YXRpb24jbGV4aWNhbC0tLWh0bWwpLlxuICAgKlxuICAgKiAqL1xuICBzdGF0aWMgaW1wb3J0SlNPTihfc2VyaWFsaXplZE5vZGUpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaW1wb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKlxuICAgKiBSZWdpc3RlcnMgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGFzIGEgdHJhbnNmb3JtIG9uIHRoZSBub2RlIGR1cmluZ1xuICAgKiBFZGl0b3IgaW5pdGlhbGl6YXRpb24uIE1vc3Qgc3VjaCB1c2UgY2FzZXMgc2hvdWxkIGJlIGFkZHJlc3NlZCB2aWFcbiAgICogdGhlIHtAbGluayBMZXhpY2FsRWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybX0gQVBJLlxuICAgKlxuICAgKiBFeHBlcmltZW50YWwgLSB1c2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIHN0YXRpYyB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBTZXR0ZXJzIGFuZCBtdXRhdG9yc1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoaXMgTGV4aWNhbE5vZGUgZnJvbSB0aGUgRWRpdG9yU3RhdGUuIElmIHRoZSBub2RlIGlzbid0IHJlLWluc2VydGVkXG4gICAqIHNvbWV3aGVyZSwgdGhlIExleGljYWwgZ2FyYmFnZSBjb2xsZWN0b3Igd2lsbCBldmVudHVhbGx5IGNsZWFuIGl0IHVwLlxuICAgKlxuICAgKiBAcGFyYW0gcHJlc2VydmVFbXB0eVBhcmVudCAtIElmIGZhbHN5LCB0aGUgbm9kZSdzIHBhcmVudCB3aWxsIGJlIHJlbW92ZWQgaWZcbiAgICogaXQncyBlbXB0eSBhZnRlciB0aGUgcmVtb3ZhbCBvcGVyYXRpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIHN1YmplY3QgdG9cbiAgICogb3RoZXIgbm9kZSBoZXVyaXN0aWNzIHN1Y2ggYXMge0BsaW5rIEVsZW1lbnROb2RlI2NhbkJlRW1wdHl9XG4gICAqICovXG4gIHJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gICAgJHJlbW92ZU5vZGUodGhpcywgdHJ1ZSwgcHJlc2VydmVFbXB0eVBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhpcyBMZXhpY2FsTm9kZSB3aXRoIHRoZSBwcm92aWRlZCBub2RlLCBvcHRpb25hbGx5IHRyYW5zZmVycmluZyB0aGUgY2hpbGRyZW5cbiAgICogb2YgdGhlIHJlcGxhY2VkIG5vZGUgdG8gdGhlIHJlcGxhY2luZyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVwbGFjZVdpdGggLSBUaGUgbm9kZSB0byByZXBsYWNlIHRoaXMgb25lIHdpdGguXG4gICAqIEBwYXJhbSBpbmNsdWRlQ2hpbGRyZW4gLSBXaGV0aGVyIG9yIG5vdCB0byB0cmFuc2ZlciB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlIHRvIHRoZSByZXBsYWNpbmcgbm9kZS5cbiAgICogKi9cbiAgcmVwbGFjZShyZXBsYWNlV2l0aCwgaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgbGV0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uY2xvbmUoKTtcbiAgICB9XG4gICAgZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KHRoaXMsIHJlcGxhY2VXaXRoKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCB0b1JlcGxhY2VLZXkgPSB0aGlzLl9fa2V5O1xuICAgIGNvbnN0IGtleSA9IHJlcGxhY2VXaXRoLl9fa2V5O1xuICAgIGNvbnN0IHdyaXRhYmxlUmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBzaXplID0gd3JpdGFibGVQYXJlbnQuX19zaXplO1xuICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVSZXBsYWNlV2l0aCk7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBzZWxmLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gc2VsZi5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHByZXZLZXkgPSBzZWxmLl9fcHJldjtcbiAgICBjb25zdCBuZXh0S2V5ID0gc2VsZi5fX25leHQ7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gc2VsZi5fX3BhcmVudDtcbiAgICAkcmVtb3ZlTm9kZShzZWxmLCBmYWxzZSwgdHJ1ZSk7XG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0ga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0ga2V5O1xuICAgIH1cbiAgICB3cml0YWJsZVJlcGxhY2VXaXRoLl9fcHJldiA9IHByZXZLZXk7XG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBrZXk7XG4gICAgfVxuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19uZXh0ID0gbmV4dEtleTtcbiAgICB3cml0YWJsZVJlcGxhY2VXaXRoLl9fcGFyZW50ID0gcGFyZW50S2V5O1xuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZSA9IHNpemU7XG4gICAgaWYgKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgaWYgKCEoJGlzRWxlbWVudE5vZGUodGhpcykgJiYgJGlzRWxlbWVudE5vZGUod3JpdGFibGVSZXBsYWNlV2l0aCkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBpbmNsdWRlQ2hpbGRyZW4gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgRWxlbWVudE5vZGVzYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguYXBwZW5kKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgaWYgKGFuY2hvci5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoYW5jaG9yLCB3cml0YWJsZVJlcGxhY2VXaXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb2N1cy5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoZm9jdXMsIHdyaXRhYmxlUmVwbGFjZVdpdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGdldENvbXBvc2l0aW9uS2V5KCkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0YWJsZVJlcGxhY2VXaXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBub2RlIGFmdGVyIHRoaXMgTGV4aWNhbE5vZGUgKGFzIHRoZSBuZXh0IHNpYmxpbmcpLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZVRvSW5zZXJ0IC0gVGhlIG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVzdG9yZVNlbGVjdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiAqL1xuICBpbnNlcnRBZnRlcihub2RlVG9JbnNlcnQsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KHRoaXMsIG5vZGVUb0luc2VydCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkUGFyZW50ID0gd3JpdGFibGVOb2RlVG9JbnNlcnQuZ2V0UGFyZW50KCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGxldCBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gZmFsc2U7XG4gICAgbGV0IGVsZW1lbnRGb2N1c1NlbGVjdGlvbk9uTm9kZSA9IGZhbHNlO1xuICAgIGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IHRoaXMgaXMgTyhuKSwgY2FuIHdlIGltcHJvdmU/XG4gICAgICBjb25zdCBvbGRJbmRleCA9IG5vZGVUb0luc2VydC5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZU5vZGVUb0luc2VydCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBvbGRQYXJlbnRLZXkgPSBvbGRQYXJlbnQuX19rZXk7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3Iua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgYW5jaG9yLm9mZnNldCA9PT0gb2xkSW5kZXggKyAxO1xuICAgICAgICBlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUgPSBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgZm9jdXMub2Zmc2V0ID09PSBvbGRJbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBpbnNlcnRLZXkgPSB3cml0YWJsZU5vZGVUb0luc2VydC5fX2tleTtcbiAgICBjb25zdCBuZXh0S2V5ID0gd3JpdGFibGVTZWxmLl9fbmV4dDtcbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IGluc2VydEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IGluc2VydEtleTtcbiAgICB9XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplKys7XG4gICAgd3JpdGFibGVTZWxmLl9fbmV4dCA9IGluc2VydEtleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX25leHQgPSBuZXh0S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcHJldiA9IHdyaXRhYmxlU2VsZi5fX2tleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9IHdyaXRhYmxlU2VsZi5fX3BhcmVudDtcbiAgICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgd3JpdGFibGVQYXJlbnQsIGluZGV4ICsgMSk7XG4gICAgICBjb25zdCB3cml0YWJsZVBhcmVudEtleSA9IHdyaXRhYmxlUGFyZW50Ll9fa2V5O1xuICAgICAgaWYgKGVsZW1lbnRBbmNob3JTZWxlY3Rpb25Pbk5vZGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQod3JpdGFibGVQYXJlbnRLZXksIGluZGV4ICsgMiwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldCh3cml0YWJsZVBhcmVudEtleSwgaW5kZXggKyAyLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVRvSW5zZXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBub2RlIGJlZm9yZSB0aGlzIExleGljYWxOb2RlIChhcyB0aGUgcHJldmlvdXMgc2libGluZykuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlVG9JbnNlcnQgLSBUaGUgbm9kZSB0byBpbnNlcnQgYmVmb3JlIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVzdG9yZVNlbGVjdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiAqL1xuICBpbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0LCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGVycm9yT25JbnNlcnRUZXh0Tm9kZU9uUm9vdCh0aGlzLCBub2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZU5vZGVUb0luc2VydCA9IG5vZGVUb0luc2VydC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGluc2VydEtleSA9IHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgcHJldktleSA9IHdyaXRhYmxlU2VsZi5fX3ByZXY7XG4gICAgLy8gVE9ETzogdGhpcyBpcyBPKG4pLCBjYW4gd2UgaW1wcm92ZT9cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBpbnNlcnRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBpbnNlcnRLZXk7XG4gICAgfVxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZSsrO1xuICAgIHdyaXRhYmxlU2VsZi5fX3ByZXYgPSBpbnNlcnRLZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wcmV2ID0gcHJldktleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX25leHQgPSB3cml0YWJsZVNlbGYuX19rZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGYuX19wYXJlbnQ7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChyZXN0b3JlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCBwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVUb0luc2VydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaGFzIGEgcmVxdWlyZWQgcGFyZW50LiBVc2VkIGR1cmluZyBjb3B5ICsgcGFzdGUgb3BlcmF0aW9uc1xuICAgKiB0byBub3JtYWxpemUgbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgb3JwaGFuZWQuIEZvciBleGFtcGxlLCBMaXN0SXRlbU5vZGVzIHdpdGhvdXRcbiAgICogYSBMaXN0Tm9kZSBwYXJlbnQgb3IgVGV4dE5vZGVzIHdpdGggYSBQYXJhZ3JhcGhOb2RlIHBhcmVudC5cbiAgICpcbiAgICogKi9cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNyZWF0aW9uIGxvZ2ljIGZvciBhbnkgcmVxdWlyZWQgcGFyZW50LiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaWYge0BsaW5rIGlzUGFyZW50UmVxdWlyZWR9IHJldHVybnMgdHJ1ZS5cbiAgICpcbiAgICogKi9cbiAgY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKSB7XG4gICAgcmV0dXJuICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0UHJldmlvdXMoKTtcbiAgfVxuICBzZWxlY3RFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0TmV4dCgwLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhpcyBub2RlLCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSBUaGUgYW5jaG9yIG9mZnNldCBmb3Igc2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSAgVGhlIGZvY3VzIG9mZnNldCBmb3Igc2VsZWN0aW9uXG4gICAqICovXG4gIHNlbGVjdFByZXZpb3VzKGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdCgwLCAwKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgIH0gZWxzZSBpZiAoISRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBwcmV2U2libGluZy5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwcmV2U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhpcyBub2RlLCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSBUaGUgYW5jaG9yIG9mZnNldCBmb3Igc2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSAgVGhlIGZvY3VzIG9mZnNldCBmb3Igc2VsZWN0aW9uXG4gICAqICovXG4gIHNlbGVjdE5leHQoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHBhcmVudC5zZWxlY3QoKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nLnNlbGVjdCgwLCAwKTtcbiAgICB9IGVsc2UgaWYgKCEkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbmV4dFNpYmxpbmcuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgYSBub2RlIGRpcnR5LCB0cmlnZ2VyaW5nIHRyYW5zZm9ybXMgYW5kXG4gICAqIGZvcmNpbmcgaXQgdG8gYmUgcmVjb25jaWxlZCBkdXJpbmcgdGhlIHVwZGF0ZSBjeWNsZS5cbiAgICpcbiAgICogKi9cbiAgbWFya0RpcnR5KCkge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPblR5cGVLbGFzc01pc21hdGNoKHR5cGUsIGtsYXNzKSB7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZ2V0QWN0aXZlRWRpdG9yKCkuX25vZGVzLmdldCh0eXBlKTtcbiAgLy8gQ29tbW9uIGVycm9yIC0gc3BsaXQgaW4gaXRzIG93biBpbnZhcmlhbnRcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQ3JlYXRlIG5vZGU6IEF0dGVtcHRlZCB0byBjcmVhdGUgbm9kZSAke2tsYXNzLm5hbWV9IHRoYXQgd2FzIG5vdCBjb25maWd1cmVkIHRvIGJlIHVzZWQgb24gdGhlIGVkaXRvci5gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZWRpdG9yS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcbiAgaWYgKGVkaXRvcktsYXNzICE9PSBrbGFzcykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBDcmVhdGUgbm9kZTogVHlwZSAke3R5cGV9IGluIG5vZGUgJHtrbGFzcy5uYW1lfSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIG5vZGUgJHtlZGl0b3JLbGFzcy5uYW1lfSB3aXRoIHRoZSBzYW1lIHR5cGVgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnNlcnQgYSBzZXJpZXMgb2Ygbm9kZXMgYWZ0ZXIgdGhpcyBMZXhpY2FsTm9kZSAoYXMgbmV4dCBzaWJsaW5ncylcbiAqXG4gKiBAcGFyYW0gZmlyc3RUb0luc2VydCAtIFRoZSBmaXJzdCBub2RlIHRvIGluc2VydCBhZnRlciB0aGlzIG9uZS5cbiAqIEBwYXJhbSBsYXN0VG9JbnNlcnQgLSBUaGUgbGFzdCBub2RlIHRvIGluc2VydCBhZnRlciB0aGlzIG9uZS4gTXVzdCBiZSBhXG4gKiBsYXRlciBzaWJsaW5nIG9mIEZpcnN0Tm9kZS4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIGl0cyBsYXN0IHNpYmxpbmcuXG4gKi9cbmZ1bmN0aW9uIGluc2VydFJhbmdlQWZ0ZXIobm9kZSwgZmlyc3RUb0luc2VydCwgbGFzdFRvSW5zZXJ0KSB7XG4gIGNvbnN0IGxhc3RUb0luc2VydDIgPSBmaXJzdFRvSW5zZXJ0LmdldFBhcmVudE9yVGhyb3coKS5nZXRMYXN0Q2hpbGQoKTtcbiAgbGV0IGN1cnJlbnQgPSBmaXJzdFRvSW5zZXJ0O1xuICBjb25zdCBub2Rlc1RvSW5zZXJ0ID0gW2ZpcnN0VG9JbnNlcnRdO1xuICB3aGlsZSAoY3VycmVudCAhPT0gbGFzdFRvSW5zZXJ0Mikge1xuICAgIGlmICghY3VycmVudC5nZXROZXh0U2libGluZygpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBpbnNlcnRSYW5nZUFmdGVyOiBsYXN0VG9JbnNlcnQgbXVzdCBiZSBhIGxhdGVyIHNpYmxpbmcgb2YgZmlyc3RUb0luc2VydGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudC5nZXROZXh0U2libGluZygpO1xuICAgIG5vZGVzVG9JbnNlcnQucHVzaChjdXJyZW50KTtcbiAgfVxuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICBmb3IgKGNvbnN0IG5vZGVUb0luc2VydCBvZiBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5pbnNlcnRBZnRlcihub2RlVG9JbnNlcnQpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpbmVCcmVha05vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluZWJyZWFrJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGluZUJyZWFrTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnXFxuJztcbiAgfVxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBicjogbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc09ubHlDaGlsZChub2RlKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaW5lQnJlYWtFbGVtZW50LFxuICAgICAgICAgIHByaW9yaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTGluZUJyZWFrTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlTGluZUJyZWFrTm9kZSgpO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaW5lYnJlYWsnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGluZUJyZWFrRWxlbWVudChub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpbmVCcmVha05vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUxpbmVCcmVha05vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmVCcmVha05vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaW5lQnJlYWtOb2RlO1xufVxuZnVuY3Rpb24gaXNPbmx5Q2hpbGQobm9kZSkge1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICBpZiAocGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKGZpcnN0Q2hpbGQgPT09IG5vZGUgfHwgZmlyc3RDaGlsZC5uZXh0U2libGluZyA9PT0gbm9kZSAmJiBpc1doaXRlc3BhY2VEb21UZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50RWxlbWVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAobGFzdENoaWxkID09PSBub2RlIHx8IGxhc3RDaGlsZC5wcmV2aW91c1NpYmxpbmcgPT09IG5vZGUgJiYgaXNXaGl0ZXNwYWNlRG9tVGV4dE5vZGUobGFzdENoaWxkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlRG9tVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSAmJiAvXiggfFxcdHxcXHI/XFxuKSskLy50ZXN0KG5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRPdXRlclRhZyhub2RlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCAmIElTX0NPREUpIHtcbiAgICByZXR1cm4gJ2NvZGUnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19ISUdITElHSFQpIHtcbiAgICByZXR1cm4gJ21hcmsnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19TVUJTQ1JJUFQpIHtcbiAgICByZXR1cm4gJ3N1Yic7XG4gIH1cbiAgaWYgKGZvcm1hdCAmIElTX1NVUEVSU0NSSVBUKSB7XG4gICAgcmV0dXJuICdzdXAnO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudElubmVyVGFnKG5vZGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ICYgSVNfQk9MRCkge1xuICAgIHJldHVybiAnc3Ryb25nJztcbiAgfVxuICBpZiAoZm9ybWF0ICYgSVNfSVRBTElDKSB7XG4gICAgcmV0dXJuICdlbSc7XG4gIH1cbiAgcmV0dXJuICdzcGFuJztcbn1cbmZ1bmN0aW9uIHNldFRleHRUaGVtZUNsYXNzTmFtZXModGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBkb20sIHRleHRDbGFzc05hbWVzKSB7XG4gIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gIC8vIEZpcnN0bHkgd2UgaGFuZGxlIHRoZSBiYXNlIHRoZW1lLlxuICBsZXQgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCAnYmFzZScpO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgfVxuICAvLyBTZWNvbmRseSB3ZSBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZTogdW5kZXJsaW5lICsgc3RyaWtldGhyb3VnaC5cbiAgLy8gV2UgaGF2ZSB0byBkbyB0aGlzIGFzIHdlIG5lZWQgYSB3YXkgdG8gY29tcG9zZSB0aGUgZmFjdCB0aGF0XG4gIC8vIHRoZSBzYW1lIENTUyBwcm9wZXJ0eSB3aWxsIG5lZWQgdG8gYmUgdXNlZDogdGV4dC1kZWNvcmF0aW9uLlxuICAvLyBJbiBhbiBpZGVhbCB3b3JsZCB3ZSBzaG91bGRuJ3QgaGF2ZSB0byBkbyB0aGlzLCBidXQgdGhlcmUncyBub1xuICAvLyBlYXN5IHdvcmthcm91bmQgZm9yIG1hbnkgYXRvbWljIENTUyBzeXN0ZW1zIHRvZGF5LlxuICBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGV4dENsYXNzTmFtZXMsICd1bmRlcmxpbmVTdHJpa2V0aHJvdWdoJyk7XG4gIGxldCBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gZmFsc2U7XG4gIGNvbnN0IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gcHJldkZvcm1hdCAmIElTX1VOREVSTElORSAmJiBwcmV2Rm9ybWF0ICYgSVNfU1RSSUtFVEhST1VHSDtcbiAgY29uc3QgbmV4dFVuZGVybGluZVN0cmlrZXRocm91Z2ggPSBuZXh0Rm9ybWF0ICYgSVNfVU5ERVJMSU5FICYmIG5leHRGb3JtYXQgJiBJU19TVFJJS0VUSFJPVUdIO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG5leHRVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIGlmICghcHJldlVuZGVybGluZVN0cmlrZXRocm91Z2gpIHtcbiAgICAgICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBkb21DbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBURVhUX1RZUEVfVE9fRk9STUFUKSB7XG4gICAgY29uc3QgZm9ybWF0ID0ga2V5O1xuICAgIGNvbnN0IGZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF07XG4gICAgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCBrZXkpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChuZXh0Rm9ybWF0ICYgZmxhZykge1xuICAgICAgICBpZiAoaGFzVW5kZXJsaW5lU3RyaWtldGhyb3VnaCAmJiAoa2V5ID09PSAndW5kZXJsaW5lJyB8fCBrZXkgPT09ICdzdHJpa2V0aHJvdWdoJykpIHtcbiAgICAgICAgICBpZiAocHJldkZvcm1hdCAmIGZsYWcpIHtcbiAgICAgICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJldkZvcm1hdCAmIGZsYWcpID09PSAwIHx8IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoICYmIGtleSA9PT0gJ3VuZGVybGluZScgfHwga2V5ID09PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZGb3JtYXQgJiBmbGFnKSB7XG4gICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWZmQ29tcG9zZWRUZXh0KGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gMDtcbiAgd2hpbGUgKGxlZnQgPCBhTGVuZ3RoICYmIGxlZnQgPCBiTGVuZ3RoICYmIGFbbGVmdF0gPT09IGJbbGVmdF0pIHtcbiAgICBsZWZ0Kys7XG4gIH1cbiAgd2hpbGUgKHJpZ2h0ICsgbGVmdCA8IGFMZW5ndGggJiYgcmlnaHQgKyBsZWZ0IDwgYkxlbmd0aCAmJiBhW2FMZW5ndGggLSByaWdodCAtIDFdID09PSBiW2JMZW5ndGggLSByaWdodCAtIDFdKSB7XG4gICAgcmlnaHQrKztcbiAgfVxuICByZXR1cm4gW2xlZnQsIGFMZW5ndGggLSBsZWZ0IC0gcmlnaHQsIGIuc2xpY2UobGVmdCwgYkxlbmd0aCAtIHJpZ2h0KV07XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChuZXh0VGV4dCwgZG9tLCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgY29uc3QgaXNDb21wb3NpbmcgPSBub2RlLmlzQ29tcG9zaW5nKCk7XG4gIC8vIEFsd2F5cyBhZGQgYSBzdWZmaXggaWYgd2UncmUgY29tcG9zaW5nIGEgbm9kZVxuICBjb25zdCBzdWZmaXggPSBpc0NvbXBvc2luZyA/IENPTVBPU0lUSU9OX1NVRkZJWCA6ICcnO1xuICBjb25zdCB0ZXh0ID0gbmV4dFRleHQgKyBzdWZmaXg7XG4gIGlmIChmaXJzdENoaWxkID09IG51bGwpIHtcbiAgICBkb20udGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuICAgIGlmIChub2RlVmFsdWUgIT09IHRleHQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZyB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSBkaWZmIGNvbXBvc2VkIHRleHQgZm9yIGdlbmVyYWwgdGV4dCBpbiBGRiB0byBhdm9pZFxuICAgICAgICAvLyB0aGUgc3BlbGxjaGVjayByZWQgbGluZSBmcm9tIGZsaWNrZXJpbmcuXG4gICAgICAgIGNvbnN0IFtpbmRleCwgcmVtb3ZlLCBpbnNlcnRdID0gZGlmZkNvbXBvc2VkVGV4dChub2RlVmFsdWUsIHRleHQpO1xuICAgICAgICBpZiAocmVtb3ZlICE9PSAwKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZpcnN0Q2hpbGQuZGVsZXRlRGF0YShpbmRleCwgcmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0RGF0YShpbmRleCwgaW5zZXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbm5lckRPTShpbm5lckRPTSwgbm9kZSwgaW5uZXJUYWcsIGZvcm1hdCwgdGV4dCwgY29uZmlnKSB7XG4gIHNldFRleHRDb250ZW50KHRleHQsIGlubmVyRE9NLCBub2RlKTtcbiAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gIC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG4gIGNvbnN0IHRleHRDbGFzc05hbWVzID0gdGhlbWUudGV4dDtcbiAgaWYgKHRleHRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKGlubmVyVGFnLCAwLCBmb3JtYXQsIGlubmVyRE9NLCB0ZXh0Q2xhc3NOYW1lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCB0YWcpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICByZXR1cm4gZWw7XG59XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGV4dCc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHROb2RlKG5vZGUuX190ZXh0LCBub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0ZXh0LCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190ZXh0ID0gdGV4dDtcbiAgICB0aGlzLl9fZm9ybWF0ID0gMDtcbiAgICB0aGlzLl9fc3R5bGUgPSAnJztcbiAgICB0aGlzLl9fbW9kZSA9IDA7XG4gICAgdGhpcy5fX2RldGFpbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIDMyLWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgVGV4dEZvcm1hdFR5cGVzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZVxuICAgKiBUZXh0Tm9kZS4gWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5IC0gY29uc2lkZXIgdXNpbmcgVGV4dE5vZGUuaGFzRm9ybWF0IGluc3RlYWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgZm9ybWF0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAqL1xuICBnZXRGb3JtYXQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19mb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIDMyLWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgVGV4dERldGFpbFR5cGVzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZVxuICAgKiBUZXh0Tm9kZS4gWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5IC0gY29uc2lkZXIgdXNpbmcgVGV4dE5vZGUuaXNEaXJlY3Rpb25sZXNzXG4gICAqIG9yIFRleHROb2RlLmlzVW5tZXJnZWFibGUgaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBkZXRhaWwgb2YgdGhlIHRleHQgbm9kZS5cbiAgICovXG4gIGdldERldGFpbCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2RldGFpbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtb2RlIChUZXh0TW9kZVR5cGUpIG9mIHRoZSBUZXh0Tm9kZSwgd2hpY2ggbWF5IGJlIFwibm9ybWFsXCIsIFwidG9rZW5cIiwgb3IgXCJzZWdtZW50ZWRcIlxuICAgKlxuICAgKiBAcmV0dXJucyBUZXh0TW9kZVR5cGUuXG4gICAqL1xuICBnZXRNb2RlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBURVhUX1RZUEVfVE9fTU9ERVtzZWxmLl9fbW9kZV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGVzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZSBub2RlLiBUaGlzIGlzIGFuYWxvZ291cyB0byBDU1NUZXh0IGluIHRoZSBET00uXG4gICAqXG4gICAqIEByZXR1cm5zIENTU1RleHQtbGlrZSBzdHJpbmcgb2Ygc3R5bGVzIGFwcGxpZWQgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuXG4gICAqL1xuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3N0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgaW4gXCJ0b2tlblwiIG1vZGUuIFRleHROb2RlcyBpbiB0b2tlbiBtb2RlIGNhbiBiZSBuYXZpZ2F0ZWQgdGhyb3VnaCBjaGFyYWN0ZXItYnktY2hhcmFjdGVyXG4gICAqIHdpdGggYSBSYW5nZVNlbGVjdGlvbiwgYnV0IGFyZSBkZWxldGVkIGFzIGEgc2luZ2xlIGVudGl0eSAobm90IGludmRpdmlkdWFsbHkgYnkgY2hhcmFjdGVyKS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBpbiB0b2tlbiBtb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1Rva2VuKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fbW9kZSA9PT0gSVNfVE9LRU47XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBMZXhpY2FsIGRldGVjdHMgdGhhdCBhbiBJTUUgb3Igb3RoZXIgM3JkLXBhcnR5IHNjcmlwdCBpcyBhdHRlbXB0aW5nIHRvXG4gICAqIG11dGF0ZSB0aGUgVGV4dE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQ29tcG9zaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9fa2V5ID09PSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGluIFwic2VnZW1lbnRlZFwiIG1vZGUuIFRleHROb2RlcyBpbiBzZWdlbWVudGVkIG1vZGUgY2FuIGJlIG5hdmlnYXRlZCB0aHJvdWdoIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXJcbiAgICogd2l0aCBhIFJhbmdlU2VsZWN0aW9uLCBidXQgYXJlIGRlbGV0ZWQgaW4gc3BhY2UtZGVsaW1pdGVkIFwic2VnbWVudHNcIi5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBpbiBzZWdtZW50ZWQgbW9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNTZWdtZW50ZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19tb2RlID09PSBJU19TRUdNRU5URUQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgXCJkaXJlY3Rpb25sZXNzXCIuIERpcmVjdGlvbmxlc3Mgbm9kZXMgZG9uJ3QgcmVzcGVjdCBjaGFuZ2VzIGJldHdlZW4gUlRMIGFuZCBMVFIgbW9kZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgZGlyZWN0aW9ubGVzcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNEaXJlY3Rpb25sZXNzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiAoc2VsZi5fX2RldGFpbCAmIElTX0RJUkVDVElPTkxFU1MpICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIHVubWVyZ2VhYmxlLiBJbiBzb21lIHNjZW5hcmlvcywgTGV4aWNhbCB0cmllcyB0byBtZXJnZVxuICAgKiBhZGphY2VudCBUZXh0Tm9kZXMgaW50byBhIHNpbmdsZSBUZXh0Tm9kZS4gSWYgYSBUZXh0Tm9kZSBpcyB1bm1lcmdlYWJsZSwgdGhpcyB3b24ndCBoYXBwZW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgdW5tZXJnZWFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzVW5tZXJnZWFibGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIChzZWxmLl9fZGV0YWlsICYgSVNfVU5NRVJHRUFCTEUpICE9PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaGFzIHRoZSBwcm92aWRlZCBmb3JtYXQgYXBwbGllZC4gVXNlIHRoaXMgd2l0aCB0aGUgaHVtYW4tcmVhZGFibGUgVGV4dEZvcm1hdFR5cGVcbiAgICogc3RyaW5nIHZhbHVlcyB0byBnZXQgdGhlIGZvcm1hdCBvZiBhIFRleHROb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSBUZXh0Rm9ybWF0VHlwZSB0byBjaGVjayBmb3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaGFzIHRoZSBwcm92aWRlZCBmb3JtYXQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuICh0aGlzLmdldEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBzaW1wbGUgdGV4dC4gU2ltcGxlIHRleHQgaXMgZGVmaW5lZCBhcyBhIFRleHROb2RlIHRoYXQgaGFzIHRoZSBzdHJpbmcgdHlwZSBcInRleHRcIlxuICAgKiAoaS5lLiwgbm90IGEgc3ViY2xhc3MpIGFuZCBoYXMgbm8gbW9kZSBhcHBsaWVkIHRvIGl0IChpLmUuLCBub3Qgc2VnbWVudGVkIG9yIHRva2VuKS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBzaW1wbGUgdGV4dCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNTaW1wbGVUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9fdHlwZSA9PT0gJ3RleHQnICYmIHRoaXMuX19tb2RlID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZSBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAqL1xuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3RleHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9ybWF0IGZsYWdzIGFwcGxpZWQgdG8gdGhlIG5vZGUgYXMgYSAzMi1iaXQgaW50ZWdlci5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBUZXh0Rm9ybWF0VHlwZXMgYXBwbGllZCB0byB0aGUgbm9kZS5cbiAgICovXG4gIGdldEZvcm1hdEZsYWdzKHR5cGUsIGFsaWduV2l0aEZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHNlbGYuX19mb3JtYXQ7XG4gICAgcmV0dXJuIHRvZ2dsZVRleHRGb3JtYXRUeXBlKGZvcm1hdCwgdHlwZSwgYWxpZ25XaXRoRm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0ZXh0IG5vZGUgc3VwcG9ydHMgZm9udCBzdHlsaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjYW5IYXZlRm9ybWF0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcsIGVkaXRvcikge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX19mb3JtYXQ7XG4gICAgY29uc3Qgb3V0ZXJUYWcgPSBnZXRFbGVtZW50T3V0ZXJUYWcodGhpcywgZm9ybWF0KTtcbiAgICBjb25zdCBpbm5lclRhZyA9IGdldEVsZW1lbnRJbm5lclRhZyh0aGlzLCBmb3JtYXQpO1xuICAgIGNvbnN0IHRhZyA9IG91dGVyVGFnID09PSBudWxsID8gaW5uZXJUYWcgOiBvdXRlclRhZztcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgbGV0IGlubmVyRE9NID0gZG9tO1xuICAgIGlmICh0aGlzLmhhc0Zvcm1hdCgnY29kZScpKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgfVxuICAgIGlmIChvdXRlclRhZyAhPT0gbnVsbCkge1xuICAgICAgaW5uZXJET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGlubmVyVGFnKTtcbiAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lckRPTSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjcmVhdGVUZXh0SW5uZXJET00oaW5uZXJET00sIHRoaXMsIGlubmVyVGFnLCBmb3JtYXQsIHRleHQsIGNvbmZpZyk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9fc3R5bGU7XG4gICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgbmV4dFRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjb25zdCBwcmV2Rm9ybWF0ID0gcHJldk5vZGUuX19mb3JtYXQ7XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IHRoaXMuX19mb3JtYXQ7XG4gICAgY29uc3QgcHJldk91dGVyVGFnID0gZ2V0RWxlbWVudE91dGVyVGFnKHRoaXMsIHByZXZGb3JtYXQpO1xuICAgIGNvbnN0IG5leHRPdXRlclRhZyA9IGdldEVsZW1lbnRPdXRlclRhZyh0aGlzLCBuZXh0Rm9ybWF0KTtcbiAgICBjb25zdCBwcmV2SW5uZXJUYWcgPSBnZXRFbGVtZW50SW5uZXJUYWcodGhpcywgcHJldkZvcm1hdCk7XG4gICAgY29uc3QgbmV4dElubmVyVGFnID0gZ2V0RWxlbWVudElubmVyVGFnKHRoaXMsIG5leHRGb3JtYXQpO1xuICAgIGNvbnN0IHByZXZUYWcgPSBwcmV2T3V0ZXJUYWcgPT09IG51bGwgPyBwcmV2SW5uZXJUYWcgOiBwcmV2T3V0ZXJUYWc7XG4gICAgY29uc3QgbmV4dFRhZyA9IG5leHRPdXRlclRhZyA9PT0gbnVsbCA/IG5leHRJbm5lclRhZyA6IG5leHRPdXRlclRhZztcbiAgICBpZiAocHJldlRhZyAhPT0gbmV4dFRhZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwcmV2T3V0ZXJUYWcgPT09IG5leHRPdXRlclRhZyAmJiBwcmV2SW5uZXJUYWcgIT09IG5leHRJbm5lclRhZykge1xuICAgICAgLy8gc2hvdWxkIGFsd2F5cyBiZSBhbiBlbGVtZW50XG4gICAgICBjb25zdCBwcmV2SW5uZXJET00gPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgIGlmIChwcmV2SW5uZXJET00gPT0gbnVsbCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYHVwZGF0ZURPTTogcHJldklubmVyRE9NIGlzIG51bGwgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRJbm5lckRPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dElubmVyVGFnKTtcbiAgICAgIGNyZWF0ZVRleHRJbm5lckRPTShuZXh0SW5uZXJET00sIHRoaXMsIG5leHRJbm5lclRhZywgbmV4dEZvcm1hdCwgbmV4dFRleHQsIGNvbmZpZyk7XG4gICAgICBkb20ucmVwbGFjZUNoaWxkKG5leHRJbm5lckRPTSwgcHJldklubmVyRE9NKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGlubmVyRE9NID0gZG9tO1xuICAgIGlmIChuZXh0T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmV2T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgICAgaW5uZXJET00gPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGlubmVyRE9NID09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgdXBkYXRlRE9NOiBpbm5lckRPTSBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZXRUZXh0Q29udGVudChuZXh0VGV4dCwgaW5uZXJET00sIHRoaXMpO1xuICAgIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lO1xuICAgIC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG4gICAgY29uc3QgdGV4dENsYXNzTmFtZXMgPSB0aGVtZS50ZXh0O1xuICAgIGlmICh0ZXh0Q2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkICYmIHByZXZGb3JtYXQgIT09IG5leHRGb3JtYXQpIHtcbiAgICAgIHNldFRleHRUaGVtZUNsYXNzTmFtZXMobmV4dElubmVyVGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBpbm5lckRPTSwgdGV4dENsYXNzTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2U3R5bGUgPSBwcmV2Tm9kZS5fX3N0eWxlO1xuICAgIGNvbnN0IG5leHRTdHlsZSA9IHRoaXMuX19zdHlsZTtcbiAgICBpZiAocHJldlN0eWxlICE9PSBuZXh0U3R5bGUpIHtcbiAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gbmV4dFN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJyN0ZXh0JzogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRUZXh0RE9NTm9kZSxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgYjogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEJyaW5nQXR0ZW50aW9uVG9FbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBjb2RlOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGVtOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGk6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgczogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzcGFuOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0U3BhbkVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHN0cm9uZzogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzdWI6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgc3VwOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHU6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoc2VyaWFsaXplZE5vZGUudGV4dCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpO1xuICAgIG5vZGUuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWROb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIFRoaXMgaW1wcm92ZXMgTGV4aWNhbCdzIGJhc2ljIHRleHQgb3V0cHV0IGluIGNvcHkrcGFzdGUgcGx1c1xuICAvLyBmb3IgaGVhZGxlc3MgbW9kZSB3aGVyZSBwZW9wbGUgbWlnaHQgdXNlIExleGljYWwgdG8gZ2VuZXJhdGVcbiAgLy8gSFRNTCBjb250ZW50IGFuZCBub3QgaGF2ZSB0aGUgYWJpbGl0eSB0byB1c2UgQ1NTIGNsYXNzZXMuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBsZXQge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoIShlbGVtZW50ICE9PSBudWxsICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGV4dE5vZGUgY3JlYXRlRE9NIHRvIGFsd2F5cyByZXR1cm4gYSBIVE1MRWxlbWVudGApO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHByb3Blcmx5IGFkZCBzdXBwb3J0IGZvciBtb3N0IGNsaWVudHMsXG4gICAgLy8gZXZlbiBpZiBpdCdzIHNlbWFudGljYWxseSBpbmNvcnJlY3QgdG8gaGF2ZSB0byByZXNvcnQgdG8gdXNpbmdcbiAgICAvLyA8Yj4sIDx1PiwgPHM+LCA8aT4gZWxlbWVudHMuXG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdib2xkJykpIHtcbiAgICAgIGVsZW1lbnQgPSB3cmFwRWxlbWVudFdpdGgoZWxlbWVudCwgJ2InKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdpdGFsaWMnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAnaScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAncycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3VuZGVybGluZScpKSB7XG4gICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICd1Jyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXRhaWw6IHRoaXMuZ2V0RGV0YWlsKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0KCksXG4gICAgICBtb2RlOiB0aGlzLmdldE1vZGUoKSxcbiAgICAgIHN0eWxlOiB0aGlzLmdldFN0eWxlKCksXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHRDb250ZW50KCksXG4gICAgICB0eXBlOiAndGV4dCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIC8vIE11dGF0b3JzXG4gIHNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgZm9ybWF0IHRvIHRoZSBwcm92aWRlZCBUZXh0Rm9ybWF0VHlwZSBvciAzMi1iaXQgaW50ZWdlci4gTm90ZSB0aGF0IHRoZSBUZXh0Rm9ybWF0VHlwZVxuICAgKiB2ZXJzaW9uIG9mIHRoZSBhcmd1bWVudCBjYW4gb25seSBzcGVjaWZ5IG9uZSBmb3JtYXQgYW5kIGRvaW5nIHNvIHdpbGwgcmVtb3ZlIGFsbCBvdGhlciBmb3JtYXRzIHRoYXRcbiAgICogbWF5IGJlIGFwcGxpZWQgdG8gdGhlIG5vZGUuIEZvciB0b2dnbGluZyBiZWhhdmlvciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIFRleHROb2RlLnRvZ2dsZUZvcm1hdH1cbiAgICpcbiAgICogQHBhcmFtIGZvcm1hdCAtIFRleHRGb3JtYXRUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbm9kZSBmb3JtYXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqIC8vIFRPRE8gMC4xMiBUaGlzIHNob3VsZCBqdXN0IGJlIGEgYHN0cmluZ2AuXG4gICAqL1xuICBzZXRGb3JtYXQoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZm9ybWF0ID0gdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycgPyBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF0gOiBmb3JtYXQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbm9kZSBkZXRhaWwgdG8gdGhlIHByb3ZpZGVkIFRleHREZXRhaWxUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyLiBOb3RlIHRoYXQgdGhlIFRleHREZXRhaWxUeXBlXG4gICAqIHZlcnNpb24gb2YgdGhlIGFyZ3VtZW50IGNhbiBvbmx5IHNwZWNpZnkgb25lIGRldGFpbCB2YWx1ZSBhbmQgZG9pbmcgc28gd2lsbCByZW1vdmUgYWxsIG90aGVyIGRldGFpbCB2YWx1ZXMgdGhhdFxuICAgKiBtYXkgYmUgYXBwbGllZCB0byB0aGUgbm9kZS4gRm9yIHRvZ2dsaW5nIGJlaGF2aW9yLCBjb25zaWRlciB1c2luZyB7QGxpbmsgVGV4dE5vZGUudG9nZ2xlRGlyZWN0aW9ubGVzc31cbiAgICogb3Ige0BsaW5rIFRleHROb2RlLnRvZ2dsZVVubWVyZ2VhYmxlfVxuICAgKlxuICAgKiBAcGFyYW0gZGV0YWlsIC0gVGV4dERldGFpbFR5cGUgb3IgMzItYml0IGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBub2RlIGRldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICogLy8gVE9ETyAwLjEyIFRoaXMgc2hvdWxkIGp1c3QgYmUgYSBgc3RyaW5nYC5cbiAgICovXG4gIHNldERldGFpbChkZXRhaWwpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgPSB0eXBlb2YgZGV0YWlsID09PSAnc3RyaW5nJyA/IERFVEFJTF9UWVBFX1RPX0RFVEFJTFtkZXRhaWxdIDogZGV0YWlsO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgc3R5bGUgdG8gdGhlIHByb3ZpZGVkIENTU1RleHQtbGlrZSBzdHJpbmcuIFNldCB0aGlzIHByb3BlcnR5IGFzIHlvdVxuICAgKiB3b3VsZCBhbiBIVE1MRWxlbWVudCBzdHlsZSBhdHRyaWJ1dGUgdG8gYXBwbHkgaW5saW5lIHN0eWxlcyB0byB0aGUgdW5kZXJseWluZyBET00gRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlIC0gQ1NTVGV4dCB0byBiZSBhcHBsaWVkIHRvIHRoZSB1bmRlcmx5aW5nIEhUTUxFbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19zdHlsZSA9IHN0eWxlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGZvcm1hdCB0byB0aGlzIFRleHROb2RlIGlmIGl0J3Mgbm90IHByZXNlbnQuIFJlbW92ZXMgaXQgaWYgaXQncyBwcmVzZW50LlxuICAgKiBUaGUgc3Vic2NyaXB0IGFuZCBzdXBlcnNjcmlwdCBmb3JtYXRzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAqIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCB0byB0dXJuIHNwZWNpZmljIGZvcm1hdHMgb24gYW5kIG9mZi5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBUZXh0Rm9ybWF0VHlwZSB0byB0b2dnbGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICB0b2dnbGVGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0Rm9ybWF0KCk7XG4gICAgY29uc3QgbmV3Rm9ybWF0ID0gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICByZXR1cm4gdGhpcy5zZXRGb3JtYXQobmV3Rm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBkaXJlY3Rpb25sZXNzIGRldGFpbCB2YWx1ZSBvZiB0aGUgbm9kZS4gUHJlZmVyIHVzaW5nIHRoaXMgbWV0aG9kIG92ZXIgc2V0RGV0YWlsLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgdG9nZ2xlRGlyZWN0aW9ubGVzcygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgXj0gSVNfRElSRUNUSU9OTEVTUztcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSB1bm1lcmdlYWJsZSBkZXRhaWwgdmFsdWUgb2YgdGhlIG5vZGUuIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCBvdmVyIHNldERldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHRvZ2dsZVVubWVyZ2VhYmxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2RldGFpbCBePSBJU19VTk1FUkdFQUJMRTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtb2RlIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh0eXBlKSB7XG4gICAgY29uc3QgbW9kZSA9IFRFWFRfTU9ERV9UT19UWVBFW3R5cGVdO1xuICAgIGlmICh0aGlzLl9fbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX21vZGUgPSBtb2RlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgLSB0aGUgc3RyaW5nIHRvIHNldCBhcyB0aGUgdGV4dCB2YWx1ZSBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNldFRleHRDb250ZW50KHRleHQpIHtcbiAgICBpZiAodGhpcy5fX3RleHQgPT09IHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX190ZXh0ID0gdGV4dDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IExleGljYWwgc2VsZWN0aW9uIHRvIGJlIGEgUmFuZ2VTZWxlY3Rpb24gd2l0aCBhbmNob3IgYW5kIGZvY3VzIG9uIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBfYW5jaG9yT2Zmc2V0IC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgU2VsZWN0aW9uIGFuY2hvciB3aWxsIGJlIHBsYWNlZC5cbiAgICogQHBhcmFtIF9mb2N1c09mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIFNlbGVjdGlvbiBmb2N1cyB3aWxsIGJlIHBsYWNlZC5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5ldyBSYW5nZVNlbGVjdGlvbi5cbiAgICovXG4gIHNlbGVjdChfYW5jaG9yT2Zmc2V0LCBfZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChmb2N1c09mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gbGFzdE9mZnNldDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgIGZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gJGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGtleSwgYW5jaG9yT2Zmc2V0LCBrZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcsICd0ZXh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IHNlbGVjdGlvbi5hbmNob3Iua2V5IHx8IGNvbXBvc2l0aW9uS2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgICAgfVxuICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UodGhpcywgYW5jaG9yT2Zmc2V0LCB0aGlzLCBmb2N1c09mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KDAsIDApO1xuICB9XG4gIHNlbGVjdEVuZCgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2l6ZSwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyB0aGUgcHJvdmlkZWQgdGV4dCBpbnRvIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIG9mZnNldCwgZGVsZXRpbmcgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAqIHNwZWNpZmllZC4gQ2FuIG9wdGlvbmFsbHkgY2FsY3VsYXRlIGEgbmV3IHNlbGVjdGlvbiBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgc3BsaWNlIG9wZXJhdGlvbiBzaG91bGQgYmVnaW4uXG4gICAqIEBwYXJhbSBkZWxDb3VudCAtIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBkZWxldGUsIHN0YXJ0aW5nIGZyb20gdGhlIG9mZnNldC5cbiAgICogQHBhcmFtIG5ld1RleHQgLSB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgVGV4dE5vZGUgYXQgdGhlIG9mZnNldC5cbiAgICogQHBhcmFtIG1vdmVTZWxlY3Rpb24gLSBvcHRpb25hbCwgd2hldGhlciBvciBub3QgdG8gbW92ZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgaW5zZXJ0ZWQgc3Vic3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgc3BsaWNlVGV4dChvZmZzZXQsIGRlbENvdW50LCBuZXdUZXh0LCBtb3ZlU2VsZWN0aW9uKSB7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHRleHQgPSB3cml0YWJsZVNlbGYuX190ZXh0O1xuICAgIGNvbnN0IGhhbmRsZWRUZXh0TGVuZ3RoID0gbmV3VGV4dC5sZW5ndGg7XG4gICAgbGV0IGluZGV4ID0gb2Zmc2V0O1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gaGFuZGxlZFRleHRMZW5ndGggKyBpbmRleDtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKG1vdmVTZWxlY3Rpb24gJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgaGFuZGxlZFRleHRMZW5ndGg7XG4gICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZSh3cml0YWJsZVNlbGYsIG5ld09mZnNldCwgd3JpdGFibGVTZWxmLCBuZXdPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkVGV4dCA9IHRleHQuc2xpY2UoMCwgaW5kZXgpICsgbmV3VGV4dCArIHRleHQuc2xpY2UoaW5kZXggKyBkZWxDb3VudCk7XG4gICAgd3JpdGFibGVTZWxmLl9fdGV4dCA9IHVwZGF0ZWRUZXh0O1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiBhIHVzZXIgZXZlbnQgd291bGQgY2F1c2UgdGV4dCB0byBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlbSBpbiB0aGUgZWRpdG9yLiBJZiB0cnVlLCBMZXhpY2FsIHdpbGwgYXR0ZW1wdFxuICAgKiB0byBpbnNlcnQgdGV4dCBpbnRvIHRoaXMgbm9kZS4gSWYgZmFsc2UsIGl0IHdpbGwgaW5zZXJ0IHRoZSB0ZXh0IGluIGEgbmV3IHNpYmxpbmcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0ZXh0IGNhbiBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiBhIHVzZXIgZXZlbnQgd291bGQgY2F1c2UgdGV4dCB0byBiZSBpbnNlcnRlZCBhZnRlciB0aGVtIGluIHRoZSBlZGl0b3IuIElmIHRydWUsIExleGljYWwgd2lsbCBhdHRlbXB0XG4gICAqIHRvIGluc2VydCB0ZXh0IGludG8gdGhpcyBub2RlLiBJZiBmYWxzZSwgaXQgd2lsbCBpbnNlcnQgdGhlIHRleHQgaW4gYSBuZXcgc2libGluZyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRleHQgY2FuIGJlIGluc2VydGVkIGFmdGVyIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIGNoYXJhY3RlciBvZmZzZXRzLCBmb3JtaW5nIG5ldyBUZXh0Tm9kZXMgZnJvbSB0aGUgc3Vic3RyaW5nc1xuICAgKiBmb3JtZWQgYnkgdGhlIHNwbGl0LCBhbmQgaW5zZXJ0aW5nIHRob3NlIG5ldyBUZXh0Tm9kZXMgaW50byB0aGUgZWRpdG9yLCByZXBsYWNpbmcgdGhlIG9uZSB0aGF0IHdhcyBzcGxpdC5cbiAgICpcbiAgICogQHBhcmFtIHNwbGl0T2Zmc2V0cyAtIHJlc3QgcGFyYW0gb2YgdGhlIHRleHQgY29udGVudCBjaGFyYWN0ZXIgb2Zmc2V0cyBhdCB3aGljaCB0aGlzIG5vZGUgc2hvdWxkIGJlIHNwbGl0LlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIHRoZSBuZXdseS1jcmVhdGVkIFRleHROb2Rlcy5cbiAgICovXG4gIHNwbGl0VGV4dCguLi5zcGxpdE9mZnNldHMpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IHNlbGYuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBrZXkgPSBzZWxmLl9fa2V5O1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgY29uc3Qgb2Zmc2V0c1NldCA9IG5ldyBTZXQoc3BsaXRPZmZzZXRzKTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dExlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nICE9PSAnJyAmJiBvZmZzZXRzU2V0LmhhcyhpKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHN0cmluZyk7XG4gICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc3RyaW5nICs9IHRleHRDb250ZW50W2ldO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nICE9PSAnJykge1xuICAgICAgcGFydHMucHVzaChzdHJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgICBpZiAocGFydHNMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSB0ZXh0Q29udGVudCkge1xuICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHNbMF07XG4gICAgY29uc3QgcGFyZW50ID0gc2VsZi5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IHdyaXRhYmxlTm9kZTtcbiAgICBjb25zdCBmb3JtYXQgPSBzZWxmLmdldEZvcm1hdCgpO1xuICAgIGNvbnN0IHN0eWxlID0gc2VsZi5nZXRTdHlsZSgpO1xuICAgIGNvbnN0IGRldGFpbCA9IHNlbGYuX19kZXRhaWw7XG4gICAgbGV0IGhhc1JlcGxhY2VkU2VsZiA9IGZhbHNlO1xuICAgIGlmIChzZWxmLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBUZXh0Tm9kZVxuICAgICAgd3JpdGFibGVOb2RlID0gJGNyZWF0ZVRleHROb2RlKGZpcnN0UGFydCk7XG4gICAgICB3cml0YWJsZU5vZGUuX19mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICB3cml0YWJsZU5vZGUuX19zdHlsZSA9IHN0eWxlO1xuICAgICAgd3JpdGFibGVOb2RlLl9fZGV0YWlsID0gZGV0YWlsO1xuICAgICAgaGFzUmVwbGFjZWRTZWxmID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIHRoZSBmaXJzdCBwYXJ0LCB1cGRhdGUgdGhlIGV4aXN0aW5nIG5vZGVcbiAgICAgIHdyaXRhYmxlTm9kZSA9IHNlbGYuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX3RleHQgPSBmaXJzdFBhcnQ7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHNlbGVjdGlvblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIFRoZW4gaGFuZGxlIGFsbCBvdGhlciBwYXJ0c1xuICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBbd3JpdGFibGVOb2RlXTtcbiAgICBsZXQgdGV4dFNpemUgPSBmaXJzdFBhcnQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgcGFydFNpemUgPSBwYXJ0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUocGFydCkuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHNpYmxpbmcuX19mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICBzaWJsaW5nLl9fc3R5bGUgPSBzdHlsZTtcbiAgICAgIHNpYmxpbmcuX19kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBjb25zdCBzaWJsaW5nS2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgIGNvbnN0IG5leHRUZXh0U2l6ZSA9IHRleHRTaXplICsgcGFydFNpemU7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSAmJiBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvci5vZmZzZXQgPiB0ZXh0U2l6ZSAmJiBhbmNob3Iub2Zmc2V0IDw9IG5leHRUZXh0U2l6ZSkge1xuICAgICAgICAgIGFuY2hvci5rZXkgPSBzaWJsaW5nS2V5O1xuICAgICAgICAgIGFuY2hvci5vZmZzZXQgLT0gdGV4dFNpemU7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXMua2V5ID09PSBrZXkgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnICYmIGZvY3VzLm9mZnNldCA+IHRleHRTaXplICYmIGZvY3VzLm9mZnNldCA8PSBuZXh0VGV4dFNpemUpIHtcbiAgICAgICAgICBmb2N1cy5rZXkgPSBzaWJsaW5nS2V5O1xuICAgICAgICAgIGZvY3VzLm9mZnNldCAtPSB0ZXh0U2l6ZTtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IGtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoc2libGluZ0tleSk7XG4gICAgICB9XG4gICAgICB0ZXh0U2l6ZSA9IG5leHRUZXh0U2l6ZTtcbiAgICAgIHNwbGl0Tm9kZXMucHVzaChzaWJsaW5nKTtcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGVzIGludG8gdGhlIHBhcmVudCdzIGNoaWxkcmVuXG4gICAgaW50ZXJuYWxNYXJrU2libGluZ3NBc0RpcnR5KHRoaXMpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gcGFyZW50LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgaWYgKGhhc1JlcGxhY2VkU2VsZikge1xuICAgICAgd3JpdGFibGVQYXJlbnQuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCBzcGxpdE5vZGVzKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50LnNwbGljZShpbnNlcnRpb25JbmRleCwgMSwgc3BsaXROb2Rlcyk7XG4gICAgfVxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAkdXBkYXRlRWxlbWVudFNlbGVjdGlvbk9uQ3JlYXRlRGVsZXRlTm9kZShzZWxlY3Rpb24sIHBhcmVudCwgaW5zZXJ0aW9uSW5kZXgsIHBhcnRzTGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBzcGxpdE5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgdGFyZ2V0IFRleHROb2RlIGludG8gdGhpcyBUZXh0Tm9kZSwgcmVtb3ZpbmcgdGhlIHRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gdGhlIFRleHROb2RlIHRvIG1lcmdlIGludG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICBtZXJnZVdpdGhTaWJsaW5nKHRhcmdldCkge1xuICAgIGNvbnN0IGlzQmVmb3JlID0gdGFyZ2V0ID09PSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmICghaXNCZWZvcmUgJiYgdGFyZ2V0ICE9PSB0aGlzLmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG1lcmdlV2l0aFNpYmxpbmc6IHNpYmxpbmcgbXVzdCBiZSBhIHByZXZpb3VzIG9yIG5leHQgc2libGluZ2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRhcmdldC5fX2tleTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5fX3RleHQ7XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgaWYgKGNvbXBvc2l0aW9uS2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgYW5jaG9yLmtleSA9PT0gdGFyZ2V0S2V5KSB7XG4gICAgICAgIGFkanVzdFBvaW50T2Zmc2V0Rm9yTWVyZ2VkU2libGluZyhhbmNob3IsIGlzQmVmb3JlLCBrZXksIHRhcmdldCwgdGV4dExlbmd0aCk7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZm9jdXMgIT09IG51bGwgJiYgZm9jdXMua2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICAgYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKGZvY3VzLCBpc0JlZm9yZSwga2V5LCB0YXJnZXQsIHRleHRMZW5ndGgpO1xuICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRUZXh0ID0gdGFyZ2V0Ll9fdGV4dDtcbiAgICBjb25zdCBuZXdUZXh0ID0gaXNCZWZvcmUgPyB0YXJnZXRUZXh0ICsgdGV4dCA6IHRleHQgKyB0YXJnZXRUZXh0O1xuICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV3VGV4dCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiBieSBUZXh0Tm9kZSBzdWJjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRob3NlIG5vZGVzXG4gICAqIHdoZW4gdXNlZCB3aXRoIHRoZSByZWdpc3RlckxleGljYWxUZXh0RW50aXR5IGZ1bmN0aW9uLiBJZiB5b3UncmUgdXNpbmcgcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSwgdGhlXG4gICAqIG5vZGUgY2xhc3MgdGhhdCB5b3UgY3JlYXRlIGFuZCByZXBsYWNlIG1hdGNoZWQgdGV4dCB3aXRoIHNob3VsZCByZXR1cm4gdHJ1ZSBmcm9tIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHRvIGJlIHRyZWF0ZWQgYXMgYSBcInRleHQgZW50aXR5XCIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzVGV4dEVudGl0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTcGFuRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8c3Bhbj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBzcGFuID0gZG9tTm9kZTtcbiAgY29uc3Qgc3R5bGUgPSBzcGFuLnN0eWxlO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoc3R5bGUpLFxuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCcmluZ0F0dGVudGlvblRvRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8Yj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBiID0gZG9tTm9kZTtcbiAgLy8gR29vZ2xlIERvY3Mgd3JhcHMgYWxsIGNvcGllZCBIVE1MIGluIGEgPGI+IHdpdGggZm9udC13ZWlnaHQgbm9ybWFsXG4gIGNvbnN0IGhhc05vcm1hbEZvbnRXZWlnaHQgPSBiLnN0eWxlLmZvbnRXZWlnaHQgPT09ICdub3JtYWwnO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoYi5zdHlsZSwgaGFzTm9ybWFsRm9udFdlaWdodCA/IHVuZGVmaW5lZCA6ICdib2xkJyksXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuY29uc3QgcHJlUGFyZW50Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaXNOb2RlUHJlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdQUkUnIHx8IG5vZGUubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUgJiYgbm9kZS5zdHlsZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuc3R5bGUud2hpdGVTcGFjZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuc3R5bGUud2hpdGVTcGFjZS5zdGFydHNXaXRoKCdwcmUnKTtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJlbnRQcmVET01Ob2RlKG5vZGUpIHtcbiAgbGV0IGNhY2hlZDtcbiAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgY29uc3QgdmlzaXRlZCA9IFtub2RlXTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiAoY2FjaGVkID0gcHJlUGFyZW50Q2FjaGUuZ2V0KHBhcmVudCkpID09PSB1bmRlZmluZWQgJiYgIWlzTm9kZVByZShwYXJlbnQpKSB7XG4gICAgdmlzaXRlZC5wdXNoKHBhcmVudCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgY29uc3QgcmVzdWx0Tm9kZSA9IGNhY2hlZCA9PT0gdW5kZWZpbmVkID8gcGFyZW50IDogY2FjaGVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBwcmVQYXJlbnRDYWNoZS5zZXQodmlzaXRlZFtpXSwgcmVzdWx0Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiAkY29udmVydFRleHRET01Ob2RlKGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBjb25zdCBwYXJlbnREb20gPSBkb21Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gIGlmICghKHBhcmVudERvbSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgcGFyZW50RWxlbWVudCBvZiBUZXh0IG5vdCB0byBiZSBudWxsYCk7XG4gIH1cbiAgbGV0IHRleHRDb250ZW50ID0gZG9tTm9kZV8udGV4dENvbnRlbnQgfHwgJyc7XG4gIC8vIE5vIGNvbGxhcHNlIGFuZCBwcmVzZXJ2ZSBzZWdtZW50IGJyZWFrIGZvciBwcmUsIHByZS13cmFwIGFuZCBwcmUtbGluZVxuICBpZiAoZmluZFBhcmVudFByZURPTU5vZGUoZG9tTm9kZV8pICE9PSBudWxsKSB7XG4gICAgY29uc3QgcGFydHMgPSB0ZXh0Q29udGVudC5zcGxpdCgvKFxccj9cXG58XFx0KS8pO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ICE9PSAnJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUZXh0Tm9kZShwYXJ0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2Rlc1xuICAgIH07XG4gIH1cbiAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9cXHIvZywgJycpLnJlcGxhY2UoL1sgXFx0XFxuXSsvZywgJyAnKTtcbiAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuICBpZiAodGV4dENvbnRlbnRbMF0gPT09ICcgJykge1xuICAgIC8vIFRyYXZlcnNlIGJhY2t3YXJkIHdoaWxlIGluIHRoZSBzYW1lIGxpbmUuIElmIGNvbnRlbnQgY29udGFpbnMgbmV3IGxpbmUgb3IgdGFiIC0+IHBvbnRlbnRpYWxcbiAgICAvLyBkZWxldGUsIG90aGVyIGVsZW1lbnRzIGNhbiBib3Jyb3cgZnJvbSB0aGlzIG9uZS4gRGVsZXRpb24gZGVwZW5kcyBvbiB3aGV0aGVyIGl0J3MgYWxzbyB0aGVcbiAgICAvLyBsYXN0IHNwYWNlIChzZWUgbmV4dCBjb25kaXRpb246IHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSAnICcpKVxuICAgIGxldCBwcmV2aW91c1RleHQgPSBkb21Ob2RlXztcbiAgICBsZXQgaXNTdGFydE9mTGluZSA9IHRydWU7XG4gICAgd2hpbGUgKHByZXZpb3VzVGV4dCAhPT0gbnVsbCAmJiAocHJldmlvdXNUZXh0ID0gZmluZFRleHRJbkxpbmUocHJldmlvdXNUZXh0LCBmYWxzZSkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1RleHRDb250ZW50ID0gcHJldmlvdXNUZXh0LnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgaWYgKHByZXZpb3VzVGV4dENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoL1sgXFx0XFxuXSQvLnRlc3QocHJldmlvdXNUZXh0Q29udGVudCkpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1N0YXJ0T2ZMaW5lKSB7XG4gICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuICBpZiAodGV4dENvbnRlbnRbdGV4dENvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgIC8vIFRyYXZlcnNlIGZvcndhcmQgd2hpbGUgaW4gdGhlIHNhbWUgbGluZSwgcHJlc2VydmUgaWYgbmV4dCBpbmxpbmUgd2lsbCByZXF1aXJlIGEgc3BhY2VcbiAgICBsZXQgbmV4dFRleHQgPSBkb21Ob2RlXztcbiAgICBsZXQgaXNFbmRPZkxpbmUgPSB0cnVlO1xuICAgIHdoaWxlIChuZXh0VGV4dCAhPT0gbnVsbCAmJiAobmV4dFRleHQgPSBmaW5kVGV4dEluTGluZShuZXh0VGV4dCwgdHJ1ZSkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBuZXh0VGV4dENvbnRlbnQgPSAobmV4dFRleHQudGV4dENvbnRlbnQgfHwgJycpLnJlcGxhY2UoL14oIHxcXHR8XFxyP1xcbikrLywgJycpO1xuICAgICAgaWYgKG5leHRUZXh0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzRW5kT2ZMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNFbmRPZkxpbmUpIHtcbiAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgdGV4dENvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlVGV4dE5vZGUodGV4dENvbnRlbnQpXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kVGV4dEluTGluZSh0ZXh0LCBmb3J3YXJkKSB7XG4gIGxldCBub2RlID0gdGV4dDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBzaWJsaW5nO1xuICAgIHdoaWxlICgoc2libGluZyA9IGZvcndhcmQgPyBub2RlLm5leHRTaWJsaW5nIDogbm9kZS5wcmV2aW91c1NpYmxpbmcpID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKHBhcmVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIGNvbnN0IGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAoZGlzcGxheSA9PT0gJycgJiYgIWlzSW5saW5lRG9tTm9kZShub2RlKSB8fCBkaXNwbGF5ICE9PSAnJyAmJiAhZGlzcGxheS5zdGFydHNXaXRoKCdpbmxpbmUnKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRlc2NlbmRhbnQgPSBub2RlO1xuICAgIHdoaWxlICgoZGVzY2VuZGFudCA9IGZvcndhcmQgPyBub2RlLmZpcnN0Q2hpbGQgOiBub2RlLmxhc3RDaGlsZCkgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBkZXNjZW5kYW50O1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG5vZGVOYW1lVG9UZXh0Rm9ybWF0ID0ge1xuICBjb2RlOiAnY29kZScsXG4gIGVtOiAnaXRhbGljJyxcbiAgaTogJ2l0YWxpYycsXG4gIHM6ICdzdHJpa2V0aHJvdWdoJyxcbiAgc3Ryb25nOiAnYm9sZCcsXG4gIHN1YjogJ3N1YnNjcmlwdCcsXG4gIHN1cDogJ3N1cGVyc2NyaXB0JyxcbiAgdTogJ3VuZGVybGluZSdcbn07XG5mdW5jdGlvbiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBmb3JtYXQgPSBub2RlTmFtZVRvVGV4dEZvcm1hdFtkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JDaGlsZDogYXBwbHlUZXh0Rm9ybWF0RnJvbVN0eWxlKGRvbU5vZGUuc3R5bGUsIGZvcm1hdCksXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRleHROb2RlKHRleHQgPSAnJykge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUZXh0Tm9kZSh0ZXh0KSk7XG59XG5mdW5jdGlvbiAkaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dE5vZGU7XG59XG5mdW5jdGlvbiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoc3R5bGUsIHNob3VsZEFwcGx5KSB7XG4gIGNvbnN0IGZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0O1xuICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IHN0eWxlLnRleHREZWNvcmF0aW9uLnNwbGl0KCcgJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgZm9udC13ZWlnaHQgZm9yIGJvbGQgdGV4dFxuICBjb25zdCBoYXNCb2xkRm9udFdlaWdodCA9IGZvbnRXZWlnaHQgPT09ICc3MDAnIHx8IGZvbnRXZWlnaHQgPT09ICdib2xkJztcbiAgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaCBmb3Igc3RyaWtldGhyb3VnaCB0ZXh0XG4gIGNvbnN0IGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygnbGluZS10aHJvdWdoJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgZm9udC1zdHlsZSBmb3IgaXRhbGljIHRleHRcbiAgY29uc3QgaGFzSXRhbGljRm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJztcbiAgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBmb3IgdW5kZXJsaW5lIHRleHRcbiAgY29uc3QgaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygndW5kZXJsaW5lJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgdmVydGljYWwtYWxpZ24gdG8gc3BlY2lmeSBzdWJzY3JpcHQgYW5kIHN1cGVyc2NyaXB0XG4gIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBzdHlsZS52ZXJ0aWNhbEFsaWduO1xuICByZXR1cm4gbGV4aWNhbE5vZGUgPT4ge1xuICAgIGlmICghJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgfVxuICAgIGlmIChoYXNCb2xkRm9udFdlaWdodCAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdib2xkJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnYm9sZCcpO1xuICAgIH1cbiAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbiAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdzdHJpa2V0aHJvdWdoJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3RyaWtldGhyb3VnaCcpO1xuICAgIH1cbiAgICBpZiAoaGFzSXRhbGljRm9udFN0eWxlICYmICFsZXhpY2FsTm9kZS5oYXNGb3JtYXQoJ2l0YWxpYycpKSB7XG4gICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2l0YWxpYycpO1xuICAgIH1cbiAgICBpZiAoaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgndW5kZXJsaW5lJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgndW5kZXJsaW5lJyk7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnc3ViJyAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdzdWJzY3JpcHQnKSkge1xuICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdWJzY3JpcHQnKTtcbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICdzdXBlcicgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgnc3VwZXJzY3JpcHQnKSkge1xuICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdXBlcnNjcmlwdCcpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQXBwbHkgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdChzaG91bGRBcHBseSkpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdChzaG91bGRBcHBseSk7XG4gICAgfVxuICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFiTm9kZSBleHRlbmRzIFRleHROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWInO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBUYWJOb2RlKG5vZGUuX19rZXkpO1xuICAgIC8vIFRhYk5vZGUgX190ZXh0IGNhbiBiZSBlaXRoZXIgJ1xcdCcgb3IgJycuIGluc2VydFRleHQgd2lsbCByZW1vdmUgdGhlIGVtcHR5IE5vZGVcbiAgICBuZXdOb2RlLl9fdGV4dCA9IG5vZGUuX190ZXh0O1xuICAgIG5ld05vZGUuX19mb3JtYXQgPSBub2RlLl9fZm9ybWF0O1xuICAgIG5ld05vZGUuX19zdHlsZSA9IG5vZGUuX19zdHlsZTtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcignXFx0Jywga2V5KTtcbiAgICB0aGlzLl9fZGV0YWlsID0gSVNfVU5NRVJHRUFCTEU7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkVGFiTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlVGFiTm9kZSgpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWRUYWJOb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRTdHlsZShzZXJpYWxpemVkVGFiTm9kZS5zdHlsZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3RhYicsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuICBzZXRUZXh0Q29udGVudChfdGV4dCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBUYWJOb2RlIGRvZXMgbm90IHN1cHBvcnQgc2V0VGV4dENvbnRlbnRgKTtcbiAgICB9XG4gIH1cbiAgc2V0RGV0YWlsKF9kZXRhaWwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVGFiTm9kZSBkb2VzIG5vdCBzdXBwb3J0IHNldERldGFpbGApO1xuICAgIH1cbiAgfVxuICBzZXRNb2RlKF90eXBlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFRhYk5vZGUgZG9lcyBub3Qgc3VwcG9ydCBzZXRNb2RlYCk7XG4gICAgfVxuICB9XG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzVGFiTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFiTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jbGFzcyBQb2ludCB7XG4gIGNvbnN0cnVjdG9yKGtleSwgb2Zmc2V0LCB0eXBlKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ID09PSBwb2ludC5rZXkgJiYgdGhpcy5vZmZzZXQgPT09IHBvaW50Lm9mZnNldCAmJiB0aGlzLnR5cGUgPT09IHBvaW50LnR5cGU7XG4gIH1cbiAgaXNCZWZvcmUoYikge1xuICAgIGxldCBhTm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIGxldCBiTm9kZSA9IGIuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGFPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICBjb25zdCBiT2Zmc2V0ID0gYi5vZmZzZXQ7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGFOb2RlKSkge1xuICAgICAgY29uc3QgYU5vZGVEZXNjZW5kYW50ID0gYU5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYU9mZnNldCk7XG4gICAgICBhTm9kZSA9IGFOb2RlRGVzY2VuZGFudCAhPSBudWxsID8gYU5vZGVEZXNjZW5kYW50IDogYU5vZGU7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShiTm9kZSkpIHtcbiAgICAgIGNvbnN0IGJOb2RlRGVzY2VuZGFudCA9IGJOb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGJPZmZzZXQpO1xuICAgICAgYk5vZGUgPSBiTm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGJOb2RlRGVzY2VuZGFudCA6IGJOb2RlO1xuICAgIH1cbiAgICBpZiAoYU5vZGUgPT09IGJOb2RlKSB7XG4gICAgICByZXR1cm4gYU9mZnNldCA8IGJPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBhTm9kZS5pc0JlZm9yZShiTm9kZSk7XG4gIH1cbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleTtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBQb2ludC5nZXROb2RlOiBub2RlIG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBzZXQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG4gICAgY29uc3Qgb2xkS2V5ID0gdGhpcy5rZXk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIGlmICgkZ2V0Q29tcG9zaXRpb25LZXkoKSA9PT0gb2xkS2V5KSB7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Q2FjaGVkTm9kZXMobnVsbCk7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlUG9pbnQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxseSBjYXN0IGFzIHdlIHVzZSBhIGNsYXNzIGZvciBwZXJmIHJlYXNvbnNcbiAgcmV0dXJuIG5ldyBQb2ludChrZXksIG9mZnNldCwgdHlwZSk7XG59XG5mdW5jdGlvbiBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSkge1xuICBsZXQga2V5ID0gbm9kZS5fX2tleTtcbiAgbGV0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgbGV0IHR5cGUgPSAnZWxlbWVudCc7XG4gIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIHR5cGUgPSAndGV4dCc7XG4gICAgY29uc3QgdGV4dENvbnRlbnRMZW5ndGggPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgIGlmIChvZmZzZXQgPiB0ZXh0Q29udGVudExlbmd0aCkge1xuICAgICAgb2Zmc2V0ID0gdGV4dENvbnRlbnRMZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGtleSA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAga2V5ID0gcGFyZW50Tm9kZS5fX2tleTtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnQuc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbn1cbmZ1bmN0aW9uICRtb3ZlU2VsZWN0aW9uUG9pbnRUb0VuZChwb2ludCwgbm9kZSkge1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpIHx8ICRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgc2VsZWN0UG9pbnRPbk5vZGUocG9pbnQsIGxhc3ROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0UG9pbnRPbk5vZGUocG9pbnQsIG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICR0cmFuc2ZlclN0YXJ0aW5nRWxlbWVudFBvaW50VG9UZXh0UG9pbnQoc3RhcnQsIGVuZCwgZm9ybWF0LCBzdHlsZSkge1xuICBjb25zdCBlbGVtZW50ID0gc3RhcnQuZ2V0Tm9kZSgpO1xuICBjb25zdCBwbGFjZW1lbnROb2RlID0gZWxlbWVudC5nZXRDaGlsZEF0SW5kZXgoc3RhcnQub2Zmc2V0KTtcbiAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgY29uc3QgdGFyZ2V0ID0gJGlzUm9vdE5vZGUoZWxlbWVudCkgPyAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLmFwcGVuZCh0ZXh0Tm9kZSkgOiB0ZXh0Tm9kZTtcbiAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgaWYgKHBsYWNlbWVudE5vZGUgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LmFwcGVuZCh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHBsYWNlbWVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhcmdldCk7XG4gIH1cbiAgLy8gVHJhbnNmZXIgdGhlIGVsZW1lbnQgcG9pbnQgdG8gYSB0ZXh0IHBvaW50LlxuICBpZiAoc3RhcnQuaXMoZW5kKSkge1xuICAgIGVuZC5zZXQodGV4dE5vZGUuX19rZXksIDAsICd0ZXh0Jyk7XG4gIH1cbiAgc3RhcnQuc2V0KHRleHROb2RlLl9fa2V5LCAwLCAndGV4dCcpO1xufVxuZnVuY3Rpb24gJHNldFBvaW50VmFsdWVzKHBvaW50LCBrZXksIG9mZnNldCwgdHlwZSkge1xuICBwb2ludC5rZXkgPSBrZXk7XG4gIHBvaW50Lm9mZnNldCA9IG9mZnNldDtcbiAgcG9pbnQudHlwZSA9IHR5cGU7XG59XG5jbGFzcyBOb2RlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0cykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLl9ub2RlcyA9IG9iamVjdHM7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG4gIGdldENhY2hlZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWROb2RlcztcbiAgfVxuICBzZXRDYWNoZWROb2Rlcyhub2Rlcykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gIH1cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHRoaXMuX25vZGVzO1xuICAgIGNvbnN0IGIgPSBzZWxlY3Rpb24uX25vZGVzO1xuICAgIHJldHVybiBhLnNpemUgPT09IGIuc2l6ZSAmJiBBcnJheS5mcm9tKGEpLmV2ZXJ5KGtleSA9PiBiLmhhcyhrZXkpKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0U3RhcnRFbmRQb2ludHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYWRkKGtleSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmFkZChrZXkpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fbm9kZXMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuaGFzKGtleSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQodGhpcy5fbm9kZXMpKTtcbiAgfVxuICBleHRyYWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gIH1cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuICBpbnNlcnRUZXh0KCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0U2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMV07XG4gICAgbGV0IHNlbGVjdGlvbkF0RW5kO1xuICAgIC8vIEluc2VydCBub2Rlc1xuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0U2VsZWN0ZWROb2RlKSkge1xuICAgICAgc2VsZWN0aW9uQXRFbmQgPSBsYXN0U2VsZWN0ZWROb2RlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBzZWxlY3Rpb25BdEVuZCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25BdEVuZC5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkTm9kZXNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLl9ub2RlcztcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG9iamVjdCk7XG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0Q29udGVudCArPSBub2Rlc1tpXS5nZXRUZXh0Q29udGVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc1JhbmdlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSYW5nZVNlbGVjdGlvbjtcbn1cbmNsYXNzIFJhbmdlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoYW5jaG9yLCBmb2N1cywgZm9ybWF0LCBzdHlsZSkge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZm9jdXMgPSBmb2N1cztcbiAgICBhbmNob3IuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgZm9jdXMuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbiAgZ2V0Q2FjaGVkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE5vZGVzO1xuICB9XG4gIHNldENhY2hlZE5vZGVzKG5vZGVzKSB7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIHRoZSBwcm92aWRlZCBzZWxlY3Rpb25zIGlzIGVxdWFsIHRvIHRoaXMgb25lIGJ5IHZhbHVlLFxuICAgKiBpbmx1ZGluZyBhbmNob3IsIGZvY3VzLCBmb3JtYXQsIGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gdGhlIFNlbGVjdGlvbiB0byBjb21wYXJlIHRoaXMgb25lIHRvLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb25zIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cykgJiYgdGhpcy5mb3JtYXQgPT09IHNlbGVjdGlvbi5mb3JtYXQgJiYgdGhpcy5zdHlsZSA9PT0gc2VsZWN0aW9uLnN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgU2VsZWN0aW9uIGlzIFwiY29sbGFwc2VkXCIsIG1lYW5pbmcgdGhlIGFuY2hvciBhbmQgZm9jdXMgYXJlXG4gICAqIHRoZSBzYW1lIG5vZGUgYW5kIGhhdmUgdGhlIHNhbWUgb2Zmc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgY29sbGFwc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmNob3IuaXModGhpcy5mb2N1cyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uIFVzZXMgY2FjaGluZyB0byBtYWtlIGl0IGdlbmVyYWxseSBzdWl0YWJsZVxuICAgKiBmb3IgdXNlIGluIGhvdCBwYXRocy5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGlzQmVmb3JlID8gYW5jaG9yIDogZm9jdXM7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gaXNCZWZvcmUgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBsZXQgZmlyc3ROb2RlID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG4gICAgbGV0IGxhc3ROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IGZpcnN0UG9pbnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGxhc3RQb2ludC5vZmZzZXQ7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Tm9kZURlc2NlbmRhbnQgPSBmaXJzdE5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoc3RhcnRPZmZzZXQpO1xuICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlRGVzY2VuZGFudCAhPSBudWxsID8gZmlyc3ROb2RlRGVzY2VuZGFudCA6IGZpcnN0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgbGV0IGxhc3ROb2RlRGVzY2VuZGFudCA9IGxhc3ROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGVuZE9mZnNldCk7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG92ZXItc2VsZWN0LCBhcyBub2RlIHNlbGVjdGlvbiBpbmZlcnMgdGhlIGNoaWxkIGJlZm9yZVxuICAgICAgLy8gdGhlIGxhc3QgZGVzY2VuZGFudCwgbm90IGluY2x1ZGluZyB0aGF0IGRlc2NlbmRhbnQuXG4gICAgICBpZiAobGFzdE5vZGVEZXNjZW5kYW50ICE9PSBudWxsICYmIGxhc3ROb2RlRGVzY2VuZGFudCAhPT0gZmlyc3ROb2RlICYmIGxhc3ROb2RlLmdldENoaWxkQXRJbmRleChlbmRPZmZzZXQpID09PSBsYXN0Tm9kZURlc2NlbmRhbnQpIHtcbiAgICAgICAgbGFzdE5vZGVEZXNjZW5kYW50ID0gbGFzdE5vZGVEZXNjZW5kYW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGxhc3ROb2RlRGVzY2VuZGFudCA6IGxhc3ROb2RlO1xuICAgIH1cbiAgICBsZXQgbm9kZXM7XG4gICAgaWYgKGZpcnN0Tm9kZS5pcyhsYXN0Tm9kZSkpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzID0gW2ZpcnN0Tm9kZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gZmlyc3ROb2RlLmdldE5vZGVzQmV0d2VlbihsYXN0Tm9kZSk7XG4gICAgfVxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBTZWxlY3Rpb24gdG8gYmUgb2YgdHlwZSBcInRleHRcIiBhdCB0aGUgcHJvdmlkZWQgYW5jaG9yIGFuZCBmb2N1cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JOb2RlIC0gdGhlIGFuY2hvciBub2RlIHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSB0aGUgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBmb2N1c05vZGUgLSB0aGUgZm9jdXMgbm9kZSB0byBzZXQgb24gdGhlIFNlbGVjdGlvblxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSB0aGUgZm9jdXMgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqL1xuICBzZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yTm9kZS5fX2tleSwgYW5jaG9yT2Zmc2V0LCAndGV4dCcpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c05vZGUuX19rZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSAocGxhaW4pIHRleHQgY29udGVudCBvZiBhbGwgdGhlIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdGV4dCBjb250ZW50IG9mIGFsbCB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHModGhpcyk7XG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XG4gICAgbGV0IHByZXZXYXNFbGVtZW50ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICBpZiAoIXByZXZXYXNFbGVtZW50KSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcHJldldhc0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2V2FzRWxlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZXYXNFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGlmIChub2RlID09PSBmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoYW5jaG9yLnR5cGUgIT09ICdlbGVtZW50JyB8fCBmb2N1cy50eXBlICE9PSAnZWxlbWVudCcgfHwgZm9jdXMub2Zmc2V0ID09PSBhbmNob3Iub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGFuY2hvck9mZnNldCA8IGZvY3VzT2Zmc2V0ID8gdGV4dC5zbGljZShhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoYW5jaG9yT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoMCwgZm9jdXNPZmZzZXQpIDogdGV4dC5zbGljZSgwLCBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUobm9kZSkpICYmIChub2RlICE9PSBsYXN0Tm9kZSB8fCAhdGhpcy5pc0NvbGxhcHNlZCgpKSkge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gbWFwIGEgRE9NIHNlbGVjdGlvbiByYW5nZSBvbnRvIHRoaXMgTGV4aWNhbCBTZWxlY3Rpb24sXG4gICAqIHNldHRpbmcgdGhlIGFuY2hvciwgZm9jdXMsIGFuZCB0eXBlIGFjY29yZGluZ2x5XG4gICAqXG4gICAqIEBwYXJhbSByYW5nZSBhIERPTSBTZWxlY3Rpb24gcmFuZ2UgY29uZm9ybWluZyB0byB0aGUgU3RhdGljUmFuZ2UgaW50ZXJmYWNlLlxuICAgKi9cbiAgYXBwbHlET01SYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICBjb25zdCByZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKTtcbiAgICBpZiAocmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2FuY2hvclBvaW50LCBmb2N1c1BvaW50XSA9IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yUG9pbnQua2V5LCBhbmNob3JQb2ludC5vZmZzZXQsIGFuY2hvclBvaW50LnR5cGUpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c1BvaW50LmtleSwgZm9jdXNQb2ludC5vZmZzZXQsIGZvY3VzUG9pbnQudHlwZSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb24sIGNvcHlpbmcgb3ZlciBhbGwgdGhlIHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG5ldyBSYW5nZVNlbGVjdGlvbiB3aXRoIHRoZSBzYW1lIHByb3BlcnR5IHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgUmFuZ2VTZWxlY3Rpb24oJGNyZWF0ZVBvaW50KGFuY2hvci5rZXksIGFuY2hvci5vZmZzZXQsIGFuY2hvci50eXBlKSwgJGNyZWF0ZVBvaW50KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKSwgdGhpcy5mb3JtYXQsIHRoaXMuc3R5bGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgcHJvdmlkZWQgZm9ybWF0IG9uIGFsbCB0aGUgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXQgYSBzdHJpbmcgVGV4dEZvcm1hdFR5cGUgdG8gdG9nZ2xlIG9uIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHNlbGVjdGlvblxuICAgKi9cbiAgdG9nZ2xlRm9ybWF0KGZvcm1hdCkge1xuICAgIHRoaXMuZm9ybWF0ID0gdG9nZ2xlVGV4dEZvcm1hdFR5cGUodGhpcy5mb3JtYXQsIGZvcm1hdCwgbnVsbCk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5IG9uIHRoZSBTZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlIC0gdGhlIHN0eWxlIHRvIHNldCBhdCB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBUZXh0Rm9ybWF0VHlwZSBpcyBwcmVzZW50IG9uIHRoZSBTZWxlY3Rpb24uIFRoaXMgd2lsbCBiZSB0cnVlIGlmIGFueSBub2RlIGluIHRoZSBTZWxlY3Rpb25cbiAgICogaGFzIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgVGV4dEZvcm1hdFR5cGUgdG8gY2hlY2sgZm9yLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBmb3JtYXQgaXMgY3VycmVudGx5IHRvZ2dsZWQgb24gb24gdGhlIFNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKHRoaXMuZm9ybWF0ICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gaW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogY29udmVydHMgdGFicywgbmV3bGluZXMsIGFuZCBjYXJyaWFnZSByZXR1cm5zIGludG8gTGV4aWNhbE5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgU2VsZWN0aW9uXG4gICAqL1xuICBpbnNlcnRSYXdUZXh0KHRleHQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRleHROb2RlKHBhcnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gaW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbiBhcyBhIG5ld1xuICAgKiBMZXhpY2FsIFRleHROb2RlLCBhY2NvcmRpbmcgdG8gYSBzZXJpZXMgb2YgaW5zZXJ0aW9uIGhldXJpc3RpY3MgYmFzZWQgb24gdGhlIHNlbGVjdGlvbiB0eXBlIGFuZCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgaW5zZXJ0VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICBsZXQgZmlyc3RQb2ludCA9IGFuY2hvcjtcbiAgICBsZXQgZW5kUG9pbnQgPSBmb2N1cztcbiAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQoKSAmJiBmb2N1cy5pc0JlZm9yZShhbmNob3IpKSB7XG4gICAgICBmaXJzdFBvaW50ID0gZm9jdXM7XG4gICAgICBlbmRQb2ludCA9IGFuY2hvcjtcbiAgICB9XG4gICAgaWYgKGZpcnN0UG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAkdHJhbnNmZXJTdGFydGluZ0VsZW1lbnRQb2ludFRvVGV4dFBvaW50KGZpcnN0UG9pbnQsIGVuZFBvaW50LCBmb3JtYXQsIHN0eWxlKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICBsZXQgZW5kT2Zmc2V0ID0gZW5kUG9pbnQub2Zmc2V0O1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICAgIGlmICghJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0VGV4dDogZmlyc3Qgbm9kZSBpcyBub3QgYSB0ZXh0IG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICBjb25zdCBmaXJzdE5vZGVQYXJlbnQgPSBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSAmJiBlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGVuZE9mZnNldCA9IGZpcnN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICBlbmRQb2ludC5zZXQoZmlyc3RQb2ludC5rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCAmJiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgfHwgZmlyc3ROb2RlLmlzVG9rZW4oKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRBZnRlcigpIHx8ICFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgJiYgZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpIHx8ICFuZXh0U2libGluZy5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgJGlzVG9rZW5PclNlZ21lbnRlZChuZXh0U2libGluZykpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgbmV4dFNpYmxpbmcuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIGlmICghZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpKSB7XG4gICAgICAgICAgZmlyc3ROb2RlUGFyZW50Lmluc2VydEFmdGVyKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdE5vZGUuaW5zZXJ0QWZ0ZXIobmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0U2libGluZy5zZWxlY3QoMCwgMCk7XG4gICAgICBmaXJzdE5vZGUgPSBuZXh0U2libGluZztcbiAgICAgIGlmICh0ZXh0ICE9PSAnJykge1xuICAgICAgICB0aGlzLmluc2VydFRleHQodGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gMCAmJiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgfHwgZmlyc3ROb2RlLmlzVG9rZW4oKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSAmJiBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgcHJldlNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RleHROb2RlKHByZXZTaWJsaW5nKSB8fCAkaXNUb2tlbk9yU2VnbWVudGVkKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBwcmV2U2libGluZyA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBwcmV2U2libGluZy5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgaWYgKCFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpKSB7XG4gICAgICAgICAgZmlyc3ROb2RlUGFyZW50Lmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3ROb2RlLmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgZmlyc3ROb2RlID0gcHJldlNpYmxpbmc7XG4gICAgICBpZiAodGV4dCAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaXJzdE5vZGUuaXNTZWdtZW50ZWQoKSAmJiBzdGFydE9mZnNldCAhPT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgICAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICBmaXJzdE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQ29sbGFwc2VkKCkgJiYgdGV4dCAhPT0gJycpIHtcbiAgICAgIC8vIFdoZW4gdGhlIGZpcnN0Tm9kZSBvciBsYXN0Tm9kZSBwYXJlbnRzIGFyZSBlbGVtZW50cyB0aGF0XG4gICAgICAvLyBkbyBub3QgYWxsb3cgdGV4dCB0byBiZSBpbnNlcnRlZCBiZWZvcmUgb3IgYWZ0ZXIsIHdlIGZpcnN0XG4gICAgICAvLyBjbGVhciB0aGUgY29udGVudC4gVGhlbiB3ZSBub3JtYWxpemUgc2VsZWN0aW9uLCB0aGVuIGluc2VydFxuICAgICAgLy8gdGhlIG5ldyBjb250ZW50LlxuICAgICAgY29uc3QgbGFzdE5vZGVQYXJlbnQgPSBsYXN0Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICghZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlUGFyZW50KSAmJiAoIWxhc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhbGFzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCgnJyk7XG4gICAgICAgICRub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKHRoaXMuYW5jaG9yLCB0aGlzLmZvY3VzLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3RlZE5vZGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoZmlyc3ROb2RlLmlzVG9rZW4oKSkge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlyc3ROb2RlRm9ybWF0ID0gZmlyc3ROb2RlLmdldEZvcm1hdCgpO1xuICAgICAgY29uc3QgZmlyc3ROb2RlU3R5bGUgPSBmaXJzdE5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0ICYmIChmaXJzdE5vZGVGb3JtYXQgIT09IGZvcm1hdCB8fCBmaXJzdE5vZGVTdHlsZSAhPT0gc3R5bGUpKSB7XG4gICAgICAgIGlmIChmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHtcbiAgICAgICAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgZmlyc3ROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBmaXJzdE5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFt0YXJnZXROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5pbnNlcnRBZnRlcih0ZXh0Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXaGVuIGNvbXBvc2luZywgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGFuY2hvciBvZmZzZXQgc28gdGhhdFxuICAgICAgICAgIC8vIHdlIGNvcnJlY3RseSByZXBsYWNlIHRoYXQgcmlnaHQgcmFuZ2UuXG4gICAgICAgICAgaWYgKHRleHROb2RlLmlzQ29tcG9zaW5nKCkgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkaXNUYWJOb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgZGVsQ291bnQgYmVjYXVzZSB0aGVyZSBpcyBvbmx5IHRoZSBlbnRpcmUgc2VsZWN0ZWQgbm9kZSBjYXNlXG4gICAgICAgIC8vIHRoYXQgY2FuIGhpdCBoZXJlIGZvciBjb250ZW50IHNpemUgMSBhbmQgd2l0aCBjYW5JbnNlcnRUZXh0QmVmb3JlQWZ0ZXIgZmFsc2VcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRleHROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgICB0ZXh0Tm9kZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgICAgIHRleHROb2RlLnNlbGVjdCgpO1xuICAgICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbENvdW50ID0gZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XG4gICAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuc3BsaWNlVGV4dChzdGFydE9mZnNldCwgZGVsQ291bnQsIHRleHQsIHRydWUpO1xuICAgICAgaWYgKGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykge1xuICAgICAgICBmaXJzdE5vZGUucmVtb3ZlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBpZiAoZmlyc3ROb2RlLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgICAgICAvLyBXaGVuIGNvbXBvc2luZywgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGFuY2hvciBvZmZzZXQgc28gdGhhdFxuICAgICAgICAgIC8vIHdlIGNvcnJlY3RseSByZXBsYWNlIHRoYXQgcmlnaHQgcmFuZ2UuXG4gICAgICAgICAgdGhpcy5hbmNob3Iub2Zmc2V0IC09IHRleHQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROb2RlRm9ybWF0O1xuICAgICAgICAgIHRoaXMuc3R5bGUgPSBmaXJzdE5vZGVTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXJrZWROb2RlS2V5c0ZvcktlZXAgPSBuZXcgU2V0KFsuLi5maXJzdE5vZGUuZ2V0UGFyZW50S2V5cygpLCAuLi5sYXN0Tm9kZS5nZXRQYXJlbnRLZXlzKCldKTtcblxuICAgICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHBhcmVudCBlbGVtZW50cyBiZWZvcmUgdGhlIG5leHQgc2VjdGlvbixcbiAgICAgIC8vIGFzIGluIHRoYXQgc2VjdGlvbiB3ZSBtaWdodCBtdXRhdGUgdGhlIGxhc3ROb2RlLlxuICAgICAgY29uc3QgZmlyc3RFbGVtZW50ID0gJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSA/IGZpcnN0Tm9kZSA6IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBsZXQgbGFzdEVsZW1lbnQgPSAkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgPyBsYXN0Tm9kZSA6IGxhc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBsYXN0RWxlbWVudENoaWxkID0gbGFzdE5vZGU7XG5cbiAgICAgIC8vIElmIHRoZSBsYXN0IGVsZW1lbnQgaXMgaW5saW5lLCB3ZSBzaG91bGQgaW5zdGVhZCBsb29rIGF0IGdldHRpbmdcbiAgICAgIC8vIHRoZSBub2RlcyBvZiBpdHMgcGFyZW50LCByYXRoZXIgdGhhbiBpdHNlbGYuIFRoaXMgYmVoYXZpb3Igd2lsbFxuICAgICAgLy8gdGhlbiBiZXR0ZXIgbWF0Y2ggaG93IHRleHQgbm9kZSBpbnNlcnRpb25zIHdvcmsuIFdlIHdpbGwgbmVlZCB0b1xuICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIGxhc3QgZWxlbWVudCdzIGNoaWxkIGFjY29yZGluZ2x5IGFzIHdlIGRvIHRoaXMuXG4gICAgICBpZiAoIWZpcnN0RWxlbWVudC5pcyhsYXN0RWxlbWVudCkgJiYgbGFzdEVsZW1lbnQuaXNJbmxpbmUoKSkge1xuICAgICAgICAvLyBLZWVwIHRyYXZlcnNpbmcgdGlsbCB3ZSBoYXZlIGEgbm9uLWlubGluZSBlbGVtZW50IHBhcmVudC5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxhc3RFbGVtZW50Q2hpbGQgPSBsYXN0RWxlbWVudDtcbiAgICAgICAgICBsYXN0RWxlbWVudCA9IGxhc3RFbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgfSB3aGlsZSAobGFzdEVsZW1lbnQuaXNJbmxpbmUoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBtdXRhdGlvbnMgdG8gdGhlIGxhc3Qgbm9kZS5cbiAgICAgIGlmIChlbmRQb2ludC50eXBlID09PSAndGV4dCcgJiYgKGVuZE9mZnNldCAhPT0gMCB8fCBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykgfHwgZW5kUG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGxhc3ROb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgPCBlbmRPZmZzZXQpIHtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSAmJiAhbGFzdE5vZGUuaXNUb2tlbigpICYmIGVuZE9mZnNldCAhPT0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgICAgICBpZiAobGFzdE5vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUobGFzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgICAgICAgICBsYXN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gdGV4dE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJvb3Qgbm9kZSBzZWxlY3Rpb25zIG9ubHkgc2VsZWN0IHdob2xlIG5vZGVzLCBzbyBubyB0ZXh0IHNwbGljZSBpcyBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAoISRpc1Jvb3ROb2RlKGVuZFBvaW50LmdldE5vZGUoKSkgJiYgZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLnNwbGljZVRleHQoMCwgZW5kT2Zmc2V0LCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtlZE5vZGVLZXlzRm9yS2VlcC5hZGQobGFzdE5vZGUuX19rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxhc3ROb2RlUGFyZW50ID0gbGFzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgIGlmICghbGFzdE5vZGVQYXJlbnQuY2FuQmVFbXB0eSgpICYmIGxhc3ROb2RlUGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICAgICAgICBsYXN0Tm9kZVBhcmVudC5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrZWROb2RlS2V5c0ZvcktlZXAuYWRkKGxhc3ROb2RlLl9fa2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gRWl0aGVyIG1vdmUgdGhlIHJlbWFpbmluZyBub2RlcyBvZiB0aGUgbGFzdCBwYXJlbnQgdG8gYWZ0ZXJcbiAgICAgIC8vIHRoZSBmaXJzdCBjaGlsZCwgb3IgcmVtb3ZlIHRoZW0gZW50aXJlbHkuIElmIHRoZSBsYXN0IHBhcmVudFxuICAgICAgLy8gaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IHBhcmVudCwgdGhpcyBsb2dpYyBhbHNvIHdvcmtzLlxuICAgICAgY29uc3QgbGFzdE5vZGVDaGlsZHJlbiA9IGxhc3RFbGVtZW50LmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVzU2V0ID0gbmV3IFNldChzZWxlY3RlZE5vZGVzKTtcbiAgICAgIGNvbnN0IGZpcnN0QW5kTGFzdEVsZW1lbnRzQXJlRXF1YWwgPSBmaXJzdEVsZW1lbnQuaXMobGFzdEVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSBjaG9vc2UgYSB0YXJnZXQgdG8gaW5zZXJ0IGFsbCBub2RlcyBhZnRlci4gSW4gdGhlIGNhc2Ugb2YgaGF2aW5nXG4gICAgICAvLyBhbmQgaW5saW5lIHN0YXJ0aW5nIHBhcmVudCBlbGVtZW50IHdpdGggYSBzdGFydGluZyBub2RlIHRoYXQgaGFzIG5vXG4gICAgICAvLyBzaWJsaW5ncywgd2Ugc2hvdWxkIGluc2VydCBhZnRlciB0aGUgc3RhcnRpbmcgcGFyZW50IGVsZW1lbnQsIG90aGVyd2lzZVxuICAgICAgLy8gd2Ugd2lsbCBpbmNvcnJlY3RseSBtZXJnZSBpbnRvIHRoZSBzdGFydGluZyBwYXJlbnQgZWxlbWVudC5cbiAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBrZWVwIG9uIHRyYXZlcnNpbmcgcGFyZW50cyBpZiB3ZSdyZSBpbnNpZGUgYW5vdGhlclxuICAgICAgLy8gbmVzdGVkIGlubGluZSBlbGVtZW50P1xuICAgICAgY29uc3QgaW5zZXJ0aW9uVGFyZ2V0ID0gZmlyc3RFbGVtZW50LmlzSW5saW5lKCkgJiYgZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwgPyBmaXJzdEVsZW1lbnQgOiBmaXJzdE5vZGU7XG4gICAgICBmb3IgKGxldCBpID0gbGFzdE5vZGVDaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBsYXN0Tm9kZUNoaWxkID0gbGFzdE5vZGVDaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGxhc3ROb2RlQ2hpbGQuaXMoZmlyc3ROb2RlKSB8fCAkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZUNoaWxkKSAmJiBsYXN0Tm9kZUNoaWxkLmlzUGFyZW50T2YoZmlyc3ROb2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZUNoaWxkLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgIGlmICghc2VsZWN0ZWROb2Rlc1NldC5oYXMobGFzdE5vZGVDaGlsZCkgfHwgbGFzdE5vZGVDaGlsZC5pcyhsYXN0RWxlbWVudENoaWxkKSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdEFuZExhc3RFbGVtZW50c0FyZUVxdWFsKSB7XG4gICAgICAgICAgICAgIGluc2VydGlvblRhcmdldC5pbnNlcnRBZnRlcihsYXN0Tm9kZUNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3ROb2RlQ2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZpcnN0QW5kTGFzdEVsZW1lbnRzQXJlRXF1YWwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbHJlYWR5IG1vdmVkIG91dCBhbGwgdGhlIG5vZGVzIG9mIHRoZVxuICAgICAgICAvLyBsYXN0IHBhcmVudCwgYW5kIGlmIHNvLCB0cmF2ZXJzZSB0aGUgcGFyZW50IHRyZWUgYW5kIG1hcmtcbiAgICAgICAgLy8gdGhlbSBhbGwgYXMgYmVpbmcgYWJsZSB0byBkZWxldGVkIHRvby5cbiAgICAgICAgbGV0IHBhcmVudCA9IGxhc3RFbGVtZW50O1xuICAgICAgICBsZXQgbGFzdFJlbW92ZWRQYXJlbnQgPSBudWxsO1xuICAgICAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDAgfHwgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5pcyhsYXN0UmVtb3ZlZFBhcmVudCkpIHtcbiAgICAgICAgICAgIG1hcmtlZE5vZGVLZXlzRm9yS2VlcC5kZWxldGUocGFyZW50Ll9fa2V5KTtcbiAgICAgICAgICAgIGxhc3RSZW1vdmVkUGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHdlIGRvIHNwbGljaW5nIGFmdGVyIG1vdmluZyBvZiBub2RlcywgYXMgc3BsaWNpbmdcbiAgICAgIC8vIGNhbiBoYXZlIHNpZGUtZWZmZWN0cyAoaW4gdGhlIGNhc2Ugb2YgaGFzaHRhZ3MpLlxuICAgICAgaWYgKCFmaXJzdE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpY2VUZXh0KHN0YXJ0T2Zmc2V0LCBmaXJzdE5vZGVUZXh0TGVuZ3RoIC0gc3RhcnRPZmZzZXQsIHRleHQsIHRydWUpO1xuICAgICAgICBpZiAoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgICAgZmlyc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Tm9kZS5pc0NvbXBvc2luZygpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRleHROb2RlLnNlbGVjdCgpO1xuICAgICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgc2VsZWN0ZWQgbm9kZXMgdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiByZW1vdmVkLlxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgY29uc3Qga2V5ID0gc2VsZWN0ZWROb2RlLl9fa2V5O1xuICAgICAgICBpZiAoIW1hcmtlZE5vZGVLZXlzRm9yS2VlcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHNlbGVjdGVkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB0ZXh0IGluIHRoZSBTZWxlY3Rpb24sIGFkanVzdGluZyB0aGUgRWRpdG9yU3RhdGUgYWNjb3JkaW5nbHkuXG4gICAqL1xuICByZW1vdmVUZXh0KCkge1xuICAgIHRoaXMuaW5zZXJ0VGV4dCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgcHJvdmlkZWQgZm9ybWF0IHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG9yXG4gICAqIG1lcmdpbmcgbm9kZXMgYXMgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gZm9ybWF0VHlwZSB0aGUgZm9ybWF0IHR5cGUgdG8gYXBwbHkgdG8gdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqL1xuICBmb3JtYXRUZXh0KGZvcm1hdFR5cGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICB0aGlzLnRvZ2dsZUZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgIC8vIFdoZW4gY2hhbmdpbmcgZm9ybWF0LCB3ZSBzaG91bGQgc3RvcCBjb21wb3NpdGlvblxuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dE5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBzZWxlY3RlZE5vZGUgb2Ygc2VsZWN0ZWROb2Rlcykge1xuICAgICAgaWYgKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkpIHtcbiAgICAgICAgc2VsZWN0ZWRUZXh0Tm9kZXMucHVzaChzZWxlY3RlZE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkVGV4dE5vZGVzLmxlbmd0aDtcbiAgICBpZiAoc2VsZWN0ZWRUZXh0Tm9kZXNMZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudG9nZ2xlRm9ybWF0KGZvcm1hdFR5cGUpO1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBmb3JtYXQsIHdlIHNob3VsZCBzdG9wIGNvbXBvc2l0aW9uXG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gdGhpcy5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IGlzQmFja3dhcmQgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBlbmRQb2ludCA9IGlzQmFja3dhcmQgPyBhbmNob3IgOiBmb2N1cztcbiAgICBsZXQgZmlyc3RJbmRleCA9IDA7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzWzBdO1xuICAgIGxldCBzdGFydE9mZnNldCA9IHN0YXJ0UG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnID8gMCA6IHN0YXJ0UG9pbnQub2Zmc2V0O1xuXG4gICAgLy8gSW4gY2FzZSBzZWxlY3Rpb24gc3RhcnRlZCBhdCB0aGUgZW5kIG9mIHRleHQgbm9kZSB1c2UgbmV4dCB0ZXh0IG5vZGVcbiAgICBpZiAoc3RhcnRQb2ludC50eXBlID09PSAndGV4dCcgJiYgc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgZmlyc3RJbmRleCA9IDE7XG4gICAgICBmaXJzdE5vZGUgPSBzZWxlY3RlZFRleHROb2Rlc1sxXTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKGZpcnN0Tm9kZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0TmV4dEZvcm1hdCA9IGZpcnN0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBudWxsKTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCAtIDE7XG4gICAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWRUZXh0Tm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBlbmRQb2ludC50eXBlID09PSAndGV4dCcgPyBlbmRQb2ludC5vZmZzZXQgOiBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgIC8vIFNpbmdsZSBub2RlIHNlbGVjdGVkXG4gICAgaWYgKGZpcnN0Tm9kZS5pcyhsYXN0Tm9kZSkpIHtcbiAgICAgIC8vIE5vIGFjdHVhbCB0ZXh0IGlzIHNlbGVjdGVkLCBzbyBkbyBub3RoaW5nLlxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkIG9yIGl0IGlzIHRva2VuLCBzbyBqdXN0IGZvcm1hdCBpdFxuICAgICAgaWYgKCRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSB8fCBzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYWRkIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgIHJlcGxhY2VtZW50LnNldEZvcm1hdChmaXJzdE5leHRGb3JtYXQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzZWxlY3Rpb24gb25seSBpZiBzdGFydHMvZW5kcyBvbiB0ZXh0IG5vZGVcbiAgICAgICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgc3RhcnRQb2ludC5zZXQocmVwbGFjZW1lbnQuX19rZXksIDAsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGVuZFBvaW50LnNldChyZXBsYWNlbWVudC5fX2tleSwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROZXh0Rm9ybWF0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsZSBub2RlcyBzZWxlY3RlZFxuICAgIC8vIFRoZSBlbnRpcmUgZmlyc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCwgc28gc3BsaXQgaXRcbiAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDAgJiYgISRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSkge1xuICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgY29uc3QgbGFzdE5leHRGb3JtYXQgPSBsYXN0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBmaXJzdE5leHRGb3JtYXQpO1xuICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgMCwgaXQgbWVhbnMgbm8gYWN0dWFsIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkLFxuICAgIC8vIHNvIHdlIHNraXAgZm9ybWF0dGluZyB0aGUgbGFzdCBub2RlIGFsdG9nZXRoZXIuXG4gICAgaWYgKGVuZE9mZnNldCA+IDApIHtcbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpICYmICEkaXNUb2tlbk9yU2VnbWVudGVkKGxhc3ROb2RlKSkge1xuICAgICAgICBbbGFzdE5vZGVdID0gbGFzdE5vZGUuc3BsaXRUZXh0KGVuZE9mZnNldCk7XG4gICAgICB9XG4gICAgICBsYXN0Tm9kZS5zZXRGb3JtYXQobGFzdE5leHRGb3JtYXQpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYWxsIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuICAgIGZvciAobGV0IGkgPSBmaXJzdEluZGV4ICsgMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzW2ldO1xuICAgICAgY29uc3QgbmV4dEZvcm1hdCA9IHRleHROb2RlLmdldEZvcm1hdEZsYWdzKGZvcm1hdFR5cGUsIGxhc3ROZXh0Rm9ybWF0KTtcbiAgICAgIHRleHROb2RlLnNldEZvcm1hdChuZXh0Rm9ybWF0KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgc3RhcnRzL2VuZHMgb24gdGV4dCBub2RlXG4gICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBzdGFydFBvaW50LnNldChmaXJzdE5vZGUuX19rZXksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgIH1cbiAgICBpZiAoZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBlbmRQb2ludC5zZXQobGFzdE5vZGUuX19rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSBmaXJzdE5leHRGb3JtYXQgfCBsYXN0TmV4dEZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBcImludGVsbGlnZW50bHlcIiBpbnNlcnQgYW4gYXJiaXRyYXJ5IGxpc3Qgb2YgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGVcbiAgICogY3VycmVudCBTZWxlY3Rpb24gYWNjb3JkaW5nIHRvIGEgc2V0IG9mIGhldXJpc3RpY3MgdGhhdCBkZXRlcm1pbmUgaG93IHN1cnJvdW5kaW5nIG5vZGVzXG4gICAqIHNob3VsZCBiZSBjaGFuZ2VkLCByZXBsYWNlZCwgb3IgbW92ZWQgdG8gYWNjb21vZGF0ZSB0aGUgaW5jb21pbmcgb25lcy5cbiAgICpcbiAgICogQHBhcmFtIG5vZGVzIC0gdGhlIG5vZGVzIHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgICAgdGhpcy5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgUmFuZ2VTZWxlY3Rpb24gYWZ0ZXIgaW5zZXJ0UGFyYWdyYXBoYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMuaXNCYWNrd2FyZCgpID8gdGhpcy5mb2N1cyA6IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZpcnN0QmxvY2sgPSAkZ2V0QW5jZXN0b3IoZmlyc3RQb2ludC5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBjb25zdCBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBDQVNFIDE6IGluc2VydCBpbnNpZGUgYSBjb2RlIGJsb2NrXG4gICAgaWYgKCdfX2xhbmd1YWdlJyBpbiBmaXJzdEJsb2NrICYmICRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spKSB7XG4gICAgICBpZiAoJ19fbGFuZ3VhZ2UnIGluIG5vZGVzWzBdKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dChub2Rlc1swXS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gJHJlbW92ZVRleHRBbmRTcGxpdEJsb2NrKHRoaXMpO1xuICAgICAgICBmaXJzdEJsb2NrLnNwbGljZShpbmRleCwgMCwgbm9kZXMpO1xuICAgICAgICBsYXN0LnNlbGVjdEVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENBU0UgMjogQWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheSBhcmUgaW5saW5lXG4gICAgY29uc3Qgbm90SW5saW5lID0gbm9kZSA9PiAoJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSkgJiYgIW5vZGUuaXNJbmxpbmUoKTtcbiAgICBpZiAoIW5vZGVzLnNvbWUobm90SW5saW5lKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShmaXJzdEJsb2NrKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgJ2ZpcnN0QmxvY2snIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9ICRyZW1vdmVUZXh0QW5kU3BsaXRCbG9jayh0aGlzKTtcbiAgICAgIGZpcnN0QmxvY2suc3BsaWNlKGluZGV4LCAwLCBub2Rlcyk7XG4gICAgICBsYXN0LnNlbGVjdEVuZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENBU0UgMzogQXQgbGVhc3QgMSBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBub3QgaW5saW5lXG4gICAgY29uc3QgYmxvY2tzUGFyZW50ID0gJHdyYXBJbmxpbmVOb2Rlcyhub2Rlcyk7XG4gICAgY29uc3Qgbm9kZVRvU2VsZWN0ID0gYmxvY2tzUGFyZW50LmdldExhc3REZXNjZW5kYW50KCk7XG4gICAgY29uc3QgYmxvY2tzID0gYmxvY2tzUGFyZW50LmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgaXNMSSA9IG5vZGUgPT4gJ19fdmFsdWUnIGluIG5vZGUgJiYgJ19fY2hlY2tlZCcgaW4gbm9kZTtcbiAgICBjb25zdCBpc01lcmdlYWJsZSA9IG5vZGUgPT4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgSU5URVJOQUxfJGlzQmxvY2sobm9kZSkgJiYgIW5vZGUuaXNFbXB0eSgpICYmICRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spICYmICghZmlyc3RCbG9jay5pc0VtcHR5KCkgfHwgaXNMSShmaXJzdEJsb2NrKSk7XG4gICAgY29uc3Qgc2hvdWxkSW5zZXJ0ID0gISRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spIHx8ICFmaXJzdEJsb2NrLmlzRW1wdHkoKTtcbiAgICBjb25zdCBpbnNlcnRlZFBhcmFncmFwaCA9IHNob3VsZEluc2VydCA/IHRoaXMuaW5zZXJ0UGFyYWdyYXBoKCkgOiBudWxsO1xuICAgIGNvbnN0IGxhc3RUb0luc2VydCA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgbGV0IGZpcnN0VG9JbnNlcnQgPSBibG9ja3NbMF07XG4gICAgaWYgKGlzTWVyZ2VhYmxlKGZpcnN0VG9JbnNlcnQpKSB7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCAnZmlyc3RCbG9jaycgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICAgIH1cbiAgICAgIGZpcnN0QmxvY2suYXBwZW5kKC4uLmZpcnN0VG9JbnNlcnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBmaXJzdFRvSW5zZXJ0ID0gYmxvY2tzWzFdO1xuICAgIH1cbiAgICBpZiAoZmlyc3RUb0luc2VydCkge1xuICAgICAgaW5zZXJ0UmFuZ2VBZnRlcihmaXJzdEJsb2NrLCBmaXJzdFRvSW5zZXJ0KTtcbiAgICB9XG4gICAgY29uc3QgbGFzdEluc2VydGVkQmxvY2sgPSAkZ2V0QW5jZXN0b3Iobm9kZVRvU2VsZWN0LCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgaWYgKGluc2VydGVkUGFyYWdyYXBoICYmICRpc0VsZW1lbnROb2RlKGxhc3RJbnNlcnRlZEJsb2NrKSAmJiAoaXNMSShpbnNlcnRlZFBhcmFncmFwaCkgfHwgSU5URVJOQUxfJGlzQmxvY2sobGFzdFRvSW5zZXJ0KSkpIHtcbiAgICAgIGxhc3RJbnNlcnRlZEJsb2NrLmFwcGVuZCguLi5pbnNlcnRlZFBhcmFncmFwaC5nZXRDaGlsZHJlbigpKTtcbiAgICAgIGluc2VydGVkUGFyYWdyYXBoLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykgJiYgZmlyc3RCbG9jay5pc0VtcHR5KCkpIHtcbiAgICAgIGZpcnN0QmxvY2sucmVtb3ZlKCk7XG4gICAgfVxuICAgIG5vZGVUb1NlbGVjdC5zZWxlY3RFbmQoKTtcblxuICAgIC8vIFRvIHVuZGVyc3RhbmQgdGhpcyB0YWtlIGEgbG9vayBhdCB0aGUgdGVzdCBcImNhbiB3cmFwIHBvc3QtbGluZWJyZWFrIG5vZGVzIGludG8gbmV3IGVsZW1lbnRcIlxuICAgIGNvbnN0IGxhc3RDaGlsZCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spID8gZmlyc3RCbG9jay5nZXRMYXN0Q2hpbGQoKSA6IG51bGw7XG4gICAgaWYgKCRpc0xpbmVCcmVha05vZGUobGFzdENoaWxkKSAmJiBsYXN0SW5zZXJ0ZWRCbG9jayAhPT0gZmlyc3RCbG9jaykge1xuICAgICAgbGFzdENoaWxkLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgbmV3IFBhcmFncmFwaE5vZGUgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlIGN1cnJlbnQgU2VsZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBuZXdseSBpbnNlcnRlZCBub2RlLlxuICAgKi9cbiAgaW5zZXJ0UGFyYWdyYXBoKCkge1xuICAgIGlmICh0aGlzLmFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICRnZXRSb290KCkuc3BsaWNlKHRoaXMuYW5jaG9yLm9mZnNldCwgMCwgW3BhcmFncmFwaF0pO1xuICAgICAgcGFyYWdyYXBoLnNlbGVjdCgpO1xuICAgICAgcmV0dXJuIHBhcmFncmFwaDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSAkcmVtb3ZlVGV4dEFuZFNwbGl0QmxvY2sodGhpcyk7XG4gICAgY29uc3QgYmxvY2sgPSAkZ2V0QW5jZXN0b3IodGhpcy5hbmNob3IuZ2V0Tm9kZSgpLCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShibG9jaykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhbmNlc3RvciB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFRvQXBwZW5kID0gYmxvY2suZ2V0Q2hpbGRBdEluZGV4KGluZGV4KTtcbiAgICBjb25zdCBub2Rlc1RvSW5zZXJ0ID0gZmlyc3RUb0FwcGVuZCA/IFtmaXJzdFRvQXBwZW5kLCAuLi5maXJzdFRvQXBwZW5kLmdldE5leHRTaWJsaW5ncygpXSA6IFtdO1xuICAgIGNvbnN0IG5ld0Jsb2NrID0gYmxvY2suaW5zZXJ0TmV3QWZ0ZXIodGhpcywgZmFsc2UpO1xuICAgIGlmIChuZXdCbG9jaykge1xuICAgICAgbmV3QmxvY2suYXBwZW5kKC4uLm5vZGVzVG9JbnNlcnQpO1xuICAgICAgbmV3QmxvY2suc2VsZWN0U3RhcnQoKTtcbiAgICAgIHJldHVybiBuZXdCbG9jaztcbiAgICB9XG4gICAgLy8gaWYgbmV3QmxvY2sgaXMgbnVsbCwgaXQgbWVhbnMgdGhhdCBibG9jayBpcyBvZiB0eXBlIENvZGVOb2RlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBsb2dpY2FsIGxpbmVicmVhaywgd2hpY2ggbWF5IGJlIGEgbmV3IExpbmVCcmVha05vZGUgb3IgYSBuZXcgUGFyYWdyYXBoTm9kZSwgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlXG4gICAqIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKi9cbiAgaW5zZXJ0TGluZUJyZWFrKHNlbGVjdFN0YXJ0KSB7XG4gICAgY29uc3QgbGluZUJyZWFrID0gJGNyZWF0ZUxpbmVCcmVha05vZGUoKTtcbiAgICB0aGlzLmluc2VydE5vZGVzKFtsaW5lQnJlYWtdKTtcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gTWFjT1Mgd2l0aCB0aGUgY29tbWFuZCAnY3RybC1PJyAob3BlbkxpbmVCcmVhaylcbiAgICBpZiAoc2VsZWN0U3RhcnQpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGxpbmVCcmVhay5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBjb25zdCBpbmRleCA9IGxpbmVCcmVhay5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgcGFyZW50LnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG5vZGVzIHdoZXJlIG5lY2Vzc2FyeVxuICAgKiB0byBnZXQgb2Zmc2V0LWxldmVsIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIGV4dHJhY3QoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWROb2Rlc0xlbmd0aCAtIDE7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBbYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldF0gPSAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cyh0aGlzKTtcbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgIXRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCBub2RlID0gc3RhcnRPZmZzZXQgPT09IDAgPyBzcGxpdE5vZGVzWzBdIDogc3BsaXROb2Rlc1sxXTtcbiAgICAgICAgcmV0dXJuIG5vZGUgIT0gbnVsbCA/IFtub2RlXSA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtmaXJzdE5vZGVdO1xuICAgIH1cbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCZWZvcmUgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgICBzZWxlY3RlZE5vZGVzWzBdID0gZmlyc3ROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHQgPSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0TGVuZ3RoID0gbGFzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKGVuZE9mZnNldCAhPT0gbGFzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgICAgc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdID0gbGFzdE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZE5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIHRoZSBTZWxlY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzIGFuZCBhIHNldCBvZiBoZXVyaXN0aWNzIHRoYXQgYWNjb3VudCBmb3JcbiAgICogdmFyaW91cyBub2RlIHR5cGVzLiBDYW4gYmUgdXNlZCB0byBzYWZlbHkgbW92ZSBvciBleHRlbmQgc2VsZWN0aW9uIGJ5IG9uZSBsb2dpY2FsIFwidW5pdFwiIHdpdGhvdXRcbiAgICogZGVhbGluZyBleHBsaWNpdGx5IHdpdGggYWxsIHRoZSBwb3NzaWJsZSBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYWx0ZXIgdGhlIHR5cGUgb2YgbW9kaWZpY2F0aW9uIHRvIHBlcmZvcm1cbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3Qgc2VsZWN0aW9uIGlzIGJhY2t3YXJkc1xuICAgKiBAcGFyYW0gZ3JhbnVsYXJpdHkgdGhlIGdyYW51bGFyaXR5IGF0IHdoaWNoIHRvIGFwcGx5IHRoZSBtb2RpZmljYXRpb25cbiAgICovXG4gIG1vZGlmeShhbHRlciwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgY29sbGFwc2UgPSBhbHRlciA9PT0gJ21vdmUnO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBzZWxlY3Rpb24gbW92ZW1lbnQgYXJvdW5kIGRlY29yYXRvcnMuXG4gICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSkge1xuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBtb3ZlIHNlbGVjdGlvbiBmcm9tIHJhbmdlIHNlbGVjdGlvbiB0b1xuICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICBpZiAoY29sbGFwc2UgJiYgcG9zc2libGVOb2RlLmlzS2V5Ym9hcmRTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZVNlbGVjdGlvbiA9ICRjcmVhdGVOb2RlU2VsZWN0aW9uKCk7XG4gICAgICAgIG5vZGVTZWxlY3Rpb24uYWRkKHBvc3NpYmxlTm9kZS5fX2tleSk7XG4gICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBpc0JhY2t3YXJkID8gcG9zc2libGVOb2RlLmdldFByZXZpb3VzU2libGluZygpIDogcG9zc2libGVOb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBvc3NpYmxlTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGxldCBlbGVtZW50S2V5O1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICBlbGVtZW50S2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgICAgICBvZmZzZXQgPSBpc0JhY2t3YXJkID8gc2libGluZy5nZXRDaGlsZHJlblNpemUoKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gcG9zc2libGVOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgICAgZWxlbWVudEtleSA9IHBhcmVudC5fX2tleTtcbiAgICAgICAgICBpZiAoIWlzQmFja3dhcmQpIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb2N1cy5zZXQoZWxlbWVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGVsZW1lbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaWJsaW5nS2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IHNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggOiAwO1xuICAgICAgICBmb2N1cy5zZXQoc2libGluZ0tleSwgb2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICAgIC8vIFJlbW92ZSB0aGUgYmxvY2sgY3Vyc29yIGVsZW1lbnQgaWYgaXQgZXhpc3RzLiBUaGlzIHdpbGwgZW5zdXJlIHNlbGVjdGlvblxuICAgIC8vIHdvcmtzIGFzIGludGVuZGVkLiBJZiB3ZSBsZWF2ZSBpdCBpbiB0aGUgRE9NIGFsbCBzb3J0cyBvZiBzdHJhbmdlIGJ1Z3NcbiAgICAvLyBvY2N1ci4gOi9cbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwgJiYgYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpICYmICFwb3NzaWJsZU5vZGUuY2FuQmVFbXB0eSgpKSB7XG4gICAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgLy8gV2UgdXNlIHRoZSBET00gc2VsZWN0aW9uLm1vZGlmeSBBUEkgaGVyZSB0byBcInRlbGxcIiB1cyB3aGF0IHRoZSBzZWxlY3Rpb25cbiAgICAvLyB3aWxsIGJlLiBXZSB0aGVuIHVzZSBpdCB0byB1cGRhdGUgdGhlIExleGljYWwgc2VsZWN0aW9uIGFjY29yZGluZ2x5LiBUaGlzXG4gICAgLy8gaXMgbXVjaCBtb3JlIHJlbGlhYmxlIHRoYW4gd2FpdGluZyBmb3IgYSBiZWZvcmVpbnB1dCBhbmQgdXNpbmcgdGhlIHJhbmdlc1xuICAgIC8vIGZyb20gZ2V0VGFyZ2V0UmFuZ2VzKCksIGFuZCBpcyBhbHNvIGJldHRlciB0aGFuIHRyeWluZyB0byBkbyBpdCBvdXJzZWx2ZXNcbiAgICAvLyB1c2luZyBJbnRsLlNlZ21lbnRlciBvciBvdGhlciB3b3JrYXJvdW5kcyB0aGF0IHN0cnVnZ2xlIHdpdGggd29yZCBzZWdtZW50c1xuICAgIC8vIGFuZCBsaW5lIHNlZ21lbnRzIChlc3BlY2lhbGx5IHdpdGggd29yZCB3cmFwcGluZyBhbmQgbm9uLVJvbWFuIGxhbmd1YWdlcykuXG4gICAgbW92ZU5hdGl2ZVNlbGVjdGlvbihkb21TZWxlY3Rpb24sIGFsdGVyLCBpc0JhY2t3YXJkID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJywgZ3JhbnVsYXJpdHkpO1xuICAgIC8vIEd1YXJkIGFnYWluc3Qgbm8gcmFuZ2VzXG4gICAgaWYgKGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBET00gc2VsZWN0aW9uIHRvIG91ciBMZXhpY2FsIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCByb290ID0gJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgPyBhbmNob3JOb2RlIDogJGdldE5lYXJlc3RSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGUpO1xuICAgICAgdGhpcy5hcHBseURPTVJhbmdlKHJhbmdlKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKCFjb2xsYXBzZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSBzZWxlY3Rpb247IG1ha2Ugc3VyZSB0aGF0IHRoZSBuZXcgZXh0ZW5kZWQgc2VsZWN0aW9uIHJlc3BlY3RzIHNoYWRvdyByb290c1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3QgdmFsaWROb2RlcyA9IFtdO1xuICAgICAgICBsZXQgc2hyaW5rU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGlmICgkaGFzQW5jZXN0b3IobmV4dE5vZGUsIHJvb3QpKSB7XG4gICAgICAgICAgICB2YWxpZE5vZGVzLnB1c2gobmV4dE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaHJpbmtTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hyaW5rU2VsZWN0aW9uICYmIHZhbGlkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHZhbGlkTm9kZXMgbGVuZ3RoIGNoZWNrIGlzIGEgc2FmZWd1YXJkIGFnYWluc3QgYW4gaW52YWxpZCBzZWxlY3Rpb247IGFzIGdldE5vZGVzKClcbiAgICAgICAgICAvLyB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheSBpbiB0aGlzIGNhc2VcbiAgICAgICAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWxpZE5vZGUgPSB2YWxpZE5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0VmFsaWROb2RlKSkge1xuICAgICAgICAgICAgICBmaXJzdFZhbGlkTm9kZS5zZWxlY3RTdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlyc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RWYWxpZE5vZGUgPSB2YWxpZE5vZGVzW3ZhbGlkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdFZhbGlkTm9kZSkpIHtcbiAgICAgICAgICAgICAgbGFzdFZhbGlkTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlY2F1c2UgYSByYW5nZSB3b3JrcyBvbiBzdGFydCBhbmQgZW5kLCB3ZSBtaWdodCBuZWVkIHRvIGZsaXBcbiAgICAgICAgLy8gdGhlIGFuY2hvciBhbmQgZm9jdXMgcG9pbnRzIHRvIG1hdGNoIHdoYXQgdGhlIERPTSBoYXMsIG5vdCB3aGF0XG4gICAgICAgIC8vIHRoZSByYW5nZSBoYXMgc3BlY2lmaWNhbGx5LlxuICAgICAgICBpZiAoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgIT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyIHx8IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT09IHJhbmdlLnN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgJHN3YXBQb2ludHModGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgaGFuZGxpbmcgZm9yd2FyZCBjaGFyYWN0ZXIgYW5kIHdvcmQgZGVsZXRpb24gdGhhdCBwcmV2ZW50cyBlbGVtZW50IG5vZGVzXG4gICAqIGxpa2UgYSB0YWJsZSwgY29sdW1ucyBsYXlvdXQgYmVpbmcgZGVzdHJveWVkXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3IgdGhlIGFuY2hvclxuICAgKiBAcGFyYW0gYW5jaG9yTm9kZSB0aGUgYW5jaG9yIG5vZGUgaW4gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCBzZWxlY3Rpb24gaXMgYmFja3dhcmRzXG4gICAqL1xuICBmb3J3YXJkRGVsZXRpb24oYW5jaG9yLCBhbmNob3JOb2RlLCBpc0JhY2t3YXJkKSB7XG4gICAgaWYgKCFpc0JhY2t3YXJkICYmIChcbiAgICAvLyBEZWxldGUgZm9yd2FyZCBoYW5kbGUgY2FzZVxuICAgIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkgJiYgYW5jaG9yLm9mZnNldCA9PT0gYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKSB8fCBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvci5vZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5nKCkgfHwgKHBhcmVudCA9PT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKSk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpICYmIG5leHRTaWJsaW5nLmlzU2hhZG93Um9vdCgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgb25lIGxvZ2ljYWwgY2hhcmFjdGVyIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZUNoYXJhY3Rlcihpc0JhY2t3YXJkKSB7XG4gICAgY29uc3Qgd2FzQ29sbGFwc2VkID0gdGhpcy5pc0NvbGxhcHNlZCgpO1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgbGV0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMuZm9yd2FyZERlbGV0aW9uKGFuY2hvciwgYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgdGhlIGRlbGV0aW9uIGFyb3VuZCBkZWNvcmF0b3JzLlxuICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG4gICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpKSB7XG4gICAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gbW92ZSBzZWxlY3Rpb24gZnJvbSByYW5nZSBzZWxlY3Rpb24gdG9cbiAgICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICAgIGlmIChwb3NzaWJsZU5vZGUuaXNLZXlib2FyZFNlbGVjdGFibGUoKSAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgYW5jaG9yTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICBjb25zdCBub2RlU2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICBub2RlU2VsZWN0aW9uLmFkZChwb3NzaWJsZU5vZGUuX19rZXkpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zc2libGVOb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzQmFja3dhcmQgJiYgJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmlzRW1wdHkoKSkge1xuICAgICAgICBhbmNob3JOb2RlLnJlbW92ZSgpO1xuICAgICAgICBwb3NzaWJsZU5vZGUuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcbiAgICAgIGlmICghdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLnR5cGUgPT09ICd0ZXh0JyA/IGZvY3VzLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT09IG51bGwgJiYgZm9jdXNOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgY29uc3QgdGV4dENvbnRlbnRTaXplID0gZm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmIChmb2N1c05vZGUuaXMoYW5jaG9yTm9kZSkgfHwgaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICRyZW1vdmVTZWdtZW50KGZvY3VzTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCAmJiBhbmNob3JOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICAgICAgaWYgKGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKSB8fCBpc0JhY2t3YXJkICYmIG9mZnNldCAhPT0gMCB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSkge1xuICAgICAgICAgICAgJHJlbW92ZVNlZ21lbnQoYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHVwZGF0ZUNhcmV0U2VsZWN0aW9uRm9yVW5pY29kZUNoYXJhY3Rlcih0aGlzLCBpc0JhY2t3YXJkKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCYWNrd2FyZCAmJiBhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgYXJvdW5kIHJpY2ggdGV4dCBub2Rlc1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyA/IGFuY2hvci5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuY29sbGFwc2VBdFN0YXJ0KHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuICAgIGlmIChpc0JhY2t3YXJkICYmICF3YXNDb2xsYXBzZWQgJiYgdGhpcy5pc0NvbGxhcHNlZCgpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiB0aGlzLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoYW5jaG9yTm9kZS5pc0VtcHR5KCkgJiYgJGlzUm9vdE5vZGUoYW5jaG9yTm9kZS5nZXRQYXJlbnQoKSkgJiYgYW5jaG9yTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpID09PSAwKSB7XG4gICAgICAgIGFuY2hvck5vZGUuY29sbGFwc2VBdFN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCBsaW5lIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZUxpbmUoaXNCYWNrd2FyZCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIC8vIFNpbmNlIGBkb21TZWxlY3Rpb24ubW9kaWZ5KCdleHRlbmQnLCAuLi4sICdsaW5lYm91bmRhcnknKWAgd29ya3Mgd2VsbCBmb3IgdGV4dCBzZWxlY3Rpb25zXG4gICAgICAvLyBidXQgZG9lc24ndCBwcm9wZXJseSBoYW5kbGUgc2VsZWN0aW9ucyB3aGljaCBlbmQgb24gZWxlbWVudHMsIGEgc3BhY2UgY2hhcmFjdGVyIGlzIGFkZGVkXG4gICAgICAvLyBmb3Igc3VjaCBzZWxlY3Rpb25zIHRyYW5zZm9ybWluZyB0aGVpciBhbmNob3IncyB0eXBlIHRvICd0ZXh0J1xuICAgICAgY29uc3QgYW5jaG9ySXNFbGVtZW50ID0gdGhpcy5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnO1xuICAgICAgaWYgKGFuY2hvcklzRWxlbWVudCkge1xuICAgICAgICB0aGlzLmluc2VydFRleHQoJyAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kaWZ5KCdleHRlbmQnLCBpc0JhY2t3YXJkLCAnbGluZWJvdW5kYXJ5Jyk7XG5cbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBleHRlbmRlZCB0byBjb3ZlciB0ZXh0IGVkZ2UgdGhlbiBleHRlbmQgaXQgb25lIGNoYXJhY3RlciBtb3JlXG4gICAgICAvLyB0byBkZWxldGUgaXRzIHBhcmVudCBlbGVtZW50LiBPdGhlcndpc2UgdGV4dCBjb250ZW50IHdpbGwgYmUgZGVsZXRlZCBidXQgZW1wdHlcbiAgICAgIC8vIHBhcmVudCBub2RlIHdpbGwgcmVtYWluXG4gICAgICBjb25zdCBlbmRQb2ludCA9IGlzQmFja3dhcmQgPyB0aGlzLmZvY3VzIDogdGhpcy5hbmNob3I7XG4gICAgICBpZiAoZW5kUG9pbnQub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHRoaXMubW9kaWZ5KCdleHRlbmQnLCBpc0JhY2t3YXJkLCAnY2hhcmFjdGVyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkanVzdHMgc2VsZWN0aW9uIHRvIGluY2x1ZGUgYW4gZXh0cmEgY2hhcmFjdGVyIGFkZGVkIGZvciBlbGVtZW50IGFuY2hvcnMgdG8gcmVtb3ZlIGl0XG4gICAgICBpZiAoYW5jaG9ySXNFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBpc0JhY2t3YXJkID8gdGhpcy5hbmNob3IgOiB0aGlzLmZvY3VzO1xuICAgICAgICBzdGFydFBvaW50LnNldChzdGFydFBvaW50LmtleSwgc3RhcnRQb2ludC5vZmZzZXQgKyAxLCBzdGFydFBvaW50LnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZVRleHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCB3b3JkIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZVdvcmQoaXNCYWNrd2FyZCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAodGhpcy5mb3J3YXJkRGVsZXRpb24oYW5jaG9yLCBhbmNob3JOb2RlLCBpc0JhY2t3YXJkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGlmeSgnZXh0ZW5kJywgaXNCYWNrd2FyZCwgJ3dvcmQnKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVUZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJiYWNrd2FyZHNcIiwgbWVhbmluZyB0aGUgZm9jdXNcbiAgICogbG9naWNhbGx5IHByZWNlZGVzIHRoZSBhbmNob3IgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgYmFja3dhcmRzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzLmlzQmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfVxuICBnZXRTdGFydEVuZFBvaW50cygpIHtcbiAgICByZXR1cm4gW3RoaXMuYW5jaG9yLCB0aGlzLmZvY3VzXTtcbiAgfVxufVxuZnVuY3Rpb24gJGlzTm9kZVNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGdldENoYXJhY3Rlck9mZnNldChwb2ludCkge1xuICBjb25zdCBvZmZzZXQgPSBwb2ludC5vZmZzZXQ7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IHBvaW50LmdldE5vZGUoKTtcbiAgcmV0dXJuIG9mZnNldCA9PT0gcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID8gcGFyZW50LmdldFRleHRDb250ZW50KCkubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uICRnZXRDaGFyYWN0ZXJPZmZzZXRzKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAoYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IGFuY2hvckFuZEZvY3VzO1xuICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmtleSA9PT0gZm9jdXMua2V5ICYmIGFuY2hvci5vZmZzZXQgPT09IGZvY3VzLm9mZnNldCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgcmV0dXJuIFtnZXRDaGFyYWN0ZXJPZmZzZXQoYW5jaG9yKSwgZ2V0Q2hhcmFjdGVyT2Zmc2V0KGZvY3VzKV07XG59XG5mdW5jdGlvbiAkc3dhcFBvaW50cyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvci5rZXk7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGFuY2hvclR5cGUgPSBhbmNob3IudHlwZTtcbiAgJHNldFBvaW50VmFsdWVzKGFuY2hvciwgZm9jdXMua2V5LCBmb2N1cy5vZmZzZXQsIGZvY3VzLnR5cGUpO1xuICAkc2V0UG9pbnRWYWx1ZXMoZm9jdXMsIGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBhbmNob3JUeXBlKTtcbiAgc2VsZWN0aW9uLl9jYWNoZWROb2RlcyA9IG51bGw7XG59XG5mdW5jdGlvbiBtb3ZlTmF0aXZlU2VsZWN0aW9uKGRvbVNlbGVjdGlvbiwgYWx0ZXIsIGRpcmVjdGlvbiwgZ3JhbnVsYXJpdHkpIHtcbiAgLy8gU2VsZWN0aW9uLm1vZGlmeSgpIG1ldGhvZCBhcHBsaWVzIGEgY2hhbmdlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBvciBjdXJzb3IgcG9zaXRpb24sXG4gIC8vIGJ1dCBpcyBzdGlsbCBub24tc3RhbmRhcmQgaW4gc29tZSBicm93c2Vycy5cbiAgZG9tU2VsZWN0aW9uLm1vZGlmeShhbHRlciwgZGlyZWN0aW9uLCBncmFudWxhcml0eSk7XG59XG5mdW5jdGlvbiAkdXBkYXRlQ2FyZXRTZWxlY3Rpb25Gb3JVbmljb2RlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgaWYgKGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIC8vIEhhbmRsaW5nIG9mIG11bHRpYnl0ZSBjaGFyYWN0ZXJzXG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvck9mZnNldCA8IGZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCZWZvcmUgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBpc0JlZm9yZSA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgIGNvbnN0IGNoYXJhY3Rlck9mZnNldCA9IGVuZE9mZnNldCAtIDE7XG4gICAgaWYgKHN0YXJ0T2Zmc2V0ICE9PSBjaGFyYWN0ZXJPZmZzZXQpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICBpZiAoIWRvZXNDb250YWluR3JhcGhlbWUodGV4dCkpIHtcbiAgICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICBmb2N1cy5vZmZzZXQgPSBjaGFyYWN0ZXJPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yLm9mZnNldCA9IGNoYXJhY3Rlck9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHJlbW92ZVNlZ21lbnQobm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KSB7XG4gIGNvbnN0IHRleHROb2RlID0gbm9kZTtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBzcGxpdCA9IHRleHRDb250ZW50LnNwbGl0KC8oPz1cXHMpL2cpO1xuICBjb25zdCBzcGxpdExlbmd0aCA9IHNwbGl0Lmxlbmd0aDtcbiAgbGV0IHNlZ21lbnRPZmZzZXQgPSAwO1xuICBsZXQgcmVzdG9yZU9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXRMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRleHQgPSBzcGxpdFtpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSBzcGxpdExlbmd0aCAtIDE7XG4gICAgcmVzdG9yZU9mZnNldCA9IHNlZ21lbnRPZmZzZXQ7XG4gICAgc2VnbWVudE9mZnNldCArPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiBzZWdtZW50T2Zmc2V0ID09PSBvZmZzZXQgfHwgc2VnbWVudE9mZnNldCA+IG9mZnNldCB8fCBpc0xhc3QpIHtcbiAgICAgIHNwbGl0LnNwbGljZShpLCAxKTtcbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgcmVzdG9yZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXh0VGV4dENvbnRlbnQgPSBzcGxpdC5qb2luKCcnKS50cmltKCk7XG4gIGlmIChuZXh0VGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgdGV4dE5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dE5vZGUuc2V0VGV4dENvbnRlbnQobmV4dFRleHRDb250ZW50KTtcbiAgICB0ZXh0Tm9kZS5zZWxlY3QocmVzdG9yZU9mZnNldCwgcmVzdG9yZU9mZnNldCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlc29sdmVBbmNlc3RvcihyZXNvbHZlZEVsZW1lbnQsIHJlc29sdmVkT2Zmc2V0LCBsYXN0UG9pbnQpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudCgpO1xuICByZXR1cm4gbGFzdFBvaW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gbnVsbCB8fCAhcGFyZW50LmNhbkJlRW1wdHkoKSB8fCBwYXJlbnQgIT09IGxhc3RQb2ludC5nZXROb2RlKCk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnQoZG9tLCBvZmZzZXQsIGxhc3RQb2ludCwgZWRpdG9yKSB7XG4gIGxldCByZXNvbHZlZE9mZnNldCA9IG9mZnNldDtcbiAgbGV0IHJlc29sdmVkTm9kZTtcbiAgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gb24gYW4gZWxlbWVudCwgd2Ugd2lsbFxuICAvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgKHVzaW5nIHRoZSBvZmZzZXQpIHdoYXQgdGV4dFxuICAvLyBub2RlIHNob3VsZCBiZSBzZWxlY3RlZC5cblxuICBpZiAoZG9tLm5vZGVUeXBlID09PSBET01fRUxFTUVOVF9UWVBFKSB7XG4gICAgLy8gUmVzb2x2ZSBlbGVtZW50IHRvIGEgRWxlbWVudE5vZGUsIG9yIFRleHROb2RlLCBvciBudWxsXG4gICAgbGV0IG1vdmVTZWxlY3Rpb25Ub0VuZCA9IGZhbHNlO1xuICAgIC8vIEdpdmVuIHdlJ3JlIG1vdmluZyBzZWxlY3Rpb24gdG8gYW5vdGhlciBub2RlLCBzZWxlY3Rpb24gaXNcbiAgICAvLyBkZWZpbml0ZWx5IGRpcnR5LlxuICAgIC8vIFdlIHVzZSB0aGUgYW5jaG9yIHRvIGZpbmQgd2hpY2ggY2hpbGQgbm9kZSB0byBzZWxlY3RcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZG9tLmNoaWxkTm9kZXM7XG4gICAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgIC8vIElmIHRoZSBhbmNob3IgaXMgdGhlIHNhbWUgYXMgbGVuZ3RoLCB0aGVuIHRoaXMgbWVhbnMgd2VcbiAgICAvLyBuZWVkIHRvIHNlbGVjdCB0aGUgdmVyeSBsYXN0IHRleHQgbm9kZS5cbiAgICBpZiAocmVzb2x2ZWRPZmZzZXQgPT09IGNoaWxkTm9kZXNMZW5ndGgpIHtcbiAgICAgIG1vdmVTZWxlY3Rpb25Ub0VuZCA9IHRydWU7XG4gICAgICByZXNvbHZlZE9mZnNldCA9IGNoaWxkTm9kZXNMZW5ndGggLSAxO1xuICAgIH1cbiAgICBsZXQgY2hpbGRET00gPSBjaGlsZE5vZGVzW3Jlc29sdmVkT2Zmc2V0XTtcbiAgICBsZXQgaGFzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBpZiAoY2hpbGRET00gPT09IGJsb2NrQ3Vyc29yRWxlbWVudCkge1xuICAgICAgY2hpbGRET00gPSBjaGlsZE5vZGVzW3Jlc29sdmVkT2Zmc2V0ICsgMV07XG4gICAgICBoYXNCbG9ja0N1cnNvciA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudFBhcmVudCA9IGJsb2NrQ3Vyc29yRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKGRvbSA9PT0gYmxvY2tDdXJzb3JFbGVtZW50UGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yT2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChibG9ja0N1cnNvckVsZW1lbnRQYXJlbnQuY2hpbGRyZW4sIGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICAgIGlmIChvZmZzZXQgPiBibG9ja0N1cnNvck9mZnNldCkge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZWROb2RlID0gJGdldE5vZGVGcm9tRE9NKGNoaWxkRE9NKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocmVzb2x2ZWROb2RlKSkge1xuICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBnZXRUZXh0Tm9kZU9mZnNldChyZXNvbHZlZE5vZGUsIG1vdmVTZWxlY3Rpb25Ub0VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXNvbHZlZEVsZW1lbnQgPSAkZ2V0Tm9kZUZyb21ET00oZG9tKTtcbiAgICAgIC8vIEVuc3VyZSByZXNvbHZlZEVsZW1lbnQgaXMgYWN0dWFsbHkgYSBlbGVtZW50LlxuICAgICAgaWYgKHJlc29sdmVkRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gTWF0aC5taW4ocmVzb2x2ZWRFbGVtZW50LmdldENoaWxkcmVuU2l6ZSgpLCByZXNvbHZlZE9mZnNldCk7XG4gICAgICAgIGxldCBjaGlsZCA9IHJlc29sdmVkRWxlbWVudC5nZXRDaGlsZEF0SW5kZXgocmVzb2x2ZWRPZmZzZXQpO1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpICYmIHNob3VsZFJlc29sdmVBbmNlc3RvcihjaGlsZCwgcmVzb2x2ZWRPZmZzZXQsIGxhc3RQb2ludCkpIHtcbiAgICAgICAgICBjb25zdCBkZXNjZW5kYW50ID0gbW92ZVNlbGVjdGlvblRvRW5kID8gY2hpbGQuZ2V0TGFzdERlc2NlbmRhbnQoKSA6IGNoaWxkLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgIGlmIChkZXNjZW5kYW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlZEVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBkZXNjZW5kYW50O1xuICAgICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gJGlzRWxlbWVudE5vZGUoY2hpbGQpID8gY2hpbGQgOiBjaGlsZC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgcmVzb2x2ZWROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IGdldFRleHROb2RlT2Zmc2V0KGNoaWxkLCBtb3ZlU2VsZWN0aW9uVG9FbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkICE9PSByZXNvbHZlZEVsZW1lbnQgJiYgbW92ZVNlbGVjdGlvblRvRW5kICYmICFoYXNCbG9ja0N1cnNvcikge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVzb2x2ZWRFbGVtZW50LmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIC8vIFdoZW4gc2VsZWN0aW5nIGRlY29yYXRvcnMsIHRoZXJlIGNhbiBiZSBzb21lIHNlbGVjdGlvbiBpc3N1ZXMgd2hlbiB1c2luZyByZXNvbHZlZE9mZnNldCxcbiAgICAgICAgLy8gYW5kIGluc3RlYWQgd2Ugc2hvdWxkIGJlIGNoZWNraW5nIGlmIHdlJ3JlIHVzaW5nIHRoZSBvZmZzZXRcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCAmJiAkaXNEZWNvcmF0b3JOb2RlKHJlc29sdmVkRWxlbWVudCkgJiYgJGdldE5vZGVGcm9tRE9NKGRvbSkgPT09IHJlc29sdmVkRWxlbWVudCkge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiAkY3JlYXRlUG9pbnQocmVzb2x2ZWRFbGVtZW50Ll9fa2V5LCByZXNvbHZlZE9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGV4dE5vZGUgb3IgbnVsbFxuICAgIHJlc29sdmVkTm9kZSA9ICRnZXROb2RlRnJvbURPTShkb20pO1xuICB9XG4gIGlmICghJGlzVGV4dE5vZGUocmVzb2x2ZWROb2RlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAkY3JlYXRlUG9pbnQocmVzb2x2ZWROb2RlLl9fa2V5LCByZXNvbHZlZE9mZnNldCwgJ3RleHQnKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb25Qb2ludE9uQm91bmRhcnkocG9pbnQsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKSB7XG4gIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmICghaXNCYWNrd2FyZCkge1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSAmJiAhaXNDb2xsYXBzZWQgJiYgcHJldlNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsXG4gICAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgIWlzQmFja3dhcmQpICYmIHByZXZTaWJsaW5nID09PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBhcmVudCkgJiYgcGFyZW50LmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcGFyZW50U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcGFyZW50U2libGluZy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSBub2RlLmdldFRleHRDb250ZW50KCkubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiAkaXNFbGVtZW50Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgcG9pbnQua2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBwb2ludC5vZmZzZXQgPSAwO1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcbiAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgaXNCYWNrd2FyZCkgJiYgbmV4dFNpYmxpbmcgPT09IG51bGwgJiYgJGlzRWxlbWVudE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNJbmxpbmUoKSAmJiAhcGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcGFyZW50U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKGFuY2hvciwgZm9jdXMsIGxhc3RTZWxlY3Rpb24pIHtcbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgaXNDb2xsYXBzZWQgPSBhbmNob3IuaXMoZm9jdXMpO1xuXG4gICAgLy8gQXR0ZW1wdCB0byBub3JtYWxpemUgdGhlIG9mZnNldCB0byB0aGUgcHJldmlvdXMgc2libGluZyBpZiB3ZSdyZSBhdCB0aGVcbiAgICAvLyBzdGFydCBvZiBhIHRleHQgbm9kZSBhbmQgdGhlIHNpYmxpbmcgaXMgYSB0ZXh0IG5vZGUgb3IgaW5saW5lIGVsZW1lbnQuXG4gICAgcmVzb2x2ZVNlbGVjdGlvblBvaW50T25Cb3VuZGFyeShhbmNob3IsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKTtcbiAgICByZXNvbHZlU2VsZWN0aW9uUG9pbnRPbkJvdW5kYXJ5KGZvY3VzLCAhaXNCYWNrd2FyZCwgaXNDb2xsYXBzZWQpO1xuICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgZm9jdXMua2V5ID0gYW5jaG9yLmtleTtcbiAgICAgIGZvY3VzLm9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBmb2N1cy50eXBlID0gYW5jaG9yLnR5cGU7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSAmJiBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ICE9PSBhbmNob3Iua2V5ICYmICRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsYXN0QW5jaG9yID0gbGFzdFNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGFuY2hvciwgbGFzdEFuY2hvci5rZXksIGxhc3RBbmNob3Iub2Zmc2V0LCBsYXN0QW5jaG9yLnR5cGUpO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGZvY3VzLCBsYXN0Rm9jdXMua2V5LCBsYXN0Rm9jdXMub2Zmc2V0LCBsYXN0Rm9jdXMudHlwZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnRzKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0RPTSwgZm9jdXNPZmZzZXQsIGVkaXRvciwgbGFzdFNlbGVjdGlvbikge1xuICBpZiAoYW5jaG9yRE9NID09PSBudWxsIHx8IGZvY3VzRE9NID09PSBudWxsIHx8ICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRBbmNob3JQb2ludCA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludChhbmNob3JET00sIGFuY2hvck9mZnNldCwgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyBsYXN0U2VsZWN0aW9uLmFuY2hvciA6IG51bGwsIGVkaXRvcik7XG4gIGlmIChyZXNvbHZlZEFuY2hvclBvaW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRGb2N1c1BvaW50ID0gJGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50KGZvY3VzRE9NLCBmb2N1c09mZnNldCwgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyBsYXN0U2VsZWN0aW9uLmZvY3VzIDogbnVsbCwgZWRpdG9yKTtcbiAgaWYgKHJlc29sdmVkRm9jdXNQb2ludCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyZXNvbHZlZEFuY2hvclBvaW50LnR5cGUgPT09ICdlbGVtZW50JyAmJiByZXNvbHZlZEZvY3VzUG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXROb2RlRnJvbURPTShhbmNob3JET00pO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9ICRnZXROb2RlRnJvbURPTShmb2N1c0RPTSk7XG4gICAgLy8gRW5zdXJlIGlmIHdlJ3JlIHNlbGVjdGluZyB0aGUgY29udGVudCBvZiBhIGRlY29yYXRvciB0aGF0IHdlXG4gICAgLy8gcmV0dXJuIG51bGwgZm9yIHRoaXMgcG9pbnQsIGFzIGl0J3Mgbm90IGluIHRoZSBjb250cm9sbGVkIHNjb3BlXG4gICAgLy8gb2YgTGV4aWNhbC5cbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShhbmNob3JOb2RlKSAmJiAkaXNEZWNvcmF0b3JOb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBub3JtYWxpemF0aW9uIG9mIHNlbGVjdGlvbiB3aGVuIGl0IGlzIGF0IHRoZSBib3VuZGFyaWVzLlxuICAkbm9ybWFsaXplU2VsZWN0aW9uUG9pbnRzRm9yQm91bmRhcmllcyhyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnQsIGxhc3RTZWxlY3Rpb24pO1xuICByZXR1cm4gW3Jlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludF07XG59XG5mdW5jdGlvbiAkaXNCbG9ja0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCk7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBtYWtlIGEgc2VsZWN0aW9uIHdoZW4gdGhlIGV4aXN0aW5nXG4vLyBzZWxlY3Rpb24gaXMgbnVsbCwgaS5lLiBmb3JjaW5nIHNlbGVjdGlvbiBvbiB0aGUgZWRpdG9yXG4vLyB3aGVuIGl0IGN1cnJlbnQgZXhpc3RzIG91dHNpZGUgdGhlIGVkaXRvci5cblxuZnVuY3Rpb24gJGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0tleSwgZm9jdXNPZmZzZXQsIGFuY2hvclR5cGUsIGZvY3VzVHlwZSkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQoYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGFuY2hvclR5cGUpLCAkY3JlYXRlUG9pbnQoZm9jdXNLZXksIGZvY3VzT2Zmc2V0LCBmb2N1c1R5cGUpLCAwLCAnJyk7XG4gIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGFuY2hvciA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIGNvbnN0IGZvY3VzID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgcmV0dXJuIG5ldyBSYW5nZVNlbGVjdGlvbihhbmNob3IsIGZvY3VzLCAwLCAnJyk7XG59XG5mdW5jdGlvbiAkY3JlYXRlTm9kZVNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQoKSk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxDcmVhdGVTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBsYXN0U2VsZWN0aW9uID0gY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSB8fCBsYXN0U2VsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gJGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbiwgZG9tU2VsZWN0aW9uLCBlZGl0b3IsIG51bGwpO1xuICB9XG4gIHJldHVybiBsYXN0U2VsZWN0aW9uLmNsb25lKCk7XG59XG5mdW5jdGlvbiAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tKGRvbVNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIHJldHVybiAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihudWxsLCBkb21TZWxlY3Rpb24sIGVkaXRvciwgbnVsbCk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIGVkaXRvciwgZXZlbnQpIHtcbiAgY29uc3Qgd2luZG93T2JqID0gZWRpdG9yLl93aW5kb3c7XG4gIGlmICh3aW5kb3dPYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBXaGVuIHdlIGNyZWF0ZSBhIHNlbGVjdGlvbiwgd2UgdHJ5IHRvIHVzZSB0aGUgcHJldmlvdXNcbiAgLy8gc2VsZWN0aW9uIHdoZXJlIHBvc3NpYmxlLCB1bmxlc3MgYW4gYWN0dWFsIHVzZXIgc2VsZWN0aW9uXG4gIC8vIGNoYW5nZSBoYXMgb2NjdXJyZWQuIFdoZW4gd2UgZG8gbmVlZCB0byBjcmVhdGUgYSBuZXcgc2VsZWN0aW9uXG4gIC8vIHdlIHZhbGlkYXRlIHdlIGNhbiBoYXZlIHRleHQgbm9kZXMgZm9yIGJvdGggYW5jaG9yIGFuZCBmb2N1c1xuICAvLyBub2Rlcy4gSWYgdGhhdCBob2xkcyB0cnVlLCB3ZSB0aGVuIHJldHVybiB0aGF0IHNlbGVjdGlvblxuICAvLyBhcyBhIG11dGFibGUgb2JqZWN0IHRoYXQgd2UgdXNlIGZvciB0aGUgZWRpdG9yIHN0YXRlIGZvciB0aGlzXG4gIC8vIHVwZGF0ZSBjeWNsZS4gSWYgYSBzZWxlY3Rpb24gZ2V0cyBjaGFuZ2VkLCBhbmQgcmVxdWlyZXMgYVxuICAvLyB1cGRhdGUgdG8gbmF0aXZlIERPTSBzZWxlY3Rpb24sIGl0IGdldHMgbWFya2VkIGFzIFwiZGlydHlcIi5cbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBidXQgbWF0Y2hlcyB3aXRoIHRoZSBleGlzdGluZ1xuICAvLyBET00gc2VsZWN0aW9uLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBzeW5jIGl0LiBPdGhlcndpc2UsXG4gIC8vIHdlIGdlbmVyYWxseSBiYWlsIG91dCBvZiBkb2luZyBhbiB1cGRhdGUgdG8gc2VsZWN0aW9uIGR1cmluZ1xuICAvLyByZWNvbmNpbGlhdGlvbiB1bmxlc3MgdGhlcmUgYXJlIGRpcnR5IG5vZGVzIHRoYXQgbmVlZFxuICAvLyByZWNvbmNpbGluZy5cblxuICBjb25zdCB3aW5kb3dFdmVudCA9IGV2ZW50IHx8IHdpbmRvd09iai5ldmVudDtcbiAgY29uc3QgZXZlbnRUeXBlID0gd2luZG93RXZlbnQgPyB3aW5kb3dFdmVudC50eXBlIDogdW5kZWZpbmVkO1xuICBjb25zdCBpc1NlbGVjdGlvbkNoYW5nZSA9IGV2ZW50VHlwZSA9PT0gJ3NlbGVjdGlvbmNoYW5nZSc7XG4gIGNvbnN0IHVzZURPTVNlbGVjdGlvbiA9ICFnZXRJc1Byb2Nlc3NpbmdNdXRhdGlvbnMoKSAmJiAoaXNTZWxlY3Rpb25DaGFuZ2UgfHwgZXZlbnRUeXBlID09PSAnYmVmb3JlaW5wdXQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NvbXBvc2l0aW9uc3RhcnQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NvbXBvc2l0aW9uZW5kJyB8fCBldmVudFR5cGUgPT09ICdjbGljaycgJiYgd2luZG93RXZlbnQgJiYgd2luZG93RXZlbnQuZGV0YWlsID09PSAzIHx8IGV2ZW50VHlwZSA9PT0gJ2Ryb3AnIHx8IGV2ZW50VHlwZSA9PT0gdW5kZWZpbmVkKTtcbiAgbGV0IGFuY2hvckRPTSwgZm9jdXNET00sIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQ7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgfHwgdXNlRE9NU2VsZWN0aW9uKSB7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgIGZvY3VzRE9NID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICAgIGlmIChpc1NlbGVjdGlvbkNoYW5nZSAmJiAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSAmJiAhaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgICAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbiAgfVxuICAvLyBMZXQncyByZXNvbHZlIHRoZSB0ZXh0IG5vZGVzIGZyb20gdGhlIG9mZnNldHMgYW5kIERPTSBub2RlcyB3ZSBoYXZlIGZyb21cbiAgLy8gbmF0aXZlIHNlbGVjdGlvbi5cbiAgY29uc3QgcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPSAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnRzKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0RPTSwgZm9jdXNPZmZzZXQsIGVkaXRvciwgbGFzdFNlbGVjdGlvbik7XG4gIGlmIChyZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFtyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnRdID0gcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHM7XG4gIHJldHVybiBuZXcgUmFuZ2VTZWxlY3Rpb24ocmVzb2x2ZWRBbmNob3JQb2ludCwgcmVzb2x2ZWRGb2N1c1BvaW50LCAhJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyAwIDogbGFzdFNlbGVjdGlvbi5mb3JtYXQsICEkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/ICcnIDogbGFzdFNlbGVjdGlvbi5zdHlsZSk7XG59XG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGdldFByZXZpb3VzU2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50Tm9kZSwgbm9kZU9mZnNldCwgdGltZXMgPSAxKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoIXBhcmVudE5vZGUuaXMoYW5jaG9yTm9kZSkgJiYgIXBhcmVudE5vZGUuaXMoZm9jdXNOb2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnROb2RlLl9fa2V5O1xuICAvLyBTaW5nbGUgbm9kZS4gV2Ugc2hpZnQgc2VsZWN0aW9uIGJ1dCBuZXZlciByZWRpbWVuc2lvbiBpdFxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBjb25zdCBzZWxlY3Rpb25PZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGlmIChub2RlT2Zmc2V0IDw9IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA+IDAgfHwgbm9kZU9mZnNldCA8IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA8IDApIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbk9mZnNldCA9IE1hdGgubWF4KDAsIHNlbGVjdGlvbk9mZnNldCArIHRpbWVzKTtcbiAgICAgIGFuY2hvci5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICBmb2N1cy5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAvLyBUaGUgbmV3IHNlbGVjdGlvbiBtaWdodCBwb2ludCB0byB0ZXh0IG5vZGVzLCB0cnkgdG8gcmVzb2x2ZSB0aGVtXG4gICAgICAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBNdWx0aXBsZSBub2RlcyBzZWxlY3RlZC4gV2Ugc2hpZnQgb3IgcmVkaW1lbnNpb24gc2VsZWN0aW9uXG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGlzQmFja3dhcmQgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBmaXJzdFBvaW50Tm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGlzQmFja3dhcmQgPyBhbmNob3IgOiBmb2N1cztcbiAgICBjb25zdCBsYXN0UG9pbnROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcbiAgICBpZiAocGFyZW50Tm9kZS5pcyhmaXJzdFBvaW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0UG9pbnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICAgIGlmIChub2RlT2Zmc2V0IDw9IGZpcnN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPiAwIHx8IG5vZGVPZmZzZXQgPCBmaXJzdFBvaW50T2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgICBmaXJzdFBvaW50LnNldChwYXJlbnRLZXksIE1hdGgubWF4KDAsIGZpcnN0UG9pbnRPZmZzZXQgKyB0aW1lcyksICdlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlLmlzKGxhc3RQb2ludE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0UG9pbnRPZmZzZXQgPSBsYXN0UG9pbnQub2Zmc2V0O1xuICAgICAgaWYgKG5vZGVPZmZzZXQgPD0gbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzID4gMCB8fCBub2RlT2Zmc2V0IDwgbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgICBsYXN0UG9pbnQuc2V0KHBhcmVudEtleSwgTWF0aC5tYXgoMCwgbGFzdFBvaW50T2Zmc2V0ICsgdGltZXMpLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBUaGUgbmV3IHNlbGVjdGlvbiBtaWdodCBwb2ludCB0byB0ZXh0IG5vZGVzLCB0cnkgdG8gcmVzb2x2ZSB0aGVtXG4gICR1cGRhdGVTZWxlY3Rpb25SZXNvbHZlVGV4dE5vZGVzKHNlbGVjdGlvbik7XG59XG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0QXRFbmQgPSBhbmNob3JPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gYW5jaG9yT2Zmc2V0QXRFbmQgPyBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBhbmNob3Iuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0QXRFbmQgPSBhbmNob3JPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gYW5jaG9yT2Zmc2V0QXRFbmQgPyBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBhbmNob3Iuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRTaXplID0gZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0QXRFbmQgPSBmb2N1c09mZnNldCA+PSBjaGlsZFNpemU7XG4gICAgY29uc3QgY2hpbGQgPSBmb2N1c09mZnNldEF0RW5kID8gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGZvY3VzTm9kZS5nZXRDaGlsZEF0SW5kZXgoZm9jdXNPZmZzZXQpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuICAgICAgaWYgKGZvY3VzT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5U2VsZWN0aW9uVHJhbnNmb3JtcyhuZXh0RWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBwcmV2RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvciA9IG5leHRTZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gbmV4dFNlbGVjdGlvbi5mb2N1cztcbiAgICBsZXQgYW5jaG9yTm9kZTtcbiAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBhbmNob3JOb2RlLnNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKGFuY2hvck5vZGUgIT09IGZvY3VzTm9kZSkge1xuICAgICAgICBmb2N1c05vZGUuc2VsZWN0aW9uVHJhbnNmb3JtKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKHBvaW50LCBub2RlLCBwYXJlbnQsIHByZXZTaWJsaW5nLCBuZXh0U2libGluZykge1xuICBsZXQgc2libGluZ0tleSA9IG51bGw7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgIHNpYmxpbmdLZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBvZmZzZXQgPSBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIG9mZnNldCA9IHByZXZTaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgdHlwZSA9ICdlbGVtZW50JztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nS2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICB0eXBlID0gJ2VsZW1lbnQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2libGluZ0tleSAhPT0gbnVsbCAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgcG9pbnQuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAvLyBNb3ZlIHNlbGVjdGlvbiB0byBlbmQgb2YgcGFyZW50XG4gICAgICBvZmZzZXQgPSBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgfVxuICAgIHBvaW50LnNldChwYXJlbnQuX19rZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKHBvaW50LCBpc0JlZm9yZSwga2V5LCB0YXJnZXQsIHRleHRMZW5ndGgpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHBvaW50LmtleSA9IGtleTtcbiAgICBpZiAoIWlzQmVmb3JlKSB7XG4gICAgICBwb2ludC5vZmZzZXQgKz0gdGV4dExlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocG9pbnQub2Zmc2V0ID4gdGFyZ2V0LmdldEluZGV4V2l0aGluUGFyZW50KCkpIHtcbiAgICBwb2ludC5vZmZzZXQgLT0gMTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRE9NU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24sIGVkaXRvciwgZG9tU2VsZWN0aW9uLCB0YWdzLCByb290RWxlbWVudCwgbm9kZUNvdW50KSB7XG4gIGNvbnN0IGFuY2hvckRPTU5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgY29uc3QgZm9jdXNET01Ob2RlID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBkb21TZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gIC8vIFRPRE86IG1ha2UgdGhpcyBub3QgaGFyZC1jb2RlZCwgYW5kIGFkZCBhbm90aGVyIGNvbmZpZyBvcHRpb25cbiAgLy8gdGhhdCBtYWtlcyB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgaWYgKHRhZ3MuaGFzKCdjb2xsYWJvcmF0aW9uJykgJiYgYWN0aXZlRWxlbWVudCAhPT0gcm9vdEVsZW1lbnQgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dChhY3RpdmVFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgLy8gV2UgZG9uJ3QgcmVtb3ZlIHNlbGVjdGlvbiBpZiB0aGUgcHJldlNlbGVjdGlvbiBpcyBudWxsIGJlY2F1c2VcbiAgICAvLyBvZiBlZGl0b3Iuc2V0Um9vdEVsZW1lbnQoKS4gSWYgdGhpcyBvY2N1cnMgb24gaW5pdCB3aGVuIHRoZVxuICAgIC8vIGVkaXRvciBpcyBhbHJlYWR5IGZvY3VzZWQsIHRoZW4gdGhpcyBjYW4gY2F1c2UgdGhlIGVkaXRvciB0b1xuICAgIC8vIGxvc2UgZm9jdXMuXG4gICAgaWYgKHByZXZTZWxlY3Rpb24gIT09IG51bGwgJiYgaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET01Ob2RlLCBmb2N1c0RPTU5vZGUpKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBuZXh0U2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzLmtleTtcbiAgY29uc3QgYW5jaG9yRE9NID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGFuY2hvcktleSk7XG4gIGNvbnN0IGZvY3VzRE9NID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGZvY3VzS2V5KTtcbiAgY29uc3QgbmV4dEFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IG5leHRGb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgY29uc3QgbmV4dEZvcm1hdCA9IG5leHRTZWxlY3Rpb24uZm9ybWF0O1xuICBjb25zdCBuZXh0U3R5bGUgPSBuZXh0U2VsZWN0aW9uLnN0eWxlO1xuICBjb25zdCBpc0NvbGxhcHNlZCA9IG5leHRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKTtcbiAgbGV0IG5leHRBbmNob3JOb2RlID0gYW5jaG9yRE9NO1xuICBsZXQgbmV4dEZvY3VzTm9kZSA9IGZvY3VzRE9NO1xuICBsZXQgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICBuZXh0QW5jaG9yTm9kZSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSBhbmNob3JOb2RlLmdldEZvcm1hdCgpICE9PSBuZXh0Rm9ybWF0IHx8IGFuY2hvck5vZGUuZ2V0U3R5bGUoKSAhPT0gbmV4dFN0eWxlO1xuICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGFuY2hvckZvcm1hdE9yU3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgfVxuICBpZiAoZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgbmV4dEZvY3VzTm9kZSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuXG4gIC8vIElmIHdlIGNhbid0IGdldCBhbiB1bmRlcmx5aW5nIHRleHQgbm9kZSBmb3Igc2VsZWN0aW9uLCB0aGVuXG4gIC8vIHdlIHNob3VsZCBhdm9pZCBzZXR0aW5nIHNlbGVjdGlvbiB0byBzb21ldGhpbmcgaW5jb3JyZWN0LlxuICBpZiAobmV4dEFuY2hvck5vZGUgPT09IG51bGwgfHwgbmV4dEZvY3VzTm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNDb2xsYXBzZWQgJiYgKHByZXZTZWxlY3Rpb24gPT09IG51bGwgfHwgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgfHwgJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgKHByZXZTZWxlY3Rpb24uZm9ybWF0ICE9PSBuZXh0Rm9ybWF0IHx8IHByZXZTZWxlY3Rpb24uc3R5bGUgIT09IG5leHRTdHlsZSkpKSB7XG4gICAgbWFya0NvbGxhcHNlZFNlbGVjdGlvbkZvcm1hdChuZXh0Rm9ybWF0LCBuZXh0U3R5bGUsIG5leHRBbmNob3JPZmZzZXQsIGFuY2hvcktleSwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICB9XG5cbiAgLy8gRGlmZiBhZ2FpbnN0IHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiB0byBlbnN1cmUgd2UgZG9uJ3QgZG9cbiAgLy8gYW4gdW5uZWNlc3Nhcnkgc2VsZWN0aW9uIHVwZGF0ZS4gV2UgYWxzbyBza2lwIHRoaXMgY2hlY2sgaWZcbiAgLy8gd2UncmUgbW92aW5nIHNlbGVjdGlvbiB0byB3aXRoaW4gYW4gZWxlbWVudCwgYXMgdGhpcyBjYW5cbiAgLy8gc29tZXRpbWVzIGJlIHByb2JsZW1hdGljIGFyb3VuZCBzY3JvbGxpbmcuXG4gIGlmIChhbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgJiYgZm9jdXNPZmZzZXQgPT09IG5leHRGb2N1c09mZnNldCAmJiBhbmNob3JET01Ob2RlID09PSBuZXh0QW5jaG9yTm9kZSAmJiBmb2N1c0RPTU5vZGUgPT09IG5leHRGb2N1c05vZGUgJiZcbiAgLy8gQmFkbHkgaW50ZXJwcmV0ZWQgcmFuZ2Ugc2VsZWN0aW9uIHdoZW4gY29sbGFwc2VkIC0gIzE0ODJcbiAgIShkb21TZWxlY3Rpb24udHlwZSA9PT0gJ1JhbmdlJyAmJiBpc0NvbGxhcHNlZCkpIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBlbGVtZW50IGRvZXMgbm90IGhhdmUgZm9jdXMsIGVuc3VyZSBpdCBoYXMgZm9jdXNcbiAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gbnVsbCB8fCAhcm9vdEVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHJvb3RFbGVtZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmNob3IudHlwZSAhPT0gJ2VsZW1lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwbHkgdGhlIHVwZGF0ZWQgc2VsZWN0aW9uIHRvIHRoZSBET00uIE5vdGU6IHRoaXMgd2lsbCB0cmlnZ2VyXG4gIC8vIGEgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCwgYWx0aG91Z2ggaXQgd2lsbCBiZSBhc3luY2hyb25vdXMuXG4gIHRyeSB7XG4gICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV4dEFuY2hvck5vZGUsIG5leHRBbmNob3JPZmZzZXQsIG5leHRGb2N1c05vZGUsIG5leHRGb2N1c09mZnNldCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVycm9yLCBjb250aW51ZS4gVGhpcyBjYW4gc29tZXRpbWVzXG4gICAgLy8gb2NjdXIgd2l0aCBGRiBhbmQgdGhlcmUncyBubyBnb29kIHJlYXNvbiBhcyB0byB3aHkgaXRcbiAgICAvLyBzaG91bGQgaGFwcGVuLlxuICAgIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgfVxuICB9XG4gIGlmICghdGFncy5oYXMoJ3NraXAtc2Nyb2xsLWludG8tdmlldycpICYmIG5leHRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiByb290RWxlbWVudCAhPT0gbnVsbCAmJiByb290RWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdGlvblRhcmdldCA9IG5leHRTZWxlY3Rpb24gaW5zdGFuY2VvZiBSYW5nZVNlbGVjdGlvbiAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgPyBuZXh0QW5jaG9yTm9kZS5jaGlsZE5vZGVzW25leHRBbmNob3JPZmZzZXRdIHx8IG51bGwgOiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDAgPyBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG4gICAgaWYgKHNlbGVjdGlvblRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgbGV0IHNlbGVjdGlvblJlY3Q7XG4gICAgICBpZiAoc2VsZWN0aW9uVGFyZ2V0IGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoc2VsZWN0aW9uVGFyZ2V0KTtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWRpdG9yLCBzZWxlY3Rpb25SZWN0LCByb290RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIG1hcmtTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlKCk7XG59XG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgbGV0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSB8fCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbiA9ICRnZXRSb290KCkuc2VsZWN0RW5kKCk7XG4gIH1cbiAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbn1cbmZ1bmN0aW9uICRnZXRUZXh0Q29udGVudCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVUZXh0QW5kU3BsaXRCbG9jayhzZWxlY3Rpb24pIHtcbiAgbGV0IHNlbGVjdGlvbl8gPSBzZWxlY3Rpb247XG4gIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBzZWxlY3Rpb25fLnJlbW92ZVRleHQoKTtcbiAgfVxuICAvLyBBIG5ldyBzZWxlY3Rpb24gY2FuIG9yaWdpbmF0ZSBhcyBhIHJlc3VsdCBvZiBub2RlIHJlcGxhY2VtZW50LCBpbiB3aGljaCBjYXNlIGlzIHJlZ2lzdGVyZWQgdmlhXG4gIC8vICRzZXRTZWxlY3Rpb25cbiAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24obmV3U2VsZWN0aW9uKSkge1xuICAgIHNlbGVjdGlvbl8gPSBuZXdTZWxlY3Rpb247XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb25fKSkge1xuICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIGRpcnR5IHNlbGVjdGlvbiB0byBiZSBudWxsYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uXy5hbmNob3I7XG4gIGxldCBub2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIHdoaWxlICghSU5URVJOQUxfJGlzQmxvY2sobm9kZSkpIHtcbiAgICBbbm9kZSwgb2Zmc2V0XSA9ICRzcGxpdE5vZGVBdFBvaW50KG5vZGUsIG9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGVBdFBvaW50KG5vZGUsIG9mZnNldCkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAoIXBhcmVudCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgJGdldFJvb3QoKS5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICBwYXJhZ3JhcGguc2VsZWN0KCk7XG4gICAgcmV0dXJuIFskZ2V0Um9vdCgpLCAwXTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzcGxpdCA9IG5vZGUuc3BsaXRUZXh0KG9mZnNldCk7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtwYXJlbnQsIG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKV07XG4gICAgfVxuICAgIGNvbnN0IHggPSBvZmZzZXQgPT09IDAgPyAwIDogMTtcbiAgICBjb25zdCBpbmRleCA9IHNwbGl0WzBdLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyB4O1xuICAgIHJldHVybiBbcGFyZW50LCBpbmRleF07XG4gIH1cbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCBvZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gW3BhcmVudCwgbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpXTtcbiAgfVxuICBjb25zdCBmaXJzdFRvQXBwZW5kID0gbm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgaWYgKGZpcnN0VG9BcHBlbmQpIHtcbiAgICBjb25zdCBpbnNlcnRQb2ludCA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQobm9kZS5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpLCAkY3JlYXRlUG9pbnQobm9kZS5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpLCAwLCAnJyk7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IG5vZGUuaW5zZXJ0TmV3QWZ0ZXIoaW5zZXJ0UG9pbnQpO1xuICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICBuZXdFbGVtZW50LmFwcGVuZChmaXJzdFRvQXBwZW5kLCAuLi5maXJzdFRvQXBwZW5kLmdldE5leHRTaWJsaW5ncygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwYXJlbnQsIG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDFdO1xufVxuZnVuY3Rpb24gJHdyYXBJbmxpbmVOb2Rlcyhub2Rlcykge1xuICAvLyBXZSB0ZW1wb3JhcmlseSBpbnNlcnQgdGhlIHRvcExldmVsTm9kZXMgaW50byBhbiBhcmJpdHJhcnkgRWxlbWVudE5vZGUsXG4gIC8vIHNpbmNlIGluc2VydEFmdGVyIGRvZXMgbm90IHdvcmsgb24gbm9kZXMgdGhhdCBoYXZlIG5vIHBhcmVudCAoVE8tRE86IGZpeCB0aGF0KS5cbiAgY29uc3QgdmlydHVhbFJvb3QgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBsZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBjb25zdCBpc0xpbmVCcmVha05vZGUgPSAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpO1xuICAgIGlmIChpc0xpbmVCcmVha05vZGUgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc1RleHROb2RlKG5vZGUpIHx8IG5vZGUuaXNQYXJlbnRSZXF1aXJlZCgpKSB7XG4gICAgICBpZiAoY3VycmVudEJsb2NrID09PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jayA9IG5vZGUuY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKTtcbiAgICAgICAgdmlydHVhbFJvb3QuYXBwZW5kKGN1cnJlbnRCbG9jayk7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIExpbmVCcmVha05vZGUsIHdlIGp1c3QgbmVlZCB0b1xuICAgICAgICAvLyBhZGQgYW4gZW1wdHkgUGFyYWdyYXBoTm9kZSB0byB0aGUgdG9wTGV2ZWxCbG9ja3MuXG4gICAgICAgIGlmIChpc0xpbmVCcmVha05vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRCbG9jayAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50QmxvY2suYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aXJ0dWFsUm9vdC5hcHBlbmQobm9kZSk7XG4gICAgICBjdXJyZW50QmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmlydHVhbFJvb3Q7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxubGV0IGFjdGl2ZUVkaXRvclN0YXRlID0gbnVsbDtcbmxldCBhY3RpdmVFZGl0b3IgPSBudWxsO1xubGV0IGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG5sZXQgaXNBdHRlbXB0aW5nVG9SZWNvdmVyRnJvbVJlY29uY2lsZXJFcnJvciA9IGZhbHNlO1xubGV0IGluZmluaXRlVHJhbnNmb3JtQ291bnQgPSAwO1xuY29uc3Qgb2JzZXJ2ZXJPcHRpb25zID0ge1xuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG5mdW5jdGlvbiBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpIHtcbiAgcmV0dXJuIGlzUmVhZE9ubHlNb2RlIHx8IGFjdGl2ZUVkaXRvclN0YXRlICE9PSBudWxsICYmIGFjdGl2ZUVkaXRvclN0YXRlLl9yZWFkT25seTtcbn1cbmZ1bmN0aW9uIGVycm9yT25SZWFkT25seSgpIHtcbiAgaWYgKGlzUmVhZE9ubHlNb2RlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCB1c2UgbWV0aG9kIGluIHJlYWQtb25seSBtb2RlLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPbkluZmluaXRlVHJhbnNmb3JtcygpIHtcbiAgaWYgKGluZmluaXRlVHJhbnNmb3JtQ291bnQgPiA5OSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBPbmUgb3IgbW9yZSB0cmFuc2Zvcm1zIGFyZSBlbmRsZXNzbHkgdHJpZ2dlcmluZyBhZGRpdGlvbmFsIHRyYW5zZm9ybXMuIE1heSBoYXZlIGVuY291bnRlcmVkIGluZmluaXRlIHJlY3Vyc2lvbiBjYXVzZWQgYnkgdHJhbnNmb3JtcyB0aGF0IGhhdmUgdGhlaXIgcHJlY29uZGl0aW9ucyB0b28gbG9zZSBhbmQvb3IgY29uZmxpY3Qgd2l0aCBlYWNoIG90aGVyLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKSB7XG4gIGlmIChhY3RpdmVFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBhbiBhY3RpdmUgZWRpdG9yIHN0YXRlLiBTdGF0ZSBoZWxwZXJzIG9yIG5vZGUgbWV0aG9kcyBjYW4gb25seSBiZSB1c2VkIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSBjYWxsYmFjayBvZiBlZGl0b3IudXBkYXRlKCkgb3IgZWRpdG9yU3RhdGUucmVhZCgpLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWN0aXZlRWRpdG9yU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVFZGl0b3IoKSB7XG4gIGlmIChhY3RpdmVFZGl0b3IgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYW4gYWN0aXZlIGVkaXRvci4gVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBzeW5jaHJvbm91c2x5IGR1cmluZyB0aGUgY2FsbGJhY2sgb2YgZWRpdG9yLnVwZGF0ZSgpLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWN0aXZlRWRpdG9yO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxHZXRBY3RpdmVFZGl0b3IoKSB7XG4gIHJldHVybiBhY3RpdmVFZGl0b3I7XG59XG5mdW5jdGlvbiBpbnRlcm5hbEdldEFjdGl2ZUVkaXRvclN0YXRlKCkge1xuICByZXR1cm4gYWN0aXZlRWRpdG9yU3RhdGU7XG59XG5mdW5jdGlvbiAkYXBwbHlUcmFuc2Zvcm1zKGVkaXRvciwgbm9kZSwgdHJhbnNmb3Jtc0NhY2hlKSB7XG4gIGNvbnN0IHR5cGUgPSBub2RlLl9fdHlwZTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBnZXRSZWdpc3RlcmVkTm9kZU9yVGhyb3coZWRpdG9yLCB0eXBlKTtcbiAgbGV0IHRyYW5zZm9ybXNBcnIgPSB0cmFuc2Zvcm1zQ2FjaGUuZ2V0KHR5cGUpO1xuICBpZiAodHJhbnNmb3Jtc0FyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNmb3Jtc0FyciA9IEFycmF5LmZyb20ocmVnaXN0ZXJlZE5vZGUudHJhbnNmb3Jtcyk7XG4gICAgdHJhbnNmb3Jtc0NhY2hlLnNldCh0eXBlLCB0cmFuc2Zvcm1zQXJyKTtcbiAgfVxuICBjb25zdCB0cmFuc2Zvcm1zQXJyTGVuZ3RoID0gdHJhbnNmb3Jtc0Fyci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3Jtc0Fyckxlbmd0aDsgaSsrKSB7XG4gICAgdHJhbnNmb3Jtc0FycltpXShub2RlKTtcbiAgICBpZiAoIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRpc05vZGVWYWxpZEZvclRyYW5zZm9ybShub2RlLCBjb21wb3NpdGlvbktleSkge1xuICByZXR1cm4gbm9kZSAhPT0gdW5kZWZpbmVkICYmXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhbnNmb3JtIG5vZGVzIGJlaW5nIGNvbXBvc2VkXG4gIG5vZGUuX19rZXkgIT09IGNvbXBvc2l0aW9uS2V5ICYmIG5vZGUuaXNBdHRhY2hlZCgpO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZUFsbERpcnR5VGV4dE5vZGVzKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkgJiYgbm9kZS5pc0F0dGFjaGVkKCkgJiYgbm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICAgICRub3JtYWxpemVUZXh0Tm9kZShub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gaGV1cmlzdGljOlxuICogMS4gV2UgdHJhbnNmb3JtIGxlYXZlcyBmaXJzdC4gSWYgdHJhbnNmb3JtcyBnZW5lcmF0ZSBhZGRpdGlvbmFsIGRpcnR5IG5vZGVzIHdlIHJlcGVhdCBzdGVwIDEuXG4gKiBUaGUgcmVhc29uaW5nIGJlaGluZCB0aGlzIGlzIHRoYXQgbWFya2luZyBhIGxlYWYgYXMgZGlydHkgbWFya3MgYWxsIGl0cyBwYXJlbnQgZWxlbWVudHMgYXMgZGlydHkgdG9vLlxuICogMi4gV2UgdHJhbnNmb3JtIGVsZW1lbnRzLiBJZiBlbGVtZW50IHRyYW5zZm9ybXMgZ2VuZXJhdGUgYWRkaXRpb25hbCBkaXJ0eSBub2RlcyB3ZSByZXBlYXQgc3RlcCAxLlxuICogSWYgZWxlbWVudCB0cmFuc2Zvcm1zIG9ubHkgZ2VuZXJhdGUgYWRkaXRpb25hbCBkaXJ0eSBlbGVtZW50cyB3ZSBvbmx5IHJlcGVhdCBzdGVwIDIuXG4gKlxuICogTm90ZSB0aGF0IHRvIGtlZXAgdHJhY2sgb2YgbmV3bHkgZGlydHkgbm9kZXMgYW5kIHN1YnRyZWVzIHdlIGxldmVyYWdlIHRoZSBlZGl0b3IuX2RpcnR5Tm9kZXMgYW5kXG4gKiBlZGl0b3IuX3N1YnRyZWVzIHdoaWNoIHdlIHJlc2V0IGluIGV2ZXJ5IGxvb3AuXG4gKi9cbmZ1bmN0aW9uICRhcHBseUFsbFRyYW5zZm9ybXMoZWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gIGNvbnN0IGRpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgY29uc3QgdHJhbnNmb3Jtc0NhY2hlID0gbmV3IE1hcCgpO1xuICBsZXQgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzID0gZGlydHlMZWF2ZXM7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTtcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzID0gZGlydHlFbGVtZW50cztcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMuc2l6ZTtcbiAgd2hpbGUgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDAgfHwgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHNMZW5ndGggPiAwKSB7XG4gICAgaWYgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDApIHtcbiAgICAgIC8vIFdlIGxldmVyYWdlIGVkaXRvci5fZGlydHlMZWF2ZXMgdG8gdHJhY2sgdGhlIG5ldyBkaXJ0eSBsZWF2ZXMgYWZ0ZXIgdGhlIHRyYW5zZm9ybXNcbiAgICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaXNBdHRhY2hlZCgpICYmIG5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgICAgICAgJG5vcm1hbGl6ZVRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgJGlzTm9kZVZhbGlkRm9yVHJhbnNmb3JtKG5vZGUsIGNvbXBvc2l0aW9uS2V5KSkge1xuICAgICAgICAgICRhcHBseVRyYW5zZm9ybXMoZWRpdG9yLCBub2RlLCB0cmFuc2Zvcm1zQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGRpcnR5TGVhdmVzLmFkZChub2RlS2V5KTtcbiAgICAgIH1cbiAgICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTtcblxuICAgICAgLy8gV2Ugd2FudCB0byBwcmlvcml0aXplIG5vZGUgdHJhbnNmb3JtcyBvdmVyIGVsZW1lbnQgdHJhbnNmb3Jtc1xuICAgICAgaWYgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDApIHtcbiAgICAgICAgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGwgZGlydHkgbGVhdmVzIGhhdmUgYmVlbiBwcm9jZXNzZWQuIExldCdzIGRvIGVsZW1lbnRzIVxuICAgIC8vIFdlIGhhdmUgcHJldmlvdXNseSBwcm9jZXNzZWQgZGlydHkgbGVhdmVzLCBzbyBsZXQncyByZXN0YXJ0IHRoZSBlZGl0b3IgbGVhdmVzIFNldCB0byB0cmFja1xuICAgIC8vIG5ldyBvbmVzIGNhdXNlZCBieSBlbGVtZW50IHRyYW5zZm9ybXNcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRVbnRyYW5zZm9ybWVkRGlydHlFbGVtZW50IG9mIHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBub2RlS2V5ID0gY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRbMF07XG4gICAgICBjb25zdCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSA9IGN1cnJlbnRVbnRyYW5zZm9ybWVkRGlydHlFbGVtZW50WzFdO1xuICAgICAgaWYgKG5vZGVLZXkgIT09ICdyb290JyAmJiAhaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICRpc05vZGVWYWxpZEZvclRyYW5zZm9ybShub2RlLCBjb21wb3NpdGlvbktleSkpIHtcbiAgICAgICAgJGFwcGx5VHJhbnNmb3JtcyhlZGl0b3IsIG5vZGUsIHRyYW5zZm9ybXNDYWNoZSk7XG4gICAgICB9XG4gICAgICBkaXJ0eUVsZW1lbnRzLnNldChub2RlS2V5LCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSk7XG4gICAgfVxuICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzLnNpemU7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cy5zaXplO1xuICAgIGluZmluaXRlVHJhbnNmb3JtQ291bnQrKztcbiAgfVxuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gZGlydHlMZWF2ZXM7XG4gIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IGRpcnR5RWxlbWVudHM7XG59XG5mdW5jdGlvbiAkcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSkge1xuICBjb25zdCBpbnRlcm5hbFNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGU7XG4gIHJldHVybiAkcGFyc2VTZXJpYWxpemVkTm9kZUltcGwoaW50ZXJuYWxTZXJpYWxpemVkTm9kZSwgZ2V0QWN0aXZlRWRpdG9yKCkuX25vZGVzKTtcbn1cbmZ1bmN0aW9uICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChzZXJpYWxpemVkTm9kZSwgcmVnaXN0ZXJlZE5vZGVzKSB7XG4gIGNvbnN0IHR5cGUgPSBzZXJpYWxpemVkTm9kZS50eXBlO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHJlZ2lzdGVyZWROb2Rlcy5nZXQodHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHBhcnNlRWRpdG9yU3RhdGU6IHR5cGUgXCIke3R5cGV9XCIgKyBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9kZUNsYXNzID0gcmVnaXN0ZXJlZE5vZGUua2xhc3M7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaW1wb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICBjb25zdCBub2RlID0gbm9kZUNsYXNzLmltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpO1xuICBjb25zdCBjaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkSlNPTkNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWRKU09OQ2hpbGROb2RlLCByZWdpc3RlcmVkTm9kZXMpO1xuICAgICAgbm9kZS5hcHBlbmQoY2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBwYXJzZUVkaXRvclN0YXRlKHNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSwgZWRpdG9yLCB1cGRhdGVGbikge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNEaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBwcmV2aW91c0RpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgY29uc3QgcHJldmlvdXNDbG9uZU5vdE5lZWRlZCA9IGVkaXRvci5fY2xvbmVOb3ROZWVkZWQ7XG4gIGNvbnN0IHByZXZpb3VzRGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZCA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSAwO1xuICBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGVzID0gZWRpdG9yLl9ub2RlcztcbiAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZWRFZGl0b3JTdGF0ZS5yb290O1xuICAgICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChzZXJpYWxpemVkTm9kZSwgcmVnaXN0ZXJlZE5vZGVzKTtcbiAgICBpZiAodXBkYXRlRm4pIHtcbiAgICAgIHVwZGF0ZUZuKCk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgZWRpdG9yU3RhdGUgaW1tdXRhYmxlXG4gICAgZWRpdG9yU3RhdGUuX3JlYWRPbmx5ID0gdHJ1ZTtcbiAgICB7XG4gICAgICBoYW5kbGVERVZPbmx5UGVuZGluZ1VwZGF0ZUd1YXJhbnRlZXMoZWRpdG9yU3RhdGUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZWRpdG9yLl9vbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gcHJldmlvdXNEaXJ0eUVsZW1lbnRzO1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBwcmV2aW91c0RpcnR5TGVhdmVzO1xuICAgIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQgPSBwcmV2aW91c0Nsb25lTm90TmVlZGVkO1xuICAgIGVkaXRvci5fZGlydHlUeXBlID0gcHJldmlvdXNEaXJ0eVR5cGU7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIGlzUmVhZE9ubHlNb2RlID0gcHJldmlvdXNSZWFkT25seU1vZGU7XG4gICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gIH1cbiAgcmV0dXJuIGVkaXRvclN0YXRlO1xufVxuXG4vLyBUaGlzIHRlY2huaWNhbGx5IGlzbid0IGFuIHVwZGF0ZSBidXQgZ2l2ZW4gd2UgbmVlZFxuLy8gZXhwb3N1cmUgdG8gdGhlIG1vZHVsZSdzIGFjdGl2ZSBiaW5kaW5ncywgd2UgaGF2ZSB0aGlzXG4vLyBmdW5jdGlvbiBoZXJlXG5cbmZ1bmN0aW9uIHJlYWRFZGl0b3JTdGF0ZShlZGl0b3JTdGF0ZSwgY2FsbGJhY2tGbikge1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IHRydWU7XG4gIGFjdGl2ZUVkaXRvciA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrRm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlREVWT25seVBlbmRpbmdVcGRhdGVHdWFyYW50ZWVzKHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICAvLyBHaXZlbiB3ZSBjYW4ndCBPYmplY3QuZnJlZXplIHRoZSBub2RlTWFwIGFzIGl0J3MgYSBNYXAsXG4gIC8vIHdlIGluc3RlYWQgcmVwbGFjZSBpdHMgc2V0LCBjbGVhciBhbmQgZGVsZXRlIG1ldGhvZHMuXG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIG5vZGVNYXAuc2V0ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgc2V0KCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xuICBub2RlTWFwLmNsZWFyID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgY2xlYXIoKSBvbiBhIGZyb3plbiBMZXhpY2FsIG5vZGUgbWFwJyk7XG4gIH07XG4gIG5vZGVNYXAuZGVsZXRlID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgZGVsZXRlKCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xufVxuZnVuY3Rpb24gJGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvciwgcmVjb3ZlcnlFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICBjb25zdCBzaG91bGRTa2lwRE9NID0gZWRpdG9yLl9oZWFkbGVzcyB8fCByb290RWxlbWVudCA9PT0gbnVsbDtcbiAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vID09PT09PVxuICAvLyBSZWNvbmNpbGlhdGlvbiBoYXMgc3RhcnRlZC5cbiAgLy8gPT09PT09XG5cbiAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IG5lZWRzVXBkYXRlID0gZWRpdG9yLl9kaXJ0eVR5cGUgIT09IE5PX0RJUlRZX05PREVTO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGxldCBtdXRhdGVkTm9kZXMgPSBudWxsO1xuICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gIGVkaXRvci5fZWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlmICghc2hvdWxkU2tpcERPTSAmJiBuZWVkc1VwZGF0ZSAmJiBvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdXBkYXRlcyB0byBzeW5jIGJsb2NrIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gICAgICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgICAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRlZE5vZGVzID0gJHJlY29uY2lsZVJvb3QoY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvciwgZGlydHlUeXBlLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFJlcG9ydCBlcnJvcnNcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVkaXRvci5fb25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IGVkaXRvciBhbmQgcmVzdG9yZSBpbmNvbWluZyBlZGl0b3Igc3RhdGUgdG8gdGhlIERPTVxuICAgICAgaWYgKCFpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yKSB7XG4gICAgICAgIHJlc2V0RWRpdG9yKGVkaXRvciwgbnVsbCwgcm9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gICAgICAgIGluaXRNdXRhdGlvbk9ic2VydmVyKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgICAgIGlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IgPSB0cnVlO1xuICAgICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICBpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUbyBhdm9pZCBhIHBvc3NpYmxlIHNpdHVhdGlvbiBvZiBpbmZpbml0ZSBsb29wcywgbGV0cyB0aHJvd1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgfVxuICB9XG4gIGlmICghcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHtcbiAgICAgIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUocGVuZGluZ1NlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHBlbmRpbmdTZWxlY3Rpb24uZm9jdXMpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBub3JtYWxpemVkTm9kZXMgPSBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcztcbiAgY29uc3QgdGFncyA9IGVkaXRvci5fdXBkYXRlVGFncztcbiAgY29uc3QgZGVmZXJyZWQgPSBlZGl0b3IuX2RlZmVycmVkO1xuICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICAgIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQuY2xlYXIoKTtcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gIH1cbiAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKTtcblxuICAvLyA9PT09PT1cbiAgLy8gUmVjb25jaWxpYXRpb24gaGFzIGZpbmlzaGVkLiBOb3cgdXBkYXRlIHNlbGVjdGlvbiBhbmQgdHJpZ2dlciBsaXN0ZW5lcnMuXG4gIC8vID09PT09PVxuXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IHNob3VsZFNraXBET00gPyBudWxsIDogZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICAvLyBBdHRlbXB0IHRvIHVwZGF0ZSB0aGUgRE9NIHNlbGVjdGlvbiwgaW5jbHVkaW5nIGZvY3VzaW5nIG9mIHRoZSByb290IGVsZW1lbnQsXG4gIC8vIGFuZCBzY3JvbGwgaW50byB2aWV3IGlmIG5lZWRlZC5cbiAgaWYgKGVkaXRvci5fZWRpdGFibGUgJiZcbiAgLy8gZG9tU2VsZWN0aW9uIHdpbGwgYmUgbnVsbCBpbiBoZWFkbGVzc1xuICBkb21TZWxlY3Rpb24gIT09IG51bGwgJiYgKG5lZWRzVXBkYXRlIHx8IHBlbmRpbmdTZWxlY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSkpIHtcbiAgICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNVcGRhdGUgfHwgcGVuZGluZ1NlbGVjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nU2VsZWN0aW9uLmRpcnR5KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgICAgICBpZiAoYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlRE9NU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24sIHBlbmRpbmdTZWxlY3Rpb24sIGVkaXRvciwgZG9tU2VsZWN0aW9uLCB0YWdzLCByb290RWxlbWVudCk7XG4gICAgICB9XG4gICAgICB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgcGVuZGluZ1NlbGVjdGlvbik7XG4gICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgfVxuICB9XG4gIGlmIChtdXRhdGVkTm9kZXMgIT09IG51bGwpIHtcbiAgICB0cmlnZ2VyTXV0YXRpb25MaXN0ZW5lcnMoZWRpdG9yLCBtdXRhdGVkTm9kZXMsIHRhZ3MsIGRpcnR5TGVhdmVzLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICB9XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24ocGVuZGluZ1NlbGVjdGlvbikgJiYgcGVuZGluZ1NlbGVjdGlvbiAhPT0gbnVsbCAmJiAoY3VycmVudFNlbGVjdGlvbiA9PT0gbnVsbCB8fCAhY3VycmVudFNlbGVjdGlvbi5pcyhwZW5kaW5nU2VsZWN0aW9uKSkpIHtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcbiAgICogQ2FwdHVyZSBwZW5kaW5nRGVjb3JhdG9ycyBhZnRlciBnYXJiYWdlIGNvbGxlY3RpbmcgZGV0YWNoZWQgZGVjb3JhdG9yc1xuICAgKi9cbiAgY29uc3QgcGVuZGluZ0RlY29yYXRvcnMgPSBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzO1xuICBpZiAocGVuZGluZ0RlY29yYXRvcnMgIT09IG51bGwpIHtcbiAgICBlZGl0b3IuX2RlY29yYXRvcnMgPSBwZW5kaW5nRGVjb3JhdG9ycztcbiAgICBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzID0gbnVsbDtcbiAgICB0cmlnZ2VyTGlzdGVuZXJzKCdkZWNvcmF0b3InLCBlZGl0b3IsIHRydWUsIHBlbmRpbmdEZWNvcmF0b3JzKTtcbiAgfVxuXG4gIC8vIElmIHJlY29uY2lsZXIgZmFpbHMsIHdlIHJlc2V0IHdob2xlIGVkaXRvciAoc28gY3VycmVudCBlZGl0b3Igc3RhdGUgYmVjb21lcyBlbXB0eSlcbiAgLy8gYW5kIGF0dGVtcHQgdG8gcmUtcmVuZGVyIHBlbmRpbmdFZGl0b3JTdGF0ZS4gSWYgdGhhdCBnb2VzIHRocm91Z2ggd2UgdHJpZ2dlclxuICAvLyBsaXN0ZW5lcnMsIGJ1dCBpbnN0ZWFkIHVzZSByZWNvdmVyRWRpdG9yU3RhdGUgd2hpY2ggaXMgY3VycmVudCBlZGl0b3Igc3RhdGUgYmVmb3JlIHJlc2V0XG4gIC8vIFRoaXMgc3BlY2lmaWNhbGx5IGltcG9ydGFudCBmb3IgY29sbGFiIHRoYXQgcmVsaWVzIG9uIHByZXZFZGl0b3JTdGF0ZSBmcm9tIHVwZGF0ZVxuICAvLyBsaXN0ZW5lciB0byBjYWxjdWxhdGUgZGVsdGEgb2YgY2hhbmdlZCBub2Rlcy9wcm9wZXJ0aWVzXG4gIHRyaWdnZXJUZXh0Q29udGVudExpc3RlbmVycyhlZGl0b3IsIHJlY292ZXJ5RWRpdG9yU3RhdGUgfHwgY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICB0cmlnZ2VyTGlzdGVuZXJzKCd1cGRhdGUnLCBlZGl0b3IsIHRydWUsIHtcbiAgICBkaXJ0eUVsZW1lbnRzLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGVkaXRvclN0YXRlOiBwZW5kaW5nRWRpdG9yU3RhdGUsXG4gICAgbm9ybWFsaXplZE5vZGVzLFxuICAgIHByZXZFZGl0b3JTdGF0ZTogcmVjb3ZlcnlFZGl0b3JTdGF0ZSB8fCBjdXJyZW50RWRpdG9yU3RhdGUsXG4gICAgdGFnc1xuICB9KTtcbiAgdHJpZ2dlckRlZmVycmVkVXBkYXRlQ2FsbGJhY2tzKGVkaXRvciwgZGVmZXJyZWQpO1xuICAkdHJpZ2dlckVucXVldWVkVXBkYXRlcyhlZGl0b3IpO1xufVxuZnVuY3Rpb24gdHJpZ2dlclRleHRDb250ZW50TGlzdGVuZXJzKGVkaXRvciwgY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgY3VycmVudFRleHRDb250ZW50ID0gZ2V0RWRpdG9yU3RhdGVUZXh0Q29udGVudChjdXJyZW50RWRpdG9yU3RhdGUpO1xuICBjb25zdCBsYXRlc3RUZXh0Q29udGVudCA9IGdldEVkaXRvclN0YXRlVGV4dENvbnRlbnQocGVuZGluZ0VkaXRvclN0YXRlKTtcbiAgaWYgKGN1cnJlbnRUZXh0Q29udGVudCAhPT0gbGF0ZXN0VGV4dENvbnRlbnQpIHtcbiAgICB0cmlnZ2VyTGlzdGVuZXJzKCd0ZXh0Y29udGVudCcsIGVkaXRvciwgdHJ1ZSwgbGF0ZXN0VGV4dENvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyTXV0YXRpb25MaXN0ZW5lcnMoZWRpdG9yLCBtdXRhdGVkTm9kZXMsIHVwZGF0ZVRhZ3MsIGRpcnR5TGVhdmVzLCBwcmV2RWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gQXJyYXkuZnJvbShlZGl0b3IuX2xpc3RlbmVycy5tdXRhdGlvbik7XG4gIGNvbnN0IGxpc3RlbmVyc0xlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbbGlzdGVuZXIsIGtsYXNzXSA9IGxpc3RlbmVyc1tpXTtcbiAgICBjb25zdCBtdXRhdGVkTm9kZXNCeVR5cGUgPSBtdXRhdGVkTm9kZXMuZ2V0KGtsYXNzKTtcbiAgICBpZiAobXV0YXRlZE5vZGVzQnlUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpc3RlbmVyKG11dGF0ZWROb2Rlc0J5VHlwZSwge1xuICAgICAgICBkaXJ0eUxlYXZlcyxcbiAgICAgICAgcHJldkVkaXRvclN0YXRlLFxuICAgICAgICB1cGRhdGVUYWdzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJMaXN0ZW5lcnModHlwZSwgZWRpdG9yLCBpc0N1cnJlbnRseUVucXVldWluZ1VwZGF0ZXMsIC4uLnBheWxvYWQpIHtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgZWRpdG9yLl91cGRhdGluZyA9IGlzQ3VycmVudGx5RW5xdWV1aW5nVXBkYXRlcztcbiAgdHJ5IHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGVkaXRvci5fbGlzdGVuZXJzW3R5cGVdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KG51bGwsIHBheWxvYWQpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gcHJldmlvdXNseVVwZGF0aW5nO1xuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyQ29tbWFuZExpc3RlbmVycyhlZGl0b3IsIHR5cGUsIHBheWxvYWQpIHtcbiAgaWYgKGVkaXRvci5fdXBkYXRpbmcgPT09IGZhbHNlIHx8IGFjdGl2ZUVkaXRvciAhPT0gZWRpdG9yKSB7XG4gICAgbGV0IHJldHVyblZhbCA9IGZhbHNlO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgcmV0dXJuVmFsID0gdHJpZ2dlckNvbW1hbmRMaXN0ZW5lcnMoZWRpdG9yLCB0eXBlLCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsO1xuICB9XG4gIGNvbnN0IGVkaXRvcnMgPSBnZXRFZGl0b3JzVG9Qcm9wYWdhdGUoZWRpdG9yKTtcbiAgZm9yIChsZXQgaSA9IDQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCBlZGl0b3JzLmxlbmd0aDsgZSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gZWRpdG9yc1tlXTtcbiAgICAgIGNvbnN0IGNvbW1hbmRMaXN0ZW5lcnMgPSBjdXJyZW50RWRpdG9yLl9jb21tYW5kcztcbiAgICAgIGNvbnN0IGxpc3RlbmVySW5Qcmlvcml0eU9yZGVyID0gY29tbWFuZExpc3RlbmVycy5nZXQodHlwZSk7XG4gICAgICBpZiAobGlzdGVuZXJJblByaW9yaXR5T3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnNTZXQgPSBsaXN0ZW5lckluUHJpb3JpdHlPcmRlcltpXTtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1NldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gQXJyYXkuZnJvbShsaXN0ZW5lcnNTZXQpO1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVyc0xlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaXN0ZW5lcnNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tqXShwYXlsb2FkLCBlZGl0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkdHJpZ2dlckVucXVldWVkVXBkYXRlcyhlZGl0b3IpIHtcbiAgY29uc3QgcXVldWVkVXBkYXRlcyA9IGVkaXRvci5fdXBkYXRlcztcbiAgaWYgKHF1ZXVlZFVwZGF0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgcXVldWVkVXBkYXRlID0gcXVldWVkVXBkYXRlcy5zaGlmdCgpO1xuICAgIGlmIChxdWV1ZWRVcGRhdGUpIHtcbiAgICAgIGNvbnN0IFt1cGRhdGVGbiwgb3B0aW9uc10gPSBxdWV1ZWRVcGRhdGU7XG4gICAgICAkYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRGVmZXJyZWRVcGRhdGVDYWxsYmFja3MoZWRpdG9yLCBkZWZlcnJlZCkge1xuICBlZGl0b3IuX2RlZmVycmVkID0gW107XG4gIGlmIChkZWZlcnJlZC5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlZmVycmVkW2ldKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IsIGluaXRpYWxTa2lwVHJhbnNmb3Jtcykge1xuICBjb25zdCBxdWV1ZWRVcGRhdGVzID0gZWRpdG9yLl91cGRhdGVzO1xuICBsZXQgc2tpcFRyYW5zZm9ybXMgPSBpbml0aWFsU2tpcFRyYW5zZm9ybXMgfHwgZmFsc2U7XG5cbiAgLy8gVXBkYXRlcyBtaWdodCBncm93IGFzIHdlIHByb2Nlc3MgdGhlbSwgd2Ugc28gd2UnbGwgbmVlZFxuICAvLyB0byBoYW5kbGUgZWFjaCB1cGRhdGUgYXMgd2UgZ28gdW50aWwgdGhlIHVwZGF0ZXMgYXJyYXkgaXNcbiAgLy8gZW1wdHkuXG4gIHdoaWxlIChxdWV1ZWRVcGRhdGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IHF1ZXVlZFVwZGF0ZSA9IHF1ZXVlZFVwZGF0ZXMuc2hpZnQoKTtcbiAgICBpZiAocXVldWVkVXBkYXRlKSB7XG4gICAgICBjb25zdCBbbmV4dFVwZGF0ZUZuLCBvcHRpb25zXSA9IHF1ZXVlZFVwZGF0ZTtcbiAgICAgIGxldCBvblVwZGF0ZTtcbiAgICAgIGxldCB0YWc7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICAgICAgdGFnID0gb3B0aW9ucy50YWc7XG4gICAgICAgIGlmIChvcHRpb25zLnNraXBUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgc2tpcFRyYW5zZm9ybXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICAgIGVkaXRvci5fZGVmZXJyZWQucHVzaChvblVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgIGVkaXRvci5fdXBkYXRlVGFncy5hZGQodGFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dFVwZGF0ZUZuKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBza2lwVHJhbnNmb3Jtcztcbn1cbmZ1bmN0aW9uICRiZWdpblVwZGF0ZShlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZVRhZ3MgPSBlZGl0b3IuX3VwZGF0ZVRhZ3M7XG4gIGxldCBvblVwZGF0ZTtcbiAgbGV0IHRhZztcbiAgbGV0IHNraXBUcmFuc2Zvcm1zID0gZmFsc2U7XG4gIGxldCBkaXNjcmV0ZSA9IGZhbHNlO1xuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIHRhZyA9IG9wdGlvbnMudGFnO1xuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlVGFncy5hZGQodGFnKTtcbiAgICB9XG4gICAgc2tpcFRyYW5zZm9ybXMgPSBvcHRpb25zLnNraXBUcmFuc2Zvcm1zIHx8IGZhbHNlO1xuICAgIGRpc2NyZXRlID0gb3B0aW9ucy5kaXNjcmV0ZSB8fCBmYWxzZTtcbiAgfVxuICBpZiAob25VcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RlZmVycmVkLnB1c2gob25VcGRhdGUpO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gIGxldCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgbGV0IGVkaXRvclN0YXRlV2FzQ2xvbmVkID0gZmFsc2U7XG4gIGlmIChwZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwgfHwgcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gY2xvbmVFZGl0b3JTdGF0ZShwZW5kaW5nRWRpdG9yU3RhdGUgfHwgY3VycmVudEVkaXRvclN0YXRlKTtcbiAgICBlZGl0b3JTdGF0ZVdhc0Nsb25lZCA9IHRydWU7XG4gIH1cbiAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSBkaXNjcmV0ZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG4gIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHRyeSB7XG4gICAgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICBpZiAoZWRpdG9yLl9oZWFkbGVzcykge1xuICAgICAgICBpZiAoY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gJGludGVybmFsQ3JlYXRlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0aW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIHVwZGF0ZUZuKCk7XG4gICAgc2tpcFRyYW5zZm9ybXMgPSBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IsIHNraXBUcmFuc2Zvcm1zKTtcbiAgICBhcHBseVNlbGVjdGlvblRyYW5zZm9ybXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICAgIGlmIChlZGl0b3IuX2RpcnR5VHlwZSAhPT0gTk9fRElSVFlfTk9ERVMpIHtcbiAgICAgIGlmIChza2lwVHJhbnNmb3Jtcykge1xuICAgICAgICAkbm9ybWFsaXplQWxsRGlydHlUZXh0Tm9kZXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGFwcGx5QWxsVHJhbnNmb3JtcyhwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IpO1xuICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWROb2RlcyhjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yLl9kaXJ0eUxlYXZlcywgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgZW5kaW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIGlmIChzdGFydGluZ0NvbXBvc2l0aW9uS2V5ICE9PSBlbmRpbmdDb21wb3NpdGlvbktleSkge1xuICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwZW5kaW5nTm9kZU1hcCA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICAgIGNvbnN0IGFuY2hvcktleSA9IHBlbmRpbmdTZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICAgIGNvbnN0IGZvY3VzS2V5ID0gcGVuZGluZ1NlbGVjdGlvbi5mb2N1cy5rZXk7XG4gICAgICBpZiAocGVuZGluZ05vZGVNYXAuZ2V0KGFuY2hvcktleSkgPT09IHVuZGVmaW5lZCB8fCBwZW5kaW5nTm9kZU1hcC5nZXQoZm9jdXNLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGB1cGRhdGVFZGl0b3I6IHNlbGVjdGlvbiBoYXMgYmVlbiBsb3N0IGJlY2F1c2UgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYW5kIHNlbGVjdGlvbiB3YXNuJ3QgbW92ZWQgdG8gYW5vdGhlciBub2RlLiBFbnN1cmUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgcmVtb3ZpbmcvcmVwbGFjaW5nIGEgc2VsZWN0ZWQgbm9kZS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzTm9kZVNlbGVjdGlvbihwZW5kaW5nU2VsZWN0aW9uKSkge1xuICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsc28gdmFsaWRhdGUgbm9kZSBzZWxlY3Rpb24/XG4gICAgICBpZiAocGVuZGluZ1NlbGVjdGlvbi5fbm9kZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFJlcG9ydCBlcnJvcnNcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZWRpdG9yLl9vbkVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIGV4aXN0aW5nIGVkaXRvciBzdGF0ZSB0byB0aGUgRE9NXG4gICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBjdXJyZW50RWRpdG9yU3RhdGU7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkLmNsZWFyKCk7XG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMuY2xlYXIoKTtcbiAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIGlzUmVhZE9ubHlNb2RlID0gcHJldmlvdXNSZWFkT25seU1vZGU7XG4gICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgZWRpdG9yLl91cGRhdGluZyA9IHByZXZpb3VzbHlVcGRhdGluZztcbiAgICBpbmZpbml0ZVRyYW5zZm9ybUNvdW50ID0gMDtcbiAgfVxuICBjb25zdCBzaG91bGRVcGRhdGUgPSBlZGl0b3IuX2RpcnR5VHlwZSAhPT0gTk9fRElSVFlfTk9ERVMgfHwgZWRpdG9yU3RhdGVIYXNEaXJ0eVNlbGVjdGlvbihwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICBpZiAocGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMpIHtcbiAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICBzY2hlZHVsZU1pY3JvVGFzaygoKSA9PiB7XG4gICAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyhlZGl0b3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICB1cGRhdGVUYWdzLmNsZWFyKCk7XG4gICAgICBlZGl0b3IuX2RlZmVycmVkID0gW107XG4gICAgICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVFZGl0b3IoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucykge1xuICBpZiAoZWRpdG9yLl91cGRhdGluZykge1xuICAgIGVkaXRvci5fdXBkYXRlcy5wdXNoKFt1cGRhdGVGbiwgb3B0aW9uc10pO1xuICB9IGVsc2Uge1xuICAgICRiZWdpblVwZGF0ZShlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBFbGVtZW50Tm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fZmlyc3QgPSBudWxsO1xuICAgIHRoaXMuX19sYXN0ID0gbnVsbDtcbiAgICB0aGlzLl9fc2l6ZSA9IDA7XG4gICAgdGhpcy5fX2Zvcm1hdCA9IDA7XG4gICAgdGhpcy5fX2luZGVudCA9IDA7XG4gICAgdGhpcy5fX2RpciA9IG51bGw7XG4gIH1cbiAgZ2V0Rm9ybWF0KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZm9ybWF0O1xuICB9XG4gIGdldEZvcm1hdFR5cGUoKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRGb3JtYXQoKTtcbiAgICByZXR1cm4gRUxFTUVOVF9GT1JNQVRfVE9fVFlQRVtmb3JtYXRdIHx8ICcnO1xuICB9XG4gIGdldEluZGVudCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2luZGVudDtcbiAgfVxuICBnZXRDaGlsZHJlbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBnZXRDaGlsZHJlbktleXMoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQuX19rZXkpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgZ2V0Q2hpbGRyZW5TaXplKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fc2l6ZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuU2l6ZSgpID09PSAwO1xuICB9XG4gIGlzRGlydHkoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3QgZGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgICByZXR1cm4gZGlydHlFbGVtZW50cyAhPT0gbnVsbCAmJiBkaXJ0eUVsZW1lbnRzLmhhcyh0aGlzLl9fa2V5KTtcbiAgfVxuICBpc0xhc3RDaGlsZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnRMYXN0Q2hpbGQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRMYXN0Q2hpbGQoKTtcbiAgICByZXR1cm4gcGFyZW50TGFzdENoaWxkICE9PSBudWxsICYmIHBhcmVudExhc3RDaGlsZC5pcyhzZWxmKTtcbiAgfVxuICBnZXRBbGxUZXh0Tm9kZXMoKSB7XG4gICAgY29uc3QgdGV4dE5vZGVzID0gW107XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHRleHROb2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgY29uc3Qgc3ViQ2hpbGRyZW5Ob2RlcyA9IGNoaWxkLmdldEFsbFRleHROb2RlcygpO1xuICAgICAgICB0ZXh0Tm9kZXMucHVzaCguLi5zdWJDaGlsZHJlbk5vZGVzKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHROb2RlcztcbiAgfVxuICBnZXRGaXJzdERlc2NlbmRhbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGdldExhc3REZXNjZW5kYW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0RGVzY2VuZGFudEJ5SW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAvLyBGb3Igbm9uLWVtcHR5IGVsZW1lbnQgbm9kZXMsIHdlIHJlc29sdmUgaXRzIGRlc2NlbmRhbnRcbiAgICAvLyAoZWl0aGVyIGEgbGVhZiBub2RlIG9yIHRoZSBib3R0b20tbW9zdCBlbGVtZW50KVxuICAgIGlmIChpbmRleCA+PSBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgY29uc3QgcmVzb2x2ZWROb2RlID0gY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiAkaXNFbGVtZW50Tm9kZShyZXNvbHZlZE5vZGUpICYmIHJlc29sdmVkTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZE5vZGUgPSBjaGlsZHJlbltpbmRleF07XG4gICAgcmV0dXJuICRpc0VsZW1lbnROb2RlKHJlc29sdmVkTm9kZSkgJiYgcmVzb2x2ZWROb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICB9XG4gIGdldEZpcnN0Q2hpbGQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgZmlyc3RLZXkgPSBzZWxmLl9fZmlyc3Q7XG4gICAgcmV0dXJuIGZpcnN0S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkoZmlyc3RLZXkpO1xuICB9XG4gIGdldEZpcnN0Q2hpbGRPclRocm93KCkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSBmaXJzdCBjaGlsZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gIH1cbiAgZ2V0TGFzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGxhc3RLZXkgPSBzZWxmLl9fbGFzdDtcbiAgICByZXR1cm4gbGFzdEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KGxhc3RLZXkpO1xuICB9XG4gIGdldExhc3RDaGlsZE9yVGhyb3coKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAobGFzdENoaWxkID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIGxhc3QgY2hpbGQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXN0Q2hpbGQ7XG4gIH1cbiAgZ2V0Q2hpbGRBdEluZGV4KGluZGV4KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGk7XG4gICAgaWYgKGluZGV4IDwgc2l6ZSAvIDIpIHtcbiAgICAgIG5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgaSA8PSBpbmRleCkge1xuICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbm9kZSA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgaSA9IHNpemUgLSAxO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkgPj0gaW5kZXgpIHtcbiAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB0ZXh0Q29udGVudCArPSBjaGlsZC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxuICBnZXRUZXh0Q29udGVudFNpemUoKSB7XG4gICAgbGV0IHRleHRDb250ZW50U2l6ZSA9IDA7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGV4dENvbnRlbnRTaXplICs9IGNoaWxkLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnRTaXplICs9IERPVUJMRV9MSU5FX0JSRUFLLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRDb250ZW50U2l6ZTtcbiAgfVxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19kaXI7XG4gIH1cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBFTEVNRU5UX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgICAgcmV0dXJuICh0aGlzLmdldEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE11dGF0b3JzXG5cbiAgc2VsZWN0KF9hbmNob3JPZmZzZXQsIF9mb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gICAgY29uc3QgY2hpbGRyZW5Db3VudCA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgaWYgKCF0aGlzLmNhbkJlRW1wdHkoKSkge1xuICAgICAgaWYgKF9hbmNob3JPZmZzZXQgPT09IDAgJiYgX2ZvY3VzT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQuc2VsZWN0KDAsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfYW5jaG9yT2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgX2FuY2hvck9mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkgJiYgKF9mb2N1c09mZnNldCA9PT0gdW5kZWZpbmVkIHx8IF9mb2N1c09mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkpIHtcbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGxhc3RDaGlsZCkgfHwgJGlzRWxlbWVudE5vZGUobGFzdENoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBsYXN0Q2hpbGQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuY2hvck9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbmNob3JPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cbiAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9jdXNPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuICRpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihrZXksIGFuY2hvck9mZnNldCwga2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnLCAnZWxlbWVudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChrZXksIGFuY2hvck9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoa2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gdGhpcy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICByZXR1cm4gZmlyc3ROb2RlID8gZmlyc3ROb2RlLnNlbGVjdFN0YXJ0KCkgOiB0aGlzLnNlbGVjdCgpO1xuICB9XG4gIHNlbGVjdEVuZCgpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICByZXR1cm4gbGFzdE5vZGUgPyBsYXN0Tm9kZS5zZWxlY3RFbmQoKSA6IHRoaXMuc2VsZWN0KCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucmVtb3ZlKCkpO1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UodGhpcy5nZXRDaGlsZHJlblNpemUoKSwgMCwgbm9kZXNUb0FwcGVuZCk7XG4gIH1cbiAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2RpciA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzZXRGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IHR5cGUgIT09ICcnID8gRUxFTUVOVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXSA6IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0SW5kZW50KGluZGVudExldmVsKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faW5kZW50ID0gaW5kZW50TGV2ZWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgbm9kZXNUb0luc2VydCkge1xuICAgIGNvbnN0IG5vZGVzVG9JbnNlcnRMZW5ndGggPSBub2Rlc1RvSW5zZXJ0Lmxlbmd0aDtcbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmS2V5ID0gd3JpdGFibGVTZWxmLl9fa2V5O1xuICAgIGNvbnN0IG5vZGVzVG9JbnNlcnRLZXlzID0gW107XG4gICAgY29uc3Qgbm9kZXNUb1JlbW92ZUtleXMgPSBbXTtcbiAgICBjb25zdCBub2RlQWZ0ZXJSYW5nZSA9IHRoaXMuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0ICsgZGVsZXRlQ291bnQpO1xuICAgIGxldCBub2RlQmVmb3JlUmFuZ2UgPSBudWxsO1xuICAgIGxldCBuZXdTaXplID0gb2xkU2l6ZSAtIGRlbGV0ZUNvdW50ICsgbm9kZXNUb0luc2VydExlbmd0aDtcbiAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgIGlmIChzdGFydCA9PT0gb2xkU2l6ZSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0KTtcbiAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWxldGVDb3VudCA+IDApIHtcbiAgICAgIGxldCBub2RlVG9EZWxldGUgPSBub2RlQmVmb3JlUmFuZ2UgPT09IG51bGwgPyB0aGlzLmdldEZpcnN0Q2hpbGQoKSA6IG5vZGVCZWZvcmVSYW5nZS5nZXROZXh0U2libGluZygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlVG9EZWxldGUgPT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgc3BsaWNlOiBzaWJsaW5nIG5vdCBmb3VuZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGVUb0RlbGV0ZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBjb25zdCBub2RlS2V5VG9EZWxldGUgPSBub2RlVG9EZWxldGUuX19rZXk7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvRGVsZXRlID0gbm9kZVRvRGVsZXRlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9EZWxldGUpO1xuICAgICAgICBub2Rlc1RvUmVtb3ZlS2V5cy5wdXNoKG5vZGVLZXlUb0RlbGV0ZSk7XG4gICAgICAgIG5vZGVUb0RlbGV0ZSA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJldk5vZGUgPSBub2RlQmVmb3JlUmFuZ2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvSW5zZXJ0TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVUb0luc2VydCA9IG5vZGVzVG9JbnNlcnRbaV07XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwgJiYgbm9kZVRvSW5zZXJ0LmlzKHByZXZOb2RlKSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBwcmV2Tm9kZSA9IHByZXZOb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlVG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuZ2V0V3JpdGFibGUoKTtcbiAgICAgIGlmICh3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIG5ld1NpemUtLTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgICAgY29uc3Qgbm9kZUtleVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgICAgaWYgKHByZXZOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHdyaXRhYmxlU2VsZi5fX2ZpcnN0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSB3cml0YWJsZVByZXZOb2RlLl9fa2V5O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVUb0luc2VydC5fX2tleSA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgYXBwZW5kOiBhdHRlbXB0aW5nIHRvIGFwcGVuZCBzZWxmYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBjaGlsZCBwYXJlbnQgdG8gc2VsZlxuICAgICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGZLZXk7XG4gICAgICBub2Rlc1RvSW5zZXJ0S2V5cy5wdXNoKG5vZGVLZXlUb0luc2VydCk7XG4gICAgICBwcmV2Tm9kZSA9IG5vZGVUb0luc2VydDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICsgZGVsZXRlQ291bnQgPT09IG9sZFNpemUpIHtcbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZOb2RlID0gcHJldk5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQcmV2Tm9kZS5fX25leHQgPSBudWxsO1xuICAgICAgICB3cml0YWJsZVNlbGYuX19sYXN0ID0gcHJldk5vZGUuX19rZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlQWZ0ZXJSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlQWZ0ZXJSYW5nZSA9IG5vZGVBZnRlclJhbmdlLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTm9kZUFmdGVyUmFuZ2UuX19wcmV2ID0gcHJldk5vZGUuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbm9kZUFmdGVyUmFuZ2UuX19rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZU5vZGVBZnRlclJhbmdlLl9fcHJldiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRhYmxlU2VsZi5fX3NpemUgPSBuZXdTaXplO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBkZWxldGlvbiB3ZSBuZWVkIHRvIGFkanVzdCBzZWxlY3Rpb24sIHVubGluayByZW1vdmVkIG5vZGVzXG4gICAgLy8gYW5kIGNsZWFuIHVwIG5vZGUgaXRzZWxmIGlmIGl0IGJlY29tZXMgZW1wdHkuIE5vbmUgb2YgdGhlc2UgbmVlZGVkXG4gICAgLy8gZm9yIGluc2VydGlvbi1vbmx5IGNhc2VzXG4gICAgaWYgKG5vZGVzVG9SZW1vdmVLZXlzLmxlbmd0aCkge1xuICAgICAgLy8gQWRqdXN0aW5nIHNlbGVjdGlvbiwgaW4gY2FzZSBub2RlIHRoYXQgd2FzIGFuY2hvci9mb2N1cyB3aWxsIGJlIGRlbGV0ZWRcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmVLZXlTZXQgPSBuZXcgU2V0KG5vZGVzVG9SZW1vdmVLZXlzKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb0luc2VydEtleVNldCA9IG5ldyBTZXQobm9kZXNUb0luc2VydEtleXMpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGZvY3VzXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmIChpc1BvaW50UmVtb3ZlZChhbmNob3IsIG5vZGVzVG9SZW1vdmVLZXlTZXQsIG5vZGVzVG9JbnNlcnRLZXlTZXQpKSB7XG4gICAgICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgYW5jaG9yLmdldE5vZGUoKSwgdGhpcywgbm9kZUJlZm9yZVJhbmdlLCBub2RlQWZ0ZXJSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUG9pbnRSZW1vdmVkKGZvY3VzLCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSkge1xuICAgICAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhmb2N1cywgZm9jdXMuZ2V0Tm9kZSgpLCB0aGlzLCBub2RlQmVmb3JlUmFuZ2UsIG5vZGVBZnRlclJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbnVwIGlmIG5vZGUgY2FuJ3QgYmUgZW1wdHlcbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDAgJiYgIXRoaXMuY2FuQmVFbXB0eSgpICYmICEkaXNSb290T3JTaGFkb3dSb290KHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG4gIC8vIEpTT04gc2VyaWFsaXphdGlvblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpLFxuICAgICAgaW5kZW50OiB0aGlzLmdldEluZGVudCgpLFxuICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgYXJlIGludGVuZGVkIHRvIGJlIGV4dGVuZHMgZm9yIHNwZWNpZmljIGVsZW1lbnQgaGV1cmlzdGljcy5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qXG4gICAqIFRoaXMgbWV0aG9kIGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBhIHRoZSBub2RlIGR1cmluZyBiYWNrd2FyZHNcbiAgICogZGVsZXRpb24gKGkuZS4sIGJhY2tzcGFjZSkgd2hlbiBzZWxlY3Rpb24gaXMgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgKiB0aGUgbm9kZSAob2Zmc2V0IDApXG4gICAqL1xuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4Y2x1ZGVGcm9tQ29weShkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhblJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQSBzaGFkb3cgcm9vdCBpcyBhIE5vZGUgdGhhdCBiZWhhdmVzIGxpa2UgUm9vdE5vZGUuIFRoZSBzaGFkb3cgcm9vdCAoYW5kIFJvb3ROb2RlKSBtYXJrIHRoZVxuICAvLyBlbmQgb2YgdGhlIGhpZXJjaGFyY2h5LCBtb3N0IGltcGxlbWVudGF0aW9ucyBzaG91bGQgdHJlYXQgaXQgYXMgdGhlcmUncyBub3RoaW5nICh1cHdhcmRzKVxuICAvLyBiZXlvbmQgdGhpcyBwb2ludC4gRm9yIGV4YW1wbGUsIG5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50KCksIHdoZW4gcGVyZm9ybWVkIGluc2lkZSBhIFRhYmxlQ2VsbE5vZGVcbiAgLy8gd2lsbCByZXR1cm4gdGhlIGltbWVkaWF0ZSBmaXJzdCBjaGlsZCB1bmRlcm5lYXRoIFRhYmxlQ2VsbE5vZGUgaW5zdGVhZCBvZiBSb290Tm9kZS5cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhbk1lcmdlV2l0aChub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRSZW1vdmVkKHBvaW50LCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSB7XG4gIGxldCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGNvbnN0IG5vZGVLZXkgPSBub2RlLl9fa2V5O1xuICAgIGlmIChub2Rlc1RvUmVtb3ZlS2V5U2V0Lmhhcyhub2RlS2V5KSAmJiAhbm9kZXNUb0luc2VydEtleVNldC5oYXMobm9kZUtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgRGVjb3JhdG9yTm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIExleGljYWxFZGl0b3IuX2RlY29yYXRvcnNcbiAgICovXG4gIGRlY29yYXRlKGVkaXRvciwgY29uZmlnKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGRlY29yYXRlOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cbiAgaXNJc29sYXRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNLZXlib2FyZFNlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc0RlY29yYXRvck5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERlY29yYXRvck5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFJvb3ROb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdyb290JztcbiAgfVxuICBzdGF0aWMgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSb290Tm9kZSgpO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdyb290Jyk7XG4gICAgdGhpcy5fX2NhY2hlZFRleHQgPSBudWxsO1xuICB9XG4gIGdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGdldFRvcExldmVsRWxlbWVudE9yVGhyb3c6IHJvb3Qgbm9kZXMgYXJlIG5vdCB0b3AgbGV2ZWwgZWxlbWVudHNgKTtcbiAgICB9XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3QgY2FjaGVkVGV4dCA9IHRoaXMuX19jYWNoZWRUZXh0O1xuICAgIGlmIChpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpIHx8IGdldEFjdGl2ZUVkaXRvcigpLl9kaXJ0eVR5cGUgPT09IE5PX0RJUlRZX05PREVTKSB7XG4gICAgICBpZiAoY2FjaGVkVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkVGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldFRleHRDb250ZW50KCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGByZW1vdmU6IGNhbm5vdCBiZSBjYWxsZWQgb24gcm9vdCBub2Rlc2ApO1xuICAgIH1cbiAgfVxuICByZXBsYWNlKG5vZGUpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcmVwbGFjZTogY2Fubm90IGJlIGNhbGxlZCBvbiByb290IG5vZGVzYCk7XG4gICAgfVxuICB9XG4gIGluc2VydEJlZm9yZShub2RlVG9JbnNlcnQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QmVmb3JlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QWZ0ZXIobm9kZVRvSW5zZXJ0KSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGluc2VydEFmdGVyOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNdXRhdGVcblxuICBhcHBlbmQoLi4ubm9kZXNUb0FwcGVuZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb0FwcGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzVG9BcHBlbmRbaV07XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpICYmICEkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgcm9vdE5vZGUuYXBwZW5kOiBPbmx5IGVsZW1lbnQgb3IgZGVjb3JhdG9yIG5vZGVzIGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgcm9vdCBub2RlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5ub2Rlc1RvQXBwZW5kKTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIC8vIFdlIGRvbid0IGNyZWF0ZSBhIHJvb3QsIGFuZCBpbnN0ZWFkIHVzZSB0aGUgZXhpc3Rpbmcgcm9vdC5cbiAgICBjb25zdCBub2RlID0gJGdldFJvb3QoKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpLFxuICAgICAgaW5kZW50OiB0aGlzLmdldEluZGVudCgpLFxuICAgICAgdHlwZTogJ3Jvb3QnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlUm9vdE5vZGUoKSB7XG4gIHJldHVybiBuZXcgUm9vdE5vZGUoKTtcbn1cbmZ1bmN0aW9uICRpc1Jvb3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBSb290Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBlZGl0b3JTdGF0ZUhhc0RpcnR5U2VsZWN0aW9uKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLl9zZWxlY3Rpb247XG4gIGNvbnN0IHBlbmRpbmdTZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXBkYXRlIGJlY2F1c2Ugb2YgY2hhbmdlcyBpbiBzZWxlY3Rpb25cbiAgaWYgKHBlbmRpbmdTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSB8fCAhcGVuZGluZ1NlbGVjdGlvbi5pcyhjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG9uZUVkaXRvclN0YXRlKGN1cnJlbnQpIHtcbiAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShuZXcgTWFwKGN1cnJlbnQuX25vZGVNYXApKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKSB7XG4gIHJldHVybiBuZXcgRWRpdG9yU3RhdGUobmV3IE1hcChbWydyb290JywgJGNyZWF0ZVJvb3ROb2RlKCldXSkpO1xufVxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IG1hdGNoIHRoZSBzZXJpYWxpemVkIHR5cGUuIENoZWNrIGlmIC5leHBvcnRKU09OKCkgaXMgaW1wbGVtZW50ZWQgYW5kIGl0IGlzIHJldHVybmluZyB0aGUgY29ycmVjdCB0eXBlLmApO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gZXhwb3J0Tm9kZVRvSlNPTihjaGlsZCk7XG4gICAgICBzZXJpYWxpemVkQ2hpbGRyZW4ucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgY29uc3RydWN0b3Iobm9kZU1hcCwgc2VsZWN0aW9uKSB7XG4gICAgdGhpcy5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IG51bGw7XG4gICAgdGhpcy5fZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlTWFwLnNpemUgPT09IDEgJiYgdGhpcy5fc2VsZWN0aW9uID09PSBudWxsO1xuICB9XG4gIHJlYWQoY2FsbGJhY2tGbikge1xuICAgIHJldHVybiByZWFkRWRpdG9yU3RhdGUodGhpcywgY2FsbGJhY2tGbik7XG4gIH1cbiAgY2xvbmUoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgZWRpdG9yU3RhdGUgPSBuZXcgRWRpdG9yU3RhdGUodGhpcy5fbm9kZU1hcCwgc2VsZWN0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLl9zZWxlY3Rpb24gOiBzZWxlY3Rpb24pO1xuICAgIGVkaXRvclN0YXRlLl9yZWFkT25seSA9IHRydWU7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gcmVhZEVkaXRvclN0YXRlKHRoaXMsICgpID0+ICh7XG4gICAgICByb290OiBleHBvcnROb2RlVG9KU09OKCRnZXRSb290KCkpXG4gICAgfSkpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUT0RPOiBDbGVhbnVwIEFydGlmaWNpYWxOb2RlX19ET19OT1RfVVNFICM1OTY2XG5jbGFzcyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdhcnRpZmljaWFsJztcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgLy8gdGhpcyBpc250IHN1cHBvc2VkIHRvIGJlIHVzZWQgYW5kIGlzIG5vdCB1c2VkIGFueXdoZXJlIGJ1dCBkZWZpbmluZyBpdCB0byBhcHBlYXNlIHRoZSBBUElcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXR1cm4gZG9tO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFBhcmFncmFwaE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190ZXh0Rm9ybWF0ID0gMDtcbiAgfVxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3BhcmFncmFwaCc7XG4gIH1cbiAgZ2V0VGV4dEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3RleHRGb3JtYXQ7XG4gIH1cbiAgc2V0VGV4dEZvcm1hdCh0eXBlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdGV4dEZvcm1hdCA9IHR5cGU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaGFzVGV4dEZvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuICh0aGlzLmdldFRleHRGb3JtYXQoKSAmIGZvcm1hdEZsYWcpICE9PSAwO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJhZ3JhcGhOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNvbmZpZy50aGVtZSwgJ3BhcmFncmFwaCcpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFBhcmFncmFwaEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGVsZW1lbnQgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgLy8gcGFkZGluZy1pbmxpbmUtc3RhcnQgaXMgbm90IHdpZGVseSBzdXBwb3J0ZWQgaW4gZW1haWwgSFRNTCwgYnV0XG4gICAgICAgIC8vIExleGljYWwgUmVjb25jaWxlciB1c2VzIHBhZGRpbmctaW5saW5lLXN0YXJ0LiBVc2luZyB0ZXh0LWluZGVudCBpbnN0ZWFkLlxuICAgICAgICBlbGVtZW50LnN0eWxlLnRleHRJbmRlbnQgPSBgJHtpbmRlbnQgKiAyMH1weGA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIG5vZGUuc2V0VGV4dEZvcm1hdChzZXJpYWxpemVkTm9kZS50ZXh0Rm9ybWF0KTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0ZXh0Rm9ybWF0OiB0aGlzLmdldFRleHRGb3JtYXQoKSxcbiAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdGlvblxuXG4gIGluc2VydE5ld0FmdGVyKHJhbmdlU2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgbmV3RWxlbWVudC5zZXRUZXh0Rm9ybWF0KHJhbmdlU2VsZWN0aW9uLmZvcm1hdCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdFbGVtZW50LnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIG5ld0VsZW1lbnQuc2V0Rm9ybWF0KHRoaXMuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5ICh0cmltbWVkKSBmaXJzdCBwYXJhZ3JhcGggYW5kIHRyeSBhbmQgcmVtb3ZlIGl0LFxuICAgIC8vIGRlbGV0ZSB0aGUgcGFyYWdyYXBoIGFzIGxvbmcgYXMgd2UgaGF2ZSBhbm90aGVyIHNpYmxpbmcgdG8gZ28gdG9cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICRpc1RleHROb2RlKGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5nZXRUZXh0Q29udGVudCgpLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0TmV4dCgpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0UGFyYWdyYXBoRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBpZiAoZWxlbWVudC5zdHlsZSkge1xuICAgIG5vZGUuc2V0Rm9ybWF0KGVsZW1lbnQuc3R5bGUudGV4dEFsaWduKTtcbiAgICBjb25zdCBpbmRlbnQgPSBwYXJzZUludChlbGVtZW50LnN0eWxlLnRleHRJbmRlbnQsIDEwKSAvIDIwO1xuICAgIGlmIChpbmRlbnQgPiAwKSB7XG4gICAgICBub2RlLnNldEluZGVudChpbmRlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBQYXJhZ3JhcGhOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzUGFyYWdyYXBoTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUGFyYWdyYXBoTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzg0MVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuY29uc3QgQ09NTUFORF9QUklPUklUWV9FRElUT1IgPSAwO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9MT1cgPSAxO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9OT1JNQUwgPSAyO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9ISUdIID0gMztcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwgPSA0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5cbi8qKlxuICogVHlwZSBoZWxwZXIgZm9yIGV4dHJhY3RpbmcgdGhlIHBheWxvYWQgdHlwZSBmcm9tIGEgY29tbWFuZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IE1ZX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kPFNvbWVUeXBlPigpO1xuICpcbiAqIC8vIC4uLlxuICpcbiAqIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoTVlfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gKiAgIC8vIFR5cGUgb2YgYHBheWxvYWRgIGlzIGluZmVycmVkIGhlcmUuIEJ1dCBsZXRzIHNheSB3ZSB3YW50IHRvIGV4dHJhY3QgYSBmdW5jdGlvbiB0byBkZWxlZ2F0ZSB0b1xuICogICBoYW5kbGVNeUNvbW1hbmQoZWRpdG9yLCBwYXlsb2FkKTtcbiAqICAgcmV0dXJuIHRydWU7XG4gKiB9KTtcbiAqXG4gKiBmdW5jdGlvbiBoYW5kbGVNeUNvbW1hbmQoZWRpdG9yOiBMZXhpY2FsRWRpdG9yLCBwYXlsb2FkOiBDb21tYW5kUGF5bG9hZFR5cGU8dHlwZW9mIE1ZX0NPTU1BTkQ+KSB7XG4gKiAgIC8vIGBwYXlsb2FkYCBpcyBvZiB0eXBlIGBTb21lVHlwZWAsIGV4dHJhY3RlZCBmcm9tIHRoZSBjb21tYW5kLlxuICogfVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRFZGl0b3IoZWRpdG9yLCBwcmV2Um9vdEVsZW1lbnQsIG5leHRSb290RWxlbWVudCwgcGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGtleU5vZGVNYXAgPSBlZGl0b3IuX2tleVRvRE9NTWFwO1xuICBrZXlOb2RlTWFwLmNsZWFyKCk7XG4gIGVkaXRvci5fZWRpdG9yU3RhdGUgPSBjcmVhdGVFbXB0eUVkaXRvclN0YXRlKCk7XG4gIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuICBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ID0gbnVsbDtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBOT19ESVJUWV9OT0RFUztcbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5jbGVhcigpO1xuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX2RpcnR5RWxlbWVudHMuY2xlYXIoKTtcbiAgZWRpdG9yLl9ub3JtYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fdXBkYXRlVGFncyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl91cGRhdGVzID0gW107XG4gIGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50ID0gbnVsbDtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBlZGl0b3IuX29ic2VydmVyO1xuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZWRpdG9yLl9vYnNlcnZlciA9IG51bGw7XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHRoZSBET00gbm9kZXMgZnJvbSB0aGUgcm9vdCBlbGVtZW50XG4gIGlmIChwcmV2Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBwcmV2Um9vdEVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgfVxuICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbmV4dFJvb3RFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAga2V5Tm9kZU1hcC5zZXQoJ3Jvb3QnLCBuZXh0Um9vdEVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiBpbml0aWFsaXplQ29udmVyc2lvbkNhY2hlKG5vZGVzLCBhZGRpdGlvbmFsQ29udmVyc2lvbnMpIHtcbiAgY29uc3QgY29udmVyc2lvbkNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBoYW5kbGVkQ29udmVyc2lvbnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGFkZENvbnZlcnNpb25zVG9DYWNoZSA9IG1hcCA9PiB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsZXQgY3VycmVudENhY2hlID0gY29udmVyc2lvbkNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKGN1cnJlbnRDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1cnJlbnRDYWNoZSA9IFtdO1xuICAgICAgICBjb252ZXJzaW9uQ2FjaGUuc2V0KGtleSwgY3VycmVudENhY2hlKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDYWNoZS5wdXNoKG1hcFtrZXldKTtcbiAgICB9KTtcbiAgfTtcbiAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICBjb25zdCBpbXBvcnRET00gPSBub2RlLmtsYXNzLmltcG9ydERPTTtcbiAgICBpZiAoaW1wb3J0RE9NID09IG51bGwgfHwgaGFuZGxlZENvbnZlcnNpb25zLmhhcyhpbXBvcnRET00pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZWRDb252ZXJzaW9ucy5hZGQoaW1wb3J0RE9NKTtcbiAgICBjb25zdCBtYXAgPSBpbXBvcnRET00uY2FsbChub2RlLmtsYXNzKTtcbiAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICBhZGRDb252ZXJzaW9uc1RvQ2FjaGUobWFwKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoYWRkaXRpb25hbENvbnZlcnNpb25zKSB7XG4gICAgYWRkQ29udmVyc2lvbnNUb0NhY2hlKGFkZGl0aW9uYWxDb252ZXJzaW9ucyk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnNpb25DYWNoZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExleGljYWxFZGl0b3IgYXR0YWNoZWQgdG8gYSBzaW5nbGUgY29udGVudEVkaXRhYmxlIChwcm92aWRlZCBpbiB0aGUgY29uZmlnKS4gVGhpcyBpc1xuICogdGhlIGxvd2VzdC1sZXZlbCBpbml0aWFsaXphdGlvbiBBUEkgZm9yIGEgTGV4aWNhbEVkaXRvci4gSWYgeW91J3JlIHVzaW5nIFJlYWN0IG9yIGFub3RoZXIgZnJhbWV3b3JrLFxuICogY29uc2lkZXIgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGFic3RyYWN0aW9ucywgc3VjaCBhcyBMZXhpY2FsQ29tcG9zZXJcbiAqIEBwYXJhbSBlZGl0b3JDb25maWcgLSB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyBhIExleGljYWxFZGl0b3IgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRpdG9yKGVkaXRvckNvbmZpZykge1xuICBjb25zdCBjb25maWcgPSBlZGl0b3JDb25maWcgfHwge307XG4gIGNvbnN0IGFjdGl2ZUVkaXRvciA9IGludGVybmFsR2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lIHx8IHt9O1xuICBjb25zdCBwYXJlbnRFZGl0b3IgPSBlZGl0b3JDb25maWcgPT09IHVuZGVmaW5lZCA/IGFjdGl2ZUVkaXRvciA6IGNvbmZpZy5wYXJlbnRFZGl0b3IgfHwgbnVsbDtcbiAgY29uc3QgZGlzYWJsZUV2ZW50cyA9IGNvbmZpZy5kaXNhYmxlRXZlbnRzIHx8IGZhbHNlO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgbmFtZXNwYWNlID0gY29uZmlnLm5hbWVzcGFjZSB8fCAocGFyZW50RWRpdG9yICE9PSBudWxsID8gcGFyZW50RWRpdG9yLl9jb25maWcubmFtZXNwYWNlIDogY3JlYXRlVUlEKCkpO1xuICBjb25zdCBpbml0aWFsRWRpdG9yU3RhdGUgPSBjb25maWcuZWRpdG9yU3RhdGU7XG4gIGNvbnN0IG5vZGVzID0gW1Jvb3ROb2RlLCBUZXh0Tm9kZSwgTGluZUJyZWFrTm9kZSwgVGFiTm9kZSwgUGFyYWdyYXBoTm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsIC4uLihjb25maWcubm9kZXMgfHwgW10pXTtcbiAgY29uc3Qge1xuICAgIG9uRXJyb3IsXG4gICAgaHRtbFxuICB9ID0gY29uZmlnO1xuICBjb25zdCBpc0VkaXRhYmxlID0gY29uZmlnLmVkaXRhYmxlICE9PSB1bmRlZmluZWQgPyBjb25maWcuZWRpdGFibGUgOiB0cnVlO1xuICBsZXQgcmVnaXN0ZXJlZE5vZGVzO1xuICBpZiAoZWRpdG9yQ29uZmlnID09PSB1bmRlZmluZWQgJiYgYWN0aXZlRWRpdG9yICE9PSBudWxsKSB7XG4gICAgcmVnaXN0ZXJlZE5vZGVzID0gYWN0aXZlRWRpdG9yLl9ub2RlcztcbiAgfSBlbHNlIHtcbiAgICByZWdpc3RlcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGtsYXNzID0gbm9kZXNbaV07XG4gICAgICBsZXQgcmVwbGFjZSA9IG51bGw7XG4gICAgICBsZXQgcmVwbGFjZVdpdGhLbGFzcyA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGtsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBrbGFzcztcbiAgICAgICAga2xhc3MgPSBvcHRpb25zLnJlcGxhY2U7XG4gICAgICAgIHJlcGxhY2UgPSBvcHRpb25zLndpdGg7XG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3MgPSBvcHRpb25zLndpdGhLbGFzcyB8fCBudWxsO1xuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIGN1c3RvbSBub2RlcyBpbXBsZW1lbnQgcmVxdWlyZWQgbWV0aG9kcyBhbmQgcmVwbGFjZVdpdGhLbGFzcyBpcyBpbnN0YW5jZSBvZiBiYXNlIGtsYXNzLlxuICAgICAge1xuICAgICAgICAvLyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSBjYW4gZ2V0IHJlbmFtZWQsIHNvIHdlIHVzZSB0aGUgdHlwZVxuICAgICAgICBjb25zdCBub2RlVHlwZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrbGFzcywgJ2dldFR5cGUnKSAmJiBrbGFzcy5nZXRUeXBlKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBrbGFzcy5uYW1lO1xuICAgICAgICBpZiAocmVwbGFjZVdpdGhLbGFzcykge1xuICAgICAgICAgIGlmICghKHJlcGxhY2VXaXRoS2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2Yga2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHtyZXBsYWNlV2l0aEtsYXNzLm5hbWV9IGRvZXNuJ3QgZXh0ZW5kIHRoZSAke25hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSAnUm9vdE5vZGUnICYmIG5vZGVUeXBlICE9PSAncm9vdCcgJiYgbm9kZVR5cGUgIT09ICdhcnRpZmljaWFsJykge1xuICAgICAgICAgIGNvbnN0IHByb3RvID0ga2xhc3MucHJvdG90eXBlO1xuICAgICAgICAgIFsnZ2V0VHlwZScsICdjbG9uZSddLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkobWV0aG9kKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gbXVzdCBpbXBsZW1lbnQgc3RhdGljIFwiJHttZXRob2R9XCIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAha2xhc3MuaGFzT3duUHJvcGVydHkoJ2ltcG9ydERPTScpICYmXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KCdleHBvcnRET00nKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IHNob3VsZCBpbXBsZW1lbnQgXCJpbXBvcnRET01cIiBpZiB1c2luZyBhIGN1c3RvbSBcImV4cG9ydERPTVwiIG1ldGhvZCB0byBlbnN1cmUgSFRNTCBzZXJpYWxpemF0aW9uIChpbXBvcnRhbnQgZm9yIGNvcHkgJiBwYXN0ZSkgd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3RvIGluc3RhbmNlb2YgRGVjb3JhdG9yTm9kZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnZGVjb3JhdGUnKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7cHJvdG8uY29uc3RydWN0b3IubmFtZX0gbXVzdCBpbXBsZW1lbnQgXCJkZWNvcmF0ZVwiIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICFrbGFzcy5oYXNPd25Qcm9wZXJ0eSgnaW1wb3J0SlNPTicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gc2hvdWxkIGltcGxlbWVudCBcImltcG9ydEpTT05cIiBtZXRob2QgdG8gZW5zdXJlIEpTT04gYW5kIGRlZmF1bHQgSFRNTCBzZXJpYWxpemF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgIXByb3RvLmhhc093blByb3BlcnR5KCdleHBvcnRKU09OJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBzaG91bGQgaW1wbGVtZW50IFwiZXhwb3J0SlNPTlwiIG1ldGhvZCB0byBlbnN1cmUgSlNPTiBhbmQgZGVmYXVsdCBIVE1MIHNlcmlhbGl6YXRpb24gd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBrbGFzcy50cmFuc2Zvcm0oKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybXMgPSBuZXcgU2V0KCk7XG4gICAgICBpZiAodHJhbnNmb3JtICE9PSBudWxsKSB7XG4gICAgICAgIHRyYW5zZm9ybXMuYWRkKHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlcmVkTm9kZXMuc2V0KHR5cGUsIHtcbiAgICAgICAgZXhwb3J0RE9NOiBodG1sICYmIGh0bWwuZXhwb3J0ID8gaHRtbC5leHBvcnQuZ2V0KGtsYXNzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAga2xhc3MsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3MsXG4gICAgICAgIHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBlZGl0b3IgPSBuZXcgTGV4aWNhbEVkaXRvcihlZGl0b3JTdGF0ZSwgcGFyZW50RWRpdG9yLCByZWdpc3RlcmVkTm9kZXMsIHtcbiAgICBkaXNhYmxlRXZlbnRzLFxuICAgIG5hbWVzcGFjZSxcbiAgICB0aGVtZVxuICB9LCBvbkVycm9yID8gb25FcnJvciA6IGNvbnNvbGUuZXJyb3IsIGluaXRpYWxpemVDb252ZXJzaW9uQ2FjaGUocmVnaXN0ZXJlZE5vZGVzLCBodG1sID8gaHRtbC5pbXBvcnQgOiB1bmRlZmluZWQpLCBpc0VkaXRhYmxlKTtcbiAgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBpbml0aWFsRWRpdG9yU3RhdGU7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgfVxuICByZXR1cm4gZWRpdG9yO1xufVxuY2xhc3MgTGV4aWNhbEVkaXRvciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihlZGl0b3JTdGF0ZSwgcGFyZW50RWRpdG9yLCBub2RlcywgY29uZmlnLCBvbkVycm9yLCBodG1sQ29udmVyc2lvbnMsIGVkaXRhYmxlKSB7XG4gICAgdGhpcy5fcGFyZW50RWRpdG9yID0gcGFyZW50RWRpdG9yO1xuICAgIC8vIFRoZSByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWRpdG9yXG4gICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBudWxsO1xuICAgIC8vIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICAgIHRoaXMuX2VkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgLy8gSGFuZGxpbmcgb2YgZHJhZnRzIGFuZCB1cGRhdGVzXG4gICAgdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlID0gbnVsbDtcbiAgICAvLyBVc2VkIHRvIGhlbHAgY28tb3JkaW5hdGUgc2VsZWN0aW9uIGFuZCBldmVudHNcbiAgICB0aGlzLl9jb21wb3NpdGlvbktleSA9IG51bGw7XG4gICAgdGhpcy5fZGVmZXJyZWQgPSBbXTtcbiAgICAvLyBVc2VkIGR1cmluZyByZWNvbmNpbGlhdGlvblxuICAgIHRoaXMuX2tleVRvRE9NTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VwZGF0ZXMgPSBbXTtcbiAgICB0aGlzLl91cGRhdGluZyA9IGZhbHNlO1xuICAgIC8vIExpc3RlbmVyc1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHtcbiAgICAgIGRlY29yYXRvcjogbmV3IFNldCgpLFxuICAgICAgZWRpdGFibGU6IG5ldyBTZXQoKSxcbiAgICAgIG11dGF0aW9uOiBuZXcgTWFwKCksXG4gICAgICByb290OiBuZXcgU2V0KCksXG4gICAgICB0ZXh0Y29udGVudDogbmV3IFNldCgpLFxuICAgICAgdXBkYXRlOiBuZXcgU2V0KClcbiAgICB9O1xuICAgIC8vIENvbW1hbmRzXG4gICAgdGhpcy5fY29tbWFuZHMgPSBuZXcgTWFwKCk7XG4gICAgLy8gRWRpdG9yIGNvbmZpZ3VyYXRpb24gZm9yIHRoZW1lL2NvbnRleHQuXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIE1hcHBpbmcgb2YgdHlwZXMgdG8gdGhlaXIgbm9kZXNcbiAgICB0aGlzLl9ub2RlcyA9IG5vZGVzO1xuICAgIC8vIFJlYWN0IG5vZGUgZGVjb3JhdG9ycyBmb3IgcG9ydGFsc1xuICAgIHRoaXMuX2RlY29yYXRvcnMgPSB7fTtcbiAgICB0aGlzLl9wZW5kaW5nRGVjb3JhdG9ycyA9IG51bGw7XG4gICAgLy8gVXNlZCB0byBvcHRpbWl6ZSByZWNvbmNpbGlhdGlvblxuICAgIHRoaXMuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICAgIHRoaXMuX2Nsb25lTm90TmVlZGVkID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RpcnR5RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbm9ybWFsaXplZE5vZGVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gICAgLy8gSGFuZGxpbmcgb2YgRE9NIG11dGF0aW9uc1xuICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAvLyBVc2VkIGZvciBpZGVudGlmeWluZyBvd25pbmcgZWRpdG9yc1xuICAgIHRoaXMuX2tleSA9IGNyZWF0ZVVJRCgpO1xuICAgIHRoaXMuX29uRXJyb3IgPSBvbkVycm9yO1xuICAgIHRoaXMuX2h0bWxDb252ZXJzaW9ucyA9IGh0bWxDb252ZXJzaW9ucztcbiAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgIHRoaXMuX2hlYWRsZXNzID0gcGFyZW50RWRpdG9yICE9PSBudWxsICYmIHBhcmVudEVkaXRvci5faGVhZGxlc3M7XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICB0aGlzLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgaW4gXCJjb21wb3NpdGlvblwiIG1vZGUgZHVlIHRvIHJlY2VpdmluZyBpbnB1dFxuICAgKiB0aHJvdWdoIGFuIElNRSwgb3IgM1AgZXh0ZW5zaW9uLCBmb3IgZXhhbXBsZS4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbXBvc2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9zaXRpb25LZXkgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIEVkaXRvciB1cGRhdGUgZXZlbnQuIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAgICogZWFjaCB0aW1lIHRoZSBlZGl0b3IgZ29lcyB0aHJvdWdoIGFuIHVwZGF0ZSAodmlhIHtAbGluayBMZXhpY2FsRWRpdG9yLnVwZGF0ZX0pIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLnVwZGF0ZTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgZm9yIHdoZW4gdGhlIGVkaXRvciBjaGFuZ2VzIGJldHdlZW4gZWRpdGFibGUgYW5kIG5vbi1lZGl0YWJsZSBzdGF0ZXMuXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy5lZGl0YWJsZTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3Igd2hlbiB0aGUgZWRpdG9yJ3MgZGVjb3JhdG9yIG9iamVjdCBjaGFuZ2VzLiBUaGUgZGVjb3JhdG9yIG9iamVjdCBjb250YWluc1xuICAgKiBhbGwgRGVjb3JhdG9yTm9kZSBrZXlzIC0+IHRoZWlyIGRlY29yYXRlZCB2YWx1ZS4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB3aXRoIGV4dGVybmFsIFVJIGZyYW1ld29ya3MuXG4gICAqXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMuZGVjb3JhdG9yO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIExleGljYWwgY29tbWl0cyBhbiB1cGRhdGUgdG8gdGhlIERPTSBhbmQgdGhlIHRleHQgY29udGVudCBvZlxuICAgKiB0aGUgZWRpdG9yIGNoYW5nZXMgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGVkaXRvci4gSWYgdGhlIHRleHQgY29udGVudCBpcyB0aGVcbiAgICogc2FtZSBiZXR3ZWVuIHVwZGF0ZXMsIG5vIG5vdGlmaWNhdGlvbnMgdG8gdGhlIGxpc3RlbmVycyB3aWxsIGhhcHBlbi5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlclRleHRDb250ZW50TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLnRleHRjb250ZW50O1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIHRoZSBlZGl0b3IncyByb290IERPTSBlbGVtZW50ICh0aGUgY29udGVudCBlZGl0YWJsZVxuICAgKiBMZXhpY2FsIGF0dGFjaGVzIHRvKSBjaGFuZ2VzLiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHJvb3RcbiAgICogIGVsZW1lbnQuIFRoZSByb290IGxpc3RlbmVyIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGRpcmVjdGx5IHVwb24gcmVnaXN0cmF0aW9uIGFuZCB0aGVuIG9uXG4gICAqIGFueSBzdWJzZXF1ZW50IHVwZGF0ZS5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlclJvb3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMucm9vdDtcbiAgICBsaXN0ZW5lcih0aGlzLl9yb290RWxlbWVudCwgbnVsbCk7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcihudWxsLCB0aGlzLl9yb290RWxlbWVudCk7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHRyaWdnZXIgYW55dGltZSB0aGUgcHJvdmlkZWQgY29tbWFuZFxuICAgKiBpcyBkaXNwYXRjaGVkLCBzdWJqZWN0IHRvIHByaW9yaXR5LiBMaXN0ZW5lcnMgdGhhdCBydW4gYXQgYSBoaWdoZXIgcHJpb3JpdHkgY2FuIFwiaW50ZXJjZXB0XCJcbiAgICogY29tbWFuZHMgYW5kIHByZXZlbnQgdGhlbSBmcm9tIHByb3BhZ2F0aW5nIHRvIG90aGVyIGhhbmRsZXJzIGJ5IHJldHVybmluZyB0cnVlLlxuICAgKlxuICAgKiBMaXN0ZW5lcnMgcmVnaXN0ZXJlZCBhdCB0aGUgc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIHJ1biBkZXRlcm1pbmlzdGljYWxseSBpbiB0aGUgb3JkZXIgb2YgcmVnaXN0cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29tbWFuZCAtIHRoZSBjb21tYW5kIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIHdoZW4gdGhlIGNvbW1hbmQgaXMgZGlzcGF0Y2hlZC5cbiAgICogQHBhcmFtIHByaW9yaXR5IC0gdGhlIHJlbGF0aXZlIHByaW9yaXR5IG9mIHRoZSBsaXN0ZW5lci4gMCB8IDEgfCAyIHwgMyB8IDRcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGxpc3RlbmVyLCBwcmlvcml0eSkge1xuICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMaXN0ZW5lciBmb3IgdHlwZSBcImNvbW1hbmRcIiByZXF1aXJlcyBhIFwicHJpb3JpdHlcIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29tbWFuZHNNYXAgPSB0aGlzLl9jb21tYW5kcztcbiAgICBpZiAoIWNvbW1hbmRzTWFwLmhhcyhjb21tYW5kKSkge1xuICAgICAgY29tbWFuZHNNYXAuc2V0KGNvbW1hbmQsIFtuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBTZXQoKV0pO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIgPSBjb21tYW5kc01hcC5nZXQoY29tbWFuZCk7XG4gICAgaWYgKGxpc3RlbmVyc0luUHJpb3JpdHlPcmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGByZWdpc3RlckNvbW1hbmQ6IENvbW1hbmQgJHtTdHJpbmcoY29tbWFuZCl9IG5vdCBmb3VuZCBpbiBjb21tYW5kIG1hcGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXJbcHJpb3JpdHldO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGlmIChsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIuZXZlcnkobGlzdGVuZXJzU2V0ID0+IGxpc3RlbmVyc1NldC5zaXplID09PSAwKSkge1xuICAgICAgICBjb21tYW5kc01hcC5kZWxldGUoY29tbWFuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgcnVuIHdoZW4gYSBMZXhpY2FsIG5vZGUgb2YgdGhlIHByb3ZpZGVkIGNsYXNzIGlzXG4gICAqIG11dGF0ZWQuIFRoZSBsaXN0ZW5lciB3aWxsIHJlY2VpdmUgYSBsaXN0IG9mIG5vZGVzIGFsb25nIHdpdGggdGhlIHR5cGUgb2YgbXV0YXRpb25cbiAgICogdGhhdCB3YXMgcGVyZm9ybWVkIG9uIGVhY2g6IGNyZWF0ZWQsIGRlc3Ryb3llZCwgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogT25lIGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0byBhdHRhY2ggRE9NIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZXMgYXMgTGV4aWNhbCBub2RlcyBhcmUgY3JlYXRlZC5cbiAgICoge0BsaW5rIExleGljYWxFZGl0b3IuZ2V0RWxlbWVudEJ5S2V5fSBjYW4gYmUgdXNlZCBmb3IgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIGtsYXNzIC0gVGhlIGNsYXNzIG9mIHRoZSBub2RlIHRoYXQgeW91IHdhbnQgdG8gbGlzdGVuIHRvIG11dGF0aW9ucyBvbi5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxvZ2ljIHlvdSB3YW50IHRvIHJ1biB3aGVuIHRoZSBub2RlIGlzIG11dGF0ZWQuXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcihrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBsZXQgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoa2xhc3MuZ2V0VHlwZSgpKTtcbiAgICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTm9kZSAke2tsYXNzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLiBFbnN1cmUgbm9kZSBoYXMgYmVlbiBwYXNzZWQgdG8gY3JlYXRlRWRpdG9yLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2xhc3NUb011dGF0ZSA9IGtsYXNzO1xuICAgIGxldCByZXBsYWNlS2xhc3MgPSBudWxsO1xuICAgIHdoaWxlIChyZXBsYWNlS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5yZXBsYWNlV2l0aEtsYXNzKSB7XG4gICAgICBrbGFzc1RvTXV0YXRlID0gcmVwbGFjZUtsYXNzO1xuICAgICAgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQocmVwbGFjZUtsYXNzLmdldFR5cGUoKSk7XG4gICAgICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtyZXBsYWNlS2xhc3MubmFtZX0gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuIEVuc3VyZSBub2RlIGhhcyBiZWVuIHBhc3NlZCB0byBjcmVhdGVFZGl0b3IuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbXV0YXRpb25zID0gdGhpcy5fbGlzdGVuZXJzLm11dGF0aW9uO1xuICAgIG11dGF0aW9ucy5zZXQobGlzdGVuZXIsIGtsYXNzVG9NdXRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtdXRhdGlvbnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWdpc3Rlck5vZGVUcmFuc2Zvcm1Ub0tsYXNzKGtsYXNzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHR5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQodHlwZSk7XG4gICAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtrbGFzcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC4gRW5zdXJlIG5vZGUgaGFzIGJlZW4gcGFzc2VkIHRvIGNyZWF0ZUVkaXRvci5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtcyA9IHJlZ2lzdGVyZWROb2RlLnRyYW5zZm9ybXM7XG4gICAgdHJhbnNmb3Jtcy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiByZWdpc3RlcmVkTm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgcnVuIHdoZW4gYSBMZXhpY2FsIG5vZGUgb2YgdGhlIHByb3ZpZGVkIGNsYXNzIGlzXG4gICAqIG1hcmtlZCBkaXJ0eSBkdXJpbmcgYW4gdXBkYXRlLiBUaGUgbGlzdGVuZXIgd2lsbCBjb250aW51ZSB0byBydW4gYXMgbG9uZyBhcyB0aGUgbm9kZVxuICAgKiBpcyBtYXJrZWQgZGlydHkuIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGFyb3VuZCB0aGUgb3JkZXIgb2YgdHJhbnNmb3JtIGV4ZWN1dGlvbiFcbiAgICpcbiAgICogV2F0Y2ggb3V0IGZvciBpbmZpbml0ZSBsb29wcy4gU2VlIFtOb2RlIFRyYW5zZm9ybXNdKGh0dHBzOi8vbGV4aWNhbC5kZXYvZG9jcy9jb25jZXB0cy90cmFuc2Zvcm1zKVxuICAgKiBAcGFyYW0ga2xhc3MgLSBUaGUgY2xhc3Mgb2YgdGhlIG5vZGUgdGhhdCB5b3Ugd2FudCB0byBydW4gdHJhbnNmb3JtcyBvbi5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxvZ2ljIHlvdSB3YW50IHRvIHJ1biB3aGVuIHRoZSBub2RlIGlzIHVwZGF0ZWQuXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyTm9kZVRyYW5zZm9ybShrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHRoaXMucmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhrbGFzcywgbGlzdGVuZXIpO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlcyA9IFtyZWdpc3RlcmVkTm9kZV07XG4gICAgY29uc3QgcmVwbGFjZVdpdGhLbGFzcyA9IHJlZ2lzdGVyZWROb2RlLnJlcGxhY2VXaXRoS2xhc3M7XG4gICAgaWYgKHJlcGxhY2VXaXRoS2xhc3MgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVnaXN0ZXJlZFJlcGxhY2VXaXRoTm9kZSA9IHRoaXMucmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhyZXBsYWNlV2l0aEtsYXNzLCBsaXN0ZW5lcik7XG4gICAgICByZWdpc3RlcmVkTm9kZXMucHVzaChyZWdpc3RlcmVkUmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG4gICAgbWFya0FsbE5vZGVzQXNEaXJ0eSh0aGlzLCBrbGFzcy5nZXRUeXBlKCkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWdpc3RlcmVkTm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUudHJhbnNmb3Jtcy5kZWxldGUobGlzdGVuZXIpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXNzZXJ0IHRoYXQgYSBjZXJ0YWluIG5vZGUgaXMgcmVnaXN0ZXJlZCwgdXN1YWxseSBieSBwbHVnaW5zIHRvIGVuc3VyZSBub2RlcyB0aGF0IHRoZXlcbiAgICogZGVwZW5kIG9uIGhhdmUgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlZGl0b3IgaGFzIHJlZ2lzdGVyZWQgdGhlIHByb3ZpZGVkIG5vZGUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmhhcyhub2RlLmdldFR5cGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBhc3NlcnQgdGhhdCBjZXJ0YWluIG5vZGVzIGFyZSByZWdpc3RlcmVkLCB1c3VhbGx5IGJ5IHBsdWdpbnMgdG8gZW5zdXJlIG5vZGVzIHRoYXQgdGhleVxuICAgKiBkZXBlbmQgb24gaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBoYXMgcmVnaXN0ZXJlZCBhbGwgb2YgdGhlIHByb3ZpZGVkIG5vZGUgdHlwZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc05vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLmV2ZXJ5KHRoaXMuaGFzTm9kZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgY29tbWFuZCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgd2l0aCB0aGUgc3BlY2lmaWVkIHBheWxvYWQuXG4gICAqIFRoaXMgdHJpZ2dlcnMgYWxsIGNvbW1hbmQgbGlzdGVuZXJzIChzZXQgYnkge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJDb21tYW5kfSlcbiAgICogZm9yIHRoaXMgdHlwZSwgcGFzc2luZyB0aGVtIHRoZSBwcm92aWRlZCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIGNvbW1hbmQgbGlzdGVuZXJzIHRvIHRyaWdnZXIuXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gdGhlIGRhdGEgdG8gcGFzcyBhcyBhbiBhcmd1bWVudCB0byB0aGUgY29tbWFuZCBsaXN0ZW5lcnMuXG4gICAqL1xuICBkaXNwYXRjaENvbW1hbmQodHlwZSwgcGF5bG9hZCkge1xuICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQodGhpcywgdHlwZSwgcGF5bG9hZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIG1hcCBvZiBhbGwgZGVjb3JhdG9ycyBpbiB0aGUgZWRpdG9yLlxuICAgKiBAcmV0dXJucyBBIG1hcHBpbmcgb2YgY2FsbCBkZWNvcmF0b3Iga2V5cyB0byB0aGVpciBkZWNvcmF0ZWQgY29udGVudFxuICAgKi9cbiAgZ2V0RGVjb3JhdG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjb3JhdG9ycztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCByb290IGVsZW1lbnQgb2YgdGhlIGVkaXRvci4gSWYgeW91IHdhbnQgdG8gcmVnaXN0ZXJcbiAgICogYW4gZXZlbnQgbGlzdGVuZXIsIGRvIGl0IHZpYSB7QGxpbmsgTGV4aWNhbEVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcn0sIHNpbmNlXG4gICAqIHRoaXMgcmVmZXJlbmNlIG1heSBub3QgYmUgc3RhYmxlLlxuICAgKi9cbiAgZ2V0Um9vdEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGtleSBvZiB0aGUgZWRpdG9yXG4gICAqIEByZXR1cm5zIFRoZSBlZGl0b3Iga2V5XG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBlcmF0aXZlbHkgc2V0IHRoZSByb290IGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IHRoYXQgTGV4aWNhbCBsaXN0ZW5zXG4gICAqIGZvciBldmVudHMgb24uXG4gICAqL1xuICBzZXRSb290RWxlbWVudChuZXh0Um9vdEVsZW1lbnQpIHtcbiAgICBjb25zdCBwcmV2Um9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBwcmV2Um9vdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBnZXRDYWNoZWRDbGFzc05hbWVBcnJheSh0aGlzLl9jb25maWcudGhlbWUsICdyb290Jyk7XG4gICAgICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSB0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgfHwgdGhpcy5fZWRpdG9yU3RhdGU7XG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IG5leHRSb290RWxlbWVudDtcbiAgICAgIHJlc2V0RWRpdG9yKHRoaXMsIHByZXZSb290RWxlbWVudCwgbmV4dFJvb3RFbGVtZW50LCBwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICAgICAgaWYgKHByZXZSb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBmbGFnIG9uY2Ugd2Ugbm8gbG9uZ2VyIHVzZSBVRXYyIGludGVybmFsbHlcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuZGlzYWJsZUV2ZW50cykge1xuICAgICAgICAgIHJlbW92ZVJvb3RFbGVtZW50RXZlbnRzKHByZXZSb290RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgIHByZXZSb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd09iaiA9IGdldERlZmF1bHRWaWV3KG5leHRSb290RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gbmV4dFJvb3RFbGVtZW50LnN0eWxlO1xuICAgICAgICBzdHlsZS51c2VyU2VsZWN0ID0gJ3RleHQnO1xuICAgICAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgICAgICAgc3R5bGUud29yZEJyZWFrID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICBuZXh0Um9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZWRpdG9yJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fd2luZG93ID0gd2luZG93T2JqO1xuICAgICAgICB0aGlzLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgICAgICAgaW5pdE11dGF0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRhZ3MuYWRkKCdoaXN0b3J5LW1lcmdlJyk7XG4gICAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyh0aGlzKTtcblxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBmbGFnIG9uY2Ugd2Ugbm8gbG9uZ2VyIHVzZSBVRXYyIGludGVybmFsbHlcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuZGlzYWJsZUV2ZW50cykge1xuICAgICAgICAgIGFkZFJvb3RFbGVtZW50RXZlbnRzKG5leHRSb290RWxlbWVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgIG5leHRSb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBjb250ZW50IGVkaXRhYmxlIGlzIHVubW91bnRlZCB3ZSdsbCByZXNldCBlZGl0b3Igc3RhdGUgYmFjayB0byBvcmlnaW5hbFxuICAgICAgICAvLyAob3IgcGVuZGluZykgZWRpdG9yIHN0YXRlIHNpbmNlIHRoZXJlIHdpbGwgYmUgbm8gcmVjb25jaWxpYXRpb25cbiAgICAgICAgdGhpcy5fZWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyTGlzdGVuZXJzKCdyb290JywgdGhpcywgZmFsc2UsIG5leHRSb290RWxlbWVudCwgcHJldlJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW5kZXJseWluZyBIVE1MRWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIExleGljYWxOb2RlIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgKiBAcmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgcmVuZGVyZWQgYnkgdGhlIExleGljYWxOb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LlxuICAgKiBAcGFyYW0ga2V5IC0gdGhlIGtleSBvZiB0aGUgTGV4aWNhbE5vZGUuXG4gICAqL1xuICBnZXRFbGVtZW50QnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleVRvRE9NTWFwLmdldChrZXkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aXZlIGVkaXRvciBzdGF0ZS5cbiAgICogQHJldHVybnMgVGhlIGVkaXRvciBzdGF0ZVxuICAgKi9cbiAgZ2V0RWRpdG9yU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvclN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGVyYXRpdmVseSBzZXQgdGhlIEVkaXRvclN0YXRlLiBUcmlnZ2VycyByZWNvbmNpbGlhdGlvbiBsaWtlIGFuIHVwZGF0ZS5cbiAgICogQHBhcmFtIGVkaXRvclN0YXRlIC0gdGhlIHN0YXRlIHRvIHNldCB0aGUgZWRpdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZS5cbiAgICovXG4gIHNldEVkaXRvclN0YXRlKGVkaXRvclN0YXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgc2V0RWRpdG9yU3RhdGU6IHRoZSBlZGl0b3Igc3RhdGUgaXMgZW1wdHkuIEVuc3VyZSB0aGUgZWRpdG9yIHN0YXRlJ3Mgcm9vdCBub2RlIG5ldmVyIGJlY29tZXMgZW1wdHkuYCk7XG4gICAgICB9XG4gICAgfVxuICAgICRmbHVzaFJvb3RNdXRhdGlvbnModGhpcyk7XG4gICAgY29uc3QgcGVuZGluZ0VkaXRvclN0YXRlID0gdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlO1xuICAgIGNvbnN0IHRhZ3MgPSB0aGlzLl91cGRhdGVUYWdzO1xuICAgIGNvbnN0IHRhZyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGFnIDogbnVsbDtcbiAgICBpZiAocGVuZGluZ0VkaXRvclN0YXRlICE9PSBudWxsICYmICFwZW5kaW5nRWRpdG9yU3RhdGUuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGFnICE9IG51bGwpIHtcbiAgICAgICAgdGFncy5hZGQodGFnKTtcbiAgICAgIH1cbiAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgdGhpcy5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgdGhpcy5fZGlydHlFbGVtZW50cy5zZXQoJ3Jvb3QnLCBmYWxzZSk7XG4gICAgdGhpcy5fY29tcG9zaXRpb25LZXkgPSBudWxsO1xuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdGFncy5hZGQodGFnKTtcbiAgICB9XG4gICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSAodXN1YWxseSBwcm9kdWNlZCBieSB7QGxpbmsgRWRpdG9yU3RhdGUudG9KU09OfSkgYW5kIHJldHVybnNcbiAgICogYW5kIEVkaXRvclN0YXRlIG9iamVjdCB0aGF0IGNhbiBiZSwgZm9yIGV4YW1wbGUsIHBhc3NlZCB0byB7QGxpbmsgTGV4aWNhbEVkaXRvci5zZXRFZGl0b3JTdGF0ZX0uIFR5cGljYWxseSxcbiAgICogZGVzZXJsaWF6YXRpb24gZnJvbSBKU09OIHN0b3JlZCBpbiBhIGRhdGFiYXNlIHVzZXMgdGhpcyBtZXRob2QuXG4gICAqIEBwYXJhbSBtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGVcbiAgICogQHBhcmFtIHVwZGF0ZUZuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBwYXJzZUVkaXRvclN0YXRlKG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSwgdXBkYXRlRm4pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkRWRpdG9yU3RhdGUgPSB0eXBlb2YgbWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlKSA6IG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZTtcbiAgICByZXR1cm4gcGFyc2VFZGl0b3JTdGF0ZShzZXJpYWxpemVkRWRpdG9yU3RhdGUsIHRoaXMsIHVwZGF0ZUZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiB1cGRhdGUgdG8gdGhlIGVkaXRvciBzdGF0ZS4gVGhlIHVwZGF0ZUZuIGNhbGxiYWNrIGlzIHRoZSBPTkxZIHBsYWNlXG4gICAqIHdoZXJlIExleGljYWwgZWRpdG9yIHN0YXRlIGNhbiBiZSBzYWZlbHkgbXV0YXRlZC5cbiAgICogQHBhcmFtIHVwZGF0ZUZuIC0gQSBmdW5jdGlvbiB0aGF0IGhhcyBhY2Nlc3MgdG8gd3JpdGFibGUgZWRpdG9yIHN0YXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEgYmFnIG9mIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhlIHVwZGF0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMub25VcGRhdGUgLSBBIGZ1bmN0aW9uIHRvIHJ1biBvbmNlIHRoZSB1cGRhdGUgaXMgY29tcGxldGUuXG4gICAqIFVzZWZ1bCBmb3Igc3luY2hyb25pemluZyB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNraXBUcmFuc2Zvcm1zIC0gU2V0dGluZyB0aGlzIHRvIHRydWUgd2lsbCBzdXBwcmVzcyBhbGwgbm9kZVxuICAgKiB0cmFuc2Zvcm1zIGZvciB0aGlzIHVwZGF0ZSBjeWNsZS5cbiAgICogQHBhcmFtIG9wdGlvbnMudGFnIC0gQSB0YWcgdG8gaWRlbnRpZnkgdGhpcyB1cGRhdGUsIGluIGFuIHVwZGF0ZSBsaXN0ZW5lciwgZm9yIGluc3RhbmNlLlxuICAgKiBTb21lIHRhZ3MgYXJlIHJlc2VydmVkIGJ5IHRoZSBjb3JlIGFuZCBjb250cm9sIHVwZGF0ZSBiZWhhdmlvciBpbiBkaWZmZXJlbnQgd2F5cy5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGlzY3JldGUgLSBJZiB0cnVlLCBwcmV2ZW50cyB0aGlzIHVwZGF0ZSBmcm9tIGJlaW5nIGJhdGNoZWQsIGZvcmNpbmcgaXQgdG9cbiAgICogcnVuIHN5bmNocm9ub3VzbHkuXG4gICAqL1xuICB1cGRhdGUodXBkYXRlRm4sIG9wdGlvbnMpIHtcbiAgICB1cGRhdGVFZGl0b3IodGhpcywgdXBkYXRlRm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIGVkaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2tGbiAtIEEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBIGJhZyBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gLSBXaGVyZSB0byBtb3ZlIHNlbGVjdGlvbiB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICogZm9jdXNlZC4gQ2FuIGJlIHJvb3RTdGFydCwgcm9vdEVuZCwgb3IgdW5kZWZpbmVkLiBEZWZhdWx0cyB0byByb290RW5kLlxuICAgKi9cbiAgZm9jdXMoY2FsbGJhY2tGbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlPUyBkb2VzIG5vdCB0cmlnZ2VyIGNhcHMgbG9jayB1cG9uIGZvY3VzXG4gICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgICAgdXBkYXRlRWRpdG9yKHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1hcmtpbmcgdGhlIHNlbGVjdGlvbiBkaXJ0eSB3aWxsIGZvcmNlIHRoZSBzZWxlY3Rpb24gYmFjayB0byBpdFxuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdC5nZXRDaGlsZHJlblNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gPT09ICdyb290U3RhcnQnKSB7XG4gICAgICAgICAgICByb290LnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgICAgIGlmIChjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICBjYWxsYmFja0ZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0YWc6ICdmb2N1cydcbiAgICAgIH0pO1xuICAgICAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgb25VcGRhdGUgZG9lc24ndCBmaXJlIChkdWUgdG8gdGhlIGZvY3VzIHVwZGF0ZSBub3RcbiAgICAgIC8vIG9jY3VyaW5nKS5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICovXG4gIGJsdXIoKSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuX3dpbmRvdyk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRpdGFibGUgcHJvcGVydHkgb2YgdGhlIGVkaXRvci4gV2hlbiBmYWxzZSwgdGhlXG4gICAqIGVkaXRvciB3aWxsIG5vdCBsaXN0ZW4gZm9yIHVzZXIgZXZlbnRzIG9uIHRoZSB1bmRlcmxpbmcgY29udGVudGVkaXRhYmxlLlxuICAgKiBAcGFyYW0gZWRpdGFibGUgLSB0aGUgdmFsdWUgdG8gc2V0IHRoZSBlZGl0YWJsZSBtb2RlIHRvLlxuICAgKi9cbiAgc2V0RWRpdGFibGUoZWRpdGFibGUpIHtcbiAgICBpZiAodGhpcy5fZWRpdGFibGUgIT09IGVkaXRhYmxlKSB7XG4gICAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgICAgdHJpZ2dlckxpc3RlbmVycygnZWRpdGFibGUnLCB0aGlzLCB0cnVlLCBlZGl0YWJsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgamF2YXNjcmlwdCBvYmplY3QgTk9UIGEgSlNPTiBzdHJpbmcuXG4gICAqIFlvdSBzdGlsbCBtdXN0IGNhbGwgSlNPTi5zdHJpbmdpZnkgKG9yIHNvbWV0aGluZyBlbHNlKSB0byB0dXJuIHRoZVxuICAgKiBzdGF0ZSBpbnRvIGEgc3RyaW5nIHlvdSBjYW4gdHJhbnNmZXIgb3ZlciB0aGUgd2lyZSBhbmQgc3RvcmUgaW4gYSBkYXRhYmFzZS5cbiAgICpcbiAgICogU2VlIHtAbGluayBMZXhpY2FsTm9kZS5leHBvcnRKU09OfVxuICAgKlxuICAgKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRvclN0YXRlOiB0aGlzLl9lZGl0b3JTdGF0ZS50b0pTT04oKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHsgJGFkZFVwZGF0ZVRhZywgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkY29weU5vZGUsICRjcmVhdGVMaW5lQnJlYWtOb2RlLCAkY3JlYXRlTm9kZVNlbGVjdGlvbiwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRjcmVhdGVQb2ludCwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tLCAkY3JlYXRlVGFiTm9kZSwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0QWRqYWNlbnROb2RlLCAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cywgJGdldEVkaXRvciwgJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUsICRnZXROZWFyZXN0Um9vdE9yU2hhZG93Um9vdCwgJGdldE5vZGVCeUtleSwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkZ2V0Um9vdCwgJGdldFNlbGVjdGlvbiwgJGdldFRleHRDb250ZW50LCAkaGFzQW5jZXN0b3IsICRoYXNVcGRhdGVUYWcsICRpbnNlcnROb2RlcywgJGlzQmxvY2tFbGVtZW50Tm9kZSwgJGlzRGVjb3JhdG9yTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUsICRpc0xlYWZOb2RlLCAkaXNMaW5lQnJlYWtOb2RlLCAkaXNOb2RlU2VsZWN0aW9uLCAkaXNQYXJhZ3JhcGhOb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE5vZGUsICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRpc1RhYk5vZGUsICRpc1RleHROb2RlLCAkbm9kZXNPZlR5cGUsICRub3JtYWxpemVTZWxlY3Rpb24gYXMgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkcGFyc2VTZXJpYWxpemVkTm9kZSwgJHNlbGVjdEFsbCwgJHNldENvbXBvc2l0aW9uS2V5LCAkc2V0U2VsZWN0aW9uLCAkc3BsaXROb2RlLCBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSwgQkxVUl9DT01NQU5ELCBDQU5fUkVET19DT01NQU5ELCBDQU5fVU5ET19DT01NQU5ELCBDTEVBUl9FRElUT1JfQ09NTUFORCwgQ0xFQVJfSElTVE9SWV9DT01NQU5ELCBDTElDS19DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgQ09NTUFORF9QUklPUklUWV9ISUdILCBDT01NQU5EX1BSSU9SSVRZX0xPVywgQ09NTUFORF9QUklPUklUWV9OT1JNQUwsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgQ09QWV9DT01NQU5ELCBDVVRfQ09NTUFORCwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfV09SRF9DT01NQU5ELCBEUkFHRU5EX0NPTU1BTkQsIERSQUdPVkVSX0NPTU1BTkQsIERSQUdTVEFSVF9DT01NQU5ELCBEUk9QX0NPTU1BTkQsIERlY29yYXRvck5vZGUsIEVsZW1lbnROb2RlLCBGT0NVU19DT01NQU5ELCBGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBGT1JNQVRfVEVYVF9DT01NQU5ELCBJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIElOU0VSVF9UQUJfQ09NTUFORCwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIEtFWV9BUlJPV19VUF9DT01NQU5ELCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORCwgS0VZX0RPV05fQ09NTUFORCwgS0VZX0VOVEVSX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgS0VZX01PRElGSUVSX0NPTU1BTkQsIEtFWV9TUEFDRV9DT01NQU5ELCBLRVlfVEFCX0NPTU1BTkQsIExpbmVCcmVha05vZGUsIE1PVkVfVE9fRU5ELCBNT1ZFX1RPX1NUQVJULCBPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgUEFTVEVfQ09NTUFORCwgUGFyYWdyYXBoTm9kZSwgUkVET19DT01NQU5ELCBSRU1PVkVfVEVYVF9DT01NQU5ELCBSb290Tm9kZSwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCBTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCBTRUxFQ1RfQUxMX0NPTU1BTkQsIFRhYk5vZGUsIFRleHROb2RlLCBVTkRPX0NPTU1BTkQsIGNyZWF0ZUNvbW1hbmQsIGNyZWF0ZUVkaXRvciwgZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlLCBpc0Jsb2NrRG9tTm9kZSwgaXNDdXJyZW50bHlSZWFkT25seU1vZGUsIGlzSFRNTEFuY2hvckVsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzSW5saW5lRG9tTm9kZSwgaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQsIGlzU2VsZWN0aW9uV2l0aGluRWRpdG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lexical/Lexical.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/lexical/Lexical.dev.mjs":
/*!**********************************************!*\
  !*** ./node_modules/lexical/Lexical.dev.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addUpdateTag: () => (/* binding */ $addUpdateTag),\n/* harmony export */   $applyNodeReplacement: () => (/* binding */ $applyNodeReplacement),\n/* harmony export */   $copyNode: () => (/* binding */ $copyNode),\n/* harmony export */   $createLineBreakNode: () => (/* binding */ $createLineBreakNode),\n/* harmony export */   $createNodeSelection: () => (/* binding */ $createNodeSelection),\n/* harmony export */   $createParagraphNode: () => (/* binding */ $createParagraphNode),\n/* harmony export */   $createPoint: () => (/* binding */ $createPoint),\n/* harmony export */   $createRangeSelection: () => (/* binding */ $createRangeSelection),\n/* harmony export */   $createRangeSelectionFromDom: () => (/* binding */ $createRangeSelectionFromDom),\n/* harmony export */   $createTabNode: () => (/* binding */ $createTabNode),\n/* harmony export */   $createTextNode: () => (/* binding */ $createTextNode),\n/* harmony export */   $getAdjacentNode: () => (/* binding */ $getAdjacentNode),\n/* harmony export */   $getCharacterOffsets: () => (/* binding */ $getCharacterOffsets),\n/* harmony export */   $getEditor: () => (/* binding */ $getEditor),\n/* harmony export */   $getNearestNodeFromDOMNode: () => (/* binding */ $getNearestNodeFromDOMNode),\n/* harmony export */   $getNearestRootOrShadowRoot: () => (/* binding */ $getNearestRootOrShadowRoot),\n/* harmony export */   $getNodeByKey: () => (/* binding */ $getNodeByKey),\n/* harmony export */   $getPreviousSelection: () => (/* binding */ $getPreviousSelection),\n/* harmony export */   $getRoot: () => (/* binding */ $getRoot),\n/* harmony export */   $getSelection: () => (/* binding */ $getSelection),\n/* harmony export */   $getTextContent: () => (/* binding */ $getTextContent),\n/* harmony export */   $hasAncestor: () => (/* binding */ $hasAncestor),\n/* harmony export */   $hasUpdateTag: () => (/* binding */ $hasUpdateTag),\n/* harmony export */   $insertNodes: () => (/* binding */ $insertNodes),\n/* harmony export */   $isBlockElementNode: () => (/* binding */ $isBlockElementNode),\n/* harmony export */   $isDecoratorNode: () => (/* binding */ $isDecoratorNode),\n/* harmony export */   $isElementNode: () => (/* binding */ $isElementNode),\n/* harmony export */   $isInlineElementOrDecoratorNode: () => (/* binding */ $isInlineElementOrDecoratorNode),\n/* harmony export */   $isLeafNode: () => (/* binding */ $isLeafNode),\n/* harmony export */   $isLineBreakNode: () => (/* binding */ $isLineBreakNode),\n/* harmony export */   $isNodeSelection: () => (/* binding */ $isNodeSelection),\n/* harmony export */   $isParagraphNode: () => (/* binding */ $isParagraphNode),\n/* harmony export */   $isRangeSelection: () => (/* binding */ $isRangeSelection),\n/* harmony export */   $isRootNode: () => (/* binding */ $isRootNode),\n/* harmony export */   $isRootOrShadowRoot: () => (/* binding */ $isRootOrShadowRoot),\n/* harmony export */   $isTabNode: () => (/* binding */ $isTabNode),\n/* harmony export */   $isTextNode: () => (/* binding */ $isTextNode),\n/* harmony export */   $nodesOfType: () => (/* binding */ $nodesOfType),\n/* harmony export */   $normalizeSelection__EXPERIMENTAL: () => (/* binding */ $normalizeSelection),\n/* harmony export */   $parseSerializedNode: () => (/* binding */ $parseSerializedNode),\n/* harmony export */   $selectAll: () => (/* binding */ $selectAll),\n/* harmony export */   $setCompositionKey: () => (/* binding */ $setCompositionKey),\n/* harmony export */   $setSelection: () => (/* binding */ $setSelection),\n/* harmony export */   $splitNode: () => (/* binding */ $splitNode),\n/* harmony export */   ArtificialNode__DO_NOT_USE: () => (/* binding */ ArtificialNode__DO_NOT_USE),\n/* harmony export */   BLUR_COMMAND: () => (/* binding */ BLUR_COMMAND),\n/* harmony export */   CAN_REDO_COMMAND: () => (/* binding */ CAN_REDO_COMMAND),\n/* harmony export */   CAN_UNDO_COMMAND: () => (/* binding */ CAN_UNDO_COMMAND),\n/* harmony export */   CLEAR_EDITOR_COMMAND: () => (/* binding */ CLEAR_EDITOR_COMMAND),\n/* harmony export */   CLEAR_HISTORY_COMMAND: () => (/* binding */ CLEAR_HISTORY_COMMAND),\n/* harmony export */   CLICK_COMMAND: () => (/* binding */ CLICK_COMMAND),\n/* harmony export */   COMMAND_PRIORITY_CRITICAL: () => (/* binding */ COMMAND_PRIORITY_CRITICAL),\n/* harmony export */   COMMAND_PRIORITY_EDITOR: () => (/* binding */ COMMAND_PRIORITY_EDITOR),\n/* harmony export */   COMMAND_PRIORITY_HIGH: () => (/* binding */ COMMAND_PRIORITY_HIGH),\n/* harmony export */   COMMAND_PRIORITY_LOW: () => (/* binding */ COMMAND_PRIORITY_LOW),\n/* harmony export */   COMMAND_PRIORITY_NORMAL: () => (/* binding */ COMMAND_PRIORITY_NORMAL),\n/* harmony export */   CONTROLLED_TEXT_INSERTION_COMMAND: () => (/* binding */ CONTROLLED_TEXT_INSERTION_COMMAND),\n/* harmony export */   COPY_COMMAND: () => (/* binding */ COPY_COMMAND),\n/* harmony export */   CUT_COMMAND: () => (/* binding */ CUT_COMMAND),\n/* harmony export */   DELETE_CHARACTER_COMMAND: () => (/* binding */ DELETE_CHARACTER_COMMAND),\n/* harmony export */   DELETE_LINE_COMMAND: () => (/* binding */ DELETE_LINE_COMMAND),\n/* harmony export */   DELETE_WORD_COMMAND: () => (/* binding */ DELETE_WORD_COMMAND),\n/* harmony export */   DRAGEND_COMMAND: () => (/* binding */ DRAGEND_COMMAND),\n/* harmony export */   DRAGOVER_COMMAND: () => (/* binding */ DRAGOVER_COMMAND),\n/* harmony export */   DRAGSTART_COMMAND: () => (/* binding */ DRAGSTART_COMMAND),\n/* harmony export */   DROP_COMMAND: () => (/* binding */ DROP_COMMAND),\n/* harmony export */   DecoratorNode: () => (/* binding */ DecoratorNode),\n/* harmony export */   ElementNode: () => (/* binding */ ElementNode),\n/* harmony export */   FOCUS_COMMAND: () => (/* binding */ FOCUS_COMMAND),\n/* harmony export */   FORMAT_ELEMENT_COMMAND: () => (/* binding */ FORMAT_ELEMENT_COMMAND),\n/* harmony export */   FORMAT_TEXT_COMMAND: () => (/* binding */ FORMAT_TEXT_COMMAND),\n/* harmony export */   INDENT_CONTENT_COMMAND: () => (/* binding */ INDENT_CONTENT_COMMAND),\n/* harmony export */   INSERT_LINE_BREAK_COMMAND: () => (/* binding */ INSERT_LINE_BREAK_COMMAND),\n/* harmony export */   INSERT_PARAGRAPH_COMMAND: () => (/* binding */ INSERT_PARAGRAPH_COMMAND),\n/* harmony export */   INSERT_TAB_COMMAND: () => (/* binding */ INSERT_TAB_COMMAND),\n/* harmony export */   KEY_ARROW_DOWN_COMMAND: () => (/* binding */ KEY_ARROW_DOWN_COMMAND),\n/* harmony export */   KEY_ARROW_LEFT_COMMAND: () => (/* binding */ KEY_ARROW_LEFT_COMMAND),\n/* harmony export */   KEY_ARROW_RIGHT_COMMAND: () => (/* binding */ KEY_ARROW_RIGHT_COMMAND),\n/* harmony export */   KEY_ARROW_UP_COMMAND: () => (/* binding */ KEY_ARROW_UP_COMMAND),\n/* harmony export */   KEY_BACKSPACE_COMMAND: () => (/* binding */ KEY_BACKSPACE_COMMAND),\n/* harmony export */   KEY_DELETE_COMMAND: () => (/* binding */ KEY_DELETE_COMMAND),\n/* harmony export */   KEY_DOWN_COMMAND: () => (/* binding */ KEY_DOWN_COMMAND),\n/* harmony export */   KEY_ENTER_COMMAND: () => (/* binding */ KEY_ENTER_COMMAND),\n/* harmony export */   KEY_ESCAPE_COMMAND: () => (/* binding */ KEY_ESCAPE_COMMAND),\n/* harmony export */   KEY_MODIFIER_COMMAND: () => (/* binding */ KEY_MODIFIER_COMMAND),\n/* harmony export */   KEY_SPACE_COMMAND: () => (/* binding */ KEY_SPACE_COMMAND),\n/* harmony export */   KEY_TAB_COMMAND: () => (/* binding */ KEY_TAB_COMMAND),\n/* harmony export */   LineBreakNode: () => (/* binding */ LineBreakNode),\n/* harmony export */   MOVE_TO_END: () => (/* binding */ MOVE_TO_END),\n/* harmony export */   MOVE_TO_START: () => (/* binding */ MOVE_TO_START),\n/* harmony export */   OUTDENT_CONTENT_COMMAND: () => (/* binding */ OUTDENT_CONTENT_COMMAND),\n/* harmony export */   PASTE_COMMAND: () => (/* binding */ PASTE_COMMAND),\n/* harmony export */   ParagraphNode: () => (/* binding */ ParagraphNode),\n/* harmony export */   REDO_COMMAND: () => (/* binding */ REDO_COMMAND),\n/* harmony export */   REMOVE_TEXT_COMMAND: () => (/* binding */ REMOVE_TEXT_COMMAND),\n/* harmony export */   RootNode: () => (/* binding */ RootNode),\n/* harmony export */   SELECTION_CHANGE_COMMAND: () => (/* binding */ SELECTION_CHANGE_COMMAND),\n/* harmony export */   SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => (/* binding */ SELECTION_INSERT_CLIPBOARD_NODES_COMMAND),\n/* harmony export */   SELECT_ALL_COMMAND: () => (/* binding */ SELECT_ALL_COMMAND),\n/* harmony export */   TabNode: () => (/* binding */ TabNode),\n/* harmony export */   TextNode: () => (/* binding */ TextNode),\n/* harmony export */   UNDO_COMMAND: () => (/* binding */ UNDO_COMMAND),\n/* harmony export */   createCommand: () => (/* binding */ createCommand),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   getNearestEditorFromDOMNode: () => (/* binding */ getNearestEditorFromDOMNode),\n/* harmony export */   isBlockDomNode: () => (/* binding */ isBlockDomNode),\n/* harmony export */   isCurrentlyReadOnlyMode: () => (/* binding */ isCurrentlyReadOnlyMode),\n/* harmony export */   isHTMLAnchorElement: () => (/* binding */ isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* binding */ isInlineDomNode),\n/* harmony export */   isSelectionCapturedInDecoratorInput: () => (/* binding */ isSelectionCapturedInDecoratorInput),\n/* harmony export */   isSelectionWithinEditor: () => (/* binding */ isSelectionWithinEditor)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction $flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore internal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  $flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(key, altKey, ctrlKey, metaKey) {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(key, shiftKey) {\n  return isReturn(key) && !shiftKey;\n}\nfunction isLineBreak(key, shiftKey) {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(key, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\nfunction isDeleteWordBackward(key, altKey, ctrlKey) {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(key, altKey, ctrlKey) {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(key, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\nfunction isDeleteLineForward(key, metaKey) {\n  return IS_APPLE && metaKey && isDelete(key);\n}\nfunction isDeleteBackward(key, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || key.toLowerCase() === 'h' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\nfunction isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || key.toLowerCase() === 'd' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\nfunction isUndo(key, shiftKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(key, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return key.toLowerCase() === 'y' && ctrlKey || key.toLowerCase() === 'z' && ctrlKey && shiftKey;\n}\nfunction isCopy(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(key) {\n  return key === 'ArrowLeft';\n}\nfunction isArrowRight(key) {\n  return key === 'ArrowRight';\n}\nfunction isArrowUp(key) {\n  return key === 'ArrowUp';\n}\nfunction isArrowDown(key) {\n  return key === 'ArrowDown';\n}\nfunction isMoveBackward(key, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(key, ctrlKey, altKey, metaKey) {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(key, ctrlKey, metaKey) {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(key, ctrlKey, metaKey) {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(key) {\n  return key === ' ';\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(key) {\n  return key === 'Enter';\n}\nfunction isBackspace(key) {\n  return key === 'Backspace';\n}\nfunction isEscape(key) {\n  return key === 'Escape';\n}\nfunction isDelete(key) {\n  return key === 'Delete';\n}\nfunction isSelectAll(key, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  // @ts-expect-error\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isRootNode(node) || $isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], dom, insertDOM);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {\n      subTreeTextFormat = node.getFormat();\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileParagraphFormat(element) {\n  if ($isParagraphNode(element) && subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat) {\n    element.setTextFormat(subTreeTextFormat);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  $reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  reconcileParagraphFormat(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n  subTreeTextFormat = null;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFrstChildKey);\n    if (subTreeTextFormat === null && $isTextNode(nextChildNode)) {\n      subTreeTextFormat = nextChildNode.getFormat();\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          $reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && subTreeTextFormat === null && $isTextNode(node)) {\n      subTreeTextFormat = node.getFormat();\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            const lastNode = anchor.getNode();\n            if (lastNode instanceof ParagraphNode && lastNode.getChildrenSize() === 0) {\n              selection.format = lastNode.getTextFormat();\n            } else {\n              selection.format = 0;\n            }\n            selection.style = '';\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType;\n          // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNodeText = selection.anchor.getNode().getTextContent();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    key,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    throw Error(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  // @ts-expect-error: internal field\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!$isElementNode(node)) {\n          throw Error(`Children of root nodes must be elements`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor;\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      if ($isParagraphNode(latestNode) && $isParagraphNode(mutableNode)) {\n        mutableNode.__textFormat = latestNode.__textFormat;\n      }\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n\n    // @ts-expect-error\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChild(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChild(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n/** @noInheritDoc */\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style !== undefined && node.style.whiteSpace !== undefined && node.style.whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    const newNode = new TabNode(node.__key);\n    // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    this.insertText('');\n  }\n\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ('__language' in firstBlock && $isElementNode(firstBlock)) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isLI = node => '__value' in node && '__checked' in node;\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || isLI(firstBlock));\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (isLI(insertedParagraph) || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be an ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset);\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    throw Error(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = $splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @noInheritDoc */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__textFormat = 0;\n  }\n  static getType() {\n    return 'paragraph';\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    node.setTextFormat(serializedNode.textFormat);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      textFormat: this.getTextFormat(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType = Object.prototype.hasOwnProperty.call(klass, 'getType') && klass.getType();\n        const name = klass.name;\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener) {\n    let registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    let klassToMutate = klass;\n    let replaceKlass = null;\n    while (replaceKlass = registeredNode.replaceWithKlass) {\n      klassToMutate = replaceKlass;\n      registeredNode = this._nodes.get(replaceKlass.getType());\n      if (registeredNode === undefined) {\n        {\n          throw Error(`Node ${replaceKlass.name} has not been registered. Ensure node has been passed to createEditor.`);\n        }\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    $flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    $commitPendingUpdates(this);\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVCQUF1Qiw0RUFBNEUsOEJBQThCO0FBQ3RMO0FBQ0EsTUFBTTtBQUNOO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsUUFBUSxJQUFJLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJDQUEyQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQ0FBMkM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsd0JBQXdCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTSxVQUFVLFlBQVksaUNBQWlDLGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUIscUJBQXFCLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTSx5QkFBeUIsT0FBTztBQUNwRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQ0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Qsb0NBQW9DO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkYsaUVBQWlFLG1DQUFtQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlxRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5tanM/ZDllZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWFuZCh0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZVxuICB9IDtcbn1cbmNvbnN0IFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVElPTl9DSEFOR0VfQ09NTUFORCcpO1xuY29uc3QgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQnKTtcbmNvbnN0IENMSUNLX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTElDS19DT01NQU5EJyk7XG5jb25zdCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfTElORV9CUkVBS19DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQnKTtcbmNvbnN0IENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCcpO1xuY29uc3QgUEFTVEVfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1BBU1RFX0NPTU1BTkQnKTtcbmNvbnN0IFJFTU9WRV9URVhUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRU1PVkVfVEVYVF9DT01NQU5EJyk7XG5jb25zdCBERUxFVEVfV09SRF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnREVMRVRFX1dPUkRfQ09NTUFORCcpO1xuY29uc3QgREVMRVRFX0xJTkVfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RFTEVURV9MSU5FX0NPTU1BTkQnKTtcbmNvbnN0IEZPUk1BVF9URVhUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT1JNQVRfVEVYVF9DT01NQU5EJyk7XG5jb25zdCBVTkRPX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdVTkRPX0NPTU1BTkQnKTtcbmNvbnN0IFJFRE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1JFRE9fQ09NTUFORCcpO1xuY29uc3QgS0VZX0RPV05fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWURPV05fQ09NTUFORCcpO1xuY29uc3QgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQVJST1dfUklHSFRfQ09NTUFORCcpO1xuY29uc3QgTU9WRV9UT19FTkQgPSBjcmVhdGVDb21tYW5kKCdNT1ZFX1RPX0VORCcpO1xuY29uc3QgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19MRUZUX0NPTU1BTkQnKTtcbmNvbnN0IE1PVkVfVE9fU1RBUlQgPSBjcmVhdGVDb21tYW5kKCdNT1ZFX1RPX1NUQVJUJyk7XG5jb25zdCBLRVlfQVJST1dfVVBfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19VUF9DT01NQU5EJyk7XG5jb25zdCBLRVlfQVJST1dfRE9XTl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0FSUk9XX0RPV05fQ09NTUFORCcpO1xuY29uc3QgS0VZX0VOVEVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfRU5URVJfQ09NTUFORCcpO1xuY29uc3QgS0VZX1NQQUNFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfU1BBQ0VfQ09NTUFORCcpO1xuY29uc3QgS0VZX0JBQ0tTUEFDRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0JBQ0tTUEFDRV9DT01NQU5EJyk7XG5jb25zdCBLRVlfRVNDQVBFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfRVNDQVBFX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9ERUxFVEVfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9ERUxFVEVfQ09NTUFORCcpO1xuY29uc3QgS0VZX1RBQl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX1RBQl9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfVEFCX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfVEFCX0NPTU1BTkQnKTtcbmNvbnN0IElOREVOVF9DT05URU5UX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTkRFTlRfQ09OVEVOVF9DT01NQU5EJyk7XG5jb25zdCBPVVRERU5UX0NPTlRFTlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ09VVERFTlRfQ09OVEVOVF9DT01NQU5EJyk7XG5jb25zdCBEUk9QX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUk9QX0NPTU1BTkQnKTtcbmNvbnN0IEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT1JNQVRfRUxFTUVOVF9DT01NQU5EJyk7XG5jb25zdCBEUkFHU1RBUlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RSQUdTVEFSVF9DT01NQU5EJyk7XG5jb25zdCBEUkFHT1ZFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJBR09WRVJfQ09NTUFORCcpO1xuY29uc3QgRFJBR0VORF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJBR0VORF9DT01NQU5EJyk7XG5jb25zdCBDT1BZX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDT1BZX0NPTU1BTkQnKTtcbmNvbnN0IENVVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ1VUX0NPTU1BTkQnKTtcbmNvbnN0IFNFTEVDVF9BTExfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVF9BTExfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfRURJVE9SX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTEVBUl9FRElUT1JfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfSElTVE9SWV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0xFQVJfSElTVE9SWV9DT01NQU5EJyk7XG5jb25zdCBDQU5fUkVET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0FOX1JFRE9fQ09NTUFORCcpO1xuY29uc3QgQ0FOX1VORE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NBTl9VTkRPX0NPTU1BTkQnKTtcbmNvbnN0IEZPQ1VTX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT0NVU19DT01NQU5EJyk7XG5jb25zdCBCTFVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdCTFVSX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9NT0RJRklFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX01PRElGSUVSX0NPTU1BTkQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuY29uc3QgSVNfQVBQTEUgPSBDQU5fVVNFX0RPTSAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0ZJUkVGT1ggPSBDQU5fVVNFX0RPTSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCA9IENBTl9VU0VfRE9NICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIGV4cG9ydCBjb25zdCBjYW5Vc2VUZXh0SW5wdXRFdmVudDogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlO1xuXG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IENBTl9VU0VfRE9NICYmIElTX0FORFJPSUQgJiYgSVNfQ0hST01FO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUID0gQ0FOX1VTRV9ET00gJiYgL0FwcGxlV2ViS2l0XFwvW1xcZC5dKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhSVNfQ0hST01FO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gRE9NXG5jb25zdCBET01fRUxFTUVOVF9UWVBFID0gMTtcbmNvbnN0IERPTV9URVhUX1RZUEUgPSAzO1xuXG4vLyBSZWNvbmNpbGluZ1xuY29uc3QgTk9fRElSVFlfTk9ERVMgPSAwO1xuY29uc3QgSEFTX0RJUlRZX05PREVTID0gMTtcbmNvbnN0IEZVTExfUkVDT05DSUxFID0gMjtcblxuLy8gVGV4dCBub2RlIG1vZGVzXG5jb25zdCBJU19OT1JNQUwgPSAwO1xuY29uc3QgSVNfVE9LRU4gPSAxO1xuY29uc3QgSVNfU0VHTUVOVEVEID0gMjtcbi8vIElTX0lORVJUID0gM1xuXG4vLyBUZXh0IG5vZGUgZm9ybWF0dGluZ1xuY29uc3QgSVNfQk9MRCA9IDE7XG5jb25zdCBJU19JVEFMSUMgPSAxIDw8IDE7XG5jb25zdCBJU19TVFJJS0VUSFJPVUdIID0gMSA8PCAyO1xuY29uc3QgSVNfVU5ERVJMSU5FID0gMSA8PCAzO1xuY29uc3QgSVNfQ09ERSA9IDEgPDwgNDtcbmNvbnN0IElTX1NVQlNDUklQVCA9IDEgPDwgNTtcbmNvbnN0IElTX1NVUEVSU0NSSVBUID0gMSA8PCA2O1xuY29uc3QgSVNfSElHSExJR0hUID0gMSA8PCA3O1xuY29uc3QgSVNfQUxMX0ZPUk1BVFRJTkcgPSBJU19CT0xEIHwgSVNfSVRBTElDIHwgSVNfU1RSSUtFVEhST1VHSCB8IElTX1VOREVSTElORSB8IElTX0NPREUgfCBJU19TVUJTQ1JJUFQgfCBJU19TVVBFUlNDUklQVCB8IElTX0hJR0hMSUdIVDtcblxuLy8gVGV4dCBub2RlIGRldGFpbHNcbmNvbnN0IElTX0RJUkVDVElPTkxFU1MgPSAxO1xuY29uc3QgSVNfVU5NRVJHRUFCTEUgPSAxIDw8IDE7XG5cbi8vIEVsZW1lbnQgbm9kZSBmb3JtYXR0aW5nXG5jb25zdCBJU19BTElHTl9MRUZUID0gMTtcbmNvbnN0IElTX0FMSUdOX0NFTlRFUiA9IDI7XG5jb25zdCBJU19BTElHTl9SSUdIVCA9IDM7XG5jb25zdCBJU19BTElHTl9KVVNUSUZZID0gNDtcbmNvbnN0IElTX0FMSUdOX1NUQVJUID0gNTtcbmNvbnN0IElTX0FMSUdOX0VORCA9IDY7XG5cbi8vIFJlY29uY2lsaWF0aW9uXG5jb25zdCBOT05fQlJFQUtJTkdfU1BBQ0UgPSAnXFx1MDBBMCc7XG5jb25zdCBaRVJPX1dJRFRIX1NQQUNFID0gJ1xcdTIwMGInO1xuXG4vLyBGb3IgaU9TL1NhZmFyaSB3ZSB1c2UgYSBub24gYnJlYWtpbmcgc3BhY2UsIG90aGVyd2lzZSB0aGUgY3Vyc29yIGFwcGVhcnNcbi8vIG92ZXJsYXBwaW5nIHRoZSBjb21wb3NlZCB0ZXh0LlxuY29uc3QgQ09NUE9TSVRJT05fU1VGRklYID0gSVNfU0FGQVJJIHx8IElTX0lPUyB8fCBJU19BUFBMRV9XRUJLSVQgPyBOT05fQlJFQUtJTkdfU1BBQ0UgOiBaRVJPX1dJRFRIX1NQQUNFO1xuY29uc3QgRE9VQkxFX0xJTkVfQlJFQUsgPSAnXFxuXFxuJztcblxuLy8gRm9yIEZGLCB3ZSBuZWVkIHRvIHVzZSBhIG5vbi1icmVha2luZyBzcGFjZSwgb3IgaXQgZ2V0cyBjb21wb3NpdGlvblxuLy8gaW4gYSBzdHVjayBzdGF0ZS5cbmNvbnN0IENPTVBPU0lUSU9OX1NUQVJUX0NIQVIgPSBJU19GSVJFRk9YID8gTk9OX0JSRUFLSU5HX1NQQUNFIDogQ09NUE9TSVRJT05fU1VGRklYO1xuY29uc3QgUlRMID0gJ1xcdTA1OTEtXFx1MDdGRlxcdUZCMUQtXFx1RkRGRFxcdUZFNzAtXFx1RkVGQyc7XG5jb25zdCBMVFIgPSAnQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2JyArICdcXHUwMEY4LVxcdTAyQjhcXHUwMzAwLVxcdTA1OTBcXHUwODAwLVxcdTFGRkZcXHUyMDBFXFx1MkMwMC1cXHVGQjFDJyArICdcXHVGRTAwLVxcdUZFNkZcXHVGRUZELVxcdUZGRkYnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcbmNvbnN0IFJUTF9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bXicgKyBMVFIgKyAnXSpbJyArIFJUTCArICddJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcbmNvbnN0IExUUl9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bXicgKyBSVEwgKyAnXSpbJyArIExUUiArICddJyk7XG5jb25zdCBURVhUX1RZUEVfVE9fRk9STUFUID0ge1xuICBib2xkOiBJU19CT0xELFxuICBjb2RlOiBJU19DT0RFLFxuICBoaWdobGlnaHQ6IElTX0hJR0hMSUdIVCxcbiAgaXRhbGljOiBJU19JVEFMSUMsXG4gIHN0cmlrZXRocm91Z2g6IElTX1NUUklLRVRIUk9VR0gsXG4gIHN1YnNjcmlwdDogSVNfU1VCU0NSSVBULFxuICBzdXBlcnNjcmlwdDogSVNfU1VQRVJTQ1JJUFQsXG4gIHVuZGVybGluZTogSVNfVU5ERVJMSU5FXG59O1xuY29uc3QgREVUQUlMX1RZUEVfVE9fREVUQUlMID0ge1xuICBkaXJlY3Rpb25sZXNzOiBJU19ESVJFQ1RJT05MRVNTLFxuICB1bm1lcmdlYWJsZTogSVNfVU5NRVJHRUFCTEVcbn07XG5jb25zdCBFTEVNRU5UX1RZUEVfVE9fRk9STUFUID0ge1xuICBjZW50ZXI6IElTX0FMSUdOX0NFTlRFUixcbiAgZW5kOiBJU19BTElHTl9FTkQsXG4gIGp1c3RpZnk6IElTX0FMSUdOX0pVU1RJRlksXG4gIGxlZnQ6IElTX0FMSUdOX0xFRlQsXG4gIHJpZ2h0OiBJU19BTElHTl9SSUdIVCxcbiAgc3RhcnQ6IElTX0FMSUdOX1NUQVJUXG59O1xuY29uc3QgRUxFTUVOVF9GT1JNQVRfVE9fVFlQRSA9IHtcbiAgW0lTX0FMSUdOX0NFTlRFUl06ICdjZW50ZXInLFxuICBbSVNfQUxJR05fRU5EXTogJ2VuZCcsXG4gIFtJU19BTElHTl9KVVNUSUZZXTogJ2p1c3RpZnknLFxuICBbSVNfQUxJR05fTEVGVF06ICdsZWZ0JyxcbiAgW0lTX0FMSUdOX1JJR0hUXTogJ3JpZ2h0JyxcbiAgW0lTX0FMSUdOX1NUQVJUXTogJ3N0YXJ0J1xufTtcbmNvbnN0IFRFWFRfTU9ERV9UT19UWVBFID0ge1xuICBub3JtYWw6IElTX05PUk1BTCxcbiAgc2VnbWVudGVkOiBJU19TRUdNRU5URUQsXG4gIHRva2VuOiBJU19UT0tFTlxufTtcbmNvbnN0IFRFWFRfVFlQRV9UT19NT0RFID0ge1xuICBbSVNfTk9STUFMXTogJ25vcm1hbCcsXG4gIFtJU19TRUdNRU5URURdOiAnc2VnbWVudGVkJyxcbiAgW0lTX1RPS0VOXTogJ3Rva2VuJ1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gVGhlIHRpbWUgYmV0d2VlbiBhIHRleHQgZW50cnkgZXZlbnQgYW5kIHRoZSBtdXRhdGlvbiBvYnNlcnZlciBmaXJpbmcuXG5jb25zdCBURVhUX01VVEFUSU9OX1ZBUklBTkNFID0gMTAwO1xubGV0IGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IGZhbHNlO1xubGV0IGxhc3RUZXh0RW50cnlUaW1lU3RhbXAgPSAwO1xuZnVuY3Rpb24gZ2V0SXNQcm9jZXNzaW5nTXV0YXRpb25zKCkge1xuICByZXR1cm4gaXNQcm9jZXNzaW5nTXV0YXRpb25zO1xufVxuZnVuY3Rpb24gdXBkYXRlVGltZVN0YW1wKGV2ZW50KSB7XG4gIGxhc3RUZXh0RW50cnlUaW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG59XG5mdW5jdGlvbiBpbml0VGV4dEVudHJ5TGlzdGVuZXIoZWRpdG9yKSB7XG4gIGlmIChsYXN0VGV4dEVudHJ5VGltZVN0YW1wID09PSAwKSB7XG4gICAgZ2V0V2luZG93KGVkaXRvcikuYWRkRXZlbnRMaXN0ZW5lcigndGV4dElucHV0JywgdXBkYXRlVGltZVN0YW1wLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYW5hZ2VkTGluZUJyZWFrKGRvbSwgdGFyZ2V0LCBlZGl0b3IpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIHRhcmdldC5fX2xleGljYWxMaW5lQnJlYWsgPT09IGRvbSB8fFxuICAgIC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cbiAgICBkb21bYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWBdICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldExhc3RTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiAhPT0gbnVsbCA/IHNlbGVjdGlvbi5jbG9uZSgpIDogbnVsbDtcbiAgfSk7XG59XG5mdW5jdGlvbiAkaGFuZGxlVGV4dE11dGF0aW9uKHRhcmdldCwgbm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBudWxsO1xuICBsZXQgZm9jdXNPZmZzZXQgPSBudWxsO1xuICBpZiAoZG9tU2VsZWN0aW9uICE9PSBudWxsICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSB0YXJnZXQpIHtcbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICB9XG4gIGNvbnN0IHRleHQgPSB0YXJnZXQubm9kZVZhbHVlO1xuICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgaWYgKGFuY2hvck5vZGUuaXModGFyZ2V0Tm9kZSkgJiYgc2VsZWN0aW9uLmZvcm1hdCAhPT0gYW5jaG9yTm9kZS5nZXRGb3JtYXQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0RE9NLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFICYmIHRhcmdldE5vZGUuaXNBdHRhY2hlZCgpO1xufVxuZnVuY3Rpb24gJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKSB7XG4gIGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IHRydWU7XG4gIGNvbnN0IHNob3VsZEZsdXNoVGV4dE11dGF0aW9ucyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdFRleHRFbnRyeVRpbWVTdGFtcCA+IFRFWFRfTVVUQVRJT05fVkFSSUFOQ0U7XG4gIHRyeSB7XG4gICAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8IGdldExhc3RTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgIGNvbnN0IGJhZERPTVRhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgICAgLy8gV2UgdXNlIHRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZSwgYXMgdGhhdCByZWZsZWN0cyB3aGF0IGlzXG4gICAgICAvLyBhY3R1YWxseSBcIm9uIHNjcmVlblwiLlxuICAgICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgICAgbGV0IHNob3VsZFJldmVydFNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgbGV0IHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSBtdXRhdGlvbi50eXBlO1xuICAgICAgICBjb25zdCB0YXJnZXRET00gPSBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUodGFyZ2V0RE9NLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICBpZiAodGFyZ2V0Tm9kZSA9PT0gbnVsbCAmJiB0YXJnZXRET00gIT09IHJvb3RFbGVtZW50IHx8ICRpc0RlY29yYXRvck5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnKSB7XG4gICAgICAgICAgLy8gVGV4dCBtdXRhdGlvbnMgYXJlIGRlZmVycmVkIGFuZCBwYXNzZWQgdG8gbXV0YXRpb24gbGlzdGVuZXJzIHRvIGJlXG4gICAgICAgICAgLy8gcHJvY2Vzc2VkIG91dHNpZGUgb2YgdGhlIExleGljYWwgZW5naW5lLlxuICAgICAgICAgIGlmIChzaG91bGRGbHVzaFRleHRNdXRhdGlvbnMgJiYgJGlzVGV4dE5vZGUodGFyZ2V0Tm9kZSkgJiYgc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICAkaGFuZGxlVGV4dE11dGF0aW9uKFxuICAgICAgICAgICAgLy8gbm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUgaXMgYSBUZXh0IERPTSBub2RlXG4gICAgICAgICAgICB0YXJnZXRET00sIHRhcmdldE5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgc2hvdWxkUmV2ZXJ0U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAvLyBXZSBhdHRlbXB0IHRvIFwidW5kb1wiIGFueSBjaGFuZ2VzIHRoYXQgaGF2ZSBvY2N1cnJlZCBvdXRzaWRlXG4gICAgICAgICAgLy8gb2YgTGV4aWNhbC4gV2Ugd2FudCBMZXhpY2FsJ3MgZWRpdG9yIHN0YXRlIHRvIGJlIHNvdXJjZSBvZiB0cnV0aC5cbiAgICAgICAgICAvLyBUbyB0aGUgdXNlciwgdGhlc2Ugd2lsbCBsb29rIGxpa2Ugbm8tb3BzLlxuICAgICAgICAgIGNvbnN0IGFkZGVkRE9NcyA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBhZGRlZERPTXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkRE9NID0gYWRkZWRET01zW3NdO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlRnJvbURPTU5vZGUoYWRkZWRET00pO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RE9NID0gYWRkZWRET00ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRET00gIT0gbnVsbCAmJiBhZGRlZERPTSAhPT0gYmxvY2tDdXJzb3JFbGVtZW50ICYmIG5vZGUgPT09IG51bGwgJiYgKGFkZGVkRE9NLm5vZGVOYW1lICE9PSAnQlInIHx8ICFpc01hbmFnZWRMaW5lQnJlYWsoYWRkZWRET00sIHBhcmVudERPTSwgZWRpdG9yKSkpIHtcbiAgICAgICAgICAgICAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZVRleHQgPSBhZGRlZERPTS5pbm5lclRleHQgfHwgYWRkZWRET00ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSArPSBwb3NzaWJsZVRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudERPTS5yZW1vdmVDaGlsZChhZGRlZERPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlbW92ZWRET01zID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzO1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWRET01zTGVuZ3RoID0gcmVtb3ZlZERPTXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChyZW1vdmVkRE9Nc0xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCB1bnJlbW92ZWRCUnMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCByZW1vdmVkRE9Nc0xlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRET00gPSByZW1vdmVkRE9Nc1tzXTtcbiAgICAgICAgICAgICAgaWYgKHJlbW92ZWRET00ubm9kZU5hbWUgPT09ICdCUicgJiYgaXNNYW5hZ2VkTGluZUJyZWFrKHJlbW92ZWRET00sIHRhcmdldERPTSwgZWRpdG9yKSB8fCBibG9ja0N1cnNvckVsZW1lbnQgPT09IHJlbW92ZWRET00pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRET00uYXBwZW5kQ2hpbGQocmVtb3ZlZERPTSk7XG4gICAgICAgICAgICAgICAgdW5yZW1vdmVkQlJzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW1vdmVkRE9Nc0xlbmd0aCAhPT0gdW5yZW1vdmVkQlJzKSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRET00gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGludGVybmFsR2V0Um9vdChjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJhZERPTVRhcmdldHMuc2V0KHRhcmdldERPTSwgdGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyB3ZSBwcm9jZXNzIGVhY2ggb2YgdGhlIHVuaXF1ZSB0YXJnZXQgbm9kZXMsIGF0dGVtcHRpbmdcbiAgICAgIC8vIHRvIHJlc3RvcmUgdGhlaXIgY29udGVudHMgYmFjayB0byB0aGUgc291cmNlIG9mIHRydXRoLCB3aGljaFxuICAgICAgLy8gaXMgTGV4aWNhbCdzIFwiY3VycmVudFwiIGVkaXRvciBzdGF0ZS4gVGhpcyBpcyBiYXNpY2FsbHkgbGlrZVxuICAgICAgLy8gYW4gaW50ZXJuYWwgcmV2ZXJ0IG9uIHRoZSBET00uXG4gICAgICBpZiAoYmFkRE9NVGFyZ2V0cy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXRET00sIHRhcmdldE5vZGVdIG9mIGJhZERPTVRhcmdldHMpIHtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5cyA9IHRhcmdldE5vZGUuZ2V0Q2hpbGRyZW5LZXlzKCk7XG4gICAgICAgICAgICBsZXQgY3VycmVudERPTSA9IHRhcmdldERPTS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjaGlsZEtleXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGRLZXlzW3NdO1xuICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0RE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShrZXkpO1xuICAgICAgICAgICAgICBpZiAoY29ycmVjdERPTSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50RE9NID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRET00uYXBwZW5kQ2hpbGQoY29ycmVjdERPTSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERPTSA9IGNvcnJlY3RET007XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudERPTSAhPT0gY29ycmVjdERPTSkge1xuICAgICAgICAgICAgICAgIHRhcmdldERPTS5yZXBsYWNlQ2hpbGQoY29ycmVjdERPTSwgY3VycmVudERPTSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudERPTSA9IGN1cnJlbnRET00ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXROb2RlKSkge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5tYXJrRGlydHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FwdHVyZSBhbGwgdGhlIG11dGF0aW9ucyBtYWRlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLiBUaGlzXG4gICAgICAvLyBhbHNvIHByZXZlbnRzIHVzIGhhdmluZyB0byBwcm9jZXNzIHRoZW0gb24gdGhlIG5leHQgY3ljbGVcbiAgICAgIC8vIG9mIG9uTXV0YXRpb24sIGFzIHRoZXNlIG11dGF0aW9ucyB3ZXJlIG1hZGUgYnkgdXMuXG4gICAgICBjb25zdCByZWNvcmRzID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGFueSByYW5kb20gYXV0by1hZGRlZCA8YnI+IGVsZW1lbnRzLCBhbmQgcmVtb3ZlIHRoZW0uXG4gICAgICAvLyBUaGVzZSBnZXQgYWRkZWQgYnkgdGhlIGJyb3dzZXIgd2hlbiB3ZSB1bmRvIHRoZSBhYm92ZSBtdXRhdGlvbnNcbiAgICAgIC8vIGFuZCB0aGlzIGNhbiBsZWFkIHRvIGEgYnJva2VuIFVJLlxuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IGFkZGVkTm9kZXMgPSByZWNvcmQuYWRkZWROb2RlcztcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSByZWNvcmQudGFyZ2V0O1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYWRkZWROb2Rlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkZWRET00gPSBhZGRlZE5vZGVzW3NdO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RE9NID0gYWRkZWRET00ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRET00gIT0gbnVsbCAmJiBhZGRlZERPTS5ub2RlTmFtZSA9PT0gJ0JSJyAmJiAhaXNNYW5hZ2VkTGluZUJyZWFrKGFkZGVkRE9NLCB0YXJnZXQsIGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgcGFyZW50RE9NLnJlbW92ZUNoaWxkKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciBhbnkgb2YgdGhvc2UgcmVtb3ZhbCBtdXRhdGlvbnNcbiAgICAgICAgb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFJldmVydFNlbGVjdGlvbikge1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQocG9zc2libGVUZXh0Rm9yRmlyZWZveFBhc3RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkZmx1c2hSb290TXV0YXRpb25zKGVkaXRvcikge1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoZWRpdG9yKSB7XG4gIGluaXRUZXh0RW50cnlMaXN0ZW5lcihlZGl0b3IpO1xuICBlZGl0b3IuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucywgb2JzZXJ2ZXIpID0+IHtcbiAgICAkZmx1c2hNdXRhdGlvbnMkMShlZGl0b3IsIG11dGF0aW9ucywgb2JzZXJ2ZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkY2FuU2ltcGxlVGV4dE5vZGVzQmVNZXJnZWQobm9kZTEsIG5vZGUyKSB7XG4gIGNvbnN0IG5vZGUxTW9kZSA9IG5vZGUxLl9fbW9kZTtcbiAgY29uc3Qgbm9kZTFGb3JtYXQgPSBub2RlMS5fX2Zvcm1hdDtcbiAgY29uc3Qgbm9kZTFTdHlsZSA9IG5vZGUxLl9fc3R5bGU7XG4gIGNvbnN0IG5vZGUyTW9kZSA9IG5vZGUyLl9fbW9kZTtcbiAgY29uc3Qgbm9kZTJGb3JtYXQgPSBub2RlMi5fX2Zvcm1hdDtcbiAgY29uc3Qgbm9kZTJTdHlsZSA9IG5vZGUyLl9fc3R5bGU7XG4gIHJldHVybiAobm9kZTFNb2RlID09PSBudWxsIHx8IG5vZGUxTW9kZSA9PT0gbm9kZTJNb2RlKSAmJiAobm9kZTFGb3JtYXQgPT09IG51bGwgfHwgbm9kZTFGb3JtYXQgPT09IG5vZGUyRm9ybWF0KSAmJiAobm9kZTFTdHlsZSA9PT0gbnVsbCB8fCBub2RlMVN0eWxlID09PSBub2RlMlN0eWxlKTtcbn1cbmZ1bmN0aW9uICRtZXJnZVRleHROb2Rlcyhub2RlMSwgbm9kZTIpIHtcbiAgY29uc3Qgd3JpdGFibGVOb2RlMSA9IG5vZGUxLm1lcmdlV2l0aFNpYmxpbmcobm9kZTIpO1xuICBjb25zdCBub3JtYWxpemVkTm9kZXMgPSBnZXRBY3RpdmVFZGl0b3IoKS5fbm9ybWFsaXplZE5vZGVzO1xuICBub3JtYWxpemVkTm9kZXMuYWRkKG5vZGUxLl9fa2V5KTtcbiAgbm9ybWFsaXplZE5vZGVzLmFkZChub2RlMi5fX2tleSk7XG4gIHJldHVybiB3cml0YWJsZU5vZGUxO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVRleHROb2RlKHRleHROb2RlKSB7XG4gIGxldCBub2RlID0gdGV4dE5vZGU7XG4gIGlmIChub2RlLl9fdGV4dCA9PT0gJycgJiYgbm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEJhY2t3YXJkXG4gIGxldCBwcmV2aW91c05vZGU7XG4gIHdoaWxlICgocHJldmlvdXNOb2RlID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSkgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUocHJldmlvdXNOb2RlKSAmJiBwcmV2aW91c05vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIXByZXZpb3VzTm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICBpZiAocHJldmlvdXNOb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIHByZXZpb3VzTm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRjYW5TaW1wbGVUZXh0Tm9kZXNCZU1lcmdlZChwcmV2aW91c05vZGUsIG5vZGUpKSB7XG4gICAgICBub2RlID0gJG1lcmdlVGV4dE5vZGVzKHByZXZpb3VzTm9kZSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gRm9yd2FyZFxuICBsZXQgbmV4dE5vZGU7XG4gIHdoaWxlICgobmV4dE5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCkpICE9PSBudWxsICYmICRpc1RleHROb2RlKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbmV4dE5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgaWYgKG5leHROb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIG5leHROb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKG5vZGUsIG5leHROb2RlKSkge1xuICAgICAgbm9kZSA9ICRtZXJnZVRleHROb2Rlcyhub2RlLCBuZXh0Tm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAkbm9ybWFsaXplUG9pbnQoc2VsZWN0aW9uLmFuY2hvcik7XG4gICRub3JtYWxpemVQb2ludChzZWxlY3Rpb24uZm9jdXMpO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVBvaW50KHBvaW50KSB7XG4gIHdoaWxlIChwb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgICBsZXQgbmV4dE5vZGU7XG4gICAgbGV0IG5leHRPZmZzZXRBdEVuZDtcbiAgICBpZiAob2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpKSB7XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUuZ2V0Q2hpbGRBdEluZGV4KG9mZnNldCAtIDEpO1xuICAgICAgbmV4dE9mZnNldEF0RW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuICAgICAgbmV4dE9mZnNldEF0RW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIHBvaW50LnNldChuZXh0Tm9kZS5fX2tleSwgbmV4dE9mZnNldEF0RW5kID8gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgOiAwLCAndGV4dCcpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobmV4dE5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcG9pbnQuc2V0KG5leHROb2RlLl9fa2V5LCBuZXh0T2Zmc2V0QXRFbmQgPyBuZXh0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA6IDAsICdlbGVtZW50Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5sZXQga2V5Q291bnRlciA9IDE7XG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUtleSgpIHtcbiAgcmV0dXJuICcnICsga2V5Q291bnRlcisrO1xufVxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZE5vZGVPclRocm93KGVkaXRvciwgbm9kZVR5cGUpIHtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldChub2RlVHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHJlZ2lzdGVyZWROb2RlOiBUeXBlICR7bm9kZVR5cGV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVnaXN0ZXJlZE5vZGU7XG59XG5jb25zdCBzY2hlZHVsZU1pY3JvVGFzayA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrIDogZm4gPT4ge1xuICAvLyBObyB3aW5kb3cgcHJlZml4IGludGVuZGVkICgjMTQwMClcbiAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbik7XG59O1xuZnVuY3Rpb24gJGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcihub2RlKSB7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKCRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0KGFuY2hvckRPTSkge1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgbm9kZU5hbWUgPSBhY3RpdmVFbGVtZW50Lm5vZGVOYW1lO1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZSgkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhbmNob3JET00pKSAmJiAobm9kZU5hbWUgPT09ICdJTlBVVCcgfHwgbm9kZU5hbWUgPT09ICdURVhUQVJFQScgfHwgYWN0aXZlRWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyAmJlxuICAvLyBAdHMtaWdub3JlIGludGVybmFsIGZpZWxkXG4gIGFjdGl2ZUVsZW1lbnQuX19sZXhpY2FsRWRpdG9yID09IG51bGwpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSB7XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJvb3RFbGVtZW50ICE9PSBudWxsICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGFuY2hvckRPTSkgJiYgcm9vdEVsZW1lbnQuY29udGFpbnMoZm9jdXNET00pICYmXG4gICAgLy8gSWdub3JlIGlmIHNlbGVjdGlvbiBpcyB3aXRoaW4gbmVzdGVkIGVkaXRvclxuICAgIGFuY2hvckRPTSAhPT0gbnVsbCAmJiAhaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoYW5jaG9yRE9NKSAmJiBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUoYW5jaG9yRE9NKSA9PT0gZWRpdG9yO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKG5vZGUpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIGNvbnN0IGVkaXRvciA9IGN1cnJlbnROb2RlLl9fbGV4aWNhbEVkaXRvcjtcbiAgICBpZiAoZWRpdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50RWxlbWVudChjdXJyZW50Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uKHRleHQpIHtcbiAgaWYgKFJUTF9SRUdFWC50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuICdydGwnO1xuICB9XG4gIGlmIChMVFJfUkVHRVgudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiAnbHRyJztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRpc1Rva2VuT3JTZWdtZW50ZWQobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc1Rva2VuKCkgfHwgbm9kZS5pc1NlZ21lbnRlZCgpO1xufVxuZnVuY3Rpb24gaXNET01Ob2RlTGV4aWNhbFRleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBnZXRET01UZXh0Tm9kZShlbGVtZW50KSB7XG4gIGxldCBub2RlID0gZWxlbWVudDtcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChpc0RPTU5vZGVMZXhpY2FsVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBhbGlnbldpdGhGb3JtYXQpIHtcbiAgY29uc3QgYWN0aXZlRm9ybWF0ID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgaWYgKGFsaWduV2l0aEZvcm1hdCAhPT0gbnVsbCAmJiAoZm9ybWF0ICYgYWN0aXZlRm9ybWF0KSA9PT0gKGFsaWduV2l0aEZvcm1hdCAmIGFjdGl2ZUZvcm1hdCkpIHtcbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG4gIGxldCBuZXdGb3JtYXQgPSBmb3JtYXQgXiBhY3RpdmVGb3JtYXQ7XG4gIGlmICh0eXBlID09PSAnc3Vic2NyaXB0Jykge1xuICAgIG5ld0Zvcm1hdCAmPSB+VEVYVF9UWVBFX1RPX0ZPUk1BVC5zdXBlcnNjcmlwdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VwZXJzY3JpcHQnKSB7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULnN1YnNjcmlwdDtcbiAgfVxuICByZXR1cm4gbmV3Rm9ybWF0O1xufVxuZnVuY3Rpb24gJGlzTGVhZk5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzVGV4dE5vZGUobm9kZSkgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gJHNldE5vZGVLZXkobm9kZSwgZXhpc3RpbmdLZXkpIHtcbiAgaWYgKGV4aXN0aW5nS2V5ICE9IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvck9uTm9kZUtleUNvbnN0cnVjdG9yTWlzbWF0Y2gobm9kZSwgZXhpc3RpbmdLZXkpO1xuICAgIH1cbiAgICBub2RlLl9fa2V5ID0gZXhpc3RpbmdLZXk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IGtleSA9IGdlbmVyYXRlUmFuZG9tS2V5KCk7XG4gIGVkaXRvclN0YXRlLl9ub2RlTWFwLnNldChrZXksIG5vZGUpO1xuICAvLyBUT0RPIFNwbGl0IHRoaXMgZnVuY3Rpb24gaW50byBsZWFmL2VsZW1lbnRcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzLnNldChrZXksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBIQVNfRElSVFlfTk9ERVM7XG4gIG5vZGUuX19rZXkgPSBrZXk7XG59XG5mdW5jdGlvbiBlcnJvck9uTm9kZUtleUNvbnN0cnVjdG9yTWlzbWF0Y2gobm9kZSwgZXhpc3RpbmdLZXkpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBpbnRlcm5hbEdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGlmICghZWRpdG9yU3RhdGUpIHtcbiAgICAvLyB0ZXN0cyBleHBlY3QgdG8gYmUgYWJsZSB0byBkbyB0aGlzIGtpbmQgb2YgY2xvbmUgd2l0aG91dCBhbiBhY3RpdmUgZWRpdG9yIHN0YXRlXG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nTm9kZSA9IGVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChleGlzdGluZ0tleSk7XG4gIGlmIChleGlzdGluZ05vZGUgJiYgZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yICE9PSBub2RlLmNvbnN0cnVjdG9yKSB7XG4gICAgLy8gTGlmdGVkIGNvbmRpdGlvbiB0byBpZiBzdGF0ZW1lbnQgYmVjYXVzZSB0aGUgaW52ZXJ0ZWQgbG9naWMgaXMgYSBiaXQgY29uZnVzaW5nXG4gICAgaWYgKG5vZGUuY29uc3RydWN0b3IubmFtZSAhPT0gZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYExleGljYWwgbm9kZSB3aXRoIGNvbnN0cnVjdG9yICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSBhdHRlbXB0ZWQgdG8gcmUtdXNlIGtleSBmcm9tIG5vZGUgaW4gYWN0aXZlIGVkaXRvciBzdGF0ZSB3aXRoIGNvbnN0cnVjdG9yICR7ZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yLm5hbWV9LiBLZXlzIG11c3Qgbm90IGJlIHJlLXVzZWQgd2hlbiB0aGUgdHlwZSBpcyBjaGFuZ2VkLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsIG5vZGUgd2l0aCBjb25zdHJ1Y3RvciAke25vZGUuY29uc3RydWN0b3IubmFtZX0gYXR0ZW1wdGVkIHRvIHJlLXVzZSBrZXkgZnJvbSBub2RlIGluIGFjdGl2ZSBlZGl0b3Igc3RhdGUgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3Igd2l0aCB0aGUgc2FtZSBuYW1lIChwb3NzaWJseSBkdWUgdG8gaW52YWxpZCBIb3QgTW9kdWxlIFJlcGxhY2VtZW50KS4gS2V5cyBtdXN0IG5vdCBiZSByZS11c2VkIHdoZW4gdGhlIHR5cGUgaXMgY2hhbmdlZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVybmFsTWFya1BhcmVudEVsZW1lbnRzQXNEaXJ0eShwYXJlbnRLZXksIG5vZGVNYXAsIGRpcnR5RWxlbWVudHMpIHtcbiAgbGV0IG5leHRQYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gIHdoaWxlIChuZXh0UGFyZW50S2V5ICE9PSBudWxsKSB7XG4gICAgaWYgKGRpcnR5RWxlbWVudHMuaGFzKG5leHRQYXJlbnRLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChuZXh0UGFyZW50S2V5KTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGlydHlFbGVtZW50cy5zZXQobmV4dFBhcmVudEtleSwgZmFsc2UpO1xuICAgIG5leHRQYXJlbnRLZXkgPSBub2RlLl9fcGFyZW50O1xuICB9XG59XG5cbi8vIFRPRE8gIzYwMzEgdGhpcyBmdW5jdGlvbiBvciB0aGVpciBjYWxsZXJzIGhhdmUgdG8gYWRqdXN0IHNlbGVjdGlvbiAoaS5lLiBpbnNlcnRCZWZvcmUpXG5mdW5jdGlvbiByZW1vdmVGcm9tUGFyZW50KG5vZGUpIHtcbiAgY29uc3Qgb2xkUGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZSA9IG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IG9sZFBhcmVudC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGR1cGxpY2F0ZXMgYSBidW5jaCBvZiBvcGVyYXRpb25zLCBjYW4gYmUgc2ltcGxpZmllZC5cbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gd3JpdGFibGVQcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSB3cml0YWJsZU5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgd3JpdGFibGVOb2RlLl9fcHJldiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSB3cml0YWJsZVByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBudWxsO1xuICAgICAgfVxuICAgICAgd3JpdGFibGVOb2RlLl9fbmV4dCA9IG51bGw7XG4gICAgfVxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZS0tO1xuICAgIHdyaXRhYmxlTm9kZS5fX3BhcmVudCA9IG51bGw7XG4gIH1cbn1cblxuLy8gTmV2ZXIgdXNlIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHkhIEl0IHdpbGwgYnJlYWtcbi8vIHRoZSBjbG9uaW5nIGhldXJpc3RpYy4gSW5zdGVhZCB1c2Ugbm9kZS5nZXRXcml0YWJsZSgpLlxuZnVuY3Rpb24gaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobm9kZSkge1xuICBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCk7XG4gIGNvbnN0IGxhdGVzdCA9IG5vZGUuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IHBhcmVudCA9IGxhdGVzdC5fX3BhcmVudDtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrUGFyZW50RWxlbWVudHNBc0RpcnR5KHBhcmVudCwgbm9kZU1hcCwgZGlydHlFbGVtZW50cyk7XG4gIH1cbiAgY29uc3Qga2V5ID0gbGF0ZXN0Ll9fa2V5O1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEhBU19ESVJUWV9OT0RFUztcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZGlydHlFbGVtZW50cy5zZXQoa2V5LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPIHNwbGl0IGludGVybmFsbHkgTWFya05vZGVBc0RpcnR5IGludG8gdHdvIGRlZGljYXRlZCBFbGVtZW50L2xlYXZlIGZ1bmN0aW9uc1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVybmFsTWFya1NpYmxpbmdzQXNEaXJ0eShub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIGNvbnN0IG5leHROb2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICBpZiAocHJldmlvdXNOb2RlICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkocHJldmlvdXNOb2RlKTtcbiAgfVxuICBpZiAobmV4dE5vZGUgIT09IG51bGwpIHtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShuZXh0Tm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRDb21wb3NpdGlvbktleShjb21wb3NpdGlvbktleSkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHByZXZpb3VzQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IHByZXZpb3VzQ29tcG9zaXRpb25LZXkpIHtcbiAgICBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ID0gY29tcG9zaXRpb25LZXk7XG4gICAgaWYgKHByZXZpb3VzQ29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHByZXZpb3VzQ29tcG9zaXRpb25LZXkpO1xuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGNvbXBvc2l0aW9uS2V5KTtcbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRDb21wb3NpdGlvbktleSgpIHtcbiAgaWYgKGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZUJ5S2V5KGtleSwgX2VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gX2VkaXRvclN0YXRlIHx8IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IG5vZGUgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gJGdldE5vZGVGcm9tRE9NTm9kZShkb20sIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAvLyBAdHMtaWdub3JlIFdlIGludGVudGlvbmFsbHkgYWRkIHRoaXMgdG8gdGhlIE5vZGUuXG4gIGNvbnN0IGtleSA9IGRvbVtgX19sZXhpY2FsS2V5XyR7ZWRpdG9yLl9rZXl9YF07XG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAkZ2V0Tm9kZUJ5S2V5KGtleSwgZWRpdG9yU3RhdGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoc3RhcnRpbmdET00sIGVkaXRvclN0YXRlKSB7XG4gIGxldCBkb20gPSBzdGFydGluZ0RPTTtcbiAgd2hpbGUgKGRvbSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlRnJvbURPTU5vZGUoZG9tLCBlZGl0b3JTdGF0ZSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBkb20gPSBnZXRQYXJlbnRFbGVtZW50KGRvbSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9uZURlY29yYXRvcnMoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gZWRpdG9yLl9kZWNvcmF0b3JzO1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnREZWNvcmF0b3JzKTtcbiAgZWRpdG9yLl9wZW5kaW5nRGVjb3JhdG9ycyA9IHBlbmRpbmdEZWNvcmF0b3JzO1xuICByZXR1cm4gcGVuZGluZ0RlY29yYXRvcnM7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JTdGF0ZVRleHRDb250ZW50KGVkaXRvclN0YXRlKSB7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+ICRnZXRSb290KCkuZ2V0VGV4dENvbnRlbnQoKSk7XG59XG5mdW5jdGlvbiBtYXJrQWxsTm9kZXNBc0RpcnR5KGVkaXRvciwgdHlwZSkge1xuICAvLyBNYXJrIGFsbCBleGlzdGluZyB0ZXh0IG5vZGVzIGFzIGRpcnR5XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gICAgaWYgKGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAkZ2V0Um9vdCgpLm1hcmtEaXJ0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2RlTWFwKSB7XG4gICAgICBub2RlLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfSwgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwgPyB7XG4gICAgdGFnOiAnaGlzdG9yeS1tZXJnZSdcbiAgfSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiAkZ2V0Um9vdCgpIHtcbiAgcmV0dXJuIGludGVybmFsR2V0Um9vdChnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpKTtcbn1cbmZ1bmN0aW9uIGludGVybmFsR2V0Um9vdChlZGl0b3JTdGF0ZSkge1xuICByZXR1cm4gZWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KCdyb290Jyk7XG59XG5mdW5jdGlvbiAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgJHNldFNlbGVjdGlvbiBjYWxsZWQgb24gZnJvemVuIHNlbGVjdGlvbiBvYmplY3QuIEVuc3VyZSBzZWxlY3Rpb24gaXMgY2xvbmVkIGJlZm9yZSBwYXNzaW5nIGluLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgc2VsZWN0aW9uLnNldENhY2hlZE5vZGVzKG51bGwpO1xuICB9XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkZmx1c2hNdXRhdGlvbnMoKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgJGZsdXNoUm9vdE11dGF0aW9ucyhlZGl0b3IpO1xufVxuZnVuY3Rpb24gJGdldE5vZGVGcm9tRE9NKGRvbSkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZUtleSA9IGdldE5vZGVLZXlGcm9tRE9NKGRvbSwgZWRpdG9yKTtcbiAgaWYgKG5vZGVLZXkgPT09IG51bGwpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChkb20gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm4gJGdldE5vZGVCeUtleSgncm9vdCcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbn1cbmZ1bmN0aW9uIGdldFRleHROb2RlT2Zmc2V0KG5vZGUsIG1vdmVTZWxlY3Rpb25Ub0VuZCkge1xuICByZXR1cm4gbW92ZVNlbGVjdGlvblRvRW5kID8gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG59XG5mdW5jdGlvbiBnZXROb2RlS2V5RnJvbURPTShcbi8vIE5vdGUgdGhhdCBub2RlIGhlcmUgcmVmZXJzIHRvIGEgRE9NIE5vZGUsIG5vdCBhbiBMZXhpY2FsIE5vZGVcbmRvbSwgZWRpdG9yKSB7XG4gIGxldCBub2RlID0gZG9tO1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBXZSBpbnRlbnRpb25hbGx5IGFkZCB0aGlzIHRvIHRoZSBOb2RlLlxuICAgIGNvbnN0IGtleSA9IG5vZGVbYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWBdO1xuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgbm9kZSA9IGdldFBhcmVudEVsZW1lbnQobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkb2VzQ29udGFpbkdyYXBoZW1lKHN0cikge1xuICByZXR1cm4gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JzVG9Qcm9wYWdhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGVkaXRvcnNUb1Byb3BhZ2F0ZSA9IFtdO1xuICBsZXQgY3VycmVudEVkaXRvciA9IGVkaXRvcjtcbiAgd2hpbGUgKGN1cnJlbnRFZGl0b3IgIT09IG51bGwpIHtcbiAgICBlZGl0b3JzVG9Qcm9wYWdhdGUucHVzaChjdXJyZW50RWRpdG9yKTtcbiAgICBjdXJyZW50RWRpdG9yID0gY3VycmVudEVkaXRvci5fcGFyZW50RWRpdG9yO1xuICB9XG4gIHJldHVybiBlZGl0b3JzVG9Qcm9wYWdhdGU7XG59XG5mdW5jdGlvbiBjcmVhdGVVSUQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5yZXBsYWNlKC9bXmEtel0rL2csICcnKS5zdWJzdHIoMCwgNSk7XG59XG5mdW5jdGlvbiBnZXRBbmNob3JUZXh0RnJvbURPTShhbmNob3JOb2RlKSB7XG4gIGlmIChhbmNob3JOb2RlLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFKSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVZhbHVlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oaXNDb21wb3NpdGlvbkVuZCwgZWRpdG9yLCBkYXRhKSB7XG4gIC8vIFVwZGF0ZSB0aGUgdGV4dCBjb250ZW50IHdpdGggdGhlIGxhdGVzdCBjb21wb3NpdGlvbiB0ZXh0XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBsZXQge1xuICAgIGFuY2hvck9mZnNldCxcbiAgICBmb2N1c09mZnNldFxuICB9ID0gZG9tU2VsZWN0aW9uO1xuICBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCkge1xuICAgIGxldCB0ZXh0Q29udGVudCA9IGdldEFuY2hvclRleHRGcm9tRE9NKGFuY2hvck5vZGUpO1xuICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhbmNob3JOb2RlKTtcbiAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIC8vIERhdGEgaXMgaW50ZW50aW9uYWxseSB0cnV0aHksIGFzIHdlIGNoZWNrIGZvciBib29sZWFuLCBudWxsIGFuZCBlbXB0eSBzdHJpbmcuXG4gICAgICBpZiAodGV4dENvbnRlbnQgPT09IENPTVBPU0lUSU9OX1NVRkZJWCAmJiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0ZXh0Q29udGVudCA9IGRhdGE7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQobm9kZSwgdGV4dENvbnRlbnQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIGlzQ29tcG9zaXRpb25FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQodGV4dE5vZGUsIHRleHRDb250ZW50LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBjb21wb3NpdGlvbkVuZCkge1xuICBsZXQgbm9kZSA9IHRleHROb2RlO1xuICBpZiAobm9kZS5pc0F0dGFjaGVkKCkgJiYgKGNvbXBvc2l0aW9uRW5kIHx8ICFub2RlLmlzRGlydHkoKSkpIHtcbiAgICBjb25zdCBpc0NvbXBvc2luZyA9IG5vZGUuaXNDb21wb3NpbmcoKTtcbiAgICBsZXQgbm9ybWFsaXplZFRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG4gICAgaWYgKChpc0NvbXBvc2luZyB8fCBjb21wb3NpdGlvbkVuZCkgJiYgdGV4dENvbnRlbnRbdGV4dENvbnRlbnQubGVuZ3RoIC0gMV0gPT09IENPTVBPU0lUSU9OX1NVRkZJWCkge1xuICAgICAgbm9ybWFsaXplZFRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2VGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgaWYgKGNvbXBvc2l0aW9uRW5kIHx8IG5vcm1hbGl6ZWRUZXh0Q29udGVudCAhPT0gcHJldlRleHRDb250ZW50KSB7XG4gICAgICBpZiAobm9ybWFsaXplZFRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19JT1MgJiYgIUlTX0FQUExFX1dFQktJVCkge1xuICAgICAgICAgIC8vIEZvciBjb21wb3NpdGlvbiAobWFpbmx5IEFuZHJvaWQpLCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgbm9kZSBvbiBhIGxhdGVyIHVwZGF0ZVxuICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBwcmV2VGV4dENvbnRlbnRTaXplID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICAgIGlmIChub2RlLmlzVG9rZW4oKSB8fCBjb21wb3NpdGlvbktleSAhPT0gbnVsbCAmJiBub2RlS2V5ID09PSBjb21wb3NpdGlvbktleSAmJiAhaXNDb21wb3NpbmcgfHxcbiAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB3YXMgYWRkZWQgYXQgdGhlIHN0YXJ0IG9yIGJvdW5kYXJpZXMgd2hlbiBub3QgaW5zZXJ0YWJsZSwgYW5kIHdlIG5lZWRcbiAgICAgIC8vIHRvIGNsZWFyIHRoaXMgaW5wdXQgZnJvbSBvY2N1cnJpbmcgYXMgdGhhdCBhY3Rpb24gd2Fzbid0IHBlcm1pdHRlZC5cbiAgICAgICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIChwYXJlbnQgIT09IG51bGwgJiYgIXBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgJiYgcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwIHx8IHByZXZTZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gdGV4dE5vZGUuX19rZXkgJiYgcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwICYmICFub2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSAmJiAhaXNDb21wb3NpbmcgfHwgcHJldlNlbGVjdGlvbi5mb2N1cy5rZXkgPT09IHRleHROb2RlLl9fa2V5ICYmIHByZXZTZWxlY3Rpb24uZm9jdXMub2Zmc2V0ID09PSBwcmV2VGV4dENvbnRlbnRTaXplICYmICFub2RlLmNhbkluc2VydFRleHRBZnRlcigpICYmICFpc0NvbXBvc2luZykpIHtcbiAgICAgICAgbm9kZS5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGFuY2hvck9mZnNldCA9PT0gbnVsbCB8fCBmb2N1c09mZnNldCA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnNldFRleHRDb250ZW50KG5vcm1hbGl6ZWRUZXh0Q29udGVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKG5vZGUsIGFuY2hvck9mZnNldCwgbm9kZSwgZm9jdXNPZmZzZXQpO1xuICAgICAgaWYgKG5vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9ICRjcmVhdGVUZXh0Tm9kZShvcmlnaW5hbFRleHRDb250ZW50KTtcbiAgICAgICAgbm9kZS5yZXBsYWNlKHJlcGxhY2VtZW50KTtcbiAgICAgICAgbm9kZSA9IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgICAgbm9kZS5zZXRUZXh0Q29udGVudChub3JtYWxpemVkVGV4dENvbnRlbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHByZXZpb3VzU2libGluZ0RvZXNOb3RBY2NlcHRUZXh0KG5vZGUpIHtcbiAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgcmV0dXJuICgkaXNUZXh0Tm9kZShwcmV2aW91c1NpYmxpbmcpIHx8ICRpc0VsZW1lbnROb2RlKHByZXZpb3VzU2libGluZykgJiYgcHJldmlvdXNTaWJsaW5nLmlzSW5saW5lKCkpICYmICFwcmV2aW91c1NpYmxpbmcuY2FuSW5zZXJ0VGV4dEFmdGVyKCk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgY29ubmVjdGVkIHRvICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGVcbi8vIFRleHROb2RlIGJvdW5kYXJpZXMgYXJlIHdyaXRhYmxlIG9yIHdlIHNob3VsZCB1c2UgdGhlIHByZXZpb3VzL25leHQgc2libGluZyBpbnN0ZWFkLiBGb3IgZXhhbXBsZSxcbi8vIGluIHRoZSBjYXNlIG9mIGEgTGlua05vZGUsIGJvdW5kYXJpZXMgYXJlIG5vdCB3cml0YWJsZS5cbmZ1bmN0aW9uICRzaG91bGRJbnNlcnRUZXh0QWZ0ZXJPckJlZm9yZVRleHROb2RlKHNlbGVjdGlvbiwgbm9kZSkge1xuICBpZiAobm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIGNvbnN0IGlzVG9rZW4gPSBub2RlLmlzVG9rZW4oKTtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiAhbm9kZS5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgIXBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgJiYgIW5vZGUuaXNDb21wb3NpbmcoKSB8fCBpc1Rva2VuIHx8ICRwcmV2aW91c1NpYmxpbmdEb2VzTm90QWNjZXB0VGV4dChub2RlKTtcbiAgfSBlbHNlIGlmIChvZmZzZXQgPT09IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICByZXR1cm4gIW5vZGUuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgfHwgIXBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSAmJiAhbm9kZS5pc0NvbXBvc2luZygpIHx8IGlzVG9rZW47XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1RhYihrZXksIGFsdEtleSwgY3RybEtleSwgbWV0YUtleSkge1xuICByZXR1cm4ga2V5ID09PSAnVGFiJyAmJiAhYWx0S2V5ICYmICFjdHJsS2V5ICYmICFtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNCb2xkKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2InICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzSXRhbGljKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2knICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVW5kZXJsaW5lKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3UnICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoKGtleSwgc2hpZnRLZXkpIHtcbiAgcmV0dXJuIGlzUmV0dXJuKGtleSkgJiYgIXNoaWZ0S2V5O1xufVxuZnVuY3Rpb24gaXNMaW5lQnJlYWsoa2V5LCBzaGlmdEtleSkge1xuICByZXR1cm4gaXNSZXR1cm4oa2V5KSAmJiBzaGlmdEtleTtcbn1cblxuLy8gSW5zZXJ0cyBhIG5ldyBsaW5lIGFmdGVyIHRoZSBzZWxlY3Rpb25cblxuZnVuY3Rpb24gaXNPcGVuTGluZUJyZWFrKGtleSwgY3RybEtleSkge1xuICAvLyA3OSA9IEtleU9cbiAgcmV0dXJuIElTX0FQUExFICYmIGN0cmxLZXkgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdvJztcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlV29yZEJhY2t3YXJkKGtleSwgYWx0S2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBpc0JhY2tzcGFjZShrZXkpICYmIChJU19BUFBMRSA/IGFsdEtleSA6IGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVXb3JkRm9yd2FyZChrZXksIGFsdEtleSwgY3RybEtleSkge1xuICByZXR1cm4gaXNEZWxldGUoa2V5KSAmJiAoSVNfQVBQTEUgPyBhbHRLZXkgOiBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlTGluZUJhY2t3YXJkKGtleSwgbWV0YUtleSkge1xuICByZXR1cm4gSVNfQVBQTEUgJiYgbWV0YUtleSAmJiBpc0JhY2tzcGFjZShrZXkpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVMaW5lRm9yd2FyZChrZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIElTX0FQUExFICYmIG1ldGFLZXkgJiYgaXNEZWxldGUoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlQmFja3dhcmQoa2V5LCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgaWYgKGFsdEtleSB8fCBtZXRhS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0JhY2tzcGFjZShrZXkpIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnaCcgJiYgY3RybEtleTtcbiAgfVxuICBpZiAoY3RybEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNCYWNrc3BhY2Uoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlRm9yd2FyZChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgaWYgKHNoaWZ0S2V5IHx8IGFsdEtleSB8fCBtZXRhS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0RlbGV0ZShrZXkpIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnZCcgJiYgY3RybEtleTtcbiAgfVxuICBpZiAoY3RybEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNEZWxldGUoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzVW5kbyhrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3onICYmICFzaGlmdEtleSAmJiBjb250cm9sT3JNZXRhKG1ldGFLZXksIGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gaXNSZWRvKGtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSAneicgJiYgbWV0YUtleSAmJiBzaGlmdEtleTtcbiAgfVxuICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICd5JyAmJiBjdHJsS2V5IHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAneicgJiYgY3RybEtleSAmJiBzaGlmdEtleTtcbn1cbmZ1bmN0aW9uIGlzQ29weShrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChzaGlmdEtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjJykge1xuICAgIHJldHVybiBJU19BUFBMRSA/IG1ldGFLZXkgOiBjdHJsS2V5O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ3V0KGtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnKSB7XG4gICAgcmV0dXJuIElTX0FQUExFID8gbWV0YUtleSA6IGN0cmxLZXk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNBcnJvd0xlZnQoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdBcnJvd0xlZnQnO1xufVxuZnVuY3Rpb24gaXNBcnJvd1JpZ2h0KGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnQXJyb3dSaWdodCc7XG59XG5mdW5jdGlvbiBpc0Fycm93VXAoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdBcnJvd1VwJztcbn1cbmZ1bmN0aW9uIGlzQXJyb3dEb3duKGtleSkge1xuICByZXR1cm4ga2V5ID09PSAnQXJyb3dEb3duJztcbn1cbmZ1bmN0aW9uIGlzTW92ZUJhY2t3YXJkKGtleSwgY3RybEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93TGVmdChrZXkpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5ICYmICFhbHRLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVUb1N0YXJ0KGtleSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd0xlZnQoa2V5KSAmJiAhYWx0S2V5ICYmICFzaGlmdEtleSAmJiAoY3RybEtleSB8fCBtZXRhS2V5KTtcbn1cbmZ1bmN0aW9uIGlzTW92ZUZvcndhcmQoa2V5LCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dSaWdodChrZXkpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5ICYmICFhbHRLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVUb0VuZChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dSaWdodChrZXkpICYmICFhbHRLZXkgJiYgIXNoaWZ0S2V5ICYmIChjdHJsS2V5IHx8IG1ldGFLZXkpO1xufVxuZnVuY3Rpb24gaXNNb3ZlVXAoa2V5LCBjdHJsS2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93VXAoa2V5KSAmJiAhY3RybEtleSAmJiAhbWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzTW92ZURvd24oa2V5LCBjdHJsS2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93RG93bihrZXkpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNNb2RpZmllcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBjdHJsS2V5IHx8IHNoaWZ0S2V5IHx8IGFsdEtleSB8fCBtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNTcGFjZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJyAnO1xufVxuZnVuY3Rpb24gY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChJU19BUFBMRSkge1xuICAgIHJldHVybiBtZXRhS2V5O1xuICB9XG4gIHJldHVybiBjdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNSZXR1cm4oa2V5KSB7XG4gIHJldHVybiBrZXkgPT09ICdFbnRlcic7XG59XG5mdW5jdGlvbiBpc0JhY2tzcGFjZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0JhY2tzcGFjZSc7XG59XG5mdW5jdGlvbiBpc0VzY2FwZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0VzY2FwZSc7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ0RlbGV0ZSc7XG59XG5mdW5jdGlvbiBpc1NlbGVjdEFsbChrZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSAnYScgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uICRzZWxlY3RBbGwoKSB7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCBzZWxlY3Rpb24gPSByb290LnNlbGVjdCgwLCByb290LmdldENoaWxkcmVuU2l6ZSgpKTtcbiAgJHNldFNlbGVjdGlvbigkbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbikpO1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkoY2xhc3NOYW1lc1RoZW1lLCBjbGFzc05hbWVUaGVtZVR5cGUpIHtcbiAgaWYgKGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xhc3NOYW1lc1RoZW1lLl9fbGV4aWNhbENsYXNzTmFtZUNhY2hlID0ge307XG4gIH1cbiAgY29uc3QgY2xhc3NOYW1lc0NhY2hlID0gY2xhc3NOYW1lc1RoZW1lLl9fbGV4aWNhbENsYXNzTmFtZUNhY2hlO1xuICBjb25zdCBjYWNoZWRDbGFzc05hbWVzID0gY2xhc3NOYW1lc0NhY2hlW2NsYXNzTmFtZVRoZW1lVHlwZV07XG4gIGlmIChjYWNoZWRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkQ2xhc3NOYW1lcztcbiAgfVxuICBjb25zdCBjbGFzc05hbWVzID0gY2xhc3NOYW1lc1RoZW1lW2NsYXNzTmFtZVRoZW1lVHlwZV07XG4gIC8vIEFzIHdlJ3JlIHVzaW5nIGNsYXNzTGlzdCwgd2UgbmVlZFxuICAvLyB0byBoYW5kbGUgY2xhc3NOYW1lIHRva2VucyB0aGF0IGhhdmUgc3BhY2VzLlxuICAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gZG8gdGhpcyB0byBjb252ZXJ0IHRoZVxuICAvLyBjbGFzc05hbWUgdG9rZW5zIHRvIGFuIGFycmF5IHRoYXQgY2FuIGJlXG4gIC8vIGFwcGxpZWQgdG8gY2xhc3NMaXN0LmFkZCgpL3JlbW92ZSgpLlxuICBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG4gICAgY2xhc3NOYW1lc0NhY2hlW2NsYXNzTmFtZVRoZW1lVHlwZV0gPSBjbGFzc05hbWVzQXJyO1xuICAgIHJldHVybiBjbGFzc05hbWVzQXJyO1xuICB9XG4gIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCByZWdpc3RlcmVkTm9kZXMsIG11dGF0aW9uTGlzdGVuZXJzLCBub2RlLCBtdXRhdGlvbikge1xuICBpZiAobXV0YXRpb25MaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBub2RlVHlwZSA9IG5vZGUuX190eXBlO1xuICBjb25zdCBub2RlS2V5ID0gbm9kZS5fX2tleTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSByZWdpc3RlcmVkTm9kZXMuZ2V0KG5vZGVUeXBlKTtcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVHlwZSAke25vZGVUeXBlfSBub3QgaW4gcmVnaXN0ZXJlZE5vZGVzYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtsYXNzID0gcmVnaXN0ZXJlZE5vZGUua2xhc3M7XG4gIGxldCBtdXRhdGVkTm9kZXNCeVR5cGUgPSBtdXRhdGVkTm9kZXMuZ2V0KGtsYXNzKTtcbiAgaWYgKG11dGF0ZWROb2Rlc0J5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbXV0YXRlZE5vZGVzQnlUeXBlID0gbmV3IE1hcCgpO1xuICAgIG11dGF0ZWROb2Rlcy5zZXQoa2xhc3MsIG11dGF0ZWROb2Rlc0J5VHlwZSk7XG4gIH1cbiAgY29uc3QgcHJldk11dGF0aW9uID0gbXV0YXRlZE5vZGVzQnlUeXBlLmdldChub2RlS2V5KTtcbiAgLy8gSWYgdGhlIG5vZGUgaGFzIGFscmVhZHkgYmVlbiBcImRlc3Ryb3llZFwiLCB5ZXQgd2UgYXJlXG4gIC8vIHJlLW1ha2luZyBpdCwgdGhlbiB0aGlzIG1lYW5zIGEgbW92ZSBsaWtlbHkgaGFwcGVuZWQuXG4gIC8vIFdlIHNob3VsZCBjaGFuZ2UgdGhlIG11dGF0aW9uIHRvIGJlIHRoYXQgb2YgXCJ1cGRhdGVkXCJcbiAgLy8gaW5zdGVhZC5cbiAgY29uc3QgaXNNb3ZlID0gcHJldk11dGF0aW9uID09PSAnZGVzdHJveWVkJyAmJiBtdXRhdGlvbiA9PT0gJ2NyZWF0ZWQnO1xuICBpZiAocHJldk11dGF0aW9uID09PSB1bmRlZmluZWQgfHwgaXNNb3ZlKSB7XG4gICAgbXV0YXRlZE5vZGVzQnlUeXBlLnNldChub2RlS2V5LCBpc01vdmUgPyAndXBkYXRlZCcgOiBtdXRhdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uICRub2Rlc09mVHlwZShrbGFzcykge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHJlYWRPbmx5ID0gZWRpdG9yU3RhdGUuX3JlYWRPbmx5O1xuICBjb25zdCBrbGFzc1R5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gIGNvbnN0IG5vZGVzID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVzT2ZUeXBlID0gW107XG4gIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygbm9kZXMpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGtsYXNzICYmIG5vZGUuX190eXBlID09PSBrbGFzc1R5cGUgJiYgKHJlYWRPbmx5IHx8IG5vZGUuaXNBdHRhY2hlZCgpKSkge1xuICAgICAgbm9kZXNPZlR5cGUucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVzT2ZUeXBlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCwgaXNCYWNrd2FyZCwgZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5nZXRQYXJlbnQoKTtcbiAgbGV0IG9mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICBsZXQgYmxvY2sgPSBlbGVtZW50O1xuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcbiAgICAgIG9mZnNldCA9IGJsb2NrLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKCFpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSBibG9jay5nZXRDaGlsZHJlblNpemUoKSkge1xuICAgICAgb2Zmc2V0ID0gYmxvY2suZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrLmdldENoaWxkQXRJbmRleChpc0JhY2t3YXJkID8gb2Zmc2V0IC0gMSA6IG9mZnNldCk7XG59XG5mdW5jdGlvbiAkZ2V0QWRqYWNlbnROb2RlKGZvY3VzLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYmxvY2sgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGJsb2NrLCBpc0JhY2t3YXJkLCBmb2N1c09mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmIChpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSAwIHx8ICFpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSBmb2N1c05vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1c05vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBmb2N1c05vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmIChwb3NzaWJsZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCksIGlzQmFja3dhcmQsIGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgKGlzQmFja3dhcmQgPyAwIDogMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3NpYmxlTm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpcmVmb3hDbGlwYm9hcmRFdmVudHMoZWRpdG9yKSB7XG4gIGNvbnN0IGV2ZW50ID0gZ2V0V2luZG93KGVkaXRvcikuZXZlbnQ7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGV2ZW50ICYmIGV2ZW50LmlucHV0VHlwZTtcbiAgcmV0dXJuIGlucHV0VHlwZSA9PT0gJ2luc2VydEZyb21QYXN0ZScgfHwgaW5wdXRUeXBlID09PSAnaW5zZXJ0RnJvbVBhc3RlQXNRdW90YXRpb24nO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgY29tbWFuZCwgcGF5bG9hZCkge1xuICByZXR1cm4gdHJpZ2dlckNvbW1hbmRMaXN0ZW5lcnMoZWRpdG9yLCBjb21tYW5kLCBwYXlsb2FkKTtcbn1cbmZ1bmN0aW9uICR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQobm9kZSkge1xuICByZXR1cm4gISRpc1Jvb3ROb2RlKG5vZGUpICYmICFub2RlLmlzTGFzdENoaWxkKCkgJiYgIW5vZGUuaXNJbmxpbmUoKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCBrZXkpIHtcbiAgY29uc3QgZWxlbWVudCA9IGVkaXRvci5fa2V5VG9ET01NYXAuZ2V0KGtleSk7XG4gIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgUmVjb25jaWxpYXRpb246IGNvdWxkIG5vdCBmaW5kIERPTSBlbGVtZW50IGZvciBub2RlIGtleSAke2tleX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRFbGVtZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50RWxlbWVudDtcbiAgcmV0dXJuIHBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgcGFyZW50RWxlbWVudC5ub2RlVHlwZSA9PT0gMTEgPyBwYXJlbnRFbGVtZW50Lmhvc3QgOiBwYXJlbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlZGl0b3IsIHNlbGVjdGlvblJlY3QsIHJvb3RFbGVtZW50KSB7XG4gIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuICBpZiAoZGVmYXVsdFZpZXcgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHtcbiAgICB0b3A6IGN1cnJlbnRUb3AsXG4gICAgYm90dG9tOiBjdXJyZW50Qm90dG9tXG4gIH0gPSBzZWxlY3Rpb25SZWN0O1xuICBsZXQgdGFyZ2V0VG9wID0gMDtcbiAgbGV0IHRhcmdldEJvdHRvbSA9IDA7XG4gIGxldCBlbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG4gIHdoaWxlIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3QgaXNCb2R5RWxlbWVudCA9IGVsZW1lbnQgPT09IGRvYy5ib2R5O1xuICAgIGlmIChpc0JvZHlFbGVtZW50KSB7XG4gICAgICB0YXJnZXRUb3AgPSAwO1xuICAgICAgdGFyZ2V0Qm90dG9tID0gZ2V0V2luZG93KGVkaXRvcikuaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGFyZ2V0VG9wID0gdGFyZ2V0UmVjdC50b3A7XG4gICAgICB0YXJnZXRCb3R0b20gPSB0YXJnZXRSZWN0LmJvdHRvbTtcbiAgICB9XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGlmIChjdXJyZW50VG9wIDwgdGFyZ2V0VG9wKSB7XG4gICAgICBkaWZmID0gLSh0YXJnZXRUb3AgLSBjdXJyZW50VG9wKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCb3R0b20gPiB0YXJnZXRCb3R0b20pIHtcbiAgICAgIGRpZmYgPSBjdXJyZW50Qm90dG9tIC0gdGFyZ2V0Qm90dG9tO1xuICAgIH1cbiAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgICAgLy8gT25seSBoYW5kbGVzIHNjcm9sbGluZyBvZiBZIGF4aXNcbiAgICAgICAgZGVmYXVsdFZpZXcuc2Nyb2xsQnkoMCwgZGlmZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgKz0gZGlmZjtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IGVsZW1lbnQuc2Nyb2xsVG9wIC0gc2Nyb2xsVG9wO1xuICAgICAgICBjdXJyZW50VG9wIC09IHlPZmZzZXQ7XG4gICAgICAgIGN1cnJlbnRCb3R0b20gLT0geU9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbGVtZW50ID0gZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gJGhhc1VwZGF0ZVRhZyh0YWcpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIHJldHVybiBlZGl0b3IuX3VwZGF0ZVRhZ3MuaGFzKHRhZyk7XG59XG5mdW5jdGlvbiAkYWRkVXBkYXRlVGFnKHRhZykge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGVkaXRvci5fdXBkYXRlVGFncy5hZGQodGFnKTtcbn1cbmZ1bmN0aW9uICRtYXliZU1vdmVDaGlsZHJlblNlbGVjdGlvblRvUGFyZW50KHBhcmVudE5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc0VsZW1lbnROb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGlmICgkaGFzQW5jZXN0b3IoYW5jaG9yTm9kZSwgcGFyZW50Tm9kZSkpIHtcbiAgICBhbmNob3Iuc2V0KHBhcmVudE5vZGUuX19rZXksIDAsICdlbGVtZW50Jyk7XG4gIH1cbiAgaWYgKCRoYXNBbmNlc3Rvcihmb2N1c05vZGUsIHBhcmVudE5vZGUpKSB7XG4gICAgZm9jdXMuc2V0KHBhcmVudE5vZGUuX19rZXksIDAsICdlbGVtZW50Jyk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRoYXNBbmNlc3RvcihjaGlsZCwgdGFyZ2V0Tm9kZSkge1xuICBsZXQgcGFyZW50ID0gY2hpbGQuZ2V0UGFyZW50KCk7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAocGFyZW50LmlzKHRhcmdldE5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRWaWV3KGRvbUVsZW0pIHtcbiAgY29uc3Qgb3duZXJEb2MgPSBkb21FbGVtLm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvYyAmJiBvd25lckRvYy5kZWZhdWx0VmlldyB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KGVkaXRvcikge1xuICBjb25zdCB3aW5kb3dPYmogPSBlZGl0b3IuX3dpbmRvdztcbiAgaWYgKHdpbmRvd09iaiA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGB3aW5kb3cgb2JqZWN0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gd2luZG93T2JqO1xufVxuZnVuY3Rpb24gJGlzSW5saW5lRWxlbWVudE9yRGVjb3JhdG9yTm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCk7XG59XG5mdW5jdGlvbiAkZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3Qobm9kZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiAkaXNSb290T3JTaGFkb3dSb290KG5vZGUpIHtcbiAgcmV0dXJuICRpc1Jvb3ROb2RlKG5vZGUpIHx8ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuaXNTaGFkb3dSb290KCk7XG59XG5mdW5jdGlvbiAkY29weU5vZGUobm9kZSkge1xuICBjb25zdCBjb3B5ID0gbm9kZS5jb25zdHJ1Y3Rvci5jbG9uZShub2RlKTtcbiAgJHNldE5vZGVLZXkoY29weSwgbnVsbCk7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobm9kZSkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLmNvbnN0cnVjdG9yLmdldFR5cGUoKTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldChub2RlVHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYCRpbml0aWFsaXplTm9kZSBmYWlsZWQuIEVuc3VyZSBub2RlIGhhcyBiZWVuIHJlZ2lzdGVyZWQgdG8gdGhlIGVkaXRvci4gWW91IGNhbiBkbyB0aGlzIGJ5IHBhc3NpbmcgdGhlIG5vZGUgY2xhc3MgdmlhIHRoZSBcIm5vZGVzXCIgYXJyYXkgaW4gdGhlIGVkaXRvciBjb25maWcuYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcGxhY2VGdW5jID0gcmVnaXN0ZXJlZE5vZGUucmVwbGFjZTtcbiAgaWYgKHJlcGxhY2VGdW5jICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gcmVwbGFjZUZ1bmMobm9kZSk7XG4gICAgaWYgKCEocmVwbGFjZW1lbnROb2RlIGluc3RhbmNlb2Ygbm9kZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCRpbml0aWFsaXplTm9kZSBmYWlsZWQuIEVuc3VyZSByZXBsYWNlbWVudCBub2RlIGlzIGEgc3ViY2xhc3Mgb2YgdGhlIG9yaWdpbmFsIG5vZGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlbWVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3Qobm9kZSwgaW5zZXJ0Tm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKCRpc1Jvb3ROb2RlKHBhcmVudE5vZGUpICYmICEkaXNFbGVtZW50Tm9kZShpbnNlcnROb2RlKSAmJiAhJGlzRGVjb3JhdG9yTm9kZShpbnNlcnROb2RlKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBPbmx5IGVsZW1lbnQgb3IgZGVjb3JhdG9yIG5vZGVzIGNhbiBiZSBpbnNlcnRlZCBpbiB0byB0aGUgcm9vdCBub2RlYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yQ29uZmlnKSB7XG4gIGNvbnN0IHRoZW1lID0gZWRpdG9yQ29uZmlnLnRoZW1lO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1jdXJzb3InLCAndHJ1ZScpO1xuICBsZXQgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yO1xuICBpZiAoYmxvY2tDdXJzb3JUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBibG9ja0N1cnNvclRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoYmxvY2tDdXJzb3JUaGVtZSk7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbFxuICAgICAgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yID0gY2xhc3NOYW1lc0FycjtcbiAgICB9XG4gICAgaWYgKGJsb2NrQ3Vyc29yVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmJsb2NrQ3Vyc29yVGhlbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIG5lZWRzQmxvY2tDdXJzb3Iobm9kZSkge1xuICByZXR1cm4gKCRpc0RlY29yYXRvck5vZGUobm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuY2FuQmVFbXB0eSgpKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCkge1xuICByb290RWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY2FyZXQtY29sb3InKTtcbiAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gYmxvY2tDdXJzb3JFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChibG9ja0N1cnNvckVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgbmV4dFNlbGVjdGlvbikge1xuICBsZXQgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSAmJiBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZWxlbWVudE5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgZWxlbWVudE5vZGVTaXplID0gZWxlbWVudE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IGlzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBsZXQgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKG9mZnNldCA9PT0gZWxlbWVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnROb2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQgLSAxKTtcbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50Tm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmIChzaWJsaW5nID09PSBudWxsIHx8IG5lZWRzQmxvY2tDdXJzb3Ioc2libGluZykpIHtcbiAgICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICBpbnNlcnRCZWZvcmVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShjaGlsZC5fX2tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQmxvY2tDdXJzb3IpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnROb2RlLl9fa2V5KTtcbiAgICAgIGlmIChibG9ja0N1cnNvckVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBibG9ja0N1cnNvckVsZW1lbnQgPSBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLl9jb25maWcpO1xuICAgICAgfVxuICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuY2FyZXRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICBpZiAoaW5zZXJ0QmVmb3JlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50RE9NLmFwcGVuZENoaWxkKGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50RE9NLmluc2VydEJlZm9yZShibG9ja0N1cnNvckVsZW1lbnQsIGluc2VydEJlZm9yZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmUgY3Vyc29yXG4gIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RE9NU2VsZWN0aW9uKHRhcmdldFdpbmRvdykge1xuICByZXR1cm4gIUNBTl9VU0VfRE9NID8gbnVsbCA6ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBzdGFydE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuICBpZiAoc3RhcnROb2RlID09IG51bGwpIHtcbiAgICBzdGFydE5vZGUgPSBub2RlO1xuICB9XG4gIGlmICghISRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgQ2FuIG5vdCBjYWxsICRzcGxpdE5vZGUoKSBvbiByb290IGVsZW1lbnRgKTtcbiAgfVxuICBjb25zdCByZWN1cnNlID0gY3VycmVudE5vZGUgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBpc1BhcmVudFJvb3QgPSAkaXNSb290T3JTaGFkb3dSb290KHBhcmVudCk7XG4gICAgLy8gVGhlIG5vZGUgd2Ugc3RhcnQgc3BsaXQgZnJvbSAobGVhZikgaXMgbW92ZWQsIGJ1dCBpdHMgcmVjdXJzaXZlXG4gICAgLy8gcGFyZW50cyBhcmUgY29waWVkIHRvIGNyZWF0ZSBzZXBhcmF0ZSB0cmVlXG4gICAgY29uc3Qgbm9kZVRvTW92ZSA9IGN1cnJlbnROb2RlID09PSBzdGFydE5vZGUgJiYgIWlzUGFyZW50Um9vdCA/IGN1cnJlbnROb2RlIDogJGNvcHlOb2RlKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoaXNQYXJlbnRSb290KSB7XG4gICAgICBpZiAoISgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgJGlzRWxlbWVudE5vZGUobm9kZVRvTW92ZSkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBDaGlsZHJlbiBvZiBhIHJvb3QgbXVzdCBiZSBFbGVtZW50Tm9kZWApO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZVRvTW92ZSk7XG4gICAgICByZXR1cm4gW2N1cnJlbnROb2RlLCBub2RlVG9Nb3ZlLCBub2RlVG9Nb3ZlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW2xlZnRUcmVlLCByaWdodFRyZWUsIG5ld1BhcmVudF0gPSByZWN1cnNlKHBhcmVudCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgIG5ld1BhcmVudC5hcHBlbmQobm9kZVRvTW92ZSwgLi4ubmV4dFNpYmxpbmdzKTtcbiAgICAgIHJldHVybiBbbGVmdFRyZWUsIHJpZ2h0VHJlZSwgbm9kZVRvTW92ZV07XG4gICAgfVxuICB9O1xuICBjb25zdCBbbGVmdFRyZWUsIHJpZ2h0VHJlZV0gPSByZWN1cnNlKHN0YXJ0Tm9kZSk7XG4gIHJldHVybiBbbGVmdFRyZWUsIHJpZ2h0VHJlZV07XG59XG5cbi8qKlxuICogQHBhcmFtIHggLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0ZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGFuIEhUTUwgYW5jaG9yIHRhZywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzSFRNTEFuY2hvckVsZW1lbnQoeCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudCh4KSAmJiB4LnRhZ05hbWUgPT09ICdBJztcbn1cblxuLyoqXG4gKiBAcGFyYW0geCAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RpbmdcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGFuIEhUTUwgZWxlbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHgpIHtcbiAgLy8gQHRzLWlnbm9yZS1uZXh0LWxpbmUgLSBzdHJpY3QgY2hlY2sgb24gbm9kZVR5cGUgaGVyZSBzaG91bGQgZmlsdGVyIG91dCBub24tRWxlbWVudCBFdmVudFRhcmdldCBpbXBsZW1lbnRvcnNcbiAgcmV0dXJuIHgubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBub2RlIC0gdGhlIERvbSBOb2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBpZiB0aGUgRG9tIE5vZGUgaXMgYW4gaW5saW5lIG5vZGVcbiAqL1xuZnVuY3Rpb24gaXNJbmxpbmVEb21Ob2RlKG5vZGUpIHtcbiAgY29uc3QgaW5saW5lTm9kZXMgPSBuZXcgUmVnRXhwKC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyfCN0ZXh0KSQvLCAnaScpO1xuICByZXR1cm4gbm9kZS5ub2RlTmFtZS5tYXRjaChpbmxpbmVOb2RlcykgIT09IG51bGw7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBub2RlIC0gdGhlIERvbSBOb2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBpZiB0aGUgRG9tIE5vZGUgaXMgYSBibG9jayBub2RlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvY2tEb21Ob2RlKG5vZGUpIHtcbiAgY29uc3QgYmxvY2tOb2RlcyA9IG5ldyBSZWdFeHAoL14oYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJsb2NrcXVvdGV8Y2FudmFzfGRkfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxoMXxoMnxoM3xoNHxoNXxoNnxoZWFkZXJ8aHJ8bGl8bWFpbnxuYXZ8bm9zY3JpcHR8b2x8cHxwcmV8c2VjdGlvbnx0YWJsZXx0ZHx0Zm9vdHx1bHx2aWRlbykkLywgJ2knKTtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUubWF0Y2goYmxvY2tOb2RlcykgIT09IG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9mIHRoZSBsaWJyYXJ5LlxuICogUGxlYXNlIGRvIG5vdCB1c2UgaXQgYXMgaXQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5mdW5jdGlvbiBJTlRFUk5BTF8kaXNCbG9jayhub2RlKSB7XG4gIGlmICgkaXNSb290Tm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpIHx8ICRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICBjb25zdCBpc0xlYWZFbGVtZW50ID0gZmlyc3RDaGlsZCA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8IGZpcnN0Q2hpbGQuaXNJbmxpbmUoKTtcbiAgcmV0dXJuICFub2RlLmlzSW5saW5lKCkgJiYgbm9kZS5jYW5CZUVtcHR5KCkgIT09IGZhbHNlICYmIGlzTGVhZkVsZW1lbnQ7XG59XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYWNjZXNzaW5nIGN1cnJlbnQgYWN0aXZlIGVkaXRvciBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIEN1cnJlbnQgYWN0aXZlIGVkaXRvclxuICovXG5mdW5jdGlvbiAkZ2V0RWRpdG9yKCkge1xuICByZXR1cm4gZ2V0QWN0aXZlRWRpdG9yKCk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gZWRpdG9yLl9kZWNvcmF0b3JzO1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IGVkaXRvci5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGxldCBkZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnMgfHwgY3VycmVudERlY29yYXRvcnM7XG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoIW5vZGVNYXAuaGFzKGtleSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzID09PSBjdXJyZW50RGVjb3JhdG9ycykge1xuICAgICAgICBkZWNvcmF0b3JzID0gY2xvbmVEZWNvcmF0b3JzKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBkZWxldGUgZGVjb3JhdG9yc1trZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBwYXJlbnRLZXksIHByZXZOb2RlTWFwLCBub2RlTWFwLCBub2RlTWFwRGVsZXRlLCBkaXJ0eU5vZGVzKSB7XG4gIGxldCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBjb25zdCBjaGlsZEtleSA9IGNoaWxkLl9fa2V5O1xuICAgIC8vIFRPRE8gUmV2aXNlIGNvbmRpdGlvbiBiZWxvdywgcmVkdW5kYW50PyBMZXhpY2FsTm9kZSBhbHJlYWR5IGNsZWFucyB1cCBjaGlsZHJlbiB3aGVuIG1vdmluZyBOb2Rlc1xuICAgIGlmIChjaGlsZC5fX3BhcmVudCA9PT0gcGFyZW50S2V5KSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVlcENoaWxkTm9kZXMoY2hpbGQsIGNoaWxkS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlOb2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgY3JlYXRlZCBhIG5vZGUgYW5kIGl0IHdhcyBkZXJlZmVyZW5jZWQsIHRoZW4gYWxzb1xuICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gb3V0IGRpcnR5IG5vZGVzIFNldC5cbiAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKGNoaWxkS2V5KSkge1xuICAgICAgICBkaXJ0eU5vZGVzLmRlbGV0ZShjaGlsZEtleSk7XG4gICAgICB9XG4gICAgICBub2RlTWFwRGVsZXRlLnB1c2goY2hpbGRLZXkpO1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRnYXJiYWdlQ29sbGVjdERldGFjaGVkTm9kZXMocHJldkVkaXRvclN0YXRlLCBlZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMpIHtcbiAgY29uc3QgcHJldk5vZGVNYXAgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgLy8gU3RvcmUgZGlydHlFbGVtZW50cyBpbiBhIHF1ZXVlIGZvciBsYXRlciBkZWxldGlvbjsgZGVsZXRpbmcgZGlydHkgc3VidHJlZXMgdG9vIGVhcmx5IHdpbGxcbiAgLy8gaGluZGVyIGFjY2Vzc2luZyAuX19uZXh0IG9uIGNoaWxkIG5vZGVzXG4gIGNvbnN0IG5vZGVNYXBEZWxldGUgPSBbXTtcbiAgZm9yIChjb25zdCBbbm9kZUtleV0gb2YgZGlydHlFbGVtZW50cykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBHYXJiYWdlIGNvbGxlY3Qgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGlmIHRoZXkgZXhpc3RcbiAgICAgIGlmICghbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBub2RlS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlFbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjcmVhdGVkIGEgbm9kZSBhbmQgaXQgd2FzIGRlcmVmZXJlbmNlZCwgdGhlbiBhbHNvXG4gICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIG91dCBkaXJ0eSBub2RlcyBTZXQuXG4gICAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgZGlydHlFbGVtZW50cy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZU1hcERlbGV0ZS5wdXNoKG5vZGVLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IG5vZGVLZXkgb2Ygbm9kZU1hcERlbGV0ZSkge1xuICAgIG5vZGVNYXAuZGVsZXRlKG5vZGVLZXkpO1xuICB9XG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgaWYgKCFwcmV2Tm9kZU1hcC5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgZGlydHlMZWF2ZXMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgfVxuICAgICAgbm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxubGV0IHN1YlRyZWVUZXh0Q29udGVudCA9ICcnO1xubGV0IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG5sZXQgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xubGV0IGVkaXRvclRleHRDb250ZW50ID0gJyc7XG5sZXQgYWN0aXZlRWRpdG9yQ29uZmlnO1xubGV0IGFjdGl2ZUVkaXRvciQxO1xubGV0IGFjdGl2ZUVkaXRvck5vZGVzO1xubGV0IHRyZWF0QWxsTm9kZXNBc0RpcnR5ID0gZmFsc2U7XG5sZXQgYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSA9IGZhbHNlO1xubGV0IGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzO1xubGV0IGFjdGl2ZVRleHREaXJlY3Rpb24gPSBudWxsO1xubGV0IGFjdGl2ZURpcnR5RWxlbWVudHM7XG5sZXQgYWN0aXZlRGlydHlMZWF2ZXM7XG5sZXQgYWN0aXZlUHJldk5vZGVNYXA7XG5sZXQgYWN0aXZlTmV4dE5vZGVNYXA7XG5sZXQgYWN0aXZlUHJldktleVRvRE9NTWFwO1xubGV0IG11dGF0ZWROb2RlcztcbmZ1bmN0aW9uIGRlc3Ryb3lOb2RlKGtleSwgcGFyZW50RE9NKSB7XG4gIGNvbnN0IG5vZGUgPSBhY3RpdmVQcmV2Tm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKHBhcmVudERPTSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRvbSA9IGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSk7XG4gICAgaWYgKGRvbS5wYXJlbnROb2RlID09PSBwYXJlbnRET00pIHtcbiAgICAgIHBhcmVudERPTS5yZW1vdmVDaGlsZChkb20pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbG9naWMgaXMgcmVhbGx5IGltcG9ydGFudCwgb3RoZXJ3aXNlIHdlIHdpbGwgbGVhayBET00gbm9kZXNcbiAgLy8gd2hlbiB0aGVpciBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gIGlmICghYWN0aXZlTmV4dE5vZGVNYXAuaGFzKGtleSkpIHtcbiAgICBhY3RpdmVFZGl0b3IkMS5fa2V5VG9ET01NYXAuZGVsZXRlKGtleSk7XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5vZGUsIGFjdGl2ZVByZXZOb2RlTWFwKTtcbiAgICBkZXN0cm95Q2hpbGRyZW4oY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCAtIDEsIG51bGwpO1xuICB9XG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIGFjdGl2ZUVkaXRvck5vZGVzLCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgJ2Rlc3Ryb3llZCcpO1xuICB9XG59XG5mdW5jdGlvbiBkZXN0cm95Q2hpbGRyZW4oY2hpbGRyZW4sIF9zdGFydEluZGV4LCBlbmRJbmRleCwgZG9tKSB7XG4gIGxldCBzdGFydEluZGV4ID0gX3N0YXJ0SW5kZXg7XG4gIGZvciAoOyBzdGFydEluZGV4IDw9IGVuZEluZGV4OyArK3N0YXJ0SW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW3N0YXJ0SW5kZXhdO1xuICAgIGlmIChjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0cm95Tm9kZShjaGlsZCwgZG9tKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRleHRBbGlnbihkb21TdHlsZSwgdmFsdWUpIHtcbiAgZG9tU3R5bGUuc2V0UHJvcGVydHkoJ3RleHQtYWxpZ24nLCB2YWx1ZSk7XG59XG5jb25zdCBERUZBVUxUX0lOREVOVF9WQUxVRSA9ICc0MHB4JztcbmZ1bmN0aW9uIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBpbmRlbnQpIHtcbiAgY29uc3QgaW5kZW50Q2xhc3NOYW1lID0gYWN0aXZlRWRpdG9yQ29uZmlnLnRoZW1lLmluZGVudDtcbiAgaWYgKHR5cGVvZiBpbmRlbnRDbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZWxlbWVudEhhc0NsYXNzTmFtZSA9IGRvbS5jbGFzc0xpc3QuY29udGFpbnMoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICBpZiAoaW5kZW50ID4gMCAmJiAhZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGluZGVudCA8IDEgJiYgZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5yZW1vdmUoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaW5kZW50YXRpb25CYXNlVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKGRvbSkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1sZXhpY2FsLWluZGVudC1iYXNlLXZhbHVlJykgfHwgREVGQVVMVF9JTkRFTlRfVkFMVUU7XG4gIGRvbS5zdHlsZS5zZXRQcm9wZXJ0eSgncGFkZGluZy1pbmxpbmUtc3RhcnQnLCBpbmRlbnQgPT09IDAgPyAnJyA6IGBjYWxjKCR7aW5kZW50fSAqICR7aW5kZW50YXRpb25CYXNlVmFsdWV9KWApO1xufVxuZnVuY3Rpb24gc2V0RWxlbWVudEZvcm1hdChkb20sIGZvcm1hdCkge1xuICBjb25zdCBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJycpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fTEVGVCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2xlZnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0NFTlRFUikge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2NlbnRlcicpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fUklHSFQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdyaWdodCcpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fSlVTVElGWSkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2p1c3RpZnknKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX1NUQVJUKSB7XG4gICAgc2V0VGV4dEFsaWduKGRvbVN0eWxlLCAnc3RhcnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0VORCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2VuZCcpO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlTm9kZShrZXksIHBhcmVudERPTSwgaW5zZXJ0RE9NKSB7XG4gIGNvbnN0IG5vZGUgPSBhY3RpdmVOZXh0Tm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBjcmVhdGVOb2RlOiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZG9tID0gbm9kZS5jcmVhdGVET00oYWN0aXZlRWRpdG9yQ29uZmlnLCBhY3RpdmVFZGl0b3IkMSk7XG4gIHN0b3JlRE9NV2l0aEtleShrZXksIGRvbSwgYWN0aXZlRWRpdG9yJDEpO1xuXG4gIC8vIFRoaXMgaGVscHMgcHJlc2VydmUgdGhlIHRleHQsIGFuZCBzdG9wcyBzcGVsbCBjaGVjayB0b29scyBmcm9tXG4gIC8vIG1lcmdpbmcgb3IgYnJlYWsgdGhlIHNwYW5zICh3aGljaCBoYXBwZW5zIGlmIHRoZXkgYXJlIG1pc3NpbmdcbiAgLy8gdGhpcyBhdHRyaWJ1dGUpLlxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtdGV4dCcsICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1kZWNvcmF0b3InLCAndHJ1ZScpO1xuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IGluZGVudCA9IG5vZGUuX19pbmRlbnQ7XG4gICAgY29uc3QgY2hpbGRyZW5TaXplID0gbm9kZS5fX3NpemU7XG4gICAgaWYgKGluZGVudCAhPT0gMCkge1xuICAgICAgc2V0RWxlbWVudEluZGVudChkb20sIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlblNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGVuZEluZGV4ID0gY2hpbGRyZW5TaXplIC0gMTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShub2RlLCBhY3RpdmVOZXh0Tm9kZU1hcCk7XG4gICAgICAkY3JlYXRlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKGNoaWxkcmVuLCBlbmRJbmRleCwgbm9kZSwgZG9tKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybWF0ID0gbm9kZS5fX2Zvcm1hdDtcbiAgICBpZiAoZm9ybWF0ICE9PSAwKSB7XG4gICAgICBzZXRFbGVtZW50Rm9ybWF0KGRvbSwgZm9ybWF0KTtcbiAgICB9XG4gICAgaWYgKCFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIHJlY29uY2lsZUVsZW1lbnRUZXJtaW5hdGluZ0xpbmVCcmVhayhudWxsLCBub2RlLCBkb20pO1xuICAgIH1cbiAgICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChub2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IG5vZGUuZGVjb3JhdGUoYWN0aXZlRWRpdG9yJDEsIGFjdGl2ZUVkaXRvckNvbmZpZyk7XG4gICAgICBpZiAoZGVjb3JhdG9yICE9PSBudWxsKSB7XG4gICAgICAgIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcik7XG4gICAgICB9XG4gICAgICAvLyBEZWNvcmF0b3JzIGFyZSBhbHdheXMgbm9uIGVkaXRhYmxlXG4gICAgICBkb20uY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBpZiAoIW5vZGUuaXNEaXJlY3Rpb25sZXNzKCkpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgfVxuICBpZiAocGFyZW50RE9NICE9PSBudWxsKSB7XG4gICAgaWYgKGluc2VydERPTSAhPSBudWxsKSB7XG4gICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGRvbSwgaW5zZXJ0RE9NKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IHBvc3NpYmxlTGluZUJyZWFrID0gcGFyZW50RE9NLl9fbGV4aWNhbExpbmVCcmVhaztcbiAgICAgIGlmIChwb3NzaWJsZUxpbmVCcmVhayAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudERPTS5pbnNlcnRCZWZvcmUoZG9tLCBwb3NzaWJsZUxpbmVCcmVhayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRET00uYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIC8vIEZyZWV6ZSB0aGUgbm9kZSBpbiBERVYgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uc1xuICAgIE9iamVjdC5mcmVlemUobm9kZSk7XG4gIH1cbiAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5vZGUsICdjcmVhdGVkJyk7XG4gIHJldHVybiBkb207XG59XG5mdW5jdGlvbiAkY3JlYXRlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKGNoaWxkcmVuLCBlbmRJbmRleCwgZWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgJGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCAwLCBlbmRJbmRleCwgZG9tLCBudWxsKTtcbiAgcmVjb25jaWxlQmxvY2tEaXJlY3Rpb24oZWxlbWVudCwgZG9tKTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCBfc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRvbSwgaW5zZXJ0RE9NKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgbGV0IHN0YXJ0SW5kZXggPSBfc3RhcnRJbmRleDtcbiAgZm9yICg7IHN0YXJ0SW5kZXggPD0gZW5kSW5kZXg7ICsrc3RhcnRJbmRleCkge1xuICAgICRjcmVhdGVOb2RlKGNoaWxkcmVuW3N0YXJ0SW5kZXhdLCBkb20sIGluc2VydERPTSk7XG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5leHROb2RlTWFwLmdldChjaGlsZHJlbltzdGFydEluZGV4XSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwgJiYgc3ViVHJlZVRleHRGb3JtYXQgPT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Rm9ybWF0ID0gbm9kZS5nZXRGb3JtYXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQoZWxlbWVudCkpIHtcbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gIH1cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgZG9tLl9fbGV4aWNhbFRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCArIHN1YlRyZWVUZXh0Q29udGVudDtcbn1cbmZ1bmN0aW9uIGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IoY2hpbGRLZXksIG5vZGVNYXApIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KGNoaWxkS2V5KTtcbiAgcmV0dXJuICRpc0xpbmVCcmVha05vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCk7XG59XG5cbi8vIElmIHdlIGVuZCBhbiBlbGVtZW50IHdpdGggYSBMaW5lQnJlYWtOb2RlLCB0aGVuIHdlIG5lZWQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgPGJyPlxuZnVuY3Rpb24gcmVjb25jaWxlRWxlbWVudFRlcm1pbmF0aW5nTGluZUJyZWFrKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZMaW5lQnJlYWsgPSBwcmV2RWxlbWVudCAhPT0gbnVsbCAmJiAocHJldkVsZW1lbnQuX19zaXplID09PSAwIHx8IGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IocHJldkVsZW1lbnQuX19sYXN0LCBhY3RpdmVQcmV2Tm9kZU1hcCkpO1xuICBjb25zdCBuZXh0TGluZUJyZWFrID0gbmV4dEVsZW1lbnQuX19zaXplID09PSAwIHx8IGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IobmV4dEVsZW1lbnQuX19sYXN0LCBhY3RpdmVOZXh0Tm9kZU1hcCk7XG4gIGlmIChwcmV2TGluZUJyZWFrKSB7XG4gICAgaWYgKCFuZXh0TGluZUJyZWFrKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY29uc3QgZWxlbWVudCA9IGRvbS5fX2xleGljYWxMaW5lQnJlYWs7XG4gICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGRvbS5fX2xleGljYWxMaW5lQnJlYWsgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0TGluZUJyZWFrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICBkb20uX19sZXhpY2FsTGluZUJyZWFrID0gZWxlbWVudDtcbiAgICBkb20uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29uY2lsZVBhcmFncmFwaEZvcm1hdChlbGVtZW50KSB7XG4gIGlmICgkaXNQYXJhZ3JhcGhOb2RlKGVsZW1lbnQpICYmIHN1YlRyZWVUZXh0Rm9ybWF0ICE9IG51bGwgJiYgc3ViVHJlZVRleHRGb3JtYXQgIT09IGVsZW1lbnQuX190ZXh0Rm9ybWF0KSB7XG4gICAgZWxlbWVudC5zZXRUZXh0Rm9ybWF0KHN1YlRyZWVUZXh0Rm9ybWF0KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb25jaWxlQmxvY2tEaXJlY3Rpb24oZWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ID1cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgZG9tLl9fbGV4aWNhbERpclRleHRDb250ZW50O1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICBjb25zdCBwcmV2aW91c0RpcmVjdGlvbiA9IGRvbS5fX2xleGljYWxEaXI7XG4gIGlmIChwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCAhPT0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgfHwgcHJldmlvdXNEaXJlY3Rpb24gIT09IGFjdGl2ZVRleHREaXJlY3Rpb24pIHtcbiAgICBjb25zdCBoYXNFbXB0eURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9PT0gJyc7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gaGFzRW1wdHlEaXJlY3Rpb25lZFRleHRDb250ZW50ID8gYWN0aXZlVGV4dERpcmVjdGlvbiA6IGdldFRleHREaXJlY3Rpb24oc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQpO1xuICAgIGlmIChkaXJlY3Rpb24gIT09IHByZXZpb3VzRGlyZWN0aW9uKSB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBkb20uY2xhc3NMaXN0O1xuICAgICAgY29uc3QgdGhlbWUgPSBhY3RpdmVFZGl0b3JDb25maWcudGhlbWU7XG4gICAgICBsZXQgcHJldmlvdXNEaXJlY3Rpb25UaGVtZSA9IHByZXZpb3VzRGlyZWN0aW9uICE9PSBudWxsID8gdGhlbWVbcHJldmlvdXNEaXJlY3Rpb25dIDogdW5kZWZpbmVkO1xuICAgICAgbGV0IG5leHREaXJlY3Rpb25UaGVtZSA9IGRpcmVjdGlvbiAhPT0gbnVsbCA/IHRoZW1lW2RpcmVjdGlvbl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIHRoZW1lIGNsYXNzZXMgaWYgdGhleSBleGlzdFxuICAgICAgaWYgKHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMocHJldmlvdXNEaXJlY3Rpb25UaGVtZSk7XG4gICAgICAgICAgcHJldmlvdXNEaXJlY3Rpb25UaGVtZSA9IHRoZW1lW3ByZXZpb3VzRGlyZWN0aW9uXSA9IGNsYXNzTmFtZXNBcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlOiBpbnRlbnRpb25hbFxuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKC4uLnByZXZpb3VzRGlyZWN0aW9uVGhlbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gbnVsbCB8fCBoYXNFbXB0eURpcmVjdGlvbmVkVGV4dENvbnRlbnQgJiYgZGlyZWN0aW9uID09PSAnbHRyJykge1xuICAgICAgICAvLyBSZW1vdmUgZGlyZWN0aW9uXG4gICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2RpcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXBwbHkgdGhlIG5ldyB0aGVtZSBjbGFzc2VzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgaWYgKG5leHREaXJlY3Rpb25UaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0RGlyZWN0aW9uVGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzQXJyID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhuZXh0RGlyZWN0aW9uVGhlbWUpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcbiAgICAgICAgICAgIG5leHREaXJlY3Rpb25UaGVtZSA9IHRoZW1lW2RpcmVjdGlvbl0gPSBjbGFzc05hbWVzQXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dERpcmVjdGlvblRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoLi4ubmV4dERpcmVjdGlvblRoZW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aW9uXG4gICAgICAgIGRvbS5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOb2RlID0gZWxlbWVudC5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZU5vZGUuX19kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZVRleHREaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICBkb20uX19sZXhpY2FsRGlyVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIGRvbS5fX2xleGljYWxEaXIgPSBkaXJlY3Rpb247XG4gIH1cbn1cbmZ1bmN0aW9uICRyZWNvbmNpbGVDaGlsZHJlbldpdGhEaXJlY3Rpb24ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xuICAkcmVjb25jaWxlQ2hpbGRyZW4ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pO1xuICByZWNvbmNpbGVCbG9ja0RpcmVjdGlvbihuZXh0RWxlbWVudCwgZG9tKTtcbiAgcmVjb25jaWxlUGFyYWdyYXBoRm9ybWF0KG5leHRFbGVtZW50KTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudDtcbiAgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5BcnJheShlbGVtZW50LCBub2RlTWFwKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG4gIGxldCBub2RlS2V5ID0gZWxlbWVudC5fX2ZpcnN0O1xuICB3aGlsZSAobm9kZUtleSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBjcmVhdGVDaGlsZHJlbkFycmF5OiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGRyZW4ucHVzaChub2RlS2V5KTtcbiAgICBub2RlS2V5ID0gbm9kZS5fX25leHQ7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gJHJlY29uY2lsZUNoaWxkcmVuKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBjb25zdCBwcmV2Q2hpbGRyZW5TaXplID0gcHJldkVsZW1lbnQuX19zaXplO1xuICBjb25zdCBuZXh0Q2hpbGRyZW5TaXplID0gbmV4dEVsZW1lbnQuX19zaXplO1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKHByZXZDaGlsZHJlblNpemUgPT09IDEgJiYgbmV4dENoaWxkcmVuU2l6ZSA9PT0gMSkge1xuICAgIGNvbnN0IHByZXZGaXJzdENoaWxkS2V5ID0gcHJldkVsZW1lbnQuX19maXJzdDtcbiAgICBjb25zdCBuZXh0RnJzdENoaWxkS2V5ID0gbmV4dEVsZW1lbnQuX19maXJzdDtcbiAgICBpZiAocHJldkZpcnN0Q2hpbGRLZXkgPT09IG5leHRGcnN0Q2hpbGRLZXkpIHtcbiAgICAgICRyZWNvbmNpbGVOb2RlKHByZXZGaXJzdENoaWxkS2V5LCBkb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0RE9NID0gZ2V0UHJldkVsZW1lbnRCeUtleU9yVGhyb3cocHJldkZpcnN0Q2hpbGRLZXkpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRET00gPSAkY3JlYXRlTm9kZShuZXh0RnJzdENoaWxkS2V5LCBudWxsLCBudWxsKTtcbiAgICAgIGRvbS5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnRET00sIGxhc3RET00pO1xuICAgICAgZGVzdHJveU5vZGUocHJldkZpcnN0Q2hpbGRLZXksIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Q2hpbGROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KG5leHRGcnN0Q2hpbGRLZXkpO1xuICAgIGlmIChzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShuZXh0Q2hpbGROb2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRGb3JtYXQgPSBuZXh0Q2hpbGROb2RlLmdldEZvcm1hdCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmV2Q2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KHByZXZFbGVtZW50LCBhY3RpdmVQcmV2Tm9kZU1hcCk7XG4gICAgY29uc3QgbmV4dENoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShuZXh0RWxlbWVudCwgYWN0aXZlTmV4dE5vZGVNYXApO1xuICAgIGlmIChwcmV2Q2hpbGRyZW5TaXplID09PSAwKSB7XG4gICAgICBpZiAobmV4dENoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgICAkY3JlYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCBuZXh0RWxlbWVudCwgMCwgbmV4dENoaWxkcmVuU2l6ZSAtIDEsIGRvbSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW5TaXplID09PSAwKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgICBjb25zdCBsZXhpY2FsTGluZUJyZWFrID0gZG9tLl9fbGV4aWNhbExpbmVCcmVhaztcbiAgICAgICAgY29uc3QgY2FuVXNlRmFzdFBhdGggPSBsZXhpY2FsTGluZUJyZWFrID09IG51bGw7XG4gICAgICAgIGRlc3Ryb3lDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIDAsIHByZXZDaGlsZHJlblNpemUgLSAxLCBjYW5Vc2VGYXN0UGF0aCA/IG51bGwgOiBkb20pO1xuICAgICAgICBpZiAoY2FuVXNlRmFzdFBhdGgpIHtcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIHJlbW92aW5nIERPTSBub2Rlc1xuICAgICAgICAgIGRvbS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyZWNvbmNpbGVOb2RlQ2hpbGRyZW4obmV4dEVsZW1lbnQsIHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBwcmV2Q2hpbGRyZW5TaXplLCBuZXh0Q2hpbGRyZW5TaXplLCBkb20pO1xuICAgIH1cbiAgfVxuICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChuZXh0RWxlbWVudCkpIHtcbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICBkb20uX19sZXhpY2FsVGV4dENvbnRlbnQgPSBzdWJUcmVlVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICsgc3ViVHJlZVRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gJHJlY29uY2lsZU5vZGUoa2V5LCBwYXJlbnRET00pIHtcbiAgY29uc3QgcHJldk5vZGUgPSBhY3RpdmVQcmV2Tm9kZU1hcC5nZXQoa2V5KTtcbiAgbGV0IG5leHROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KGtleSk7XG4gIGlmIChwcmV2Tm9kZSA9PT0gdW5kZWZpbmVkIHx8IG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcmVjb25jaWxlTm9kZTogcHJldk5vZGUgb3IgbmV4dE5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc0RpcnR5ID0gdHJlYXRBbGxOb2Rlc0FzRGlydHkgfHwgYWN0aXZlRGlydHlMZWF2ZXMuaGFzKGtleSkgfHwgYWN0aXZlRGlydHlFbGVtZW50cy5oYXMoa2V5KTtcbiAgY29uc3QgZG9tID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhhY3RpdmVFZGl0b3IkMSwga2V5KTtcblxuICAvLyBJZiB0aGUgbm9kZSBrZXkgcG9pbnRzIHRvIHRoZSBzYW1lIGluc3RhbmNlIGluIGJvdGggc3RhdGVzXG4gIC8vIGFuZCBpc24ndCBkaXJ0eSwgd2UganVzdCB1cGRhdGUgdGhlIHRleHQgY29udGVudCBjYWNoZVxuICAvLyBhbmQgcmV0dXJuIHRoZSBleGlzdGluZyBET00gTm9kZS5cbiAgaWYgKHByZXZOb2RlID09PSBuZXh0Tm9kZSAmJiAhaXNEaXJ0eSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2Tm9kZSkpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCA9IGRvbS5fX2xleGljYWxUZXh0Q29udGVudDtcbiAgICAgIGlmIChwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudDtcbiAgICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCA9IGRvbS5fX2xleGljYWxEaXJUZXh0Q29udGVudDtcbiAgICAgIGlmIChwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ZXh0ID0gcHJldk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgIXByZXZOb2RlLmlzRGlyZWN0aW9ubGVzcygpKSB7XG4gICAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICB9XG4gICAgICBlZGl0b3JUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH1cbiAgLy8gSWYgdGhlIG5vZGUga2V5IGRvZXNuJ3QgcG9pbnQgdG8gdGhlIHNhbWUgaW5zdGFuY2UgaW4gYm90aCBtYXBzLFxuICAvLyBpdCBtZWFucyBpdCB3ZXJlIGNsb25lZC4gSWYgdGhleSdyZSBhbHNvIGRpcnR5LCB3ZSBtYXJrIHRoZW0gYXMgbXV0YXRlZC5cbiAgaWYgKHByZXZOb2RlICE9PSBuZXh0Tm9kZSAmJiBpc0RpcnR5KSB7XG4gICAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5leHROb2RlLCAndXBkYXRlZCcpO1xuICB9XG5cbiAgLy8gVXBkYXRlIG5vZGUuIElmIGl0IHJldHVybnMgdHJ1ZSwgd2UgbmVlZCB0byB1bm1vdW50IGFuZCByZS1jcmVhdGUgdGhlIG5vZGVcbiAgaWYgKG5leHROb2RlLnVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBhY3RpdmVFZGl0b3JDb25maWcpKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRET00gPSAkY3JlYXRlTm9kZShrZXksIG51bGwsIG51bGwpO1xuICAgIGlmIChwYXJlbnRET00gPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHJlY29uY2lsZU5vZGU6IHBhcmVudERPTSBpcyBudWxsYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcmVudERPTS5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnRET00sIGRvbSk7XG4gICAgZGVzdHJveU5vZGUoa2V5LCBudWxsKTtcbiAgICByZXR1cm4gcmVwbGFjZW1lbnRET007XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZOb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICAvLyBSZWNvbmNpbGUgZWxlbWVudCBjaGlsZHJlblxuICAgIGNvbnN0IG5leHRJbmRlbnQgPSBuZXh0Tm9kZS5fX2luZGVudDtcbiAgICBpZiAobmV4dEluZGVudCAhPT0gcHJldk5vZGUuX19pbmRlbnQpIHtcbiAgICAgIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBuZXh0SW5kZW50KTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IG5leHROb2RlLl9fZm9ybWF0O1xuICAgIGlmIChuZXh0Rm9ybWF0ICE9PSBwcmV2Tm9kZS5fX2Zvcm1hdCkge1xuICAgICAgc2V0RWxlbWVudEZvcm1hdChkb20sIG5leHRGb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoaXNEaXJ0eSkge1xuICAgICAgJHJlY29uY2lsZUNoaWxkcmVuV2l0aERpcmVjdGlvbihwcmV2Tm9kZSwgbmV4dE5vZGUsIGRvbSk7XG4gICAgICBpZiAoISRpc1Jvb3ROb2RlKG5leHROb2RlKSAmJiAhbmV4dE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICByZWNvbmNpbGVFbGVtZW50VGVybWluYXRpbmdMaW5lQnJlYWsocHJldk5vZGUsIG5leHROb2RlLCBkb20pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChuZXh0Tm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IG5leHROb2RlLmRlY29yYXRlKGFjdGl2ZUVkaXRvciQxLCBhY3RpdmVFZGl0b3JDb25maWcpO1xuICAgICAgaWYgKGRlY29yYXRvciAhPT0gbnVsbCkge1xuICAgICAgICByZWNvbmNpbGVEZWNvcmF0b3Ioa2V5LCBkZWNvcmF0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobmV4dE5vZGUpICYmICFuZXh0Tm9kZS5pc0RpcmVjdGlvbmxlc3MoKSkge1xuICAgICAgLy8gSGFuZGxlIHRleHQgY29udGVudCwgZm9yIExUUiwgTFRSIGNhc2VzLlxuICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICB9XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgfVxuICBpZiAoIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkgJiYgJGlzUm9vdE5vZGUobmV4dE5vZGUpICYmIG5leHROb2RlLl9fY2FjaGVkVGV4dCAhPT0gZWRpdG9yVGV4dENvbnRlbnQpIHtcbiAgICAvLyBDYWNoZSB0aGUgbGF0ZXN0IHRleHQgY29udGVudC5cbiAgICBjb25zdCBuZXh0Um9vdE5vZGUgPSBuZXh0Tm9kZS5nZXRXcml0YWJsZSgpO1xuICAgIG5leHRSb290Tm9kZS5fX2NhY2hlZFRleHQgPSBlZGl0b3JUZXh0Q29udGVudDtcbiAgICBuZXh0Tm9kZSA9IG5leHRSb290Tm9kZTtcbiAgfVxuICB7XG4gICAgLy8gRnJlZXplIHRoZSBub2RlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZShuZXh0Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcikge1xuICBsZXQgcGVuZGluZ0RlY29yYXRvcnMgPSBhY3RpdmVFZGl0b3IkMS5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gYWN0aXZlRWRpdG9yJDEuX2RlY29yYXRvcnM7XG4gIGlmIChwZW5kaW5nRGVjb3JhdG9ycyA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50RGVjb3JhdG9yc1trZXldID09PSBkZWNvcmF0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ0RlY29yYXRvcnMgPSBjbG9uZURlY29yYXRvcnMoYWN0aXZlRWRpdG9yJDEpO1xuICB9XG4gIHBlbmRpbmdEZWNvcmF0b3JzW2tleV0gPSBkZWNvcmF0b3I7XG59XG5mdW5jdGlvbiBnZXRGaXJzdENoaWxkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKGVsZW1lbnQpIHtcbiAgbGV0IG5leHRTaWJsaW5nID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsICYmIG5leHRTaWJsaW5nID09PSBhY3RpdmVFZGl0b3IkMS5fYmxvY2tDdXJzb3JFbGVtZW50KSB7XG4gICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcbiAgfVxuICByZXR1cm4gbmV4dFNpYmxpbmc7XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlTm9kZUNoaWxkcmVuKG5leHRFbGVtZW50LCBwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcHJldkNoaWxkcmVuTGVuZ3RoLCBuZXh0Q2hpbGRyZW5MZW5ndGgsIGRvbSkge1xuICBjb25zdCBwcmV2RW5kSW5kZXggPSBwcmV2Q2hpbGRyZW5MZW5ndGggLSAxO1xuICBjb25zdCBuZXh0RW5kSW5kZXggPSBuZXh0Q2hpbGRyZW5MZW5ndGggLSAxO1xuICBsZXQgcHJldkNoaWxkcmVuU2V0O1xuICBsZXQgbmV4dENoaWxkcmVuU2V0O1xuICBsZXQgc2libGluZ0RPTSA9IGdldEZpcnN0Q2hpbGQoZG9tKTtcbiAgbGV0IHByZXZJbmRleCA9IDA7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuICB3aGlsZSAocHJldkluZGV4IDw9IHByZXZFbmRJbmRleCAmJiBuZXh0SW5kZXggPD0gbmV4dEVuZEluZGV4KSB7XG4gICAgY29uc3QgcHJldktleSA9IHByZXZDaGlsZHJlbltwcmV2SW5kZXhdO1xuICAgIGNvbnN0IG5leHRLZXkgPSBuZXh0Q2hpbGRyZW5bbmV4dEluZGV4XTtcbiAgICBpZiAocHJldktleSA9PT0gbmV4dEtleSkge1xuICAgICAgc2libGluZ0RPTSA9IGdldE5leHRTaWJsaW5nKCRyZWNvbmNpbGVOb2RlKG5leHRLZXksIGRvbSkpO1xuICAgICAgcHJldkluZGV4Kys7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZDaGlsZHJlblNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZXZDaGlsZHJlblNldCA9IG5ldyBTZXQocHJldkNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW5TZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW5TZXQgPSBuZXcgU2V0KG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0SGFzUHJldktleSA9IG5leHRDaGlsZHJlblNldC5oYXMocHJldktleSk7XG4gICAgICBjb25zdCBwcmV2SGFzTmV4dEtleSA9IHByZXZDaGlsZHJlblNldC5oYXMobmV4dEtleSk7XG4gICAgICBpZiAoIW5leHRIYXNQcmV2S2V5KSB7XG4gICAgICAgIC8vIFJlbW92ZSBwcmV2XG4gICAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZyhnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhwcmV2S2V5KSk7XG4gICAgICAgIGRlc3Ryb3lOb2RlKHByZXZLZXksIGRvbSk7XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgfSBlbHNlIGlmICghcHJldkhhc05leHRLZXkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5leHRcbiAgICAgICAgJGNyZWF0ZU5vZGUobmV4dEtleSwgZG9tLCBzaWJsaW5nRE9NKTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3ZlIG5leHRcbiAgICAgICAgY29uc3QgY2hpbGRET00gPSBnZXRFbGVtZW50QnlLZXlPclRocm93KGFjdGl2ZUVkaXRvciQxLCBuZXh0S2V5KTtcbiAgICAgICAgaWYgKGNoaWxkRE9NID09PSBzaWJsaW5nRE9NKSB7XG4gICAgICAgICAgc2libGluZ0RPTSA9IGdldE5leHRTaWJsaW5nKCRyZWNvbmNpbGVOb2RlKG5leHRLZXksIGRvbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaWJsaW5nRE9NICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvbS5pbnNlcnRCZWZvcmUoY2hpbGRET00sIHNpYmxpbmdET00pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY2hpbGRET00pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkcmVjb25jaWxlTm9kZShuZXh0S2V5LCBkb20pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5leHROb2RlTWFwLmdldChuZXh0S2V5KTtcbiAgICBpZiAobm9kZSAhPT0gbnVsbCAmJiBzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRGb3JtYXQgPSBub2RlLmdldEZvcm1hdCgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBhcHBlbmROZXdDaGlsZHJlbiA9IHByZXZJbmRleCA+IHByZXZFbmRJbmRleDtcbiAgY29uc3QgcmVtb3ZlT2xkQ2hpbGRyZW4gPSBuZXh0SW5kZXggPiBuZXh0RW5kSW5kZXg7XG4gIGlmIChhcHBlbmROZXdDaGlsZHJlbiAmJiAhcmVtb3ZlT2xkQ2hpbGRyZW4pIHtcbiAgICBjb25zdCBwcmV2aW91c05vZGUgPSBuZXh0Q2hpbGRyZW5bbmV4dEVuZEluZGV4ICsgMV07XG4gICAgY29uc3QgaW5zZXJ0RE9NID0gcHJldmlvdXNOb2RlID09PSB1bmRlZmluZWQgPyBudWxsIDogYWN0aXZlRWRpdG9yJDEuZ2V0RWxlbWVudEJ5S2V5KHByZXZpb3VzTm9kZSk7XG4gICAgJGNyZWF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgbmV4dEVsZW1lbnQsIG5leHRJbmRleCwgbmV4dEVuZEluZGV4LCBkb20sIGluc2VydERPTSk7XG4gIH0gZWxzZSBpZiAocmVtb3ZlT2xkQ2hpbGRyZW4gJiYgIWFwcGVuZE5ld0NoaWxkcmVuKSB7XG4gICAgZGVzdHJveUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgcHJldkluZGV4LCBwcmV2RW5kSW5kZXgsIGRvbSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRyZWNvbmNpbGVSb290KHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBlZGl0b3IsIGRpcnR5VHlwZSwgZGlydHlFbGVtZW50cywgZGlydHlMZWF2ZXMpIHtcbiAgLy8gV2UgY2FjaGUgdGV4dCBjb250ZW50IHRvIG1ha2UgcmV0cmlldmFsIG1vcmUgZWZmaWNpZW50LlxuICAvLyBUaGUgY2FjaGUgbXVzdCBiZSByZWJ1aWx0IGR1cmluZyByZWNvbmNpbGlhdGlvbiB0byBhY2NvdW50IGZvciBhbnkgY2hhbmdlcy5cbiAgc3ViVHJlZVRleHRDb250ZW50ID0gJyc7XG4gIGVkaXRvclRleHRDb250ZW50ID0gJyc7XG4gIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG4gIC8vIFJhdGhlciB0aGFuIHBhc3MgYXJvdW5kIGEgbG9hZCBvZiBhcmd1bWVudHMgdGhyb3VnaCB0aGUgc3RhY2sgcmVjdXJzaXZlbHlcbiAgLy8gd2UgaW5zdGVhZCBzZXQgdGhlbSBhcyBiaW5kaW5ncyB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBtb2R1bGUuXG4gIHRyZWF0QWxsTm9kZXNBc0RpcnR5ID0gZGlydHlUeXBlID09PSBGVUxMX1JFQ09OQ0lMRTtcbiAgYWN0aXZlVGV4dERpcmVjdGlvbiA9IG51bGw7XG4gIGFjdGl2ZUVkaXRvciQxID0gZWRpdG9yO1xuICBhY3RpdmVFZGl0b3JDb25maWcgPSBlZGl0b3IuX2NvbmZpZztcbiAgYWN0aXZlRWRpdG9yTm9kZXMgPSBlZGl0b3IuX25vZGVzO1xuICBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycyA9IGFjdGl2ZUVkaXRvciQxLl9saXN0ZW5lcnMubXV0YXRpb247XG4gIGFjdGl2ZURpcnR5RWxlbWVudHMgPSBkaXJ0eUVsZW1lbnRzO1xuICBhY3RpdmVEaXJ0eUxlYXZlcyA9IGRpcnR5TGVhdmVzO1xuICBhY3RpdmVQcmV2Tm9kZU1hcCA9IHByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgYWN0aXZlTmV4dE5vZGVNYXAgPSBuZXh0RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkgPSBuZXh0RWRpdG9yU3RhdGUuX3JlYWRPbmx5O1xuICBhY3RpdmVQcmV2S2V5VG9ET01NYXAgPSBuZXcgTWFwKGVkaXRvci5fa2V5VG9ET01NYXApO1xuICAvLyBXZSBrZWVwIHRyYWNrIG9mIG11dGF0ZWQgbm9kZXMgc28gd2UgY2FuIHRyaWdnZXIgbXV0YXRpb25cbiAgLy8gbGlzdGVuZXJzIGxhdGVyIGluIHRoZSB1cGRhdGUgY3ljbGUuXG4gIGNvbnN0IGN1cnJlbnRNdXRhdGVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gIG11dGF0ZWROb2RlcyA9IGN1cnJlbnRNdXRhdGVkTm9kZXM7XG4gICRyZWNvbmNpbGVOb2RlKCdyb290JywgbnVsbCk7XG4gIC8vIFdlIGRvbid0IHdhbnQgYSBidW5jaCBvZiB2b2lkIGNoZWNrcyB0aHJvdWdob3V0IHRoZSBzY29wZVxuICAvLyBzbyBpbnN0ZWFkIHdlIG1ha2UgaXQgc2VlbSB0aGF0IHRoZXNlIHZhbHVlcyBhcmUgYWx3YXlzIHNldC5cbiAgLy8gV2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBjbGVhciB0aGVtIGRvd24sIG90aGVyd2lzZSB3ZVxuICAvLyBjYW4gbGVhayBtZW1vcnkuXG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRWRpdG9yJDEgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRWRpdG9yTm9kZXMgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlRGlydHlFbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVEaXJ0eUxlYXZlcyA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVQcmV2Tm9kZU1hcCA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVOZXh0Tm9kZU1hcCA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVFZGl0b3JDb25maWcgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZlUHJldktleVRvRE9NTWFwID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIG11dGF0ZWROb2RlcyA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGN1cnJlbnRNdXRhdGVkTm9kZXM7XG59XG5mdW5jdGlvbiBzdG9yZURPTVdpdGhLZXkoa2V5LCBkb20sIGVkaXRvcikge1xuICBjb25zdCBrZXlUb0RPTU1hcCA9IGVkaXRvci5fa2V5VG9ET01NYXA7XG4gIC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cbiAgZG9tWydfX2xleGljYWxLZXlfJyArIGVkaXRvci5fa2V5XSA9IGtleTtcbiAga2V5VG9ET01NYXAuc2V0KGtleSwgZG9tKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSkge1xuICBjb25zdCBlbGVtZW50ID0gYWN0aXZlUHJldktleVRvRE9NTWFwLmdldChrZXkpO1xuICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFJlY29uY2lsaWF0aW9uOiBjb3VsZCBub3QgZmluZCBET00gZWxlbWVudCBmb3Igbm9kZSBrZXkgJHtrZXl9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFBBU1NfVEhST1VHSF9DT01NQU5EID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5jb25zdCBBTkRST0lEX0NPTVBPU0lUSU9OX0xBVEVOQ1kgPSAzMDtcbmNvbnN0IHJvb3RFbGVtZW50RXZlbnRzID0gW1sna2V5ZG93bicsIG9uS2V5RG93bl0sIFsncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duXSwgWydjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0XSwgWydjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmRdLCBbJ2lucHV0Jywgb25JbnB1dF0sIFsnY2xpY2snLCBvbkNsaWNrXSwgWydjdXQnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnY29weScsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcmFnc3RhcnQnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJhZ292ZXInLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJhZ2VuZCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydwYXN0ZScsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydmb2N1cycsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydibHVyJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2Ryb3AnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF1dO1xuaWYgKENBTl9VU0VfQkVGT1JFX0lOUFVUKSB7XG4gIHJvb3RFbGVtZW50RXZlbnRzLnB1c2goWydiZWZvcmVpbnB1dCcsIChldmVudCwgZWRpdG9yKSA9PiBvbkJlZm9yZUlucHV0KGV2ZW50LCBlZGl0b3IpXSk7XG59XG5sZXQgbGFzdEtleURvd25UaW1lU3RhbXAgPSAwO1xubGV0IGxhc3RLZXlDb2RlID0gbnVsbDtcbmxldCBsYXN0QmVmb3JlSW5wdXRJbnNlcnRUZXh0VGltZVN0YW1wID0gMDtcbmxldCB1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSA9IG51bGw7XG5jb25zdCByb290RWxlbWVudHNSZWdpc3RlcmVkID0gbmV3IFdlYWtNYXAoKTtcbmxldCBpc1NlbGVjdGlvbkNoYW5nZUZyb21ET01VcGRhdGUgPSBmYWxzZTtcbmxldCBpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24gPSBmYWxzZTtcbmxldCBpc0luc2VydExpbmVCcmVhayA9IGZhbHNlO1xubGV0IGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG5sZXQgY29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0ID0gWzAsICcnLCAwLCAncm9vdCcsIDBdO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIExleGljYWwgc2hvdWxkIGF0dGVtcHQgdG8gb3ZlcnJpZGVcbi8vIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgZm9yIGluc2VydGlvbiBvZiB0ZXh0IGFuZCB1c2UgaXRzIG93biBpbnRlcm5hbFxuLy8gaGV1cmlzdGljcy4gVGhpcyBpcyBhbiBleHRyZW1lbHkgaW1wb3J0YW50IGZ1bmN0aW9uLCBhbmQgbWFrZXMgbXVjaCBvZiBMZXhpY2FsXG4vLyB3b3JrIGFzIGludGVuZGVkIGJldHdlZW4gZGlmZmVyZW50IGJyb3dzZXJzIGFuZCBhY3Jvc3Mgd29yZCwgbGluZSBhbmQgY2hhcmFjdGVyXG4vLyBib3VuZGFyeS9mb3JtYXRzLiBJdCBhbHNvIGlzIGltcG9ydGFudCBmb3IgdGV4dCByZXBsYWNlbWVudCwgbm9kZSBzY2hlbWFzIGFuZFxuLy8gY29tcG9zaXRpb24gbWVjaGFuaWNzLlxuXG5mdW5jdGlvbiAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0KHNlbGVjdGlvbiwgZG9tVGFyZ2V0UmFuZ2UsIHRleHQsIHRpbWVTdGFtcCwgaXNCZWZvcmVJbnB1dCkge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uICE9PSBudWxsID8gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgOiBudWxsO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBiYWNraW5nQW5jaG9yRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICByZXR1cm4gYW5jaG9yS2V5ICE9PSBmb2N1cy5rZXkgfHxcbiAgLy8gSWYgd2UncmUgd29ya2luZyB3aXRoIGEgbm9uLXRleHQgbm9kZS5cbiAgISRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8XG4gIC8vIElmIHdlIGFyZSByZXBsYWNpbmcgYSByYW5nZSB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBvciBncmFwaGVtZSwgYW5kIG5vdCBjb21wb3NpbmcuXG4gICghaXNCZWZvcmVJbnB1dCAmJiAoIUNBTl9VU0VfQkVGT1JFX0lOUFVUIHx8XG4gIC8vIFdlIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBoYXMgYmVlblxuICAvLyBhIHJlY2VudCBiZWZvcmVpbnB1dCBldmVudCBmb3IgXCJ0ZXh0SW5wdXRcIi4gSWYgdGhlcmUgaGFzIGJlZW4gb25lIGluIHRoZSBsYXN0XG4gIC8vIDUwbXMgdGhlbiB3ZSBwcm9jZWVkIGFzIG5vcm1hbC4gSG93ZXZlciwgaWYgdGhlcmUgaXMgbm90LCB0aGVuIHRoaXMgaXMgbGlrZWx5XG4gIC8vIGEgZGFuZ2xpbmcgYGlucHV0YCBldmVudCBjYXVzZWQgYnkgZXhlY0NvbW1hbmQoJ2luc2VydFRleHQnKS5cbiAgbGFzdEJlZm9yZUlucHV0SW5zZXJ0VGV4dFRpbWVTdGFtcCA8IHRpbWVTdGFtcCArIDUwKSB8fCBhbmNob3JOb2RlLmlzRGlydHkoKSAmJiB0ZXh0TGVuZ3RoIDwgMiB8fCBkb2VzQ29udGFpbkdyYXBoZW1lKHRleHQpKSAmJiBhbmNob3Iub2Zmc2V0ICE9PSBmb2N1cy5vZmZzZXQgJiYgIWFuY2hvck5vZGUuaXNDb21wb3NpbmcoKSB8fFxuICAvLyBBbnkgbm9uIHN0YW5kYXJkIHRleHQgbm9kZS5cbiAgJGlzVG9rZW5PclNlZ21lbnRlZChhbmNob3JOb2RlKSB8fFxuICAvLyBJZiB0aGUgdGV4dCBsZW5ndGggaXMgbW9yZSB0aGFuIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgd2UncmUgZWl0aGVyXG4gIC8vIGRlYWxpbmcgd2l0aCB0aGlzIGluIFwiYmVmb3JlaW5wdXRcIiBvciB3aGVyZSB0aGUgbm9kZSBoYXMgYWxyZWFkeSByZWNlbnRseVxuICAvLyBiZWVuIGNoYW5nZWQgKHRodXMgaXMgZGlydHkpLlxuICBhbmNob3JOb2RlLmlzRGlydHkoKSAmJiB0ZXh0TGVuZ3RoID4gMSB8fFxuICAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBlbGVtZW50IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgYmFja2luZyBub2RlIGR1cmluZyBiZWZvcmVpbnB1dC5cbiAgKGlzQmVmb3JlSW5wdXQgfHwgIUNBTl9VU0VfQkVGT1JFX0lOUFVUKSAmJiBiYWNraW5nQW5jaG9yRWxlbWVudCAhPT0gbnVsbCAmJiAhYW5jaG9yTm9kZS5pc0NvbXBvc2luZygpICYmIGRvbUFuY2hvck5vZGUgIT09IGdldERPTVRleHROb2RlKGJhY2tpbmdBbmNob3JFbGVtZW50KSB8fFxuICAvLyBJZiBUYXJnZXRSYW5nZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIERPTSBzZWxlY3Rpb247IGJyb3dzZXIgdHJ5aW5nIHRvIGVkaXQgcmFuZG9tIHBhcnRzXG4gIC8vIG9mIHRoZSBlZGl0b3IuXG4gIGRvbVNlbGVjdGlvbiAhPT0gbnVsbCAmJiBkb21UYXJnZXRSYW5nZSAhPT0gbnVsbCAmJiAoIWRvbVRhcmdldFJhbmdlLmNvbGxhcHNlZCB8fCBkb21UYXJnZXRSYW5nZS5zdGFydENvbnRhaW5lciAhPT0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgfHwgZG9tVGFyZ2V0UmFuZ2Uuc3RhcnRPZmZzZXQgIT09IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQpIHx8XG4gIC8vIENoZWNrIGlmIHdlJ3JlIGNoYW5naW5nIGZyb20gYm9sZCB0byBpdGFsaWNzLCBvciBzb21lIG90aGVyIGZvcm1hdC5cbiAgYW5jaG9yTm9kZS5nZXRGb3JtYXQoKSAhPT0gc2VsZWN0aW9uLmZvcm1hdCB8fCBhbmNob3JOb2RlLmdldFN0eWxlKCkgIT09IHNlbGVjdGlvbi5zdHlsZSB8fFxuICAvLyBPbmUgbGFzdCBzZXQgb2YgaGV1cmlzdGljcyB0byBjaGVjayBhZ2FpbnN0LlxuICAkc2hvdWxkSW5zZXJ0VGV4dEFmdGVyT3JCZWZvcmVUZXh0Tm9kZShzZWxlY3Rpb24sIGFuY2hvck5vZGUpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2tpcFNlbGVjdGlvbkNoYW5nZShkb21Ob2RlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRvbU5vZGUgIT09IG51bGwgJiYgZG9tTm9kZS5ub2RlVmFsdWUgIT09IG51bGwgJiYgZG9tTm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSAmJiBvZmZzZXQgIT09IDAgJiYgb2Zmc2V0ICE9PSBkb21Ob2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIGVkaXRvciwgaXNBY3RpdmUpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvck5vZGU6IGFuY2hvckRPTSxcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNOb2RlOiBmb2N1c0RPTSxcbiAgICBmb2N1c09mZnNldFxuICB9ID0gZG9tU2VsZWN0aW9uO1xuICBpZiAoaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlKSB7XG4gICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gZmFsc2U7XG5cbiAgICAvLyBJZiBuYXRpdmUgRE9NIHNlbGVjdGlvbiBpcyBvbiBhIERPTSBlbGVtZW50LCB0aGVuXG4gICAgLy8gd2Ugc2hvdWxkIGNvbnRpbnVlIGFzIHVzdWFsLCBhcyBMZXhpY2FsJ3Mgc2VsZWN0aW9uXG4gICAgLy8gbWF5IGhhdmUgbm9ybWFsaXplZCB0byBhIGJldHRlciBjaGlsZC4gSWYgdGhlIERPTVxuICAgIC8vIGVsZW1lbnQgaXMgYSB0ZXh0IG5vZGUsIHdlIGNhbiBzYWZlbHkgYXBwbHkgdGhpc1xuICAgIC8vIG9wdGltaXphdGlvbiBhbmQgc2tpcCB0aGUgc2VsZWN0aW9uIGNoYW5nZSBlbnRpcmVseS5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG9mZnNldCBpcyBhdCB0aGUgYm91bmRhcnksXG4gICAgLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UsIHdlIG1pZ2h0IG5lZWQgdG8gbm9ybWFsaXplIHRvIGFcbiAgICAvLyBzaWJsaW5nIGluc3RlYWQuXG4gICAgaWYgKHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpICYmIHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoZm9jdXNET00sIGZvY3VzT2Zmc2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgLy8gTm9uLWFjdGl2ZSBlZGl0b3IgZG9uJ3QgbmVlZCBhbnkgZXh0cmEgbG9naWMgZm9yIHNlbGVjdGlvbiwgaXQgb25seSBuZWVkcyB1cGRhdGVcbiAgICAvLyB0byByZWNvbmNpbGUgc2VsZWN0aW9uIChzZXQgaXQgdG8gbnVsbCkgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgZWRpdG9yIGhhcyBub24tbnVsbCBzZWxlY3Rpb24uXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgJHNldFNlbGVjdGlvbihudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uIGZvcm1hdFxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgLy8gQmFkbHkgaW50ZXJwcmV0ZWQgcmFuZ2Ugc2VsZWN0aW9uIHdoZW4gY29sbGFwc2VkIC0gIzE0ODJcbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbi50eXBlID09PSAnUmFuZ2UnICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbWFya2VkIGEgY29sbGFwc2VkIHNlbGVjdGlvbiBmb3JtYXQsIGFuZCB3ZSdyZVxuICAgICAgICAvLyB3aXRoaW4gdGhlIGdpdmVuIHRpbWUgcmFuZ2Ug4oCTIHRoZW4gYXR0ZW1wdCB0byB1c2UgdGhhdCBmb3JtYXRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBnZXR0aW5nIHRoZSBmb3JtYXQgZnJvbSB0aGUgYW5jaG9yIG5vZGUuXG4gICAgICAgIGNvbnN0IHdpbmRvd0V2ZW50ID0gZ2V0V2luZG93KGVkaXRvcikuZXZlbnQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lU3RhbXAgPSB3aW5kb3dFdmVudCA/IHdpbmRvd0V2ZW50LnRpbWVTdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBbbGFzdEZvcm1hdCwgbGFzdFN0eWxlLCBsYXN0T2Zmc2V0LCBsYXN0S2V5LCB0aW1lU3RhbXBdID0gY29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0O1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgY29uc3QgaXNSb290VGV4dENvbnRlbnRFbXB0eSA9IGVkaXRvci5pc0NvbXBvc2luZygpID09PSBmYWxzZSAmJiByb290LmdldFRleHRDb250ZW50KCkgPT09ICcnO1xuICAgICAgICBpZiAoY3VycmVudFRpbWVTdGFtcCA8IHRpbWVTdGFtcCArIDIwMCAmJiBhbmNob3Iub2Zmc2V0ID09PSBsYXN0T2Zmc2V0ICYmIGFuY2hvci5rZXkgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gbGFzdEZvcm1hdDtcbiAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBsYXN0U3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGlmICghJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBvaW50LmdldE5vZGUoKSBtdXN0IHJldHVybiBUZXh0Tm9kZSB3aGVuIHR5cGUgaXMgdGV4dGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBhbmNob3JOb2RlLmdldFN0eWxlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmICFpc1Jvb3RUZXh0Q29udGVudEVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUgaW5zdGFuY2VvZiBQYXJhZ3JhcGhOb2RlICYmIGxhc3ROb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBsYXN0Tm9kZS5nZXRUZXh0Rm9ybWF0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbi5zdHlsZSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXMua2V5O1xuICAgICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0S2V5ID0gaXNCYWNrd2FyZCA/IGZvY3VzS2V5IDogYW5jaG9yS2V5O1xuICAgICAgICBjb25zdCBlbmRLZXkgPSBpc0JhY2t3YXJkID8gYW5jaG9yS2V5IDogZm9jdXNLZXk7XG4gICAgICAgIGxldCBjb21iaW5lZEZvcm1hdCA9IElTX0FMTF9GT1JNQVRUSU5HO1xuICAgICAgICBsZXQgaGFzVGV4dE5vZGVzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiB0ZXh0Q29udGVudFNpemUgIT09IDAgJiZcbiAgICAgICAgICAvLyBFeGNsdWRlIGVtcHR5IHRleHQgbm9kZXMgYXQgYm91bmRhcmllcyByZXN1bHRpbmcgZnJvbSB1c2VyJ3Mgc2VsZWN0aW9uXG4gICAgICAgICAgIShpID09PSAwICYmIG5vZGUuX19rZXkgPT09IHN0YXJ0S2V5ICYmIHN0YXJ0T2Zmc2V0ID09PSB0ZXh0Q29udGVudFNpemUgfHwgaSA9PT0gbm9kZXNMZW5ndGggLSAxICYmIG5vZGUuX19rZXkgPT09IGVuZEtleSAmJiBlbmRPZmZzZXQgPT09IDApKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHN0eWxlP1xuICAgICAgICAgICAgaGFzVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbWJpbmVkRm9ybWF0ICY9IG5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoY29tYmluZWRGb3JtYXQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBoYXNUZXh0Tm9kZXMgPyBjb21iaW5lZEZvcm1hdCA6IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSk7XG59XG5cbi8vIFRoaXMgaXMgYSB3b3JrLWFyb3VuZCBpcyBtYWlubHkgQ2hyb21lIHNwZWNpZmljIGJ1ZyB3aGVyZSBpZiB5b3Ugc2VsZWN0XG4vLyB0aGUgY29udGVudHMgb2YgYW4gZW1wdHkgYmxvY2ssIHlvdSBjYW5ub3QgZWFzaWx5IHVuc2VsZWN0IGFueXRoaW5nLlxuLy8gVGhpcyByZXN1bHRzIGluIGEgdGlueSBzZWxlY3Rpb24gYm94IHRoYXQgbG9va3MgYnVnZ3kvYnJva2VuLiBUaGlzIGNhblxuLy8gYWxzbyBoZWxwIG90aGVyIGJyb3dzZXJzIHdoZW4gc2VsZWN0aW9uIG1pZ2h0IFwiYXBwZWFyXCIgbG9zdCwgd2hlbiBpdFxuLy8gcmVhbGx5IGlzbid0LlxuZnVuY3Rpb24gb25DbGljayhldmVudCwgZWRpdG9yKSB7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbikge1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgISRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpICYmICRnZXRSb290KCkuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaXNFbXB0eSgpICYmIGxhc3RTZWxlY3Rpb24gIT09IG51bGwgJiYgc2VsZWN0aW9uLmlzKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsID09PSAzICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIC8vIFRyaXBwbGUgY2xpY2sgY2F1c2luZyBzZWxlY3Rpb24gdG8gb3ZlcmZsb3cgaW50byB0aGUgbmVhcmVzdCBlbGVtZW50LiBJbiB0aGF0XG4gICAgICAgICAgLy8gY2FzZSB2aXN1YWxseSBpdCBsb29rcyBsaWtlIGEgc2luZ2xlIGVsZW1lbnQgY29udGVudCBpcyBzZWxlY3RlZCwgZm9jdXMgbm9kZVxuICAgICAgICAgIC8vIGlzIGFjdHVhbGx5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZWxlbWVudCAoaWYgcHJlc2VudCkgYW5kIGFueSBtYW5pcHVsYXRpb25zXG4gICAgICAgICAgLy8gd2l0aCBzZWxlY3Rpb24gKGZvcm1hdHRpbmcpIGFyZSBhZmZlY3Rpbmcgc2Vjb25kIGVsZW1lbnQgYXMgd2VsbFxuICAgICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgICAgICBpZiAoYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZS5zZWxlY3QoMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3QoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byB1cGRhdGUgdGhlIHNlbGVjdGlvbiBvbiB0b3VjaCBkZXZpY2VzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRleHQgYWZ0ZXIgYVxuICAgICAgICAvLyBub2RlIHNlbGVjdGlvbi4gU2VlIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biBmb3IgdGhlIGludmVyc2VcbiAgICAgICAgY29uc3QgZG9tQW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgICBpZiAoZG9tQW5jaG9yTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gZG9tQW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIGNsaWNrIHNlbGVjdGlvbiBiYWNrIG9udG8gdGV4dCwgdGhlblxuICAgICAgICAgIC8vIHdlIHNob3VsZCBhdHRlbXB0IGNyZWF0ZSBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgICAgICAvLyBXaGVuIHdlIGNsaWNrIG9uIGFuIGVtcHR5IHBhcmFncmFwaCBub2RlIG9yIHRoZSBlbmQgb2YgYSBwYXJhZ3JhcGggdGhhdCBlbmRzXG4gICAgICAgICAgLy8gd2l0aCBhbiBpbWFnZS9wb2xsLCB0aGUgbm9kZVR5cGUgd2lsbCBiZSBFTEVNRU5UX05PREVcbiAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUgfHwgbm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9ICRpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yLCBldmVudCk7XG4gICAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENMSUNLX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gVE9ETyBpbXBsZW1lbnQgdGV4dCBkcmFnICYgZHJvcFxuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIHBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgICAgLy8gRHJhZyAmIGRyb3Agc2hvdWxkIG5vdCByZWNvbXB1dGUgc2VsZWN0aW9uIHVudGlsIG1vdXNlIHVwOyBvdGhlcndpc2UgdGhlIGluaXRpYWxseVxuICAgICAgLy8gc2VsZWN0ZWQgY29udGVudCBpcyBsb3N0LlxuICAgICAgaWYgKCEkaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9yKHRhcmdldCkpIHtcbiAgICAgICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0UmFuZ2UoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5nZXRUYXJnZXRSYW5nZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0YXJnZXRSYW5nZXMgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcbiAgaWYgKHRhcmdldFJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0UmFuZ2VzWzBdO1xufVxuZnVuY3Rpb24gJGNhblJlbW92ZVRleHQoYW5jaG9yTm9kZSwgZm9jdXNOb2RlKSB7XG4gIHJldHVybiBhbmNob3JOb2RlICE9PSBmb2N1c05vZGUgfHwgJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkgfHwgJGlzRWxlbWVudE5vZGUoZm9jdXNOb2RlKSB8fCAhYW5jaG9yTm9kZS5pc1Rva2VuKCkgfHwgIWZvY3VzTm9kZS5pc1Rva2VuKCk7XG59XG5mdW5jdGlvbiBpc1Bvc3NpYmx5QW5kcm9pZEtleVByZXNzKHRpbWVTdGFtcCkge1xuICByZXR1cm4gbGFzdEtleUNvZGUgPT09ICdNZWRpYUxhc3QnICYmIHRpbWVTdGFtcCA8IGxhc3RLZXlEb3duVGltZVN0YW1wICsgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZO1xufVxuZnVuY3Rpb24gb25CZWZvcmVJbnB1dChldmVudCwgZWRpdG9yKSB7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGV2ZW50LmlucHV0VHlwZTtcbiAgY29uc3QgdGFyZ2V0UmFuZ2UgPSBnZXRUYXJnZXRSYW5nZShldmVudCk7XG5cbiAgLy8gV2UgbGV0IHRoZSBicm93c2VyIGRvIGl0cyBvd24gdGhpbmcgZm9yIGNvbXBvc2l0aW9uLlxuICBpZiAoaW5wdXRUeXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JyB8fFxuICAvLyBJZiB3ZSdyZSBwYXN0aW5nIGluIEZGLCB3ZSBzaG91bGRuJ3QgZ2V0IHRoaXMgZXZlbnRcbiAgLy8gYXMgdGhlIGBwYXN0ZWAgZXZlbnQgc2hvdWxkIGhhdmUgdHJpZ2dlcmVkLCB1bmxlc3MgdGhlXG4gIC8vIHVzZXIgaGFzIGRvbS5ldmVudC5jbGlwYm9hcmRldmVudHMuZW5hYmxlZCBkaXNhYmxlZCBpblxuICAvLyBhYm91dDpjb25maWcuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBwcm9jZXNzIHRoZVxuICAvLyBwYXN0ZWQgY29udGVudCBpbiB0aGUgRE9NIG11dGF0aW9uIHBoYXNlLlxuICBJU19GSVJFRk9YICYmIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlucHV0VHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoaW5wdXRUeXBlID09PSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJykge1xuICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBVc2UgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkc2V0U2VsZWN0aW9uKHByZXZTZWxlY3Rpb24uY2xvbmUoKSk7XG4gICAgICB9XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBpc1NlbGVjdGlvbkFuY2hvclNhbWVBc0ZvY3VzID0gc2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHNlbGVjdGlvbi5mb2N1cy5rZXk7XG4gICAgICAgIGlmIChpc1Bvc3NpYmx5QW5kcm9pZEtleVByZXNzKGV2ZW50LnRpbWVTdGFtcCkgJiYgZWRpdG9yLmlzQ29tcG9zaW5nKCkgJiYgaXNTZWxlY3Rpb25BbmNob3JTYW1lQXNGb2N1cykge1xuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7XG4gICAgICAgICAgLy8gRml4ZXMgYW4gQW5kcm9pZCBidWcgd2hlcmUgc2VsZWN0aW9uIGZsaWNrZXJzIHdoZW4gYmFja3NwYWNpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZKTtcbiAgICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgYW5jaG9yTm9kZS5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBhbmNob3JOb2RlLmdldEZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKCEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgQW5jaG9yIG5vZGUgbXVzdCBiZSBhIFRleHROb2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBhbmNob3JOb2RlLmdldFN0eWxlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8vIENocm9taXVtIEFuZHJvaWQgYXQgdGhlIG1vbWVudCBzZWVtcyB0byBpZ25vcmUgdGhlIHByZXZlbnREZWZhdWx0XG4gICAgICAgICAgLy8gb24gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcgYW5kIHN0aWxsIGRlbGV0ZXMgdGhlIGNvbnRlbnQuIFdoaWNoIGxlYWRzXG4gICAgICAgICAgLy8gdG8gbXVsdGlwbGUgZGVsZXRpb25zLiBTbyB3ZSBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIHRoZSBkZWxldGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlVGV4dCA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgaGFzU2VsZWN0ZWRBbGxUZXh0SW5Ob2RlID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gc2VsZWN0ZWROb2RlVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkTGV0QnJvd3NlckhhbmRsZURlbGV0ZSA9IElTX0FORFJPSURfQ0hST01FICYmIGlzU2VsZWN0aW9uQW5jaG9yU2FtZUFzRm9jdXMgJiYgIWhhc1NlbGVjdGVkQWxsVGV4dEluTm9kZTtcbiAgICAgICAgICBpZiAoIXNob3VsZExldEJyb3dzZXJIYW5kbGVEZWxldGUpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgLy8gVGhpcyByZXByZXNlbnRzIHRoZSBjYXNlIHdoZW4gdHdvIGJlZm9yZWlucHV0IGV2ZW50cyBhcmUgdHJpZ2dlcmVkIGF0IHRoZSBzYW1lIHRpbWUgKHdpdGhvdXQgYVxuICAgIC8vIGZ1bGwgZXZlbnQgbG9vcCBlbmRpbmcgYXQgaW5wdXQpLiBUaGlzIGhhcHBlbnMgd2l0aCBNYWNPUyB3aXRoIHRoZSBkZWZhdWx0IGtleWJvYXJkIHNldHRpbmdzLFxuICAgIC8vIGEgY29tYmluYXRpb24gb2YgYXV0b2NvcnJlY3Rpb24gKyBhdXRvY2FwaXRhbGl6YXRpb24uXG4gICAgLy8gSGF2aW5nIExleGljYWwgcnVuIGV2ZXJ5dGhpbmcgaW4gY29udHJvbGxlZCBtb2RlIHdvdWxkIGZpeCB0aGUgaXNzdWUgd2l0aG91dCBhZGRpdGlvbmFsIGNvZGVcbiAgICAvLyBidXQgdGhpcyB3b3VsZCBraWxsIHRoZSBtYXNzaXZlIHBlcmZvcm1hbmNlIHdpbiBmcm9tIHRoZSBtb3N0IGNvbW1vbiB0eXBpbmcgZXZlbnQuXG4gICAgLy8gQWx0ZXJuYXRpdmVseSwgd2hlbiB0aGlzIGhhcHBlbnMgd2UgY2FuIHByZW1hdHVyZWx5IHVwZGF0ZSBvdXIgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIERPTVxuICAgIC8vIGNvbnRlbnQsIGEgam9iIHRoYXQgd291bGQgdXN1YWxseSBiZSB0aGUgaW5wdXQgZXZlbnQncyByZXNwb25zaWJpbGl0eS5cbiAgICBpZiAodW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgIT09IG51bGwpIHtcbiAgICAgICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKGZhbHNlLCBlZGl0b3IsIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhKTtcbiAgICB9XG4gICAgaWYgKCghc2VsZWN0aW9uLmRpcnR5IHx8IHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhICE9PSBudWxsKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAhJGlzUm9vdE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpICYmIHRhcmdldFJhbmdlICE9PSBudWxsKSB7XG4gICAgICBzZWxlY3Rpb24uYXBwbHlET01SYW5nZSh0YXJnZXRSYW5nZSk7XG4gICAgfVxuICAgIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gbnVsbDtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoaW5wdXRUeXBlID09PSAnaW5zZXJ0VGV4dCcgfHwgaW5wdXRUeXBlID09PSAnaW5zZXJ0VHJhbnNwb3NlJykge1xuICAgICAgaWYgKGRhdGEgPT09ICdcXG4nKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gRE9VQkxFX0xJTkVfQlJFQUspIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09IG51bGwgJiYgZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIC8vIEdldHMgYXJvdW5kIGEgU2FmYXJpIHRleHQgcmVwbGFjZW1lbnQgYnVnLlxuICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT0gbnVsbCAmJiAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0KHNlbGVjdGlvbiwgdGFyZ2V0UmFuZ2UsIGRhdGEsIGV2ZW50LnRpbWVTdGFtcCwgdHJ1ZSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gZGF0YTtcbiAgICAgIH1cbiAgICAgIGxhc3RCZWZvcmVJbnB1dEluc2VydFRleHRUaW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGNhcnJ5aW5nIG91dFxuICAgIC8vIHRoZSBpbnB1dCBldmVudCwgc28gd2UgY2FuIGNvbnRyb2wgdGhlXG4gICAgLy8gb3V0cHV0LlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvblxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFVzZWQgZm9yIEFuZHJvaWRcbiAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVXNlZCBmb3IgQW5kcm9pZFxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcblxuICAgICAgICAgIC8vIFNhZmFyaSBkb2VzIG5vdCBwcm92aWRlIHRoZSB0eXBlIFwiaW5zZXJ0TGluZUJyZWFrXCIuXG4gICAgICAgICAgLy8gU28gaW5zdGVhZCwgd2UgbmVlZCB0byBpbmZlciBpdCBmcm9tIHRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgICAgICAvLyBXZSBkbyBub3QgYXBwbHkgdGhpcyBsb2dpYyB0byBpT1MgdG8gYWxsb3cgbmV3bGluZSBhdXRvLWNhcGl0YWxpemF0aW9uXG4gICAgICAgICAgLy8gd29yayB3aXRob3V0IGNyZWF0aW5nIGxpbmVicmVha3Mgd2hlbiBwcmVzc2luZyBFbnRlclxuICAgICAgICAgIGlmIChpc0luc2VydExpbmVCcmVhayAmJiAhSVNfSU9TKSB7XG4gICAgICAgICAgICBpc0luc2VydExpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlQXNRdW90YXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUEFTVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkY2FuUmVtb3ZlVGV4dChhbmNob3JOb2RlLCBmb2N1c05vZGUpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBSRU1PVkVfVEVYVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVNT1ZFX1RFWFRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0U3RyaWtlVGhyb3VnaCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnc3RyaWtldGhyb3VnaCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmb3JtYXRCb2xkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdib2xkJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Zvcm1hdEl0YWxpYyc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnaXRhbGljJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Zvcm1hdFVuZGVybGluZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAndW5kZXJsaW5lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2hpc3RvcnlVbmRvJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFVORE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaGlzdG9yeVJlZG8nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBOTy1PUFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvbklucHV0KGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgb25JbnB1dCB0byBidWJibGUsIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBlZGl0b3JzLlxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IGdldFRhcmdldFJhbmdlKGV2ZW50KTtcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgJHNob3VsZFByZXZlbnREZWZhdWx0QW5kSW5zZXJ0VGV4dChzZWxlY3Rpb24sIHRhcmdldFJhbmdlLCBkYXRhLCBldmVudC50aW1lU3RhbXAsIGZhbHNlKSkge1xuICAgICAgLy8gR2l2ZW4gd2UncmUgb3Zlci1yaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIHdlIHdpbGwgbmVlZFxuICAgICAgLy8gdG8gZW5zdXJlIHRvIGRpc2FibGUgY29tcG9zaXRpb24gYmVmb3JlIGRpc3BhdGNoaW5nIHRoZVxuICAgICAgLy8gaW5zZXJ0VGV4dCBjb21tYW5kIGZvciB3aGVuIGNoYW5naW5nIHRoZSBzZXF1ZW5jZSBmb3IgRkYuXG4gICAgICBpZiAoaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICAgICAgJG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZGF0YSk7XG4gICAgICAgIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICAgICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCYWNrd2FyZCA/IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0IDogc2VsZWN0aW9uLmZvY3VzLm9mZnNldDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmFja3dhcmQgPyBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0IDogc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgICAvLyBJZiB0aGUgY29udGVudCBpcyB0aGUgc2FtZSBhcyBpbnNlcnRlZCwgdGhlbiBkb24ndCBkaXNwYXRjaCBhbiBpbnNlcnRpb24uXG4gICAgICAvLyBHaXZlbiBvbklucHV0IGRvZXNuJ3QgdGFrZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGl0IHVzZXMgdGhlIHByZXZpb3VzKVxuICAgICAgLy8gd2UgY2FuIGNvbXBhcmUgdGhhdCBhZ2FpbnN0IHdoYXQgdGhlIERPTSBjdXJyZW50bHkgc2F5cy5cbiAgICAgIGlmICghQ0FOX1VTRV9CRUZPUkVfSU5QVVQgfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBudWxsIHx8IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZSgwLCBzdGFydE9mZnNldCkgKyBkYXRhICsgYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpLnNsaWNlKHN0YXJ0T2Zmc2V0ICsgZW5kT2Zmc2V0KSAhPT0gZ2V0QW5jaG9yVGV4dEZyb21ET00oZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZGF0YSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIEFub3RoZXIgaGFjayBmb3IgRkYsIGFzIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgSU1FIGlzIHN0aWxsXG4gICAgICAvLyBvcGVuLCBldmVuIHRob3VnaCBjb21wb3NpdGlvbmVuZCBoYXMgYWxyZWFkeSBmaXJlZCAoc2lnaCkuXG4gICAgICBpZiAoSVNfRklSRUZPWCAmJiB0ZXh0TGVuZ3RoID4gMSAmJiBldmVudC5pbnB1dFR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnICYmICFlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCAtPSB0ZXh0TGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgY29uc2lzdGVuY3kgb24gQW5kcm9pZC5cbiAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19JT1MgJiYgIUlTX0FQUExFX1dFQktJVCAmJiBlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhcmFjdGVyRGF0YSA9IGRhdGEgIT09IG51bGwgPyBkYXRhIDogdW5kZWZpbmVkO1xuICAgICAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oZmFsc2UsIGVkaXRvciwgY2hhcmFjdGVyRGF0YSk7XG5cbiAgICAgIC8vIG9uSW5wdXQgYWx3YXlzIGZpcmVzIGFmdGVyIG9uQ29tcG9zaXRpb25FbmQgZm9yIEZGLlxuICAgICAgaWYgKGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICRvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHNvIGZsdXNoIGFueSBvdGhlciBtdXRhdGlvbnMgdGhhdCBtaWdodCBoYXZlIG9jY3VycmVkXG4gICAgLy8gc2luY2UgdGhlIGNoYW5nZS5cbiAgICAkZmx1c2hNdXRhdGlvbnMoKTtcbiAgfSk7XG4gIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChldmVudCwgZWRpdG9yKSB7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgIWVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3Qgbm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGFuY2hvci5rZXkpO1xuICAgICAgaWYgKFxuICAgICAgLy8gSWYgaXQgaGFzIGJlZW4gMzBtcyBzaW5jZSB0aGUgbGFzdCBrZXlkb3duLCB0aGVuIHdlIHNob3VsZFxuICAgICAgLy8gYXBwbHkgdGhlIGVtcHR5IHNwYWNlIGhldXJpc3RpYy4gV2UgY2FuJ3QgZG8gdGhpcyBmb3IgU2FmYXJpLFxuICAgICAgLy8gYXMgdGhlIGtleWRvd24gZmlyZXMgYWZ0ZXIgY29tcG9zaXRpb24gc3RhcnQuXG4gICAgICBldmVudC50aW1lU3RhbXAgPCBsYXN0S2V5RG93blRpbWVTdGFtcCArIEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWSB8fFxuICAgICAgLy8gRkYgaGFzIGlzc3VlcyBhcm91bmQgY29tcG9zaW5nIG11bHRpYnl0ZSBjaGFyYWN0ZXJzLCBzbyB3ZSBhbHNvXG4gICAgICAvLyBuZWVkIHRvIGludm9rZSB0aGUgZW1wdHkgc3BhY2UgaGV1cmlzdGljIGJlbG93LlxuICAgICAgYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgbm9kZS5nZXRGb3JtYXQoKSAhPT0gc2VsZWN0aW9uLmZvcm1hdCB8fCAkaXNUZXh0Tm9kZShub2RlKSAmJiBub2RlLmdldFN0eWxlKCkgIT09IHNlbGVjdGlvbi5zdHlsZSkge1xuICAgICAgICAvLyBXZSBpbnNlcnQgYSB6ZXJvIHdpZHRoIGNoYXJhY3RlciwgcmVhZHkgZm9yIHRoZSBjb21wb3NpdGlvblxuICAgICAgICAvLyB0byBnZXQgaW5zZXJ0ZWQgaW50byB0aGUgbmV3IG5vZGUgd2UgY3JlYXRlLiBJZlxuICAgICAgICAvLyB3ZSBkb24ndCBkbyB0aGlzLCBTYWZhcmkgd2lsbCBmYWlsIG9uIHVzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gdGV4dCBub2RlIG1hdGNoaW5nIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgQ09NUE9TSVRJT05fU1RBUlRfQ0hBUik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uICRvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEpIHtcbiAgY29uc3QgY29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG5cbiAgLy8gSGFuZGxlIHRlcm1pbmF0aW9uIG9mIGNvbXBvc2l0aW9uLlxuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwgJiYgZGF0YSAhPSBudWxsKSB7XG4gICAgLy8gQ29tcG9zaXRpb24gY2FuIHNvbWV0aW1lcyBtb3ZlIHRvIGFuIGFkamFjZW50IERPTSBub2RlIHdoZW4gYmFja3NwYWNpbmcuXG4gICAgLy8gU28gY2hlY2sgZm9yIHRoZSBlbXB0eSBjYXNlLlxuICAgIGlmIChkYXRhID09PSAnJykge1xuICAgICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkoY29tcG9zaXRpb25LZXkpO1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBnZXRET01UZXh0Tm9kZShlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGNvbXBvc2l0aW9uS2V5KSk7XG4gICAgICBpZiAodGV4dE5vZGUgIT09IG51bGwgJiYgdGV4dE5vZGUubm9kZVZhbHVlICE9PSBudWxsICYmICRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHROb2RlLm5vZGVWYWx1ZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcG9zaXRpb24gY2FuIHNvbWV0aW1lcyBiZSB0aGF0IG9mIGEgbmV3IGxpbmUuIEluIHdoaWNoIGNhc2UsIHdlIG5lZWQgdG9cbiAgICAvLyBoYW5kbGUgdGhhdCBhY2NvcmRpbmdseS5cbiAgICBpZiAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgbGluZSBicmVhaywgd2UgYWxzbyBuZWVkIHRvIGluc2VydFxuICAgICAgICAvLyBhIGxpbmUgYnJlYWsuXG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChmb2N1cy5rZXksIGZvY3VzLm9mZnNldCwgZm9jdXMudHlwZSk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9FTlRFUl9DT01NQU5ELCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAkdXBkYXRlU2VsZWN0ZWRUZXh0RnJvbURPTSh0cnVlLCBlZGl0b3IsIGRhdGEpO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChldmVudCwgZWRpdG9yKSB7XG4gIC8vIEZpcmVmb3ggZmlyZXMgb25Db21wb3NpdGlvbkVuZCBiZWZvcmUgb25JbnB1dCwgYnV0IENocm9tZS9XZWJraXQsXG4gIC8vIGZpcmUgb25JbnB1dCBiZWZvcmUgb25Db21wb3NpdGlvbkVuZC4gVG8gZW5zdXJlIHRoZSBzZXF1ZW5jZSB3b3Jrc1xuICAvLyBsaWtlIENocm9tZS9XZWJraXQgd2UgdXNlIHRoZSBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiBmbGFnIHRvXG4gIC8vIGRlZmVyIGhhbmRsaW5nIG9mIG9uQ29tcG9zaXRpb25FbmQgaW4gRmlyZWZveCB0aWxsIHdlIGhhdmUgcHJvY2Vzc2VkXG4gIC8vIHRoZSBsb2dpYyBpbiBvbklucHV0LlxuICBpZiAoSVNfRklSRUZPWCkge1xuICAgIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAkb25Db21wb3NpdGlvbkVuZEltcGwoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50LCBlZGl0b3IpIHtcbiAgbGFzdEtleURvd25UaW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gIGxhc3RLZXlDb2RlID0gZXZlbnQua2V5O1xuICBpZiAoZWRpdG9yLmlzQ29tcG9zaW5nKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIGtleSxcbiAgICBzaGlmdEtleSxcbiAgICBjdHJsS2V5LFxuICAgIG1ldGFLZXksXG4gICAgYWx0S2V5XG4gIH0gPSBldmVudDtcbiAgaWYgKGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9ET1dOX0NPTU1BTkQsIGV2ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzTW92ZUZvcndhcmQoa2V5LCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVUb0VuZChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgTU9WRV9UT19FTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVCYWNrd2FyZChrZXksIGN0cmxLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlVG9TdGFydChrZXksIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgTU9WRV9UT19TVEFSVCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZVVwKGtleSwgY3RybEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZURvd24oa2V5LCBjdHJsS2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0xpbmVCcmVhayhrZXksIHNoaWZ0S2V5KSkge1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gdHJ1ZTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzU3BhY2Uoa2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9TUEFDRV9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNPcGVuTGluZUJyZWFrKGtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gdHJ1ZTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCB0cnVlKTtcbiAgfSBlbHNlIGlmIChpc1BhcmFncmFwaChrZXksIHNoaWZ0S2V5KSkge1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUJhY2t3YXJkKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGlmIChpc0JhY2tzcGFjZShrZXkpKSB7XG4gICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRXNjYXBlKGtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRVNDQVBFX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUZvcndhcmQoa2V5LCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGlmIChpc0RlbGV0ZShrZXkpKSB7XG4gICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfREVMRVRFX0NPTU1BTkQsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0RlbGV0ZVdvcmRCYWNrd2FyZChrZXksIGFsdEtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlV29yZEZvcndhcmQoa2V5LCBhbHRLZXksIGN0cmxLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfV09SRF9DT01NQU5ELCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVMaW5lQmFja3dhcmQoa2V5LCBtZXRhS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0xJTkVfQ09NTUFORCwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVMaW5lRm9yd2FyZChrZXksIG1ldGFLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNCb2xkKGtleSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2JvbGQnKTtcbiAgfSBlbHNlIGlmIChpc1VuZGVybGluZShrZXksIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICd1bmRlcmxpbmUnKTtcbiAgfSBlbHNlIGlmIChpc0l0YWxpYyhrZXksIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdpdGFsaWMnKTtcbiAgfSBlbHNlIGlmIChpc1RhYihrZXksIGFsdEtleSwgY3RybEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfVEFCX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc1VuZG8oa2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFVORE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSBlbHNlIGlmIChpc1JlZG8oa2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFJFRE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gZWRpdG9yLl9lZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoaXNDb3B5KGtleSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPUFlfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0N1dChrZXksIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDVVRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc1NlbGVjdEFsbChrZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVF9BTExfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfVxuICAgICAgLy8gRkYgZG9lcyBpdCB3ZWxsIChubyBuZWVkIHRvIG92ZXJyaWRlIGJlaGF2aW9yKVxuICAgIH0gZWxzZSBpZiAoIUlTX0ZJUkVGT1ggJiYgaXNTZWxlY3RBbGwoa2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVF9BTExfQ09NTUFORCwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNNb2RpZmllcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9NT0RJRklFUl9DT01NQU5ELCBldmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJvb3RFbGVtZW50UmVtb3ZlSGFuZGxlcyhyb290RWxlbWVudCkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICBsZXQgZXZlbnRIYW5kbGVzID0gcm9vdEVsZW1lbnQuX19sZXhpY2FsRXZlbnRIYW5kbGVzO1xuICBpZiAoZXZlbnRIYW5kbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudEhhbmRsZXMgPSBbXTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIHJvb3RFbGVtZW50Ll9fbGV4aWNhbEV2ZW50SGFuZGxlcyA9IGV2ZW50SGFuZGxlcztcbiAgfVxuICByZXR1cm4gZXZlbnRIYW5kbGVzO1xufVxuXG4vLyBNYXBwaW5nIHJvb3QgZWRpdG9ycyB0byB0aGVpciBhY3RpdmUgbmVzdGVkIGVkaXRvcnMsIGNvbnRhaW5zIG5lc3RlZCBlZGl0b3JzXG4vLyBtYXBwaW5nIG9ubHksIHNvIGlmIHJvb3QgZWRpdG9yIGlzIHNlbGVjdGVkIG1hcCB3aWxsIGhhdmUgbm8gcmVmZXJlbmNlIHRvIGZyZWUgdXAgbWVtb3J5XG5jb25zdCBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IHRhcmdldCA9PSBudWxsID8gbnVsbCA6IHRhcmdldC5ub2RlVHlwZSA9PT0gOSA/IHRhcmdldC5kZWZhdWx0VmlldyA6IHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24odGFyZ2V0V2luZG93KTtcbiAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuZXh0QWN0aXZlRWRpdG9yID0gZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgaWYgKG5leHRBY3RpdmVFZGl0b3IgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93bikge1xuICAgIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biA9IGZhbHNlO1xuICAgIHVwZGF0ZUVkaXRvcihuZXh0QWN0aXZlRWRpdG9yLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgICBpZiAoZG9tQW5jaG9yTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlVHlwZSA9IGRvbUFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgICAvLyBJZiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIGNsaWNrIHNlbGVjdGlvbiBiYWNrIG9udG8gdGV4dCwgdGhlblxuICAgICAgLy8gd2Ugc2hvdWxkIGF0dGVtcHQgY3JlYXRlIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgLy8gV2hlbiB3ZSBjbGljayBvbiBhbiBlbXB0eSBwYXJhZ3JhcGggbm9kZSBvciB0aGUgZW5kIG9mIGEgcGFyYWdyYXBoIHRoYXQgZW5kc1xuICAgICAgLy8gd2l0aCBhbiBpbWFnZS9wb2xsLCB0aGUgbm9kZVR5cGUgd2lsbCBiZSBFTEVNRU5UX05PREVcbiAgICAgIGlmIChub2RlVHlwZSAhPT0gRE9NX0VMRU1FTlRfVFlQRSAmJiBub2RlVHlwZSAhPT0gRE9NX1RFWFRfVFlQRSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIG5leHRBY3RpdmVFZGl0b3IsIGV2ZW50KTtcbiAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdoZW4gZWRpdG9yIHJlY2VpdmVzIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQsIHdlJ3JlIGNoZWNraW5nIGlmXG4gIC8vIGl0IGhhcyBhbnkgc2libGluZyBlZGl0b3JzICh3aXRoaW4gc2FtZSBwYXJlbnQgZWRpdG9yKSB0aGF0IHdlcmUgYWN0aXZlXG4gIC8vIGJlZm9yZSwgYW5kIHRyaWdnZXIgc2VsZWN0aW9uIGNoYW5nZSBvbiBpdCB0byBudWxsaWZ5IHNlbGVjdGlvbi5cbiAgY29uc3QgZWRpdG9ycyA9IGdldEVkaXRvcnNUb1Byb3BhZ2F0ZShuZXh0QWN0aXZlRWRpdG9yKTtcbiAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgcm9vdEVkaXRvcktleSA9IHJvb3RFZGl0b3IuX2tleTtcbiAgY29uc3QgYWN0aXZlTmVzdGVkRWRpdG9yID0gYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5nZXQocm9vdEVkaXRvcktleSk7XG4gIGNvbnN0IHByZXZBY3RpdmVFZGl0b3IgPSBhY3RpdmVOZXN0ZWRFZGl0b3IgfHwgcm9vdEVkaXRvcjtcbiAgaWYgKHByZXZBY3RpdmVFZGl0b3IgIT09IG5leHRBY3RpdmVFZGl0b3IpIHtcbiAgICBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIHByZXZBY3RpdmVFZGl0b3IsIGZhbHNlKTtcbiAgfVxuICBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIG5leHRBY3RpdmVFZGl0b3IsIHRydWUpO1xuXG4gIC8vIElmIG5ld2x5IHNlbGVjdGVkIGVkaXRvciBpcyBuZXN0ZWQsIHRoZW4gYWRkIGl0IHRvIHRoZSBtYXAsIGNsZWFuIG1hcCBvdGhlcndpc2VcbiAgaWYgKG5leHRBY3RpdmVFZGl0b3IgIT09IHJvb3RFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLnNldChyb290RWRpdG9yS2V5LCBuZXh0QWN0aXZlRWRpdG9yKTtcbiAgfSBlbHNlIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCkge1xuICAvLyBXZSBhdHRhY2ggYSBzcGVjaWFsIHByb3BlcnR5IHRvIGVuc3VyZSB0aGUgc2FtZSBldmVudCBkb2Vzbid0IHJlLWZpcmVcbiAgLy8gZm9yIHBhcmVudCBlZGl0b3JzLlxuICAvLyBAdHMtaWdub3JlXG4gIGV2ZW50Ll9sZXhpY2FsSGFuZGxlZCA9IHRydWU7XG59XG5mdW5jdGlvbiBoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgc3RvcHBlZCA9IGV2ZW50Ll9sZXhpY2FsSGFuZGxlZCA9PT0gdHJ1ZTtcbiAgcmV0dXJuIHN0b3BwZWQ7XG59XG5mdW5jdGlvbiBhZGRSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCwgZWRpdG9yKSB7XG4gIC8vIFdlIG9ubHkgd2FudCB0byBoYXZlIGEgc2luZ2xlIGdsb2JhbCBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQgaGFuZGxlciwgc2hhcmVkXG4gIC8vIGJldHdlZW4gYWxsIGVkaXRvciBpbnN0YW5jZXMuXG4gIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgPSByb290RWxlbWVudHNSZWdpc3RlcmVkLmdldChkb2MpO1xuICBpZiAoZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCA9PT0gdW5kZWZpbmVkIHx8IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgPCAxKSB7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG4gIHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQuc2V0KGRvYywgKGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgfHwgMCkgKyAxKTtcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICByb290RWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBlZGl0b3I7XG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvb3RFbGVtZW50RXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2V2ZW50TmFtZSwgb25FdmVudF0gPSByb290RWxlbWVudEV2ZW50c1tpXTtcbiAgICBjb25zdCBldmVudEhhbmRsZXIgPSB0eXBlb2Ygb25FdmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50ID0+IHtcbiAgICAgIGlmIChoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgIGlmIChlZGl0b3IuaXNFZGl0YWJsZSgpIHx8IGV2ZW50TmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICBvbkV2ZW50KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgfVxuICAgIH0gOiBldmVudCA9PiB7XG4gICAgICBpZiAoaGFzU3RvcHBlZExleGljYWxQcm9wYWdhdGlvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCk7XG4gICAgICBjb25zdCBpc0VkaXRhYmxlID0gZWRpdG9yLmlzRWRpdGFibGUoKTtcbiAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgIGNhc2UgJ2N1dCc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ1VUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgY2FzZSAnY29weSc6XG4gICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPUFlfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdwYXN0ZSc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUEFTVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdTVEFSVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBEUkFHT1ZFUl9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdFTkRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9DVVNfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBCTFVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERST1BfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgcmVtb3ZlSGFuZGxlcy5wdXNoKCgpID0+IHtcbiAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCkge1xuICBjb25zdCBkb2MgPSByb290RWxlbWVudC5vd25lckRvY3VtZW50O1xuICBjb25zdCBkb2N1bWVudFJvb3RFbGVtZW50c0NvdW50ID0gcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZC5nZXQoZG9jKTtcbiAgaWYgKCEoZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHRocm93IEVycm9yKGBSb290IGVsZW1lbnQgbm90IHJlZ2lzdGVyZWRgKTtcbiAgfSAvLyBXZSBvbmx5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSBnbG9iYWwgc2VsZWN0aW9uY2hhbmdlIGV2ZW50IGhhbmRsZXIsIHNoYXJlZFxuICAvLyBiZXR3ZWVuIGFsbCBlZGl0b3IgaW5zdGFuY2VzLlxuICBjb25zdCBuZXdDb3VudCA9IGRvY3VtZW50Um9vdEVsZW1lbnRzQ291bnQgLSAxO1xuICBpZiAoIShuZXdDb3VudCA+PSAwKSkge1xuICAgIHRocm93IEVycm9yKGBSb290IGVsZW1lbnQgY291bnQgbGVzcyB0aGFuIDBgKTtcbiAgfVxuICByb290RWxlbWVudHNSZWdpc3RlcmVkLnNldChkb2MsIG5ld0NvdW50KTtcbiAgaWYgKG5ld0NvdW50ID09PSAwKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgY29uc3QgZWRpdG9yID0gcm9vdEVsZW1lbnQuX19sZXhpY2FsRWRpdG9yO1xuICBpZiAoZWRpdG9yICE9PSBudWxsICYmIGVkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xlYW5BY3RpdmVOZXN0ZWRFZGl0b3JzTWFwKGVkaXRvcik7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICByb290RWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBudWxsO1xuICB9XG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZUhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZW1vdmVIYW5kbGVzW2ldKCk7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXMgPSBbXTtcbn1cbmZ1bmN0aW9uIGNsZWFuQWN0aXZlTmVzdGVkRWRpdG9yc01hcChlZGl0b3IpIHtcbiAgaWYgKGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIG5lc3RlZCBlZGl0b3IgY2xlYW51cCBtYXAgaWYgdGhpcyBlZGl0b3Igd2FzIG1hcmtlZCBhcyBhY3RpdmVcbiAgICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcik7XG4gICAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCByb290RWRpdG9yS2V5ID0gcm9vdEVkaXRvci5fa2V5O1xuICAgIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmdldChyb290RWRpdG9yS2V5KSA9PT0gZWRpdG9yKSB7XG4gICAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIHRvcC1sZXZlbCBlZGl0b3JzIGNsZWFudXAgbWFwXG4gICAgYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5kZWxldGUoZWRpdG9yLl9rZXkpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpIHtcbiAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcmtDb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQoZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcCkge1xuICBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQgPSBbZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcF07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJHJlbW92ZU5vZGUobm9kZVRvUmVtb3ZlLCByZXN0b3JlU2VsZWN0aW9uLCBwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBrZXkgPSBub2RlVG9SZW1vdmUuX19rZXk7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGVUb1JlbW92ZS5nZXRQYXJlbnQoKTtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSAkbWF5YmVNb3ZlQ2hpbGRyZW5TZWxlY3Rpb25Ub1BhcmVudChub2RlVG9SZW1vdmUpO1xuICBsZXQgc2VsZWN0aW9uTW92ZWQgPSBmYWxzZTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSkge1xuICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgbm9kZVRvUmVtb3ZlLCBwYXJlbnQsIG5vZGVUb1JlbW92ZS5nZXRQcmV2aW91c1NpYmxpbmcoKSwgbm9kZVRvUmVtb3ZlLmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgc2VsZWN0aW9uTW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZm9jdXMua2V5ID09PSBrZXkpIHtcbiAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhmb2N1cywgbm9kZVRvUmVtb3ZlLCBwYXJlbnQsIG5vZGVUb1JlbW92ZS5nZXRQcmV2aW91c1NpYmxpbmcoKSwgbm9kZVRvUmVtb3ZlLmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgc2VsZWN0aW9uTW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbiAmJiBub2RlVG9SZW1vdmUuaXNTZWxlY3RlZCgpKSB7XG4gICAgbm9kZVRvUmVtb3ZlLnNlbGVjdFByZXZpb3VzKCk7XG4gIH1cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uTW92ZWQpIHtcbiAgICAvLyBEb2luZyB0aGlzIGlzIE8obikgc28gbGV0cyBhdm9pZCBpdCB1bmxlc3Mgd2UgbmVlZCB0byBkbyBpdFxuICAgIGNvbnN0IGluZGV4ID0gbm9kZVRvUmVtb3ZlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgcmVtb3ZlRnJvbVBhcmVudChub2RlVG9SZW1vdmUpO1xuICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50LCBpbmRleCwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUZyb21QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgfVxuICBpZiAoIXByZXNlcnZlRW1wdHlQYXJlbnQgJiYgISRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSAmJiAhcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuaXNFbXB0eSgpKSB7XG4gICAgJHJlbW92ZU5vZGUocGFyZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgfVxuICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSb290Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0VtcHR5KCkpIHtcbiAgICBwYXJlbnQuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmNsYXNzIExleGljYWxOb2RlIHtcbiAgLy8gQWxsb3cgdXMgdG8gbG9vayB1cCB0aGUgdHlwZSBpbmNsdWRpbmcgc3RhdGljIHByb3BzXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgLy9AdHMtaWdub3JlIFdlIHNldCB0aGUga2V5IGluIHRoZSBjb25zdHJ1Y3Rvci5cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCBhYnN0cmFjdCBjbGFzc2VzIHVuZm9ydHVuYXRlbHksIHNvIHdlIGNhbid0IF9mb3JjZV9cbiAgLy8gc3ViY2xhc3NlcyBvZiBOb2RlIHRvIGltcGxlbWVudCBzdGF0aWNzLiBBbGwgc3ViY2xhc3NlcyBvZiBOb2RlIHNob3VsZCBoYXZlXG4gIC8vIGEgc3RhdGljIGdldFR5cGUgYW5kIGNsb25lIG1ldGhvZCB0aG91Z2guIFdlIGRlZmluZSBnZXRUeXBlIGFuZCBjbG9uZSBoZXJlIHNvIHdlIGNhbiBjYWxsIGl0XG4gIC8vIG9uIGFueSAgTm9kZSwgYW5kIHdlIHRocm93IHRoaXMgZXJyb3IgYnkgZGVmYXVsdCBzaW5jZSB0aGUgc3ViY2xhc3Mgc2hvdWxkIHByb3ZpZGVcbiAgLy8gdGhlaXIgb3duIGltcGxlbWVudGF0aW9uLlxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHR5cGUgb2YgdGhpcyBub2RlLiBFdmVyeSBub2RlIG11c3RcbiAgICogaW1wbGVtZW50IHRoaXMgYW5kIGl0IE1VU1QgQkUgVU5JUVVFIGFtb25nc3Qgbm9kZXMgcmVnaXN0ZXJlZFxuICAgKiBvbiB0aGUgZWRpdG9yLlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmdldFR5cGUoKS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoaXMgbm9kZSwgY3JlYXRpbmcgYSBuZXcgbm9kZSB3aXRoIGEgZGlmZmVyZW50IGtleVxuICAgKiBhbmQgYWRkaW5nIGl0IHRvIHRoZSBFZGl0b3JTdGF0ZSAoYnV0IG5vdCBhdHRhY2hpbmcgaXQgYW55d2hlcmUhKS4gQWxsIG5vZGVzIG11c3RcbiAgICogaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGNsb25lKF9kYXRhKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmNsb25lKCkuYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICB0aGlzLl9fdHlwZSA9IHRoaXMuY29uc3RydWN0b3IuZ2V0VHlwZSgpO1xuICAgIHRoaXMuX19wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX19wcmV2ID0gbnVsbDtcbiAgICB0aGlzLl9fbmV4dCA9IG51bGw7XG4gICAgJHNldE5vZGVLZXkodGhpcywga2V5KTtcbiAgICB7XG4gICAgICBpZiAodGhpcy5fX3R5cGUgIT09ICdyb290Jykge1xuICAgICAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICAgICAgZXJyb3JPblR5cGVLbGFzc01pc21hdGNoKHRoaXMuX190eXBlLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gR2V0dGVycyBhbmQgVHJhdmVyc2Vyc1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdHlwZSBvZiB0aGlzIG5vZGUuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9fdHlwZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaXNJbmxpbmUoKS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgcGF0aCBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgdGhlIFJvb3ROb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIFRoaXMgaXMgYSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgdGhlIG5vZGUgaXMgXCJhdHRhY2hlZFwiIEVkaXRvclN0YXRlLiBVbmF0dGFjaGVkIG5vZGVzXG4gICAqIHdvbid0IGJlIHJlY29uY2lsZWQgYW5kIHdpbGwgdWx0aW1hdGVsdCBiZSBjbGVhbmVkIHVwIGJ5IHRoZSBMZXhpY2FsIEdDLlxuICAgKi9cbiAgaXNBdHRhY2hlZCgpIHtcbiAgICBsZXQgbm9kZUtleSA9IHRoaXMuX19rZXk7XG4gICAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlS2V5ID09PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZUtleSA9IG5vZGUuX19wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi4sIGZhbHNlIG90aGVyd2lzZS5cbiAgICogUmVsaWVzIG9uIHRoZSBhbGdvcml0aG1zIGltcGxlbWVudGVkIGluIHtAbGluayBCYXNlU2VsZWN0aW9uLmdldE5vZGVzfSB0byBkZXRlcm1pbmVcbiAgICogd2hhdCdzIGluY2x1ZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0aGF0IHdlIHdhbnQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBub2RlIGlzIGluLlxuICAgKi9cbiAgaXNTZWxlY3RlZChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICh0YXJnZXRTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gdGFyZ2V0U2VsZWN0aW9uLmdldE5vZGVzKCkuc29tZShuID0+IG4uX19rZXkgPT09IHRoaXMuX19rZXkpO1xuICAgIGlmICgkaXNUZXh0Tm9kZSh0aGlzKSkge1xuICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8vIEZvciBpbmxpbmUgaW1hZ2VzIGluc2lkZSBvZiBlbGVtZW50IG5vZGVzLlxuICAgIC8vIFdpdGhvdXQgdGhpcyBjaGFuZ2UgdGhlIGltYWdlIHdpbGwgYmUgc2VsZWN0ZWQgaWYgdGhlIGN1cnNvciBpcyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHRhcmdldFNlbGVjdGlvbikgJiYgdGFyZ2V0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiB0YXJnZXRTZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLmtleSAmJiB0YXJnZXRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLm9mZnNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgbm9kZXMga2V5LlxuICAgKi9cbiAgZ2V0S2V5KCkge1xuICAgIC8vIEtleSBpcyBzdGFibGUgYmV0d2VlbiBjb3BpZXNcbiAgICByZXR1cm4gdGhpcy5fX2tleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoaXMgbm9kZSB3aXRoaW4gdGhlIHBhcmVudC5cbiAgICovXG4gIGdldEluZGV4V2l0aGluUGFyZW50KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuaXMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgaW5kZXgrKztcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuXG4gICAqL1xuICBnZXRQYXJlbnQoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRMYXRlc3QoKS5fX3BhcmVudDtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICRnZXROb2RlQnlLZXkocGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLCBvciB0aHJvd3MgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICovXG4gIGdldFBhcmVudE9yVGhyb3coKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIHBhcmVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IChpbiB0aGUgRWRpdG9yU3RhdGUgdHJlZSlcbiAgICogbm9uLXJvb3QgYW5jZXN0b3Igb2YgdGhpcyBub2RlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuIFNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGljaCBFbGVtZW50cyBjb21wcmlzZSBcInJvb3RzXCIuXG4gICAqL1xuICBnZXRUb3BMZXZlbEVsZW1lbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSkge1xuICAgICAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYENoaWxkcmVuIG9mIHJvb3Qgbm9kZXMgbXVzdCBiZSBlbGVtZW50c2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaGVzdCAoaW4gdGhlIEVkaXRvclN0YXRlIHRyZWUpXG4gICAqIG5vbi1yb290IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSwgb3IgdGhyb3dzIGlmIG5vbmUgaXMgZm91bmQuIFNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGljaCBFbGVtZW50cyBjb21wcmlzZSBcInJvb3RzXCIuXG4gICAqL1xuICBnZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0VG9wTGV2ZWxFbGVtZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSB0b3AgcGFyZW50IGVsZW1lbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGV2ZXJ5IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSxcbiAgICogYWxsIHRoZSB3YXkgdXAgdG8gdGhlIFJvb3ROb2RlLlxuICAgKlxuICAgKi9cbiAgZ2V0UGFyZW50cygpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGtleXMgb2YgZXZlcnkgYW5jZXN0b3Igb2YgdGhpcyBub2RlLFxuICAgKiBhbGwgdGhlIHdheSB1cCB0byB0aGUgUm9vdE5vZGUuXG4gICAqXG4gICAqL1xuICBnZXRQYXJlbnRLZXlzKCkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudHMucHVzaChub2RlLl9fa2V5KTtcbiAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBcInByZXZpb3VzXCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZSB0aGF0IGNvbWVzXG4gICAqIGJlZm9yZSB0aGlzIG9uZSBpbiB0aGUgc2FtZSBwYXJlbnQuXG4gICAqXG4gICAqL1xuICBnZXRQcmV2aW91c1NpYmxpbmcoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgcHJldktleSA9IHNlbGYuX19wcmV2O1xuICAgIHJldHVybiBwcmV2S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkocHJldktleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJwcmV2aW91c1wiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGVzIHRoYXQgY29tZSBiZXR3ZWVuXG4gICAqIHRoaXMgb25lIGFuZCB0aGUgZmlyc3QgY2hpbGQgb2YgaXQncyBwYXJlbnQsIGluY2x1c2l2ZS5cbiAgICpcbiAgICovXG4gIGdldFByZXZpb3VzU2libGluZ3MoKSB7XG4gICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5pcyh0aGlzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gc2libGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJuZXh0XCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZSB0aGF0IGNvbWVzXG4gICAqIGFmdGVyIHRoaXMgb25lIGluIHRoZSBzYW1lIHBhcmVudFxuICAgKlxuICAgKi9cbiAgZ2V0TmV4dFNpYmxpbmcoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgbmV4dEtleSA9IHNlbGYuX19uZXh0O1xuICAgIHJldHVybiBuZXh0S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkobmV4dEtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgXCJuZXh0XCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZXMgdGhhdCBjb21lIGJldHdlZW4gdGhpc1xuICAgKiBvbmUgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGl0J3MgcGFyZW50LCBpbmNsdXNpdmUuXG4gICAqXG4gICAqL1xuICBnZXROZXh0U2libGluZ3MoKSB7XG4gICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgc2libGluZ3MucHVzaChub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBzaWJsaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbG9zZXN0IGNvbW1vbiBhbmNlc3RvciBvZiB0aGlzIG5vZGUgYW5kIHRoZSBwcm92aWRlZCBvbmUgb3IgbnVsbFxuICAgKiBpZiBvbmUgY2Fubm90IGJlIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAtIHRoZSBvdGhlciBub2RlIHRvIGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RvciBvZi5cbiAgICovXG4gIGdldENvbW1vbkFuY2VzdG9yKG5vZGUpIHtcbiAgICBjb25zdCBhID0gdGhpcy5nZXRQYXJlbnRzKCk7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0UGFyZW50cygpO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0aGlzKSkge1xuICAgICAgYS51bnNoaWZ0KHRoaXMpO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGIudW5zaGlmdChub2RlKTtcbiAgICB9XG4gICAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgICBpZiAoYUxlbmd0aCA9PT0gMCB8fCBiTGVuZ3RoID09PSAwIHx8IGFbYUxlbmd0aCAtIDFdICE9PSBiW2JMZW5ndGggLSAxXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGJTZXQgPSBuZXcgU2V0KGIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhbmNlc3RvciA9IGFbaV07XG4gICAgICBpZiAoYlNldC5oYXMoYW5jZXN0b3IpKSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBub2RlIGlzIHRoZSBleGFjdCBzYW1lIG9uZSBhcyB0aGlzIG5vZGUsIGZyb20gTGV4aWNhbCdzIHBlcnNwZWN0aXZlLlxuICAgKiBBbHdheXMgdXNlIHRoaXMgaW5zdGVhZCBvZiByZWZlcmVudGlhbCBlcXVhbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIG9iamVjdCAtIHRoZSBub2RlIHRvIHBlcmZvcm0gdGhlIGVxdWFsaXR5IGNvbXBhcmlzb24gb24uXG4gICAqL1xuICBpcyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19rZXkgPT09IG9iamVjdC5fX2tleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGxvZ2ljYWwgcHJlY2VkZXMgdGhlIHRhcmdldCBub2RlIGluIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIG5vZGUgd2UncmUgdGVzdGluZyB0byBzZWUgaWYgaXQncyBhZnRlciB0aGlzIG9uZS5cbiAgICovXG4gIGlzQmVmb3JlKHRhcmdldE5vZGUpIHtcbiAgICBpZiAodGhpcyA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Tm9kZS5pc1BhcmVudE9mKHRoaXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNQYXJlbnRPZih0YXJnZXROb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25BbmNlc3RvciA9IHRoaXMuZ2V0Q29tbW9uQW5jZXN0b3IodGFyZ2V0Tm9kZSk7XG4gICAgbGV0IGluZGV4QSA9IDA7XG4gICAgbGV0IGluZGV4QiA9IDA7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGlmIChwYXJlbnQgPT09IGNvbW1vbkFuY2VzdG9yKSB7XG4gICAgICAgIGluZGV4QSA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBub2RlID0gdGFyZ2V0Tm9kZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBpZiAocGFyZW50ID09PSBjb21tb25BbmNlc3Rvcikge1xuICAgICAgICBpbmRleEIgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4QSA8IGluZGV4QjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIHRoZSBwYXJlbnQgb2YgdGhlIHRhcmdldCBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIHdvdWxkLWJlIGNoaWxkIG5vZGUuXG4gICAqL1xuICBpc1BhcmVudE9mKHRhcmdldE5vZGUpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGlmIChrZXkgPT09IHRhcmdldE5vZGUuX19rZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSB0YXJnZXROb2RlO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5fX2tleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRPLURPOiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBzaW1wbGlmaWVkIGEgbG90XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBiZXR3ZWVuIHRoaXMgbm9kZSBhbmRcbiAgICogdGhlIHRhcmdldCBub2RlIGluIHRoZSBFZGl0b3JTdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRhcmdldE5vZGUgLSB0aGUgbm9kZSB0aGF0IG1hcmtzIHRoZSBvdGhlciBlbmQgb2YgdGhlIHJhbmdlIG9mIG5vZGVzIHRvIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0Tm9kZXNCZXR3ZWVuKHRhcmdldE5vZGUpIHtcbiAgICBjb25zdCBpc0JlZm9yZSA9IHRoaXMuaXNCZWZvcmUodGFyZ2V0Tm9kZSk7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIGxldCBub2RlID0gdGhpcztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBub2RlLl9fa2V5O1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhrZXkpKSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKGtleSk7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gJGlzRWxlbWVudE5vZGUobm9kZSkgPyBpc0JlZm9yZSA/IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpIDogbm9kZS5nZXRMYXN0Q2hpbGQoKSA6IG51bGw7XG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gaXNCZWZvcmUgPyBub2RlLmdldE5leHRTaWJsaW5nKCkgOiBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBuZXh0U2libGluZztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMocGFyZW50Ll9fa2V5KSkge1xuICAgICAgICBub2Rlcy5wdXNoKHBhcmVudCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IHBhcmVudFNpYmxpbmcgPSBudWxsO1xuICAgICAgbGV0IGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoYW5jZXN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXNCZXR3ZWVuOiBhbmNlc3RvciBpcyBudWxsYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBpc0JlZm9yZSA/IGFuY2VzdG9yLmdldE5leHRTaWJsaW5nKCkgOiBhbmNlc3Rvci5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKGFuY2VzdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT09IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGFuY2VzdG9yLl9fa2V5KSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChhbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChwYXJlbnRTaWJsaW5nID09PSBudWxsKTtcbiAgICAgIG5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgICBpZiAoIWlzQmVmb3JlKSB7XG4gICAgICBub2Rlcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGhhcyBiZWVuIG1hcmtlZCBkaXJ0eSBkdXJpbmcgdGhpcyB1cGRhdGUgY3ljbGUuXG4gICAqXG4gICAqL1xuICBpc0RpcnR5KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGRpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgICByZXR1cm4gZGlydHlMZWF2ZXMgIT09IG51bGwgJiYgZGlydHlMZWF2ZXMuaGFzKHRoaXMuX19rZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBub2RlIGZyb20gdGhlIGFjdGl2ZSBFZGl0b3JTdGF0ZS5cbiAgICogVGhpcyBpcyB1c2VkIHRvIGF2b2lkIGdldHRpbmcgdmFsdWVzIGZyb20gc3RhbGUgbm9kZSByZWZlcmVuY2VzLlxuICAgKlxuICAgKi9cbiAgZ2V0TGF0ZXN0KCkge1xuICAgIGNvbnN0IGxhdGVzdCA9ICRnZXROb2RlQnlLZXkodGhpcy5fX2tleSk7XG4gICAgaWYgKGxhdGVzdCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbCBub2RlIGRvZXMgbm90IGV4aXN0IGluIGFjdGl2ZSBlZGl0b3Igc3RhdGUuIEF2b2lkIHVzaW5nIHRoZSBzYW1lIG5vZGUgcmVmZXJlbmNlcyBiZXR3ZWVuIG5lc3RlZCBjbG9zdXJlcyBmcm9tIGVkaXRvclN0YXRlLnJlYWQvZWRpdG9yLnVwZGF0ZS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhdGVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbXV0YWJsZSB2ZXJzaW9uIG9mIHRoZSBub2RlLiBXaWxsIHRocm93IGFuIGVycm9yIGlmXG4gICAqIGNhbGxlZCBvdXRzaWRlIG9mIGEgTGV4aWNhbCBFZGl0b3Ige0BsaW5rIExleGljYWxFZGl0b3IudXBkYXRlfSBjYWxsYmFjay5cbiAgICpcbiAgICovXG4gIGdldFdyaXRhYmxlKCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcbiAgICAvLyBFbnN1cmUgd2UgZ2V0IHRoZSBsYXRlc3Qgbm9kZSBmcm9tIHBlbmRpbmcgc3RhdGVcbiAgICBjb25zdCBsYXRlc3ROb2RlID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBsYXRlc3ROb2RlLl9fcGFyZW50O1xuICAgIGNvbnN0IGNsb25lTm90TmVlZGVkID0gZWRpdG9yLl9jbG9uZU5vdE5lZWRlZDtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgc2VsZWN0aW9uLnNldENhY2hlZE5vZGVzKG51bGwpO1xuICAgIH1cbiAgICBpZiAoY2xvbmVOb3ROZWVkZWQuaGFzKGtleSkpIHtcbiAgICAgIC8vIFRyYW5zZm9ybXMgY2xlYXIgdGhlIGRpcnR5IG5vZGUgc2V0IG9uIGVhY2ggaXRlcmF0aW9uIHRvIGtlZXAgdHJhY2sgb24gbmV3bHkgZGlydHkgbm9kZXNcbiAgICAgIGludGVybmFsTWFya05vZGVBc0RpcnR5KGxhdGVzdE5vZGUpO1xuICAgICAgcmV0dXJuIGxhdGVzdE5vZGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gbGF0ZXN0Tm9kZS5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBtdXRhYmxlTm9kZSA9IGNvbnN0cnVjdG9yLmNsb25lKGxhdGVzdE5vZGUpO1xuICAgIG11dGFibGVOb2RlLl9fcGFyZW50ID0gcGFyZW50O1xuICAgIG11dGFibGVOb2RlLl9fbmV4dCA9IGxhdGVzdE5vZGUuX19uZXh0O1xuICAgIG11dGFibGVOb2RlLl9fcHJldiA9IGxhdGVzdE5vZGUuX19wcmV2O1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXRlc3ROb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShtdXRhYmxlTm9kZSkpIHtcbiAgICAgIGlmICgkaXNQYXJhZ3JhcGhOb2RlKGxhdGVzdE5vZGUpICYmICRpc1BhcmFncmFwaE5vZGUobXV0YWJsZU5vZGUpKSB7XG4gICAgICAgIG11dGFibGVOb2RlLl9fdGV4dEZvcm1hdCA9IGxhdGVzdE5vZGUuX190ZXh0Rm9ybWF0O1xuICAgICAgfVxuICAgICAgbXV0YWJsZU5vZGUuX19maXJzdCA9IGxhdGVzdE5vZGUuX19maXJzdDtcbiAgICAgIG11dGFibGVOb2RlLl9fbGFzdCA9IGxhdGVzdE5vZGUuX19sYXN0O1xuICAgICAgbXV0YWJsZU5vZGUuX19zaXplID0gbGF0ZXN0Tm9kZS5fX3NpemU7XG4gICAgICBtdXRhYmxlTm9kZS5fX2luZGVudCA9IGxhdGVzdE5vZGUuX19pbmRlbnQ7XG4gICAgICBtdXRhYmxlTm9kZS5fX2Zvcm1hdCA9IGxhdGVzdE5vZGUuX19mb3JtYXQ7XG4gICAgICBtdXRhYmxlTm9kZS5fX2RpciA9IGxhdGVzdE5vZGUuX19kaXI7XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShsYXRlc3ROb2RlKSAmJiAkaXNUZXh0Tm9kZShtdXRhYmxlTm9kZSkpIHtcbiAgICAgIG11dGFibGVOb2RlLl9fZm9ybWF0ID0gbGF0ZXN0Tm9kZS5fX2Zvcm1hdDtcbiAgICAgIG11dGFibGVOb2RlLl9fc3R5bGUgPSBsYXRlc3ROb2RlLl9fc3R5bGU7XG4gICAgICBtdXRhYmxlTm9kZS5fX21vZGUgPSBsYXRlc3ROb2RlLl9fbW9kZTtcbiAgICAgIG11dGFibGVOb2RlLl9fZGV0YWlsID0gbGF0ZXN0Tm9kZS5fX2RldGFpbDtcbiAgICB9XG4gICAgY2xvbmVOb3ROZWVkZWQuYWRkKGtleSk7XG4gICAgbXV0YWJsZU5vZGUuX19rZXkgPSBrZXk7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobXV0YWJsZU5vZGUpO1xuICAgIC8vIFVwZGF0ZSByZWZlcmVuY2UgaW4gbm9kZSBtYXBcbiAgICBub2RlTWFwLnNldChrZXksIG11dGFibGVOb2RlKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gbXV0YWJsZU5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlLiBPdmVycmlkZSB0aGlzIGZvclxuICAgKiBjdXN0b20gbm9kZXMgdGhhdCBzaG91bGQgaGF2ZSBhIHJlcHJlc2VudGF0aW9uIGluIHBsYWluIHRleHRcbiAgICogZm9ybWF0IChmb3IgY29weSArIHBhc3RlLCBmb3IgZXhhbXBsZSlcbiAgICpcbiAgICovXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBwcm9kdWNlZCBieSBjYWxsaW5nIGdldFRleHRDb250ZW50IG9uIHRoaXMgbm9kZS5cbiAgICpcbiAgICovXG4gIGdldFRleHRDb250ZW50U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgfVxuXG4gIC8vIFZpZXdcblxuICAvKipcbiAgICogQ2FsbGVkIGR1cmluZyB0aGUgcmVjb25jaWxpYXRpb24gcHJvY2VzcyB0byBkZXRlcm1pbmUgd2hpY2ggbm9kZXNcbiAgICogdG8gaW5zZXJ0IGludG8gdGhlIERPTSBmb3IgdGhpcyBMZXhpY2FsIE5vZGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIG11c3QgcmV0dXJuIGV4YWN0bHkgb25lIEhUTUxFbGVtZW50LiBOZXN0ZWQgZWxlbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIERvIG5vdCBhdHRlbXB0IHRvIHVwZGF0ZSB0aGUgTGV4aWNhbCBFZGl0b3JTdGF0ZSBkdXJpbmcgdGhpcyBwaGFzZSBvZiB0aGUgdXBkYXRlIGxpZmVjeWxlLlxuICAgKlxuICAgKiBAcGFyYW0gX2NvbmZpZyAtIGFsbG93cyBhY2Nlc3MgdG8gdGhpbmdzIGxpa2UgdGhlIEVkaXRvclRoZW1lICh0byBhcHBseSBjbGFzc2VzKSBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gICAqIEBwYXJhbSBfZWRpdG9yIC0gYWxsb3dzIGFjY2VzcyB0byB0aGUgZWRpdG9yIGZvciBjb250ZXh0IGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAgICpcbiAgICogKi9cbiAgY3JlYXRlRE9NKF9jb25maWcsIF9lZGl0b3IpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgY3JlYXRlRE9NOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBub2RlIGNoYW5nZXMgYW5kIHNob3VsZCB1cGRhdGUgdGhlIERPTVxuICAgKiBpbiB3aGF0ZXZlciB3YXkgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaXQgYWxpZ24gd2l0aCBhbnkgY2hhbmdlcyB0aGF0IG1pZ2h0XG4gICAqIGhhdmUgaGFwcGVuZWQgZHVyaW5nIHRoZSB1cGRhdGUuXG4gICAqXG4gICAqIFJldHVybmluZyBcInRydWVcIiBoZXJlIHdpbGwgY2F1c2UgbGV4aWNhbCB0byB1bm1vdW50IGFuZCByZWNyZWF0ZSB0aGUgRE9NIG5vZGVcbiAgICogKGJ5IGNhbGxpbmcgY3JlYXRlRE9NKS4gWW91IHdvdWxkIG5lZWQgdG8gZG8gdGhpcyBpZiB0aGUgZWxlbWVudCB0YWcgY2hhbmdlcyxcbiAgICogZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiAqL1xuICB1cGRhdGVET00oX3ByZXZOb2RlLCBfZG9tLCBfY29uZmlnKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHVwZGF0ZURPTTogYmFzZSBtZXRob2Qgbm90IGV4dGVuZGVkYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyB0aGUgdGhpcyBub2RlIGlzIHNlcmlhbGl6ZWQgdG8gSFRNTC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yXG4gICAqIGNvcHkgYW5kIHBhc3RlIGJldHdlZW4gTGV4aWNhbCBhbmQgbm9uLUxleGljYWwgZWRpdG9ycywgb3IgTGV4aWNhbCBlZGl0b3JzIHdpdGggZGlmZmVyZW50IG5hbWVzcGFjZXMsXG4gICAqIGluIHdoaWNoIGNhc2UgdGhlIHByaW1hcnkgdHJhbnNmZXIgZm9ybWF0IGlzIEhUTUwuIEl0J3MgYWxzbyBpbXBvcnRhbnQgaWYgeW91J3JlIHNlcmlhbGl6aW5nXG4gICAqIHRvIEhUTUwgZm9yIGFueSBvdGhlciByZWFzb24gdmlhIHtAbGluayBAbGV4aWNhbC9odG1sISRnZW5lcmF0ZUh0bWxGcm9tTm9kZXN9LiBZb3UgY291bGRcbiAgICogYWxzbyB1c2UgdGhpcyBtZXRob2QgdG8gYnVpbGQgeW91ciBvd24gSFRNTCByZW5kZXJlci5cbiAgICpcbiAgICogKi9cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZURPTShlZGl0b3IuX2NvbmZpZywgZWRpdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgc2VyaWFsaXplZCB0byBKU09OLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgICogY29weSBhbmQgcGFzdGUgYmV0d2VlbiBMZXhpY2FsIGVkaXRvcnMgc2hhcmluZyB0aGUgc2FtZSBuYW1lc3BhY2UuIEl0J3MgYWxzbyBpbXBvcnRhbnRcbiAgICogaWYgeW91J3JlIHNlcmlhbGl6aW5nIHRvIEpTT04gZm9yIHBlcnNpc3RlbnQgc3RvcmFnZSBzb21ld2hlcmUuXG4gICAqIFNlZSBbU2VyaWFsaXphdGlvbiAmIERlc2VyaWFsaXphdGlvbl0oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3NlcmlhbGl6YXRpb24jbGV4aWNhbC0tLWh0bWwpLlxuICAgKlxuICAgKiAqL1xuICBleHBvcnRKU09OKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBleHBvcnRKU09OOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgZGVzZXJpYWxpemVkIGZyb20gSlNPTi4gVGhpcyBpcyB1c3VhbGx5IGJvaWxlcnBsYXRlLFxuICAgKiBidXQgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gYmV0d2VlbiB0aGUgbm9kZSBpbXBsZW1lbnRhdGlvbiBhbmQgc2VyaWFsaXplZCBpbnRlcmZhY2UgdGhhdCBjYW5cbiAgICogYmUgaW1wb3J0YW50IGlmIHlvdSBldmVyIG1ha2UgYnJlYWtpbmcgY2hhbmdlcyB0byBhIG5vZGUgc2NoZW1hIChieSBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJvcGVydGllcykuXG4gICAqIFNlZSBbU2VyaWFsaXphdGlvbiAmIERlc2VyaWFsaXphdGlvbl0oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3NlcmlhbGl6YXRpb24jbGV4aWNhbC0tLWh0bWwpLlxuICAgKlxuICAgKiAqL1xuICBzdGF0aWMgaW1wb3J0SlNPTihfc2VyaWFsaXplZE5vZGUpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaW1wb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKlxuICAgKiBSZWdpc3RlcnMgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGFzIGEgdHJhbnNmb3JtIG9uIHRoZSBub2RlIGR1cmluZ1xuICAgKiBFZGl0b3IgaW5pdGlhbGl6YXRpb24uIE1vc3Qgc3VjaCB1c2UgY2FzZXMgc2hvdWxkIGJlIGFkZHJlc3NlZCB2aWFcbiAgICogdGhlIHtAbGluayBMZXhpY2FsRWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybX0gQVBJLlxuICAgKlxuICAgKiBFeHBlcmltZW50YWwgLSB1c2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIHN0YXRpYyB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBTZXR0ZXJzIGFuZCBtdXRhdG9yc1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoaXMgTGV4aWNhbE5vZGUgZnJvbSB0aGUgRWRpdG9yU3RhdGUuIElmIHRoZSBub2RlIGlzbid0IHJlLWluc2VydGVkXG4gICAqIHNvbWV3aGVyZSwgdGhlIExleGljYWwgZ2FyYmFnZSBjb2xsZWN0b3Igd2lsbCBldmVudHVhbGx5IGNsZWFuIGl0IHVwLlxuICAgKlxuICAgKiBAcGFyYW0gcHJlc2VydmVFbXB0eVBhcmVudCAtIElmIGZhbHN5LCB0aGUgbm9kZSdzIHBhcmVudCB3aWxsIGJlIHJlbW92ZWQgaWZcbiAgICogaXQncyBlbXB0eSBhZnRlciB0aGUgcmVtb3ZhbCBvcGVyYXRpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIHN1YmplY3QgdG9cbiAgICogb3RoZXIgbm9kZSBoZXVyaXN0aWNzIHN1Y2ggYXMge0BsaW5rIEVsZW1lbnROb2RlI2NhbkJlRW1wdHl9XG4gICAqICovXG4gIHJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gICAgJHJlbW92ZU5vZGUodGhpcywgdHJ1ZSwgcHJlc2VydmVFbXB0eVBhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhpcyBMZXhpY2FsTm9kZSB3aXRoIHRoZSBwcm92aWRlZCBub2RlLCBvcHRpb25hbGx5IHRyYW5zZmVycmluZyB0aGUgY2hpbGRyZW5cbiAgICogb2YgdGhlIHJlcGxhY2VkIG5vZGUgdG8gdGhlIHJlcGxhY2luZyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVwbGFjZVdpdGggLSBUaGUgbm9kZSB0byByZXBsYWNlIHRoaXMgb25lIHdpdGguXG4gICAqIEBwYXJhbSBpbmNsdWRlQ2hpbGRyZW4gLSBXaGV0aGVyIG9yIG5vdCB0byB0cmFuc2ZlciB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlIHRvIHRoZSByZXBsYWNpbmcgbm9kZS5cbiAgICogKi9cbiAgcmVwbGFjZShyZXBsYWNlV2l0aCwgaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgbGV0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uY2xvbmUoKTtcbiAgICB9XG4gICAgZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KHRoaXMsIHJlcGxhY2VXaXRoKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCB0b1JlcGxhY2VLZXkgPSB0aGlzLl9fa2V5O1xuICAgIGNvbnN0IGtleSA9IHJlcGxhY2VXaXRoLl9fa2V5O1xuICAgIGNvbnN0IHdyaXRhYmxlUmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBzaXplID0gd3JpdGFibGVQYXJlbnQuX19zaXplO1xuICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVSZXBsYWNlV2l0aCk7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBzZWxmLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gc2VsZi5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHByZXZLZXkgPSBzZWxmLl9fcHJldjtcbiAgICBjb25zdCBuZXh0S2V5ID0gc2VsZi5fX25leHQ7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gc2VsZi5fX3BhcmVudDtcbiAgICAkcmVtb3ZlTm9kZShzZWxmLCBmYWxzZSwgdHJ1ZSk7XG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0ga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0ga2V5O1xuICAgIH1cbiAgICB3cml0YWJsZVJlcGxhY2VXaXRoLl9fcHJldiA9IHByZXZLZXk7XG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBrZXk7XG4gICAgfVxuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19uZXh0ID0gbmV4dEtleTtcbiAgICB3cml0YWJsZVJlcGxhY2VXaXRoLl9fcGFyZW50ID0gcGFyZW50S2V5O1xuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZSA9IHNpemU7XG4gICAgaWYgKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgaWYgKCEoJGlzRWxlbWVudE5vZGUodGhpcykgJiYgJGlzRWxlbWVudE5vZGUod3JpdGFibGVSZXBsYWNlV2l0aCkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBpbmNsdWRlQ2hpbGRyZW4gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgRWxlbWVudE5vZGVzYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguYXBwZW5kKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgaWYgKGFuY2hvci5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoYW5jaG9yLCB3cml0YWJsZVJlcGxhY2VXaXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb2N1cy5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoZm9jdXMsIHdyaXRhYmxlUmVwbGFjZVdpdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGdldENvbXBvc2l0aW9uS2V5KCkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0YWJsZVJlcGxhY2VXaXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBub2RlIGFmdGVyIHRoaXMgTGV4aWNhbE5vZGUgKGFzIHRoZSBuZXh0IHNpYmxpbmcpLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZVRvSW5zZXJ0IC0gVGhlIG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVzdG9yZVNlbGVjdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiAqL1xuICBpbnNlcnRBZnRlcihub2RlVG9JbnNlcnQsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KHRoaXMsIG5vZGVUb0luc2VydCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkUGFyZW50ID0gd3JpdGFibGVOb2RlVG9JbnNlcnQuZ2V0UGFyZW50KCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGxldCBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gZmFsc2U7XG4gICAgbGV0IGVsZW1lbnRGb2N1c1NlbGVjdGlvbk9uTm9kZSA9IGZhbHNlO1xuICAgIGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IHRoaXMgaXMgTyhuKSwgY2FuIHdlIGltcHJvdmU/XG4gICAgICBjb25zdCBvbGRJbmRleCA9IG5vZGVUb0luc2VydC5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZU5vZGVUb0luc2VydCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBvbGRQYXJlbnRLZXkgPSBvbGRQYXJlbnQuX19rZXk7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3Iua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgYW5jaG9yLm9mZnNldCA9PT0gb2xkSW5kZXggKyAxO1xuICAgICAgICBlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUgPSBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgZm9jdXMub2Zmc2V0ID09PSBvbGRJbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBpbnNlcnRLZXkgPSB3cml0YWJsZU5vZGVUb0luc2VydC5fX2tleTtcbiAgICBjb25zdCBuZXh0S2V5ID0gd3JpdGFibGVTZWxmLl9fbmV4dDtcbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IGluc2VydEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IGluc2VydEtleTtcbiAgICB9XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplKys7XG4gICAgd3JpdGFibGVTZWxmLl9fbmV4dCA9IGluc2VydEtleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX25leHQgPSBuZXh0S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcHJldiA9IHdyaXRhYmxlU2VsZi5fX2tleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9IHdyaXRhYmxlU2VsZi5fX3BhcmVudDtcbiAgICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgd3JpdGFibGVQYXJlbnQsIGluZGV4ICsgMSk7XG4gICAgICBjb25zdCB3cml0YWJsZVBhcmVudEtleSA9IHdyaXRhYmxlUGFyZW50Ll9fa2V5O1xuICAgICAgaWYgKGVsZW1lbnRBbmNob3JTZWxlY3Rpb25Pbk5vZGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQod3JpdGFibGVQYXJlbnRLZXksIGluZGV4ICsgMiwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldCh3cml0YWJsZVBhcmVudEtleSwgaW5kZXggKyAyLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVRvSW5zZXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBub2RlIGJlZm9yZSB0aGlzIExleGljYWxOb2RlIChhcyB0aGUgcHJldmlvdXMgc2libGluZykuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlVG9JbnNlcnQgLSBUaGUgbm9kZSB0byBpbnNlcnQgYmVmb3JlIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVzdG9yZVNlbGVjdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiAqL1xuICBpbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0LCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGVycm9yT25JbnNlcnRUZXh0Tm9kZU9uUm9vdCh0aGlzLCBub2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZU5vZGVUb0luc2VydCA9IG5vZGVUb0luc2VydC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGluc2VydEtleSA9IHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgcHJldktleSA9IHdyaXRhYmxlU2VsZi5fX3ByZXY7XG4gICAgLy8gVE9ETzogdGhpcyBpcyBPKG4pLCBjYW4gd2UgaW1wcm92ZT9cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBpbnNlcnRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBpbnNlcnRLZXk7XG4gICAgfVxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZSsrO1xuICAgIHdyaXRhYmxlU2VsZi5fX3ByZXYgPSBpbnNlcnRLZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wcmV2ID0gcHJldktleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX25leHQgPSB3cml0YWJsZVNlbGYuX19rZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGYuX19wYXJlbnQ7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChyZXN0b3JlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCBwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVUb0luc2VydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaGFzIGEgcmVxdWlyZWQgcGFyZW50LiBVc2VkIGR1cmluZyBjb3B5ICsgcGFzdGUgb3BlcmF0aW9uc1xuICAgKiB0byBub3JtYWxpemUgbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgb3JwaGFuZWQuIEZvciBleGFtcGxlLCBMaXN0SXRlbU5vZGVzIHdpdGhvdXRcbiAgICogYSBMaXN0Tm9kZSBwYXJlbnQgb3IgVGV4dE5vZGVzIHdpdGggYSBQYXJhZ3JhcGhOb2RlIHBhcmVudC5cbiAgICpcbiAgICogKi9cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNyZWF0aW9uIGxvZ2ljIGZvciBhbnkgcmVxdWlyZWQgcGFyZW50LiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaWYge0BsaW5rIGlzUGFyZW50UmVxdWlyZWR9IHJldHVybnMgdHJ1ZS5cbiAgICpcbiAgICogKi9cbiAgY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKSB7XG4gICAgcmV0dXJuICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0UHJldmlvdXMoKTtcbiAgfVxuICBzZWxlY3RFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0TmV4dCgwLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhpcyBub2RlLCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSBUaGUgYW5jaG9yIG9mZnNldCBmb3Igc2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSAgVGhlIGZvY3VzIG9mZnNldCBmb3Igc2VsZWN0aW9uXG4gICAqICovXG4gIHNlbGVjdFByZXZpb3VzKGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdCgwLCAwKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgIH0gZWxzZSBpZiAoISRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBwcmV2U2libGluZy5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwcmV2U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhpcyBub2RlLCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSBUaGUgYW5jaG9yIG9mZnNldCBmb3Igc2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSAgVGhlIGZvY3VzIG9mZnNldCBmb3Igc2VsZWN0aW9uXG4gICAqICovXG4gIHNlbGVjdE5leHQoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHBhcmVudC5zZWxlY3QoKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nLnNlbGVjdCgwLCAwKTtcbiAgICB9IGVsc2UgaWYgKCEkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbmV4dFNpYmxpbmcuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgYSBub2RlIGRpcnR5LCB0cmlnZ2VyaW5nIHRyYW5zZm9ybXMgYW5kXG4gICAqIGZvcmNpbmcgaXQgdG8gYmUgcmVjb25jaWxlZCBkdXJpbmcgdGhlIHVwZGF0ZSBjeWNsZS5cbiAgICpcbiAgICogKi9cbiAgbWFya0RpcnR5KCkge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPblR5cGVLbGFzc01pc21hdGNoKHR5cGUsIGtsYXNzKSB7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZ2V0QWN0aXZlRWRpdG9yKCkuX25vZGVzLmdldCh0eXBlKTtcbiAgLy8gQ29tbW9uIGVycm9yIC0gc3BsaXQgaW4gaXRzIG93biBpbnZhcmlhbnRcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQ3JlYXRlIG5vZGU6IEF0dGVtcHRlZCB0byBjcmVhdGUgbm9kZSAke2tsYXNzLm5hbWV9IHRoYXQgd2FzIG5vdCBjb25maWd1cmVkIHRvIGJlIHVzZWQgb24gdGhlIGVkaXRvci5gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZWRpdG9yS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcbiAgaWYgKGVkaXRvcktsYXNzICE9PSBrbGFzcykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBDcmVhdGUgbm9kZTogVHlwZSAke3R5cGV9IGluIG5vZGUgJHtrbGFzcy5uYW1lfSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIG5vZGUgJHtlZGl0b3JLbGFzcy5uYW1lfSB3aXRoIHRoZSBzYW1lIHR5cGVgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnNlcnQgYSBzZXJpZXMgb2Ygbm9kZXMgYWZ0ZXIgdGhpcyBMZXhpY2FsTm9kZSAoYXMgbmV4dCBzaWJsaW5ncylcbiAqXG4gKiBAcGFyYW0gZmlyc3RUb0luc2VydCAtIFRoZSBmaXJzdCBub2RlIHRvIGluc2VydCBhZnRlciB0aGlzIG9uZS5cbiAqIEBwYXJhbSBsYXN0VG9JbnNlcnQgLSBUaGUgbGFzdCBub2RlIHRvIGluc2VydCBhZnRlciB0aGlzIG9uZS4gTXVzdCBiZSBhXG4gKiBsYXRlciBzaWJsaW5nIG9mIEZpcnN0Tm9kZS4gSWYgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGJlIGl0cyBsYXN0IHNpYmxpbmcuXG4gKi9cbmZ1bmN0aW9uIGluc2VydFJhbmdlQWZ0ZXIobm9kZSwgZmlyc3RUb0luc2VydCwgbGFzdFRvSW5zZXJ0KSB7XG4gIGNvbnN0IGxhc3RUb0luc2VydDIgPSBmaXJzdFRvSW5zZXJ0LmdldFBhcmVudE9yVGhyb3coKS5nZXRMYXN0Q2hpbGQoKTtcbiAgbGV0IGN1cnJlbnQgPSBmaXJzdFRvSW5zZXJ0O1xuICBjb25zdCBub2Rlc1RvSW5zZXJ0ID0gW2ZpcnN0VG9JbnNlcnRdO1xuICB3aGlsZSAoY3VycmVudCAhPT0gbGFzdFRvSW5zZXJ0Mikge1xuICAgIGlmICghY3VycmVudC5nZXROZXh0U2libGluZygpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBpbnNlcnRSYW5nZUFmdGVyOiBsYXN0VG9JbnNlcnQgbXVzdCBiZSBhIGxhdGVyIHNpYmxpbmcgb2YgZmlyc3RUb0luc2VydGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudC5nZXROZXh0U2libGluZygpO1xuICAgIG5vZGVzVG9JbnNlcnQucHVzaChjdXJyZW50KTtcbiAgfVxuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICBmb3IgKGNvbnN0IG5vZGVUb0luc2VydCBvZiBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5pbnNlcnRBZnRlcihub2RlVG9JbnNlcnQpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpbmVCcmVha05vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluZWJyZWFrJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGluZUJyZWFrTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnXFxuJztcbiAgfVxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBicjogbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc09ubHlDaGlsZChub2RlKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaW5lQnJlYWtFbGVtZW50LFxuICAgICAgICAgIHByaW9yaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTGluZUJyZWFrTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlTGluZUJyZWFrTm9kZSgpO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaW5lYnJlYWsnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGluZUJyZWFrRWxlbWVudChub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpbmVCcmVha05vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUxpbmVCcmVha05vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmVCcmVha05vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaW5lQnJlYWtOb2RlO1xufVxuZnVuY3Rpb24gaXNPbmx5Q2hpbGQobm9kZSkge1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICBpZiAocGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKGZpcnN0Q2hpbGQgPT09IG5vZGUgfHwgZmlyc3RDaGlsZC5uZXh0U2libGluZyA9PT0gbm9kZSAmJiBpc1doaXRlc3BhY2VEb21UZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50RWxlbWVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAobGFzdENoaWxkID09PSBub2RlIHx8IGxhc3RDaGlsZC5wcmV2aW91c1NpYmxpbmcgPT09IG5vZGUgJiYgaXNXaGl0ZXNwYWNlRG9tVGV4dE5vZGUobGFzdENoaWxkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlRG9tVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSAmJiAvXiggfFxcdHxcXHI/XFxuKSskLy50ZXN0KG5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRPdXRlclRhZyhub2RlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCAmIElTX0NPREUpIHtcbiAgICByZXR1cm4gJ2NvZGUnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19ISUdITElHSFQpIHtcbiAgICByZXR1cm4gJ21hcmsnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19TVUJTQ1JJUFQpIHtcbiAgICByZXR1cm4gJ3N1Yic7XG4gIH1cbiAgaWYgKGZvcm1hdCAmIElTX1NVUEVSU0NSSVBUKSB7XG4gICAgcmV0dXJuICdzdXAnO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudElubmVyVGFnKG5vZGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ICYgSVNfQk9MRCkge1xuICAgIHJldHVybiAnc3Ryb25nJztcbiAgfVxuICBpZiAoZm9ybWF0ICYgSVNfSVRBTElDKSB7XG4gICAgcmV0dXJuICdlbSc7XG4gIH1cbiAgcmV0dXJuICdzcGFuJztcbn1cbmZ1bmN0aW9uIHNldFRleHRUaGVtZUNsYXNzTmFtZXModGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBkb20sIHRleHRDbGFzc05hbWVzKSB7XG4gIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gIC8vIEZpcnN0bHkgd2UgaGFuZGxlIHRoZSBiYXNlIHRoZW1lLlxuICBsZXQgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCAnYmFzZScpO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgfVxuICAvLyBTZWNvbmRseSB3ZSBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZTogdW5kZXJsaW5lICsgc3RyaWtldGhyb3VnaC5cbiAgLy8gV2UgaGF2ZSB0byBkbyB0aGlzIGFzIHdlIG5lZWQgYSB3YXkgdG8gY29tcG9zZSB0aGUgZmFjdCB0aGF0XG4gIC8vIHRoZSBzYW1lIENTUyBwcm9wZXJ0eSB3aWxsIG5lZWQgdG8gYmUgdXNlZDogdGV4dC1kZWNvcmF0aW9uLlxuICAvLyBJbiBhbiBpZGVhbCB3b3JsZCB3ZSBzaG91bGRuJ3QgaGF2ZSB0byBkbyB0aGlzLCBidXQgdGhlcmUncyBub1xuICAvLyBlYXN5IHdvcmthcm91bmQgZm9yIG1hbnkgYXRvbWljIENTUyBzeXN0ZW1zIHRvZGF5LlxuICBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGV4dENsYXNzTmFtZXMsICd1bmRlcmxpbmVTdHJpa2V0aHJvdWdoJyk7XG4gIGxldCBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gZmFsc2U7XG4gIGNvbnN0IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gcHJldkZvcm1hdCAmIElTX1VOREVSTElORSAmJiBwcmV2Rm9ybWF0ICYgSVNfU1RSSUtFVEhST1VHSDtcbiAgY29uc3QgbmV4dFVuZGVybGluZVN0cmlrZXRocm91Z2ggPSBuZXh0Rm9ybWF0ICYgSVNfVU5ERVJMSU5FICYmIG5leHRGb3JtYXQgJiBJU19TVFJJS0VUSFJPVUdIO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG5leHRVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIGlmICghcHJldlVuZGVybGluZVN0cmlrZXRocm91Z2gpIHtcbiAgICAgICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBkb21DbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBURVhUX1RZUEVfVE9fRk9STUFUKSB7XG4gICAgY29uc3QgZm9ybWF0ID0ga2V5O1xuICAgIGNvbnN0IGZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF07XG4gICAgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCBrZXkpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChuZXh0Rm9ybWF0ICYgZmxhZykge1xuICAgICAgICBpZiAoaGFzVW5kZXJsaW5lU3RyaWtldGhyb3VnaCAmJiAoa2V5ID09PSAndW5kZXJsaW5lJyB8fCBrZXkgPT09ICdzdHJpa2V0aHJvdWdoJykpIHtcbiAgICAgICAgICBpZiAocHJldkZvcm1hdCAmIGZsYWcpIHtcbiAgICAgICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJldkZvcm1hdCAmIGZsYWcpID09PSAwIHx8IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoICYmIGtleSA9PT0gJ3VuZGVybGluZScgfHwga2V5ID09PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZGb3JtYXQgJiBmbGFnKSB7XG4gICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWZmQ29tcG9zZWRUZXh0KGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gMDtcbiAgd2hpbGUgKGxlZnQgPCBhTGVuZ3RoICYmIGxlZnQgPCBiTGVuZ3RoICYmIGFbbGVmdF0gPT09IGJbbGVmdF0pIHtcbiAgICBsZWZ0Kys7XG4gIH1cbiAgd2hpbGUgKHJpZ2h0ICsgbGVmdCA8IGFMZW5ndGggJiYgcmlnaHQgKyBsZWZ0IDwgYkxlbmd0aCAmJiBhW2FMZW5ndGggLSByaWdodCAtIDFdID09PSBiW2JMZW5ndGggLSByaWdodCAtIDFdKSB7XG4gICAgcmlnaHQrKztcbiAgfVxuICByZXR1cm4gW2xlZnQsIGFMZW5ndGggLSBsZWZ0IC0gcmlnaHQsIGIuc2xpY2UobGVmdCwgYkxlbmd0aCAtIHJpZ2h0KV07XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChuZXh0VGV4dCwgZG9tLCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgY29uc3QgaXNDb21wb3NpbmcgPSBub2RlLmlzQ29tcG9zaW5nKCk7XG4gIC8vIEFsd2F5cyBhZGQgYSBzdWZmaXggaWYgd2UncmUgY29tcG9zaW5nIGEgbm9kZVxuICBjb25zdCBzdWZmaXggPSBpc0NvbXBvc2luZyA/IENPTVBPU0lUSU9OX1NVRkZJWCA6ICcnO1xuICBjb25zdCB0ZXh0ID0gbmV4dFRleHQgKyBzdWZmaXg7XG4gIGlmIChmaXJzdENoaWxkID09IG51bGwpIHtcbiAgICBkb20udGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuICAgIGlmIChub2RlVmFsdWUgIT09IHRleHQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZyB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSBkaWZmIGNvbXBvc2VkIHRleHQgZm9yIGdlbmVyYWwgdGV4dCBpbiBGRiB0byBhdm9pZFxuICAgICAgICAvLyB0aGUgc3BlbGxjaGVjayByZWQgbGluZSBmcm9tIGZsaWNrZXJpbmcuXG4gICAgICAgIGNvbnN0IFtpbmRleCwgcmVtb3ZlLCBpbnNlcnRdID0gZGlmZkNvbXBvc2VkVGV4dChub2RlVmFsdWUsIHRleHQpO1xuICAgICAgICBpZiAocmVtb3ZlICE9PSAwKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZpcnN0Q2hpbGQuZGVsZXRlRGF0YShpbmRleCwgcmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0RGF0YShpbmRleCwgaW5zZXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbm5lckRPTShpbm5lckRPTSwgbm9kZSwgaW5uZXJUYWcsIGZvcm1hdCwgdGV4dCwgY29uZmlnKSB7XG4gIHNldFRleHRDb250ZW50KHRleHQsIGlubmVyRE9NLCBub2RlKTtcbiAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gIC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG4gIGNvbnN0IHRleHRDbGFzc05hbWVzID0gdGhlbWUudGV4dDtcbiAgaWYgKHRleHRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKGlubmVyVGFnLCAwLCBmb3JtYXQsIGlubmVyRE9NLCB0ZXh0Q2xhc3NOYW1lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCB0YWcpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICByZXR1cm4gZWw7XG59XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGV4dCc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHROb2RlKG5vZGUuX190ZXh0LCBub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0ZXh0LCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190ZXh0ID0gdGV4dDtcbiAgICB0aGlzLl9fZm9ybWF0ID0gMDtcbiAgICB0aGlzLl9fc3R5bGUgPSAnJztcbiAgICB0aGlzLl9fbW9kZSA9IDA7XG4gICAgdGhpcy5fX2RldGFpbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIDMyLWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgVGV4dEZvcm1hdFR5cGVzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZVxuICAgKiBUZXh0Tm9kZS4gWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5IC0gY29uc2lkZXIgdXNpbmcgVGV4dE5vZGUuaGFzRm9ybWF0IGluc3RlYWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgZm9ybWF0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAqL1xuICBnZXRGb3JtYXQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19mb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIDMyLWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgVGV4dERldGFpbFR5cGVzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZVxuICAgKiBUZXh0Tm9kZS4gWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5IC0gY29uc2lkZXIgdXNpbmcgVGV4dE5vZGUuaXNEaXJlY3Rpb25sZXNzXG4gICAqIG9yIFRleHROb2RlLmlzVW5tZXJnZWFibGUgaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBkZXRhaWwgb2YgdGhlIHRleHQgbm9kZS5cbiAgICovXG4gIGdldERldGFpbCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2RldGFpbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtb2RlIChUZXh0TW9kZVR5cGUpIG9mIHRoZSBUZXh0Tm9kZSwgd2hpY2ggbWF5IGJlIFwibm9ybWFsXCIsIFwidG9rZW5cIiwgb3IgXCJzZWdtZW50ZWRcIlxuICAgKlxuICAgKiBAcmV0dXJucyBUZXh0TW9kZVR5cGUuXG4gICAqL1xuICBnZXRNb2RlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBURVhUX1RZUEVfVE9fTU9ERVtzZWxmLl9fbW9kZV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3R5bGVzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZSBub2RlLiBUaGlzIGlzIGFuYWxvZ291cyB0byBDU1NUZXh0IGluIHRoZSBET00uXG4gICAqXG4gICAqIEByZXR1cm5zIENTU1RleHQtbGlrZSBzdHJpbmcgb2Ygc3R5bGVzIGFwcGxpZWQgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuXG4gICAqL1xuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3N0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgaW4gXCJ0b2tlblwiIG1vZGUuIFRleHROb2RlcyBpbiB0b2tlbiBtb2RlIGNhbiBiZSBuYXZpZ2F0ZWQgdGhyb3VnaCBjaGFyYWN0ZXItYnktY2hhcmFjdGVyXG4gICAqIHdpdGggYSBSYW5nZVNlbGVjdGlvbiwgYnV0IGFyZSBkZWxldGVkIGFzIGEgc2luZ2xlIGVudGl0eSAobm90IGludmRpdmlkdWFsbHkgYnkgY2hhcmFjdGVyKS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBpbiB0b2tlbiBtb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1Rva2VuKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fbW9kZSA9PT0gSVNfVE9LRU47XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBMZXhpY2FsIGRldGVjdHMgdGhhdCBhbiBJTUUgb3Igb3RoZXIgM3JkLXBhcnR5IHNjcmlwdCBpcyBhdHRlbXB0aW5nIHRvXG4gICAqIG11dGF0ZSB0aGUgVGV4dE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQ29tcG9zaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9fa2V5ID09PSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGluIFwic2VnZW1lbnRlZFwiIG1vZGUuIFRleHROb2RlcyBpbiBzZWdlbWVudGVkIG1vZGUgY2FuIGJlIG5hdmlnYXRlZCB0aHJvdWdoIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXJcbiAgICogd2l0aCBhIFJhbmdlU2VsZWN0aW9uLCBidXQgYXJlIGRlbGV0ZWQgaW4gc3BhY2UtZGVsaW1pdGVkIFwic2VnbWVudHNcIi5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBpbiBzZWdtZW50ZWQgbW9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNTZWdtZW50ZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19tb2RlID09PSBJU19TRUdNRU5URUQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgXCJkaXJlY3Rpb25sZXNzXCIuIERpcmVjdGlvbmxlc3Mgbm9kZXMgZG9uJ3QgcmVzcGVjdCBjaGFuZ2VzIGJldHdlZW4gUlRMIGFuZCBMVFIgbW9kZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgZGlyZWN0aW9ubGVzcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNEaXJlY3Rpb25sZXNzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiAoc2VsZi5fX2RldGFpbCAmIElTX0RJUkVDVElPTkxFU1MpICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIHVubWVyZ2VhYmxlLiBJbiBzb21lIHNjZW5hcmlvcywgTGV4aWNhbCB0cmllcyB0byBtZXJnZVxuICAgKiBhZGphY2VudCBUZXh0Tm9kZXMgaW50byBhIHNpbmdsZSBUZXh0Tm9kZS4gSWYgYSBUZXh0Tm9kZSBpcyB1bm1lcmdlYWJsZSwgdGhpcyB3b24ndCBoYXBwZW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgdW5tZXJnZWFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzVW5tZXJnZWFibGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIChzZWxmLl9fZGV0YWlsICYgSVNfVU5NRVJHRUFCTEUpICE9PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaGFzIHRoZSBwcm92aWRlZCBmb3JtYXQgYXBwbGllZC4gVXNlIHRoaXMgd2l0aCB0aGUgaHVtYW4tcmVhZGFibGUgVGV4dEZvcm1hdFR5cGVcbiAgICogc3RyaW5nIHZhbHVlcyB0byBnZXQgdGhlIGZvcm1hdCBvZiBhIFRleHROb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSBUZXh0Rm9ybWF0VHlwZSB0byBjaGVjayBmb3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaGFzIHRoZSBwcm92aWRlZCBmb3JtYXQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuICh0aGlzLmdldEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBzaW1wbGUgdGV4dC4gU2ltcGxlIHRleHQgaXMgZGVmaW5lZCBhcyBhIFRleHROb2RlIHRoYXQgaGFzIHRoZSBzdHJpbmcgdHlwZSBcInRleHRcIlxuICAgKiAoaS5lLiwgbm90IGEgc3ViY2xhc3MpIGFuZCBoYXMgbm8gbW9kZSBhcHBsaWVkIHRvIGl0IChpLmUuLCBub3Qgc2VnbWVudGVkIG9yIHRva2VuKS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBzaW1wbGUgdGV4dCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNTaW1wbGVUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9fdHlwZSA9PT0gJ3RleHQnICYmIHRoaXMuX19tb2RlID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZSBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAqL1xuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3RleHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9ybWF0IGZsYWdzIGFwcGxpZWQgdG8gdGhlIG5vZGUgYXMgYSAzMi1iaXQgaW50ZWdlci5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBUZXh0Rm9ybWF0VHlwZXMgYXBwbGllZCB0byB0aGUgbm9kZS5cbiAgICovXG4gIGdldEZvcm1hdEZsYWdzKHR5cGUsIGFsaWduV2l0aEZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHNlbGYuX19mb3JtYXQ7XG4gICAgcmV0dXJuIHRvZ2dsZVRleHRGb3JtYXRUeXBlKGZvcm1hdCwgdHlwZSwgYWxpZ25XaXRoRm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0ZXh0IG5vZGUgc3VwcG9ydHMgZm9udCBzdHlsaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjYW5IYXZlRm9ybWF0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcsIGVkaXRvcikge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX19mb3JtYXQ7XG4gICAgY29uc3Qgb3V0ZXJUYWcgPSBnZXRFbGVtZW50T3V0ZXJUYWcodGhpcywgZm9ybWF0KTtcbiAgICBjb25zdCBpbm5lclRhZyA9IGdldEVsZW1lbnRJbm5lclRhZyh0aGlzLCBmb3JtYXQpO1xuICAgIGNvbnN0IHRhZyA9IG91dGVyVGFnID09PSBudWxsID8gaW5uZXJUYWcgOiBvdXRlclRhZztcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgbGV0IGlubmVyRE9NID0gZG9tO1xuICAgIGlmICh0aGlzLmhhc0Zvcm1hdCgnY29kZScpKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgfVxuICAgIGlmIChvdXRlclRhZyAhPT0gbnVsbCkge1xuICAgICAgaW5uZXJET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGlubmVyVGFnKTtcbiAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lckRPTSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjcmVhdGVUZXh0SW5uZXJET00oaW5uZXJET00sIHRoaXMsIGlubmVyVGFnLCBmb3JtYXQsIHRleHQsIGNvbmZpZyk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9fc3R5bGU7XG4gICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgbmV4dFRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjb25zdCBwcmV2Rm9ybWF0ID0gcHJldk5vZGUuX19mb3JtYXQ7XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IHRoaXMuX19mb3JtYXQ7XG4gICAgY29uc3QgcHJldk91dGVyVGFnID0gZ2V0RWxlbWVudE91dGVyVGFnKHRoaXMsIHByZXZGb3JtYXQpO1xuICAgIGNvbnN0IG5leHRPdXRlclRhZyA9IGdldEVsZW1lbnRPdXRlclRhZyh0aGlzLCBuZXh0Rm9ybWF0KTtcbiAgICBjb25zdCBwcmV2SW5uZXJUYWcgPSBnZXRFbGVtZW50SW5uZXJUYWcodGhpcywgcHJldkZvcm1hdCk7XG4gICAgY29uc3QgbmV4dElubmVyVGFnID0gZ2V0RWxlbWVudElubmVyVGFnKHRoaXMsIG5leHRGb3JtYXQpO1xuICAgIGNvbnN0IHByZXZUYWcgPSBwcmV2T3V0ZXJUYWcgPT09IG51bGwgPyBwcmV2SW5uZXJUYWcgOiBwcmV2T3V0ZXJUYWc7XG4gICAgY29uc3QgbmV4dFRhZyA9IG5leHRPdXRlclRhZyA9PT0gbnVsbCA/IG5leHRJbm5lclRhZyA6IG5leHRPdXRlclRhZztcbiAgICBpZiAocHJldlRhZyAhPT0gbmV4dFRhZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwcmV2T3V0ZXJUYWcgPT09IG5leHRPdXRlclRhZyAmJiBwcmV2SW5uZXJUYWcgIT09IG5leHRJbm5lclRhZykge1xuICAgICAgLy8gc2hvdWxkIGFsd2F5cyBiZSBhbiBlbGVtZW50XG4gICAgICBjb25zdCBwcmV2SW5uZXJET00gPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgIGlmIChwcmV2SW5uZXJET00gPT0gbnVsbCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYHVwZGF0ZURPTTogcHJldklubmVyRE9NIGlzIG51bGwgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRJbm5lckRPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dElubmVyVGFnKTtcbiAgICAgIGNyZWF0ZVRleHRJbm5lckRPTShuZXh0SW5uZXJET00sIHRoaXMsIG5leHRJbm5lclRhZywgbmV4dEZvcm1hdCwgbmV4dFRleHQsIGNvbmZpZyk7XG4gICAgICBkb20ucmVwbGFjZUNoaWxkKG5leHRJbm5lckRPTSwgcHJldklubmVyRE9NKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGlubmVyRE9NID0gZG9tO1xuICAgIGlmIChuZXh0T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmV2T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgICAgaW5uZXJET00gPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGlubmVyRE9NID09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgdXBkYXRlRE9NOiBpbm5lckRPTSBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZXRUZXh0Q29udGVudChuZXh0VGV4dCwgaW5uZXJET00sIHRoaXMpO1xuICAgIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lO1xuICAgIC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG4gICAgY29uc3QgdGV4dENsYXNzTmFtZXMgPSB0aGVtZS50ZXh0O1xuICAgIGlmICh0ZXh0Q2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkICYmIHByZXZGb3JtYXQgIT09IG5leHRGb3JtYXQpIHtcbiAgICAgIHNldFRleHRUaGVtZUNsYXNzTmFtZXMobmV4dElubmVyVGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBpbm5lckRPTSwgdGV4dENsYXNzTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2U3R5bGUgPSBwcmV2Tm9kZS5fX3N0eWxlO1xuICAgIGNvbnN0IG5leHRTdHlsZSA9IHRoaXMuX19zdHlsZTtcbiAgICBpZiAocHJldlN0eWxlICE9PSBuZXh0U3R5bGUpIHtcbiAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gbmV4dFN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJyN0ZXh0JzogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRUZXh0RE9NTm9kZSxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgYjogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEJyaW5nQXR0ZW50aW9uVG9FbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBjb2RlOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGVtOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGk6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgczogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzcGFuOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0U3BhbkVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHN0cm9uZzogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzdWI6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgc3VwOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHU6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoc2VyaWFsaXplZE5vZGUudGV4dCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpO1xuICAgIG5vZGUuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWROb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIFRoaXMgaW1wcm92ZXMgTGV4aWNhbCdzIGJhc2ljIHRleHQgb3V0cHV0IGluIGNvcHkrcGFzdGUgcGx1c1xuICAvLyBmb3IgaGVhZGxlc3MgbW9kZSB3aGVyZSBwZW9wbGUgbWlnaHQgdXNlIExleGljYWwgdG8gZ2VuZXJhdGVcbiAgLy8gSFRNTCBjb250ZW50IGFuZCBub3QgaGF2ZSB0aGUgYWJpbGl0eSB0byB1c2UgQ1NTIGNsYXNzZXMuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBsZXQge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoIShlbGVtZW50ICE9PSBudWxsICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGV4dE5vZGUgY3JlYXRlRE9NIHRvIGFsd2F5cyByZXR1cm4gYSBIVE1MRWxlbWVudGApO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHByb3Blcmx5IGFkZCBzdXBwb3J0IGZvciBtb3N0IGNsaWVudHMsXG4gICAgLy8gZXZlbiBpZiBpdCdzIHNlbWFudGljYWxseSBpbmNvcnJlY3QgdG8gaGF2ZSB0byByZXNvcnQgdG8gdXNpbmdcbiAgICAvLyA8Yj4sIDx1PiwgPHM+LCA8aT4gZWxlbWVudHMuXG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdib2xkJykpIHtcbiAgICAgIGVsZW1lbnQgPSB3cmFwRWxlbWVudFdpdGgoZWxlbWVudCwgJ2InKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdpdGFsaWMnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAnaScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAncycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3VuZGVybGluZScpKSB7XG4gICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICd1Jyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXRhaWw6IHRoaXMuZ2V0RGV0YWlsKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0KCksXG4gICAgICBtb2RlOiB0aGlzLmdldE1vZGUoKSxcbiAgICAgIHN0eWxlOiB0aGlzLmdldFN0eWxlKCksXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHRDb250ZW50KCksXG4gICAgICB0eXBlOiAndGV4dCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIC8vIE11dGF0b3JzXG4gIHNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgZm9ybWF0IHRvIHRoZSBwcm92aWRlZCBUZXh0Rm9ybWF0VHlwZSBvciAzMi1iaXQgaW50ZWdlci4gTm90ZSB0aGF0IHRoZSBUZXh0Rm9ybWF0VHlwZVxuICAgKiB2ZXJzaW9uIG9mIHRoZSBhcmd1bWVudCBjYW4gb25seSBzcGVjaWZ5IG9uZSBmb3JtYXQgYW5kIGRvaW5nIHNvIHdpbGwgcmVtb3ZlIGFsbCBvdGhlciBmb3JtYXRzIHRoYXRcbiAgICogbWF5IGJlIGFwcGxpZWQgdG8gdGhlIG5vZGUuIEZvciB0b2dnbGluZyBiZWhhdmlvciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIFRleHROb2RlLnRvZ2dsZUZvcm1hdH1cbiAgICpcbiAgICogQHBhcmFtIGZvcm1hdCAtIFRleHRGb3JtYXRUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbm9kZSBmb3JtYXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqIC8vIFRPRE8gMC4xMiBUaGlzIHNob3VsZCBqdXN0IGJlIGEgYHN0cmluZ2AuXG4gICAqL1xuICBzZXRGb3JtYXQoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZm9ybWF0ID0gdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycgPyBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF0gOiBmb3JtYXQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbm9kZSBkZXRhaWwgdG8gdGhlIHByb3ZpZGVkIFRleHREZXRhaWxUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyLiBOb3RlIHRoYXQgdGhlIFRleHREZXRhaWxUeXBlXG4gICAqIHZlcnNpb24gb2YgdGhlIGFyZ3VtZW50IGNhbiBvbmx5IHNwZWNpZnkgb25lIGRldGFpbCB2YWx1ZSBhbmQgZG9pbmcgc28gd2lsbCByZW1vdmUgYWxsIG90aGVyIGRldGFpbCB2YWx1ZXMgdGhhdFxuICAgKiBtYXkgYmUgYXBwbGllZCB0byB0aGUgbm9kZS4gRm9yIHRvZ2dsaW5nIGJlaGF2aW9yLCBjb25zaWRlciB1c2luZyB7QGxpbmsgVGV4dE5vZGUudG9nZ2xlRGlyZWN0aW9ubGVzc31cbiAgICogb3Ige0BsaW5rIFRleHROb2RlLnRvZ2dsZVVubWVyZ2VhYmxlfVxuICAgKlxuICAgKiBAcGFyYW0gZGV0YWlsIC0gVGV4dERldGFpbFR5cGUgb3IgMzItYml0IGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBub2RlIGRldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICogLy8gVE9ETyAwLjEyIFRoaXMgc2hvdWxkIGp1c3QgYmUgYSBgc3RyaW5nYC5cbiAgICovXG4gIHNldERldGFpbChkZXRhaWwpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgPSB0eXBlb2YgZGV0YWlsID09PSAnc3RyaW5nJyA/IERFVEFJTF9UWVBFX1RPX0RFVEFJTFtkZXRhaWxdIDogZGV0YWlsO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgc3R5bGUgdG8gdGhlIHByb3ZpZGVkIENTU1RleHQtbGlrZSBzdHJpbmcuIFNldCB0aGlzIHByb3BlcnR5IGFzIHlvdVxuICAgKiB3b3VsZCBhbiBIVE1MRWxlbWVudCBzdHlsZSBhdHRyaWJ1dGUgdG8gYXBwbHkgaW5saW5lIHN0eWxlcyB0byB0aGUgdW5kZXJseWluZyBET00gRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlIC0gQ1NTVGV4dCB0byBiZSBhcHBsaWVkIHRvIHRoZSB1bmRlcmx5aW5nIEhUTUxFbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19zdHlsZSA9IHN0eWxlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGZvcm1hdCB0byB0aGlzIFRleHROb2RlIGlmIGl0J3Mgbm90IHByZXNlbnQuIFJlbW92ZXMgaXQgaWYgaXQncyBwcmVzZW50LlxuICAgKiBUaGUgc3Vic2NyaXB0IGFuZCBzdXBlcnNjcmlwdCBmb3JtYXRzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAqIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCB0byB0dXJuIHNwZWNpZmljIGZvcm1hdHMgb24gYW5kIG9mZi5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBUZXh0Rm9ybWF0VHlwZSB0byB0b2dnbGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICB0b2dnbGVGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0Rm9ybWF0KCk7XG4gICAgY29uc3QgbmV3Rm9ybWF0ID0gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBudWxsKTtcbiAgICByZXR1cm4gdGhpcy5zZXRGb3JtYXQobmV3Rm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBkaXJlY3Rpb25sZXNzIGRldGFpbCB2YWx1ZSBvZiB0aGUgbm9kZS4gUHJlZmVyIHVzaW5nIHRoaXMgbWV0aG9kIG92ZXIgc2V0RGV0YWlsLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgdG9nZ2xlRGlyZWN0aW9ubGVzcygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgXj0gSVNfRElSRUNUSU9OTEVTUztcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSB1bm1lcmdlYWJsZSBkZXRhaWwgdmFsdWUgb2YgdGhlIG5vZGUuIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCBvdmVyIHNldERldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHRvZ2dsZVVubWVyZ2VhYmxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2RldGFpbCBePSBJU19VTk1FUkdFQUJMRTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtb2RlIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgc2V0TW9kZSh0eXBlKSB7XG4gICAgY29uc3QgbW9kZSA9IFRFWFRfTU9ERV9UT19UWVBFW3R5cGVdO1xuICAgIGlmICh0aGlzLl9fbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX21vZGUgPSBtb2RlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgLSB0aGUgc3RyaW5nIHRvIHNldCBhcyB0aGUgdGV4dCB2YWx1ZSBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNldFRleHRDb250ZW50KHRleHQpIHtcbiAgICBpZiAodGhpcy5fX3RleHQgPT09IHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX190ZXh0ID0gdGV4dDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IExleGljYWwgc2VsZWN0aW9uIHRvIGJlIGEgUmFuZ2VTZWxlY3Rpb24gd2l0aCBhbmNob3IgYW5kIGZvY3VzIG9uIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBfYW5jaG9yT2Zmc2V0IC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgU2VsZWN0aW9uIGFuY2hvciB3aWxsIGJlIHBsYWNlZC5cbiAgICogQHBhcmFtIF9mb2N1c09mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIFNlbGVjdGlvbiBmb2N1cyB3aWxsIGJlIHBsYWNlZC5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5ldyBSYW5nZVNlbGVjdGlvbi5cbiAgICovXG4gIHNlbGVjdChfYW5jaG9yT2Zmc2V0LCBfZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChmb2N1c09mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gbGFzdE9mZnNldDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgIGZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gJGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGtleSwgYW5jaG9yT2Zmc2V0LCBrZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcsICd0ZXh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IHNlbGVjdGlvbi5hbmNob3Iua2V5IHx8IGNvbXBvc2l0aW9uS2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgICAgfVxuICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UodGhpcywgYW5jaG9yT2Zmc2V0LCB0aGlzLCBmb2N1c09mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KDAsIDApO1xuICB9XG4gIHNlbGVjdEVuZCgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2l6ZSwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyB0aGUgcHJvdmlkZWQgdGV4dCBpbnRvIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIG9mZnNldCwgZGVsZXRpbmcgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAqIHNwZWNpZmllZC4gQ2FuIG9wdGlvbmFsbHkgY2FsY3VsYXRlIGEgbmV3IHNlbGVjdGlvbiBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgc3BsaWNlIG9wZXJhdGlvbiBzaG91bGQgYmVnaW4uXG4gICAqIEBwYXJhbSBkZWxDb3VudCAtIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBkZWxldGUsIHN0YXJ0aW5nIGZyb20gdGhlIG9mZnNldC5cbiAgICogQHBhcmFtIG5ld1RleHQgLSB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgVGV4dE5vZGUgYXQgdGhlIG9mZnNldC5cbiAgICogQHBhcmFtIG1vdmVTZWxlY3Rpb24gLSBvcHRpb25hbCwgd2hldGhlciBvciBub3QgdG8gbW92ZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgaW5zZXJ0ZWQgc3Vic3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgc3BsaWNlVGV4dChvZmZzZXQsIGRlbENvdW50LCBuZXdUZXh0LCBtb3ZlU2VsZWN0aW9uKSB7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHRleHQgPSB3cml0YWJsZVNlbGYuX190ZXh0O1xuICAgIGNvbnN0IGhhbmRsZWRUZXh0TGVuZ3RoID0gbmV3VGV4dC5sZW5ndGg7XG4gICAgbGV0IGluZGV4ID0gb2Zmc2V0O1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gaGFuZGxlZFRleHRMZW5ndGggKyBpbmRleDtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKG1vdmVTZWxlY3Rpb24gJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgaGFuZGxlZFRleHRMZW5ndGg7XG4gICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZSh3cml0YWJsZVNlbGYsIG5ld09mZnNldCwgd3JpdGFibGVTZWxmLCBuZXdPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkVGV4dCA9IHRleHQuc2xpY2UoMCwgaW5kZXgpICsgbmV3VGV4dCArIHRleHQuc2xpY2UoaW5kZXggKyBkZWxDb3VudCk7XG4gICAgd3JpdGFibGVTZWxmLl9fdGV4dCA9IHVwZGF0ZWRUZXh0O1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiBhIHVzZXIgZXZlbnQgd291bGQgY2F1c2UgdGV4dCB0byBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlbSBpbiB0aGUgZWRpdG9yLiBJZiB0cnVlLCBMZXhpY2FsIHdpbGwgYXR0ZW1wdFxuICAgKiB0byBpbnNlcnQgdGV4dCBpbnRvIHRoaXMgbm9kZS4gSWYgZmFsc2UsIGl0IHdpbGwgaW5zZXJ0IHRoZSB0ZXh0IGluIGEgbmV3IHNpYmxpbmcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0ZXh0IGNhbiBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiBhIHVzZXIgZXZlbnQgd291bGQgY2F1c2UgdGV4dCB0byBiZSBpbnNlcnRlZCBhZnRlciB0aGVtIGluIHRoZSBlZGl0b3IuIElmIHRydWUsIExleGljYWwgd2lsbCBhdHRlbXB0XG4gICAqIHRvIGluc2VydCB0ZXh0IGludG8gdGhpcyBub2RlLiBJZiBmYWxzZSwgaXQgd2lsbCBpbnNlcnQgdGhlIHRleHQgaW4gYSBuZXcgc2libGluZyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRleHQgY2FuIGJlIGluc2VydGVkIGFmdGVyIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIGNoYXJhY3RlciBvZmZzZXRzLCBmb3JtaW5nIG5ldyBUZXh0Tm9kZXMgZnJvbSB0aGUgc3Vic3RyaW5nc1xuICAgKiBmb3JtZWQgYnkgdGhlIHNwbGl0LCBhbmQgaW5zZXJ0aW5nIHRob3NlIG5ldyBUZXh0Tm9kZXMgaW50byB0aGUgZWRpdG9yLCByZXBsYWNpbmcgdGhlIG9uZSB0aGF0IHdhcyBzcGxpdC5cbiAgICpcbiAgICogQHBhcmFtIHNwbGl0T2Zmc2V0cyAtIHJlc3QgcGFyYW0gb2YgdGhlIHRleHQgY29udGVudCBjaGFyYWN0ZXIgb2Zmc2V0cyBhdCB3aGljaCB0aGlzIG5vZGUgc2hvdWxkIGJlIHNwbGl0LlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIHRoZSBuZXdseS1jcmVhdGVkIFRleHROb2Rlcy5cbiAgICovXG4gIHNwbGl0VGV4dCguLi5zcGxpdE9mZnNldHMpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IHNlbGYuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBrZXkgPSBzZWxmLl9fa2V5O1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgY29uc3Qgb2Zmc2V0c1NldCA9IG5ldyBTZXQoc3BsaXRPZmZzZXRzKTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dExlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nICE9PSAnJyAmJiBvZmZzZXRzU2V0LmhhcyhpKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHN0cmluZyk7XG4gICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc3RyaW5nICs9IHRleHRDb250ZW50W2ldO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nICE9PSAnJykge1xuICAgICAgcGFydHMucHVzaChzdHJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgICBpZiAocGFydHNMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSB0ZXh0Q29udGVudCkge1xuICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHNbMF07XG4gICAgY29uc3QgcGFyZW50ID0gc2VsZi5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IHdyaXRhYmxlTm9kZTtcbiAgICBjb25zdCBmb3JtYXQgPSBzZWxmLmdldEZvcm1hdCgpO1xuICAgIGNvbnN0IHN0eWxlID0gc2VsZi5nZXRTdHlsZSgpO1xuICAgIGNvbnN0IGRldGFpbCA9IHNlbGYuX19kZXRhaWw7XG4gICAgbGV0IGhhc1JlcGxhY2VkU2VsZiA9IGZhbHNlO1xuICAgIGlmIChzZWxmLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBUZXh0Tm9kZVxuICAgICAgd3JpdGFibGVOb2RlID0gJGNyZWF0ZVRleHROb2RlKGZpcnN0UGFydCk7XG4gICAgICB3cml0YWJsZU5vZGUuX19mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICB3cml0YWJsZU5vZGUuX19zdHlsZSA9IHN0eWxlO1xuICAgICAgd3JpdGFibGVOb2RlLl9fZGV0YWlsID0gZGV0YWlsO1xuICAgICAgaGFzUmVwbGFjZWRTZWxmID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIHRoZSBmaXJzdCBwYXJ0LCB1cGRhdGUgdGhlIGV4aXN0aW5nIG5vZGVcbiAgICAgIHdyaXRhYmxlTm9kZSA9IHNlbGYuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX3RleHQgPSBmaXJzdFBhcnQ7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHNlbGVjdGlvblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIFRoZW4gaGFuZGxlIGFsbCBvdGhlciBwYXJ0c1xuICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBbd3JpdGFibGVOb2RlXTtcbiAgICBsZXQgdGV4dFNpemUgPSBmaXJzdFBhcnQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgcGFydFNpemUgPSBwYXJ0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUocGFydCkuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHNpYmxpbmcuX19mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICBzaWJsaW5nLl9fc3R5bGUgPSBzdHlsZTtcbiAgICAgIHNpYmxpbmcuX19kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBjb25zdCBzaWJsaW5nS2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgIGNvbnN0IG5leHRUZXh0U2l6ZSA9IHRleHRTaXplICsgcGFydFNpemU7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSAmJiBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvci5vZmZzZXQgPiB0ZXh0U2l6ZSAmJiBhbmNob3Iub2Zmc2V0IDw9IG5leHRUZXh0U2l6ZSkge1xuICAgICAgICAgIGFuY2hvci5rZXkgPSBzaWJsaW5nS2V5O1xuICAgICAgICAgIGFuY2hvci5vZmZzZXQgLT0gdGV4dFNpemU7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXMua2V5ID09PSBrZXkgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnICYmIGZvY3VzLm9mZnNldCA+IHRleHRTaXplICYmIGZvY3VzLm9mZnNldCA8PSBuZXh0VGV4dFNpemUpIHtcbiAgICAgICAgICBmb2N1cy5rZXkgPSBzaWJsaW5nS2V5O1xuICAgICAgICAgIGZvY3VzLm9mZnNldCAtPSB0ZXh0U2l6ZTtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IGtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoc2libGluZ0tleSk7XG4gICAgICB9XG4gICAgICB0ZXh0U2l6ZSA9IG5leHRUZXh0U2l6ZTtcbiAgICAgIHNwbGl0Tm9kZXMucHVzaChzaWJsaW5nKTtcbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGVzIGludG8gdGhlIHBhcmVudCdzIGNoaWxkcmVuXG4gICAgaW50ZXJuYWxNYXJrU2libGluZ3NBc0RpcnR5KHRoaXMpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gcGFyZW50LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgaWYgKGhhc1JlcGxhY2VkU2VsZikge1xuICAgICAgd3JpdGFibGVQYXJlbnQuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCBzcGxpdE5vZGVzKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50LnNwbGljZShpbnNlcnRpb25JbmRleCwgMSwgc3BsaXROb2Rlcyk7XG4gICAgfVxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAkdXBkYXRlRWxlbWVudFNlbGVjdGlvbk9uQ3JlYXRlRGVsZXRlTm9kZShzZWxlY3Rpb24sIHBhcmVudCwgaW5zZXJ0aW9uSW5kZXgsIHBhcnRzTGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBzcGxpdE5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgdGFyZ2V0IFRleHROb2RlIGludG8gdGhpcyBUZXh0Tm9kZSwgcmVtb3ZpbmcgdGhlIHRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gdGhlIFRleHROb2RlIHRvIG1lcmdlIGludG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICBtZXJnZVdpdGhTaWJsaW5nKHRhcmdldCkge1xuICAgIGNvbnN0IGlzQmVmb3JlID0gdGFyZ2V0ID09PSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmICghaXNCZWZvcmUgJiYgdGFyZ2V0ICE9PSB0aGlzLmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG1lcmdlV2l0aFNpYmxpbmc6IHNpYmxpbmcgbXVzdCBiZSBhIHByZXZpb3VzIG9yIG5leHQgc2libGluZ2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRhcmdldC5fX2tleTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5fX3RleHQ7XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgaWYgKGNvbXBvc2l0aW9uS2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgIGlmIChhbmNob3IgIT09IG51bGwgJiYgYW5jaG9yLmtleSA9PT0gdGFyZ2V0S2V5KSB7XG4gICAgICAgIGFkanVzdFBvaW50T2Zmc2V0Rm9yTWVyZ2VkU2libGluZyhhbmNob3IsIGlzQmVmb3JlLCBrZXksIHRhcmdldCwgdGV4dExlbmd0aCk7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZm9jdXMgIT09IG51bGwgJiYgZm9jdXMua2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICAgYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKGZvY3VzLCBpc0JlZm9yZSwga2V5LCB0YXJnZXQsIHRleHRMZW5ndGgpO1xuICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRUZXh0ID0gdGFyZ2V0Ll9fdGV4dDtcbiAgICBjb25zdCBuZXdUZXh0ID0gaXNCZWZvcmUgPyB0YXJnZXRUZXh0ICsgdGV4dCA6IHRleHQgKyB0YXJnZXRUZXh0O1xuICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV3VGV4dCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiBieSBUZXh0Tm9kZSBzdWJjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRob3NlIG5vZGVzXG4gICAqIHdoZW4gdXNlZCB3aXRoIHRoZSByZWdpc3RlckxleGljYWxUZXh0RW50aXR5IGZ1bmN0aW9uLiBJZiB5b3UncmUgdXNpbmcgcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSwgdGhlXG4gICAqIG5vZGUgY2xhc3MgdGhhdCB5b3UgY3JlYXRlIGFuZCByZXBsYWNlIG1hdGNoZWQgdGV4dCB3aXRoIHNob3VsZCByZXR1cm4gdHJ1ZSBmcm9tIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHRvIGJlIHRyZWF0ZWQgYXMgYSBcInRleHQgZW50aXR5XCIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzVGV4dEVudGl0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTcGFuRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8c3Bhbj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBzcGFuID0gZG9tTm9kZTtcbiAgY29uc3Qgc3R5bGUgPSBzcGFuLnN0eWxlO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoc3R5bGUpLFxuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCcmluZ0F0dGVudGlvblRvRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8Yj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBiID0gZG9tTm9kZTtcbiAgLy8gR29vZ2xlIERvY3Mgd3JhcHMgYWxsIGNvcGllZCBIVE1MIGluIGEgPGI+IHdpdGggZm9udC13ZWlnaHQgbm9ybWFsXG4gIGNvbnN0IGhhc05vcm1hbEZvbnRXZWlnaHQgPSBiLnN0eWxlLmZvbnRXZWlnaHQgPT09ICdub3JtYWwnO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoYi5zdHlsZSwgaGFzTm9ybWFsRm9udFdlaWdodCA/IHVuZGVmaW5lZCA6ICdib2xkJyksXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuY29uc3QgcHJlUGFyZW50Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaXNOb2RlUHJlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdQUkUnIHx8IG5vZGUubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUgJiYgbm9kZS5zdHlsZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuc3R5bGUud2hpdGVTcGFjZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuc3R5bGUud2hpdGVTcGFjZS5zdGFydHNXaXRoKCdwcmUnKTtcbn1cbmZ1bmN0aW9uIGZpbmRQYXJlbnRQcmVET01Ob2RlKG5vZGUpIHtcbiAgbGV0IGNhY2hlZDtcbiAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgY29uc3QgdmlzaXRlZCA9IFtub2RlXTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiAoY2FjaGVkID0gcHJlUGFyZW50Q2FjaGUuZ2V0KHBhcmVudCkpID09PSB1bmRlZmluZWQgJiYgIWlzTm9kZVByZShwYXJlbnQpKSB7XG4gICAgdmlzaXRlZC5wdXNoKHBhcmVudCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgY29uc3QgcmVzdWx0Tm9kZSA9IGNhY2hlZCA9PT0gdW5kZWZpbmVkID8gcGFyZW50IDogY2FjaGVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBwcmVQYXJlbnRDYWNoZS5zZXQodmlzaXRlZFtpXSwgcmVzdWx0Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiAkY29udmVydFRleHRET01Ob2RlKGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBjb25zdCBwYXJlbnREb20gPSBkb21Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gIGlmICghKHBhcmVudERvbSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgcGFyZW50RWxlbWVudCBvZiBUZXh0IG5vdCB0byBiZSBudWxsYCk7XG4gIH1cbiAgbGV0IHRleHRDb250ZW50ID0gZG9tTm9kZV8udGV4dENvbnRlbnQgfHwgJyc7XG4gIC8vIE5vIGNvbGxhcHNlIGFuZCBwcmVzZXJ2ZSBzZWdtZW50IGJyZWFrIGZvciBwcmUsIHByZS13cmFwIGFuZCBwcmUtbGluZVxuICBpZiAoZmluZFBhcmVudFByZURPTU5vZGUoZG9tTm9kZV8pICE9PSBudWxsKSB7XG4gICAgY29uc3QgcGFydHMgPSB0ZXh0Q29udGVudC5zcGxpdCgvKFxccj9cXG58XFx0KS8pO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ICE9PSAnJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUZXh0Tm9kZShwYXJ0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2Rlc1xuICAgIH07XG4gIH1cbiAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9cXHIvZywgJycpLnJlcGxhY2UoL1sgXFx0XFxuXSsvZywgJyAnKTtcbiAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuICBpZiAodGV4dENvbnRlbnRbMF0gPT09ICcgJykge1xuICAgIC8vIFRyYXZlcnNlIGJhY2t3YXJkIHdoaWxlIGluIHRoZSBzYW1lIGxpbmUuIElmIGNvbnRlbnQgY29udGFpbnMgbmV3IGxpbmUgb3IgdGFiIC0+IHBvbnRlbnRpYWxcbiAgICAvLyBkZWxldGUsIG90aGVyIGVsZW1lbnRzIGNhbiBib3Jyb3cgZnJvbSB0aGlzIG9uZS4gRGVsZXRpb24gZGVwZW5kcyBvbiB3aGV0aGVyIGl0J3MgYWxzbyB0aGVcbiAgICAvLyBsYXN0IHNwYWNlIChzZWUgbmV4dCBjb25kaXRpb246IHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSAnICcpKVxuICAgIGxldCBwcmV2aW91c1RleHQgPSBkb21Ob2RlXztcbiAgICBsZXQgaXNTdGFydE9mTGluZSA9IHRydWU7XG4gICAgd2hpbGUgKHByZXZpb3VzVGV4dCAhPT0gbnVsbCAmJiAocHJldmlvdXNUZXh0ID0gZmluZFRleHRJbkxpbmUocHJldmlvdXNUZXh0LCBmYWxzZSkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1RleHRDb250ZW50ID0gcHJldmlvdXNUZXh0LnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgaWYgKHByZXZpb3VzVGV4dENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoL1sgXFx0XFxuXSQvLnRlc3QocHJldmlvdXNUZXh0Q29udGVudCkpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlzU3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1N0YXJ0T2ZMaW5lKSB7XG4gICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuICBpZiAodGV4dENvbnRlbnRbdGV4dENvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgIC8vIFRyYXZlcnNlIGZvcndhcmQgd2hpbGUgaW4gdGhlIHNhbWUgbGluZSwgcHJlc2VydmUgaWYgbmV4dCBpbmxpbmUgd2lsbCByZXF1aXJlIGEgc3BhY2VcbiAgICBsZXQgbmV4dFRleHQgPSBkb21Ob2RlXztcbiAgICBsZXQgaXNFbmRPZkxpbmUgPSB0cnVlO1xuICAgIHdoaWxlIChuZXh0VGV4dCAhPT0gbnVsbCAmJiAobmV4dFRleHQgPSBmaW5kVGV4dEluTGluZShuZXh0VGV4dCwgdHJ1ZSkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBuZXh0VGV4dENvbnRlbnQgPSAobmV4dFRleHQudGV4dENvbnRlbnQgfHwgJycpLnJlcGxhY2UoL14oIHxcXHR8XFxyP1xcbikrLywgJycpO1xuICAgICAgaWYgKG5leHRUZXh0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzRW5kT2ZMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNFbmRPZkxpbmUpIHtcbiAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgdGV4dENvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlVGV4dE5vZGUodGV4dENvbnRlbnQpXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kVGV4dEluTGluZSh0ZXh0LCBmb3J3YXJkKSB7XG4gIGxldCBub2RlID0gdGV4dDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBzaWJsaW5nO1xuICAgIHdoaWxlICgoc2libGluZyA9IGZvcndhcmQgPyBub2RlLm5leHRTaWJsaW5nIDogbm9kZS5wcmV2aW91c1NpYmxpbmcpID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKHBhcmVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIGNvbnN0IGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAoZGlzcGxheSA9PT0gJycgJiYgIWlzSW5saW5lRG9tTm9kZShub2RlKSB8fCBkaXNwbGF5ICE9PSAnJyAmJiAhZGlzcGxheS5zdGFydHNXaXRoKCdpbmxpbmUnKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRlc2NlbmRhbnQgPSBub2RlO1xuICAgIHdoaWxlICgoZGVzY2VuZGFudCA9IGZvcndhcmQgPyBub2RlLmZpcnN0Q2hpbGQgOiBub2RlLmxhc3RDaGlsZCkgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBkZXNjZW5kYW50O1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IG5vZGVOYW1lVG9UZXh0Rm9ybWF0ID0ge1xuICBjb2RlOiAnY29kZScsXG4gIGVtOiAnaXRhbGljJyxcbiAgaTogJ2l0YWxpYycsXG4gIHM6ICdzdHJpa2V0aHJvdWdoJyxcbiAgc3Ryb25nOiAnYm9sZCcsXG4gIHN1YjogJ3N1YnNjcmlwdCcsXG4gIHN1cDogJ3N1cGVyc2NyaXB0JyxcbiAgdTogJ3VuZGVybGluZSdcbn07XG5mdW5jdGlvbiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBmb3JtYXQgPSBub2RlTmFtZVRvVGV4dEZvcm1hdFtkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JDaGlsZDogYXBwbHlUZXh0Rm9ybWF0RnJvbVN0eWxlKGRvbU5vZGUuc3R5bGUsIGZvcm1hdCksXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRleHROb2RlKHRleHQgPSAnJykge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUZXh0Tm9kZSh0ZXh0KSk7XG59XG5mdW5jdGlvbiAkaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dE5vZGU7XG59XG5mdW5jdGlvbiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoc3R5bGUsIHNob3VsZEFwcGx5KSB7XG4gIGNvbnN0IGZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0O1xuICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IHN0eWxlLnRleHREZWNvcmF0aW9uLnNwbGl0KCcgJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgZm9udC13ZWlnaHQgZm9yIGJvbGQgdGV4dFxuICBjb25zdCBoYXNCb2xkRm9udFdlaWdodCA9IGZvbnRXZWlnaHQgPT09ICc3MDAnIHx8IGZvbnRXZWlnaHQgPT09ICdib2xkJztcbiAgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaCBmb3Igc3RyaWtldGhyb3VnaCB0ZXh0XG4gIGNvbnN0IGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygnbGluZS10aHJvdWdoJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgZm9udC1zdHlsZSBmb3IgaXRhbGljIHRleHRcbiAgY29uc3QgaGFzSXRhbGljRm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJztcbiAgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBmb3IgdW5kZXJsaW5lIHRleHRcbiAgY29uc3QgaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygndW5kZXJsaW5lJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgdmVydGljYWwtYWxpZ24gdG8gc3BlY2lmeSBzdWJzY3JpcHQgYW5kIHN1cGVyc2NyaXB0XG4gIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBzdHlsZS52ZXJ0aWNhbEFsaWduO1xuICByZXR1cm4gbGV4aWNhbE5vZGUgPT4ge1xuICAgIGlmICghJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgfVxuICAgIGlmIChoYXNCb2xkRm9udFdlaWdodCAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdib2xkJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnYm9sZCcpO1xuICAgIH1cbiAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbiAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdzdHJpa2V0aHJvdWdoJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3RyaWtldGhyb3VnaCcpO1xuICAgIH1cbiAgICBpZiAoaGFzSXRhbGljRm9udFN0eWxlICYmICFsZXhpY2FsTm9kZS5oYXNGb3JtYXQoJ2l0YWxpYycpKSB7XG4gICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2l0YWxpYycpO1xuICAgIH1cbiAgICBpZiAoaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgndW5kZXJsaW5lJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgndW5kZXJsaW5lJyk7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnc3ViJyAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdzdWJzY3JpcHQnKSkge1xuICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdWJzY3JpcHQnKTtcbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICdzdXBlcicgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgnc3VwZXJzY3JpcHQnKSkge1xuICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdXBlcnNjcmlwdCcpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQXBwbHkgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdChzaG91bGRBcHBseSkpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdChzaG91bGRBcHBseSk7XG4gICAgfVxuICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFiTm9kZSBleHRlbmRzIFRleHROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWInO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBUYWJOb2RlKG5vZGUuX19rZXkpO1xuICAgIC8vIFRhYk5vZGUgX190ZXh0IGNhbiBiZSBlaXRoZXIgJ1xcdCcgb3IgJycuIGluc2VydFRleHQgd2lsbCByZW1vdmUgdGhlIGVtcHR5IE5vZGVcbiAgICBuZXdOb2RlLl9fdGV4dCA9IG5vZGUuX190ZXh0O1xuICAgIG5ld05vZGUuX19mb3JtYXQgPSBub2RlLl9fZm9ybWF0O1xuICAgIG5ld05vZGUuX19zdHlsZSA9IG5vZGUuX19zdHlsZTtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcignXFx0Jywga2V5KTtcbiAgICB0aGlzLl9fZGV0YWlsID0gSVNfVU5NRVJHRUFCTEU7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkVGFiTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlVGFiTm9kZSgpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWRUYWJOb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRTdHlsZShzZXJpYWxpemVkVGFiTm9kZS5zdHlsZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3RhYicsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuICBzZXRUZXh0Q29udGVudChfdGV4dCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBUYWJOb2RlIGRvZXMgbm90IHN1cHBvcnQgc2V0VGV4dENvbnRlbnRgKTtcbiAgICB9XG4gIH1cbiAgc2V0RGV0YWlsKF9kZXRhaWwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVGFiTm9kZSBkb2VzIG5vdCBzdXBwb3J0IHNldERldGFpbGApO1xuICAgIH1cbiAgfVxuICBzZXRNb2RlKF90eXBlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFRhYk5vZGUgZG9lcyBub3Qgc3VwcG9ydCBzZXRNb2RlYCk7XG4gICAgfVxuICB9XG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzVGFiTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFiTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jbGFzcyBQb2ludCB7XG4gIGNvbnN0cnVjdG9yKGtleSwgb2Zmc2V0LCB0eXBlKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ID09PSBwb2ludC5rZXkgJiYgdGhpcy5vZmZzZXQgPT09IHBvaW50Lm9mZnNldCAmJiB0aGlzLnR5cGUgPT09IHBvaW50LnR5cGU7XG4gIH1cbiAgaXNCZWZvcmUoYikge1xuICAgIGxldCBhTm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIGxldCBiTm9kZSA9IGIuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGFPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICBjb25zdCBiT2Zmc2V0ID0gYi5vZmZzZXQ7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGFOb2RlKSkge1xuICAgICAgY29uc3QgYU5vZGVEZXNjZW5kYW50ID0gYU5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYU9mZnNldCk7XG4gICAgICBhTm9kZSA9IGFOb2RlRGVzY2VuZGFudCAhPSBudWxsID8gYU5vZGVEZXNjZW5kYW50IDogYU5vZGU7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShiTm9kZSkpIHtcbiAgICAgIGNvbnN0IGJOb2RlRGVzY2VuZGFudCA9IGJOb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGJPZmZzZXQpO1xuICAgICAgYk5vZGUgPSBiTm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGJOb2RlRGVzY2VuZGFudCA6IGJOb2RlO1xuICAgIH1cbiAgICBpZiAoYU5vZGUgPT09IGJOb2RlKSB7XG4gICAgICByZXR1cm4gYU9mZnNldCA8IGJPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBhTm9kZS5pc0JlZm9yZShiTm9kZSk7XG4gIH1cbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleTtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBQb2ludC5nZXROb2RlOiBub2RlIG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBzZXQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG4gICAgY29uc3Qgb2xkS2V5ID0gdGhpcy5rZXk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIGlmICgkZ2V0Q29tcG9zaXRpb25LZXkoKSA9PT0gb2xkS2V5KSB7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3Rpb24uc2V0Q2FjaGVkTm9kZXMobnVsbCk7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlUG9pbnQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxseSBjYXN0IGFzIHdlIHVzZSBhIGNsYXNzIGZvciBwZXJmIHJlYXNvbnNcbiAgcmV0dXJuIG5ldyBQb2ludChrZXksIG9mZnNldCwgdHlwZSk7XG59XG5mdW5jdGlvbiBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSkge1xuICBsZXQga2V5ID0gbm9kZS5fX2tleTtcbiAgbGV0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgbGV0IHR5cGUgPSAnZWxlbWVudCc7XG4gIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIHR5cGUgPSAndGV4dCc7XG4gICAgY29uc3QgdGV4dENvbnRlbnRMZW5ndGggPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgIGlmIChvZmZzZXQgPiB0ZXh0Q29udGVudExlbmd0aCkge1xuICAgICAgb2Zmc2V0ID0gdGV4dENvbnRlbnRMZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGtleSA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAga2V5ID0gcGFyZW50Tm9kZS5fX2tleTtcbiAgICAgICAgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcG9pbnQuc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbn1cbmZ1bmN0aW9uICRtb3ZlU2VsZWN0aW9uUG9pbnRUb0VuZChwb2ludCwgbm9kZSkge1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpIHx8ICRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgc2VsZWN0UG9pbnRPbk5vZGUocG9pbnQsIGxhc3ROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0UG9pbnRPbk5vZGUocG9pbnQsIG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICR0cmFuc2ZlclN0YXJ0aW5nRWxlbWVudFBvaW50VG9UZXh0UG9pbnQoc3RhcnQsIGVuZCwgZm9ybWF0LCBzdHlsZSkge1xuICBjb25zdCBlbGVtZW50ID0gc3RhcnQuZ2V0Tm9kZSgpO1xuICBjb25zdCBwbGFjZW1lbnROb2RlID0gZWxlbWVudC5nZXRDaGlsZEF0SW5kZXgoc3RhcnQub2Zmc2V0KTtcbiAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgY29uc3QgdGFyZ2V0ID0gJGlzUm9vdE5vZGUoZWxlbWVudCkgPyAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLmFwcGVuZCh0ZXh0Tm9kZSkgOiB0ZXh0Tm9kZTtcbiAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgaWYgKHBsYWNlbWVudE5vZGUgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LmFwcGVuZCh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHBsYWNlbWVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhcmdldCk7XG4gIH1cbiAgLy8gVHJhbnNmZXIgdGhlIGVsZW1lbnQgcG9pbnQgdG8gYSB0ZXh0IHBvaW50LlxuICBpZiAoc3RhcnQuaXMoZW5kKSkge1xuICAgIGVuZC5zZXQodGV4dE5vZGUuX19rZXksIDAsICd0ZXh0Jyk7XG4gIH1cbiAgc3RhcnQuc2V0KHRleHROb2RlLl9fa2V5LCAwLCAndGV4dCcpO1xufVxuZnVuY3Rpb24gJHNldFBvaW50VmFsdWVzKHBvaW50LCBrZXksIG9mZnNldCwgdHlwZSkge1xuICBwb2ludC5rZXkgPSBrZXk7XG4gIHBvaW50Lm9mZnNldCA9IG9mZnNldDtcbiAgcG9pbnQudHlwZSA9IHR5cGU7XG59XG5jbGFzcyBOb2RlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0cykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLl9ub2RlcyA9IG9iamVjdHM7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG4gIGdldENhY2hlZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWROb2RlcztcbiAgfVxuICBzZXRDYWNoZWROb2Rlcyhub2Rlcykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gIH1cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHRoaXMuX25vZGVzO1xuICAgIGNvbnN0IGIgPSBzZWxlY3Rpb24uX25vZGVzO1xuICAgIHJldHVybiBhLnNpemUgPT09IGIuc2l6ZSAmJiBBcnJheS5mcm9tKGEpLmV2ZXJ5KGtleSA9PiBiLmhhcyhrZXkpKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0U3RhcnRFbmRQb2ludHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYWRkKGtleSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmFkZChrZXkpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fbm9kZXMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuaGFzKGtleSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQodGhpcy5fbm9kZXMpKTtcbiAgfVxuICBleHRyYWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gIH1cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuICBpbnNlcnRUZXh0KCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0U2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMV07XG4gICAgbGV0IHNlbGVjdGlvbkF0RW5kO1xuICAgIC8vIEluc2VydCBub2Rlc1xuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0U2VsZWN0ZWROb2RlKSkge1xuICAgICAgc2VsZWN0aW9uQXRFbmQgPSBsYXN0U2VsZWN0ZWROb2RlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBzZWxlY3Rpb25BdEVuZCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25BdEVuZC5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkTm9kZXNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLl9ub2RlcztcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG9iamVjdCk7XG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0Q29udGVudCArPSBub2Rlc1tpXS5nZXRUZXh0Q29udGVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc1JhbmdlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSYW5nZVNlbGVjdGlvbjtcbn1cbmNsYXNzIFJhbmdlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoYW5jaG9yLCBmb2N1cywgZm9ybWF0LCBzdHlsZSkge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZm9jdXMgPSBmb2N1cztcbiAgICBhbmNob3IuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgZm9jdXMuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbiAgZ2V0Q2FjaGVkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE5vZGVzO1xuICB9XG4gIHNldENhY2hlZE5vZGVzKG5vZGVzKSB7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIHRoZSBwcm92aWRlZCBzZWxlY3Rpb25zIGlzIGVxdWFsIHRvIHRoaXMgb25lIGJ5IHZhbHVlLFxuICAgKiBpbmx1ZGluZyBhbmNob3IsIGZvY3VzLCBmb3JtYXQsIGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gdGhlIFNlbGVjdGlvbiB0byBjb21wYXJlIHRoaXMgb25lIHRvLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb25zIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cykgJiYgdGhpcy5mb3JtYXQgPT09IHNlbGVjdGlvbi5mb3JtYXQgJiYgdGhpcy5zdHlsZSA9PT0gc2VsZWN0aW9uLnN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgU2VsZWN0aW9uIGlzIFwiY29sbGFwc2VkXCIsIG1lYW5pbmcgdGhlIGFuY2hvciBhbmQgZm9jdXMgYXJlXG4gICAqIHRoZSBzYW1lIG5vZGUgYW5kIGhhdmUgdGhlIHNhbWUgb2Zmc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgY29sbGFwc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmNob3IuaXModGhpcy5mb2N1cyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uIFVzZXMgY2FjaGluZyB0byBtYWtlIGl0IGdlbmVyYWxseSBzdWl0YWJsZVxuICAgKiBmb3IgdXNlIGluIGhvdCBwYXRocy5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGlzQmVmb3JlID8gYW5jaG9yIDogZm9jdXM7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gaXNCZWZvcmUgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBsZXQgZmlyc3ROb2RlID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG4gICAgbGV0IGxhc3ROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IGZpcnN0UG9pbnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGxhc3RQb2ludC5vZmZzZXQ7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Tm9kZURlc2NlbmRhbnQgPSBmaXJzdE5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoc3RhcnRPZmZzZXQpO1xuICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlRGVzY2VuZGFudCAhPSBudWxsID8gZmlyc3ROb2RlRGVzY2VuZGFudCA6IGZpcnN0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgbGV0IGxhc3ROb2RlRGVzY2VuZGFudCA9IGxhc3ROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGVuZE9mZnNldCk7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG92ZXItc2VsZWN0LCBhcyBub2RlIHNlbGVjdGlvbiBpbmZlcnMgdGhlIGNoaWxkIGJlZm9yZVxuICAgICAgLy8gdGhlIGxhc3QgZGVzY2VuZGFudCwgbm90IGluY2x1ZGluZyB0aGF0IGRlc2NlbmRhbnQuXG4gICAgICBpZiAobGFzdE5vZGVEZXNjZW5kYW50ICE9PSBudWxsICYmIGxhc3ROb2RlRGVzY2VuZGFudCAhPT0gZmlyc3ROb2RlICYmIGxhc3ROb2RlLmdldENoaWxkQXRJbmRleChlbmRPZmZzZXQpID09PSBsYXN0Tm9kZURlc2NlbmRhbnQpIHtcbiAgICAgICAgbGFzdE5vZGVEZXNjZW5kYW50ID0gbGFzdE5vZGVEZXNjZW5kYW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGxhc3ROb2RlRGVzY2VuZGFudCA6IGxhc3ROb2RlO1xuICAgIH1cbiAgICBsZXQgbm9kZXM7XG4gICAgaWYgKGZpcnN0Tm9kZS5pcyhsYXN0Tm9kZSkpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzID0gW2ZpcnN0Tm9kZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gZmlyc3ROb2RlLmdldE5vZGVzQmV0d2VlbihsYXN0Tm9kZSk7XG4gICAgfVxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBTZWxlY3Rpb24gdG8gYmUgb2YgdHlwZSBcInRleHRcIiBhdCB0aGUgcHJvdmlkZWQgYW5jaG9yIGFuZCBmb2N1cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JOb2RlIC0gdGhlIGFuY2hvciBub2RlIHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSB0aGUgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBmb2N1c05vZGUgLSB0aGUgZm9jdXMgbm9kZSB0byBzZXQgb24gdGhlIFNlbGVjdGlvblxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSB0aGUgZm9jdXMgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqL1xuICBzZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yTm9kZS5fX2tleSwgYW5jaG9yT2Zmc2V0LCAndGV4dCcpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c05vZGUuX19rZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSAocGxhaW4pIHRleHQgY29udGVudCBvZiBhbGwgdGhlIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdGV4dCBjb250ZW50IG9mIGFsbCB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHModGhpcyk7XG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XG4gICAgbGV0IHByZXZXYXNFbGVtZW50ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICBpZiAoIXByZXZXYXNFbGVtZW50KSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcHJldldhc0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2V2FzRWxlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZXYXNFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGlmIChub2RlID09PSBmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoYW5jaG9yLnR5cGUgIT09ICdlbGVtZW50JyB8fCBmb2N1cy50eXBlICE9PSAnZWxlbWVudCcgfHwgZm9jdXMub2Zmc2V0ID09PSBhbmNob3Iub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGFuY2hvck9mZnNldCA8IGZvY3VzT2Zmc2V0ID8gdGV4dC5zbGljZShhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoYW5jaG9yT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoMCwgZm9jdXNPZmZzZXQpIDogdGV4dC5zbGljZSgwLCBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUobm9kZSkpICYmIChub2RlICE9PSBsYXN0Tm9kZSB8fCAhdGhpcy5pc0NvbGxhcHNlZCgpKSkge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gbWFwIGEgRE9NIHNlbGVjdGlvbiByYW5nZSBvbnRvIHRoaXMgTGV4aWNhbCBTZWxlY3Rpb24sXG4gICAqIHNldHRpbmcgdGhlIGFuY2hvciwgZm9jdXMsIGFuZCB0eXBlIGFjY29yZGluZ2x5XG4gICAqXG4gICAqIEBwYXJhbSByYW5nZSBhIERPTSBTZWxlY3Rpb24gcmFuZ2UgY29uZm9ybWluZyB0byB0aGUgU3RhdGljUmFuZ2UgaW50ZXJmYWNlLlxuICAgKi9cbiAgYXBwbHlET01SYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICBjb25zdCByZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKTtcbiAgICBpZiAocmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2FuY2hvclBvaW50LCBmb2N1c1BvaW50XSA9IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yUG9pbnQua2V5LCBhbmNob3JQb2ludC5vZmZzZXQsIGFuY2hvclBvaW50LnR5cGUpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c1BvaW50LmtleSwgZm9jdXNQb2ludC5vZmZzZXQsIGZvY3VzUG9pbnQudHlwZSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb24sIGNvcHlpbmcgb3ZlciBhbGwgdGhlIHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG5ldyBSYW5nZVNlbGVjdGlvbiB3aXRoIHRoZSBzYW1lIHByb3BlcnR5IHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgUmFuZ2VTZWxlY3Rpb24oJGNyZWF0ZVBvaW50KGFuY2hvci5rZXksIGFuY2hvci5vZmZzZXQsIGFuY2hvci50eXBlKSwgJGNyZWF0ZVBvaW50KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKSwgdGhpcy5mb3JtYXQsIHRoaXMuc3R5bGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgcHJvdmlkZWQgZm9ybWF0IG9uIGFsbCB0aGUgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXQgYSBzdHJpbmcgVGV4dEZvcm1hdFR5cGUgdG8gdG9nZ2xlIG9uIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHNlbGVjdGlvblxuICAgKi9cbiAgdG9nZ2xlRm9ybWF0KGZvcm1hdCkge1xuICAgIHRoaXMuZm9ybWF0ID0gdG9nZ2xlVGV4dEZvcm1hdFR5cGUodGhpcy5mb3JtYXQsIGZvcm1hdCwgbnVsbCk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5IG9uIHRoZSBTZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlIC0gdGhlIHN0eWxlIHRvIHNldCBhdCB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBUZXh0Rm9ybWF0VHlwZSBpcyBwcmVzZW50IG9uIHRoZSBTZWxlY3Rpb24uIFRoaXMgd2lsbCBiZSB0cnVlIGlmIGFueSBub2RlIGluIHRoZSBTZWxlY3Rpb25cbiAgICogaGFzIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgVGV4dEZvcm1hdFR5cGUgdG8gY2hlY2sgZm9yLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBmb3JtYXQgaXMgY3VycmVudGx5IHRvZ2dsZWQgb24gb24gdGhlIFNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKHRoaXMuZm9ybWF0ICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gaW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogY29udmVydHMgdGFicywgbmV3bGluZXMsIGFuZCBjYXJyaWFnZSByZXR1cm5zIGludG8gTGV4aWNhbE5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgU2VsZWN0aW9uXG4gICAqL1xuICBpbnNlcnRSYXdUZXh0KHRleHQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRleHROb2RlKHBhcnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gaW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbiBhcyBhIG5ld1xuICAgKiBMZXhpY2FsIFRleHROb2RlLCBhY2NvcmRpbmcgdG8gYSBzZXJpZXMgb2YgaW5zZXJ0aW9uIGhldXJpc3RpY3MgYmFzZWQgb24gdGhlIHNlbGVjdGlvbiB0eXBlIGFuZCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgaW5zZXJ0VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICBsZXQgZmlyc3RQb2ludCA9IGFuY2hvcjtcbiAgICBsZXQgZW5kUG9pbnQgPSBmb2N1cztcbiAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQoKSAmJiBmb2N1cy5pc0JlZm9yZShhbmNob3IpKSB7XG4gICAgICBmaXJzdFBvaW50ID0gZm9jdXM7XG4gICAgICBlbmRQb2ludCA9IGFuY2hvcjtcbiAgICB9XG4gICAgaWYgKGZpcnN0UG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAkdHJhbnNmZXJTdGFydGluZ0VsZW1lbnRQb2ludFRvVGV4dFBvaW50KGZpcnN0UG9pbnQsIGVuZFBvaW50LCBmb3JtYXQsIHN0eWxlKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICBsZXQgZW5kT2Zmc2V0ID0gZW5kUG9pbnQub2Zmc2V0O1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICAgIGlmICghJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0VGV4dDogZmlyc3Qgbm9kZSBpcyBub3QgYSB0ZXh0IG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICBjb25zdCBmaXJzdE5vZGVQYXJlbnQgPSBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSAmJiBlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGVuZE9mZnNldCA9IGZpcnN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICBlbmRQb2ludC5zZXQoZmlyc3RQb2ludC5rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCAmJiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgfHwgZmlyc3ROb2RlLmlzVG9rZW4oKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRBZnRlcigpIHx8ICFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgJiYgZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpIHx8ICFuZXh0U2libGluZy5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgJGlzVG9rZW5PclNlZ21lbnRlZChuZXh0U2libGluZykpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgbmV4dFNpYmxpbmcuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIGlmICghZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpKSB7XG4gICAgICAgICAgZmlyc3ROb2RlUGFyZW50Lmluc2VydEFmdGVyKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdE5vZGUuaW5zZXJ0QWZ0ZXIobmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0U2libGluZy5zZWxlY3QoMCwgMCk7XG4gICAgICBmaXJzdE5vZGUgPSBuZXh0U2libGluZztcbiAgICAgIGlmICh0ZXh0ICE9PSAnJykge1xuICAgICAgICB0aGlzLmluc2VydFRleHQodGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gMCAmJiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgfHwgZmlyc3ROb2RlLmlzVG9rZW4oKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSAmJiBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgcHJldlNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RleHROb2RlKHByZXZTaWJsaW5nKSB8fCAkaXNUb2tlbk9yU2VnbWVudGVkKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBwcmV2U2libGluZyA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBwcmV2U2libGluZy5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgaWYgKCFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpKSB7XG4gICAgICAgICAgZmlyc3ROb2RlUGFyZW50Lmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3ROb2RlLmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgZmlyc3ROb2RlID0gcHJldlNpYmxpbmc7XG4gICAgICBpZiAodGV4dCAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaXJzdE5vZGUuaXNTZWdtZW50ZWQoKSAmJiBzdGFydE9mZnNldCAhPT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgICAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICBmaXJzdE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQ29sbGFwc2VkKCkgJiYgdGV4dCAhPT0gJycpIHtcbiAgICAgIC8vIFdoZW4gdGhlIGZpcnN0Tm9kZSBvciBsYXN0Tm9kZSBwYXJlbnRzIGFyZSBlbGVtZW50cyB0aGF0XG4gICAgICAvLyBkbyBub3QgYWxsb3cgdGV4dCB0byBiZSBpbnNlcnRlZCBiZWZvcmUgb3IgYWZ0ZXIsIHdlIGZpcnN0XG4gICAgICAvLyBjbGVhciB0aGUgY29udGVudC4gVGhlbiB3ZSBub3JtYWxpemUgc2VsZWN0aW9uLCB0aGVuIGluc2VydFxuICAgICAgLy8gdGhlIG5ldyBjb250ZW50LlxuICAgICAgY29uc3QgbGFzdE5vZGVQYXJlbnQgPSBsYXN0Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICghZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlUGFyZW50KSAmJiAoIWxhc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhbGFzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCgnJyk7XG4gICAgICAgICRub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKHRoaXMuYW5jaG9yLCB0aGlzLmZvY3VzLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3RlZE5vZGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoZmlyc3ROb2RlLmlzVG9rZW4oKSkge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlyc3ROb2RlRm9ybWF0ID0gZmlyc3ROb2RlLmdldEZvcm1hdCgpO1xuICAgICAgY29uc3QgZmlyc3ROb2RlU3R5bGUgPSBmaXJzdE5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0ICYmIChmaXJzdE5vZGVGb3JtYXQgIT09IGZvcm1hdCB8fCBmaXJzdE5vZGVTdHlsZSAhPT0gc3R5bGUpKSB7XG4gICAgICAgIGlmIChmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHtcbiAgICAgICAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgZmlyc3ROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBmaXJzdE5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFt0YXJnZXROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5pbnNlcnRBZnRlcih0ZXh0Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXaGVuIGNvbXBvc2luZywgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGFuY2hvciBvZmZzZXQgc28gdGhhdFxuICAgICAgICAgIC8vIHdlIGNvcnJlY3RseSByZXBsYWNlIHRoYXQgcmlnaHQgcmFuZ2UuXG4gICAgICAgICAgaWYgKHRleHROb2RlLmlzQ29tcG9zaW5nKCkgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkaXNUYWJOb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgZGVsQ291bnQgYmVjYXVzZSB0aGVyZSBpcyBvbmx5IHRoZSBlbnRpcmUgc2VsZWN0ZWQgbm9kZSBjYXNlXG4gICAgICAgIC8vIHRoYXQgY2FuIGhpdCBoZXJlIGZvciBjb250ZW50IHNpemUgMSBhbmQgd2l0aCBjYW5JbnNlcnRUZXh0QmVmb3JlQWZ0ZXIgZmFsc2VcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRleHROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgICB0ZXh0Tm9kZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgICAgIHRleHROb2RlLnNlbGVjdCgpO1xuICAgICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbENvdW50ID0gZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XG4gICAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuc3BsaWNlVGV4dChzdGFydE9mZnNldCwgZGVsQ291bnQsIHRleHQsIHRydWUpO1xuICAgICAgaWYgKGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykge1xuICAgICAgICBmaXJzdE5vZGUucmVtb3ZlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBpZiAoZmlyc3ROb2RlLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgICAgICAvLyBXaGVuIGNvbXBvc2luZywgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGFuY2hvciBvZmZzZXQgc28gdGhhdFxuICAgICAgICAgIC8vIHdlIGNvcnJlY3RseSByZXBsYWNlIHRoYXQgcmlnaHQgcmFuZ2UuXG4gICAgICAgICAgdGhpcy5hbmNob3Iub2Zmc2V0IC09IHRleHQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROb2RlRm9ybWF0O1xuICAgICAgICAgIHRoaXMuc3R5bGUgPSBmaXJzdE5vZGVTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXJrZWROb2RlS2V5c0ZvcktlZXAgPSBuZXcgU2V0KFsuLi5maXJzdE5vZGUuZ2V0UGFyZW50S2V5cygpLCAuLi5sYXN0Tm9kZS5nZXRQYXJlbnRLZXlzKCldKTtcblxuICAgICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHBhcmVudCBlbGVtZW50cyBiZWZvcmUgdGhlIG5leHQgc2VjdGlvbixcbiAgICAgIC8vIGFzIGluIHRoYXQgc2VjdGlvbiB3ZSBtaWdodCBtdXRhdGUgdGhlIGxhc3ROb2RlLlxuICAgICAgY29uc3QgZmlyc3RFbGVtZW50ID0gJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSA/IGZpcnN0Tm9kZSA6IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBsZXQgbGFzdEVsZW1lbnQgPSAkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgPyBsYXN0Tm9kZSA6IGxhc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBsYXN0RWxlbWVudENoaWxkID0gbGFzdE5vZGU7XG5cbiAgICAgIC8vIElmIHRoZSBsYXN0IGVsZW1lbnQgaXMgaW5saW5lLCB3ZSBzaG91bGQgaW5zdGVhZCBsb29rIGF0IGdldHRpbmdcbiAgICAgIC8vIHRoZSBub2RlcyBvZiBpdHMgcGFyZW50LCByYXRoZXIgdGhhbiBpdHNlbGYuIFRoaXMgYmVoYXZpb3Igd2lsbFxuICAgICAgLy8gdGhlbiBiZXR0ZXIgbWF0Y2ggaG93IHRleHQgbm9kZSBpbnNlcnRpb25zIHdvcmsuIFdlIHdpbGwgbmVlZCB0b1xuICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIGxhc3QgZWxlbWVudCdzIGNoaWxkIGFjY29yZGluZ2x5IGFzIHdlIGRvIHRoaXMuXG4gICAgICBpZiAoIWZpcnN0RWxlbWVudC5pcyhsYXN0RWxlbWVudCkgJiYgbGFzdEVsZW1lbnQuaXNJbmxpbmUoKSkge1xuICAgICAgICAvLyBLZWVwIHRyYXZlcnNpbmcgdGlsbCB3ZSBoYXZlIGEgbm9uLWlubGluZSBlbGVtZW50IHBhcmVudC5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxhc3RFbGVtZW50Q2hpbGQgPSBsYXN0RWxlbWVudDtcbiAgICAgICAgICBsYXN0RWxlbWVudCA9IGxhc3RFbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgfSB3aGlsZSAobGFzdEVsZW1lbnQuaXNJbmxpbmUoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBtdXRhdGlvbnMgdG8gdGhlIGxhc3Qgbm9kZS5cbiAgICAgIGlmIChlbmRQb2ludC50eXBlID09PSAndGV4dCcgJiYgKGVuZE9mZnNldCAhPT0gMCB8fCBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykgfHwgZW5kUG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGxhc3ROb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgPCBlbmRPZmZzZXQpIHtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSAmJiAhbGFzdE5vZGUuaXNUb2tlbigpICYmIGVuZE9mZnNldCAhPT0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgICAgICBpZiAobGFzdE5vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUobGFzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgICAgICAgICBsYXN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gdGV4dE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJvb3Qgbm9kZSBzZWxlY3Rpb25zIG9ubHkgc2VsZWN0IHdob2xlIG5vZGVzLCBzbyBubyB0ZXh0IHNwbGljZSBpcyBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAoISRpc1Jvb3ROb2RlKGVuZFBvaW50LmdldE5vZGUoKSkgJiYgZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLnNwbGljZVRleHQoMCwgZW5kT2Zmc2V0LCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtlZE5vZGVLZXlzRm9yS2VlcC5hZGQobGFzdE5vZGUuX19rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxhc3ROb2RlUGFyZW50ID0gbGFzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgIGlmICghbGFzdE5vZGVQYXJlbnQuY2FuQmVFbXB0eSgpICYmIGxhc3ROb2RlUGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICAgICAgICBsYXN0Tm9kZVBhcmVudC5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrZWROb2RlS2V5c0ZvcktlZXAuYWRkKGxhc3ROb2RlLl9fa2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gRWl0aGVyIG1vdmUgdGhlIHJlbWFpbmluZyBub2RlcyBvZiB0aGUgbGFzdCBwYXJlbnQgdG8gYWZ0ZXJcbiAgICAgIC8vIHRoZSBmaXJzdCBjaGlsZCwgb3IgcmVtb3ZlIHRoZW0gZW50aXJlbHkuIElmIHRoZSBsYXN0IHBhcmVudFxuICAgICAgLy8gaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IHBhcmVudCwgdGhpcyBsb2dpYyBhbHNvIHdvcmtzLlxuICAgICAgY29uc3QgbGFzdE5vZGVDaGlsZHJlbiA9IGxhc3RFbGVtZW50LmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVzU2V0ID0gbmV3IFNldChzZWxlY3RlZE5vZGVzKTtcbiAgICAgIGNvbnN0IGZpcnN0QW5kTGFzdEVsZW1lbnRzQXJlRXF1YWwgPSBmaXJzdEVsZW1lbnQuaXMobGFzdEVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSBjaG9vc2UgYSB0YXJnZXQgdG8gaW5zZXJ0IGFsbCBub2RlcyBhZnRlci4gSW4gdGhlIGNhc2Ugb2YgaGF2aW5nXG4gICAgICAvLyBhbmQgaW5saW5lIHN0YXJ0aW5nIHBhcmVudCBlbGVtZW50IHdpdGggYSBzdGFydGluZyBub2RlIHRoYXQgaGFzIG5vXG4gICAgICAvLyBzaWJsaW5ncywgd2Ugc2hvdWxkIGluc2VydCBhZnRlciB0aGUgc3RhcnRpbmcgcGFyZW50IGVsZW1lbnQsIG90aGVyd2lzZVxuICAgICAgLy8gd2Ugd2lsbCBpbmNvcnJlY3RseSBtZXJnZSBpbnRvIHRoZSBzdGFydGluZyBwYXJlbnQgZWxlbWVudC5cbiAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBrZWVwIG9uIHRyYXZlcnNpbmcgcGFyZW50cyBpZiB3ZSdyZSBpbnNpZGUgYW5vdGhlclxuICAgICAgLy8gbmVzdGVkIGlubGluZSBlbGVtZW50P1xuICAgICAgY29uc3QgaW5zZXJ0aW9uVGFyZ2V0ID0gZmlyc3RFbGVtZW50LmlzSW5saW5lKCkgJiYgZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwgPyBmaXJzdEVsZW1lbnQgOiBmaXJzdE5vZGU7XG4gICAgICBmb3IgKGxldCBpID0gbGFzdE5vZGVDaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBsYXN0Tm9kZUNoaWxkID0gbGFzdE5vZGVDaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGxhc3ROb2RlQ2hpbGQuaXMoZmlyc3ROb2RlKSB8fCAkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZUNoaWxkKSAmJiBsYXN0Tm9kZUNoaWxkLmlzUGFyZW50T2YoZmlyc3ROb2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZUNoaWxkLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgIGlmICghc2VsZWN0ZWROb2Rlc1NldC5oYXMobGFzdE5vZGVDaGlsZCkgfHwgbGFzdE5vZGVDaGlsZC5pcyhsYXN0RWxlbWVudENoaWxkKSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdEFuZExhc3RFbGVtZW50c0FyZUVxdWFsKSB7XG4gICAgICAgICAgICAgIGluc2VydGlvblRhcmdldC5pbnNlcnRBZnRlcihsYXN0Tm9kZUNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3ROb2RlQ2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZpcnN0QW5kTGFzdEVsZW1lbnRzQXJlRXF1YWwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbHJlYWR5IG1vdmVkIG91dCBhbGwgdGhlIG5vZGVzIG9mIHRoZVxuICAgICAgICAvLyBsYXN0IHBhcmVudCwgYW5kIGlmIHNvLCB0cmF2ZXJzZSB0aGUgcGFyZW50IHRyZWUgYW5kIG1hcmtcbiAgICAgICAgLy8gdGhlbSBhbGwgYXMgYmVpbmcgYWJsZSB0byBkZWxldGVkIHRvby5cbiAgICAgICAgbGV0IHBhcmVudCA9IGxhc3RFbGVtZW50O1xuICAgICAgICBsZXQgbGFzdFJlbW92ZWRQYXJlbnQgPSBudWxsO1xuICAgICAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDAgfHwgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5pcyhsYXN0UmVtb3ZlZFBhcmVudCkpIHtcbiAgICAgICAgICAgIG1hcmtlZE5vZGVLZXlzRm9yS2VlcC5kZWxldGUocGFyZW50Ll9fa2V5KTtcbiAgICAgICAgICAgIGxhc3RSZW1vdmVkUGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHdlIGRvIHNwbGljaW5nIGFmdGVyIG1vdmluZyBvZiBub2RlcywgYXMgc3BsaWNpbmdcbiAgICAgIC8vIGNhbiBoYXZlIHNpZGUtZWZmZWN0cyAoaW4gdGhlIGNhc2Ugb2YgaGFzaHRhZ3MpLlxuICAgICAgaWYgKCFmaXJzdE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpY2VUZXh0KHN0YXJ0T2Zmc2V0LCBmaXJzdE5vZGVUZXh0TGVuZ3RoIC0gc3RhcnRPZmZzZXQsIHRleHQsIHRydWUpO1xuICAgICAgICBpZiAoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgICAgZmlyc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Tm9kZS5pc0NvbXBvc2luZygpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRleHROb2RlLnNlbGVjdCgpO1xuICAgICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgc2VsZWN0ZWQgbm9kZXMgdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiByZW1vdmVkLlxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgY29uc3Qga2V5ID0gc2VsZWN0ZWROb2RlLl9fa2V5O1xuICAgICAgICBpZiAoIW1hcmtlZE5vZGVLZXlzRm9yS2VlcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHNlbGVjdGVkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB0ZXh0IGluIHRoZSBTZWxlY3Rpb24sIGFkanVzdGluZyB0aGUgRWRpdG9yU3RhdGUgYWNjb3JkaW5nbHkuXG4gICAqL1xuICByZW1vdmVUZXh0KCkge1xuICAgIHRoaXMuaW5zZXJ0VGV4dCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgcHJvdmlkZWQgZm9ybWF0IHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG9yXG4gICAqIG1lcmdpbmcgbm9kZXMgYXMgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gZm9ybWF0VHlwZSB0aGUgZm9ybWF0IHR5cGUgdG8gYXBwbHkgdG8gdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqL1xuICBmb3JtYXRUZXh0KGZvcm1hdFR5cGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICB0aGlzLnRvZ2dsZUZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgIC8vIFdoZW4gY2hhbmdpbmcgZm9ybWF0LCB3ZSBzaG91bGQgc3RvcCBjb21wb3NpdGlvblxuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dE5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBzZWxlY3RlZE5vZGUgb2Ygc2VsZWN0ZWROb2Rlcykge1xuICAgICAgaWYgKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkpIHtcbiAgICAgICAgc2VsZWN0ZWRUZXh0Tm9kZXMucHVzaChzZWxlY3RlZE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkVGV4dE5vZGVzLmxlbmd0aDtcbiAgICBpZiAoc2VsZWN0ZWRUZXh0Tm9kZXNMZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudG9nZ2xlRm9ybWF0KGZvcm1hdFR5cGUpO1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBmb3JtYXQsIHdlIHNob3VsZCBzdG9wIGNvbXBvc2l0aW9uXG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gdGhpcy5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IGlzQmFja3dhcmQgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBlbmRQb2ludCA9IGlzQmFja3dhcmQgPyBhbmNob3IgOiBmb2N1cztcbiAgICBsZXQgZmlyc3RJbmRleCA9IDA7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzWzBdO1xuICAgIGxldCBzdGFydE9mZnNldCA9IHN0YXJ0UG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnID8gMCA6IHN0YXJ0UG9pbnQub2Zmc2V0O1xuXG4gICAgLy8gSW4gY2FzZSBzZWxlY3Rpb24gc3RhcnRlZCBhdCB0aGUgZW5kIG9mIHRleHQgbm9kZSB1c2UgbmV4dCB0ZXh0IG5vZGVcbiAgICBpZiAoc3RhcnRQb2ludC50eXBlID09PSAndGV4dCcgJiYgc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgZmlyc3RJbmRleCA9IDE7XG4gICAgICBmaXJzdE5vZGUgPSBzZWxlY3RlZFRleHROb2Rlc1sxXTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKGZpcnN0Tm9kZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0TmV4dEZvcm1hdCA9IGZpcnN0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBudWxsKTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCAtIDE7XG4gICAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWRUZXh0Tm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBlbmRQb2ludC50eXBlID09PSAndGV4dCcgPyBlbmRQb2ludC5vZmZzZXQgOiBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgIC8vIFNpbmdsZSBub2RlIHNlbGVjdGVkXG4gICAgaWYgKGZpcnN0Tm9kZS5pcyhsYXN0Tm9kZSkpIHtcbiAgICAgIC8vIE5vIGFjdHVhbCB0ZXh0IGlzIHNlbGVjdGVkLCBzbyBkbyBub3RoaW5nLlxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkIG9yIGl0IGlzIHRva2VuLCBzbyBqdXN0IGZvcm1hdCBpdFxuICAgICAgaWYgKCRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSB8fCBzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYWRkIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgIHJlcGxhY2VtZW50LnNldEZvcm1hdChmaXJzdE5leHRGb3JtYXQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzZWxlY3Rpb24gb25seSBpZiBzdGFydHMvZW5kcyBvbiB0ZXh0IG5vZGVcbiAgICAgICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgc3RhcnRQb2ludC5zZXQocmVwbGFjZW1lbnQuX19rZXksIDAsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGVuZFBvaW50LnNldChyZXBsYWNlbWVudC5fX2tleSwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROZXh0Rm9ybWF0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsZSBub2RlcyBzZWxlY3RlZFxuICAgIC8vIFRoZSBlbnRpcmUgZmlyc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCwgc28gc3BsaXQgaXRcbiAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDAgJiYgISRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSkge1xuICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgY29uc3QgbGFzdE5leHRGb3JtYXQgPSBsYXN0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBmaXJzdE5leHRGb3JtYXQpO1xuICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgMCwgaXQgbWVhbnMgbm8gYWN0dWFsIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkLFxuICAgIC8vIHNvIHdlIHNraXAgZm9ybWF0dGluZyB0aGUgbGFzdCBub2RlIGFsdG9nZXRoZXIuXG4gICAgaWYgKGVuZE9mZnNldCA+IDApIHtcbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpICYmICEkaXNUb2tlbk9yU2VnbWVudGVkKGxhc3ROb2RlKSkge1xuICAgICAgICBbbGFzdE5vZGVdID0gbGFzdE5vZGUuc3BsaXRUZXh0KGVuZE9mZnNldCk7XG4gICAgICB9XG4gICAgICBsYXN0Tm9kZS5zZXRGb3JtYXQobGFzdE5leHRGb3JtYXQpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgYWxsIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuICAgIGZvciAobGV0IGkgPSBmaXJzdEluZGV4ICsgMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzW2ldO1xuICAgICAgY29uc3QgbmV4dEZvcm1hdCA9IHRleHROb2RlLmdldEZvcm1hdEZsYWdzKGZvcm1hdFR5cGUsIGxhc3ROZXh0Rm9ybWF0KTtcbiAgICAgIHRleHROb2RlLnNldEZvcm1hdChuZXh0Rm9ybWF0KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgc3RhcnRzL2VuZHMgb24gdGV4dCBub2RlXG4gICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBzdGFydFBvaW50LnNldChmaXJzdE5vZGUuX19rZXksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgIH1cbiAgICBpZiAoZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBlbmRQb2ludC5zZXQobGFzdE5vZGUuX19rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSBmaXJzdE5leHRGb3JtYXQgfCBsYXN0TmV4dEZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBcImludGVsbGlnZW50bHlcIiBpbnNlcnQgYW4gYXJiaXRyYXJ5IGxpc3Qgb2YgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGVcbiAgICogY3VycmVudCBTZWxlY3Rpb24gYWNjb3JkaW5nIHRvIGEgc2V0IG9mIGhldXJpc3RpY3MgdGhhdCBkZXRlcm1pbmUgaG93IHN1cnJvdW5kaW5nIG5vZGVzXG4gICAqIHNob3VsZCBiZSBjaGFuZ2VkLCByZXBsYWNlZCwgb3IgbW92ZWQgdG8gYWNjb21vZGF0ZSB0aGUgaW5jb21pbmcgb25lcy5cbiAgICpcbiAgICogQHBhcmFtIG5vZGVzIC0gdGhlIG5vZGVzIHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgICAgdGhpcy5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgUmFuZ2VTZWxlY3Rpb24gYWZ0ZXIgaW5zZXJ0UGFyYWdyYXBoYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMuaXNCYWNrd2FyZCgpID8gdGhpcy5mb2N1cyA6IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZpcnN0QmxvY2sgPSAkZ2V0QW5jZXN0b3IoZmlyc3RQb2ludC5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBjb25zdCBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBDQVNFIDE6IGluc2VydCBpbnNpZGUgYSBjb2RlIGJsb2NrXG4gICAgaWYgKCdfX2xhbmd1YWdlJyBpbiBmaXJzdEJsb2NrICYmICRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spKSB7XG4gICAgICBpZiAoJ19fbGFuZ3VhZ2UnIGluIG5vZGVzWzBdKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dChub2Rlc1swXS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gJHJlbW92ZVRleHRBbmRTcGxpdEJsb2NrKHRoaXMpO1xuICAgICAgICBmaXJzdEJsb2NrLnNwbGljZShpbmRleCwgMCwgbm9kZXMpO1xuICAgICAgICBsYXN0LnNlbGVjdEVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENBU0UgMjogQWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheSBhcmUgaW5saW5lXG4gICAgY29uc3Qgbm90SW5saW5lID0gbm9kZSA9PiAoJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSkgJiYgIW5vZGUuaXNJbmxpbmUoKTtcbiAgICBpZiAoIW5vZGVzLnNvbWUobm90SW5saW5lKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShmaXJzdEJsb2NrKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgJ2ZpcnN0QmxvY2snIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9ICRyZW1vdmVUZXh0QW5kU3BsaXRCbG9jayh0aGlzKTtcbiAgICAgIGZpcnN0QmxvY2suc3BsaWNlKGluZGV4LCAwLCBub2Rlcyk7XG4gICAgICBsYXN0LnNlbGVjdEVuZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENBU0UgMzogQXQgbGVhc3QgMSBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBub3QgaW5saW5lXG4gICAgY29uc3QgYmxvY2tzUGFyZW50ID0gJHdyYXBJbmxpbmVOb2Rlcyhub2Rlcyk7XG4gICAgY29uc3Qgbm9kZVRvU2VsZWN0ID0gYmxvY2tzUGFyZW50LmdldExhc3REZXNjZW5kYW50KCk7XG4gICAgY29uc3QgYmxvY2tzID0gYmxvY2tzUGFyZW50LmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgaXNMSSA9IG5vZGUgPT4gJ19fdmFsdWUnIGluIG5vZGUgJiYgJ19fY2hlY2tlZCcgaW4gbm9kZTtcbiAgICBjb25zdCBpc01lcmdlYWJsZSA9IG5vZGUgPT4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgSU5URVJOQUxfJGlzQmxvY2sobm9kZSkgJiYgIW5vZGUuaXNFbXB0eSgpICYmICRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spICYmICghZmlyc3RCbG9jay5pc0VtcHR5KCkgfHwgaXNMSShmaXJzdEJsb2NrKSk7XG4gICAgY29uc3Qgc2hvdWxkSW5zZXJ0ID0gISRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spIHx8ICFmaXJzdEJsb2NrLmlzRW1wdHkoKTtcbiAgICBjb25zdCBpbnNlcnRlZFBhcmFncmFwaCA9IHNob3VsZEluc2VydCA/IHRoaXMuaW5zZXJ0UGFyYWdyYXBoKCkgOiBudWxsO1xuICAgIGNvbnN0IGxhc3RUb0luc2VydCA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgbGV0IGZpcnN0VG9JbnNlcnQgPSBibG9ja3NbMF07XG4gICAgaWYgKGlzTWVyZ2VhYmxlKGZpcnN0VG9JbnNlcnQpKSB7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCAnZmlyc3RCbG9jaycgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICAgIH1cbiAgICAgIGZpcnN0QmxvY2suYXBwZW5kKC4uLmZpcnN0VG9JbnNlcnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBmaXJzdFRvSW5zZXJ0ID0gYmxvY2tzWzFdO1xuICAgIH1cbiAgICBpZiAoZmlyc3RUb0luc2VydCkge1xuICAgICAgaW5zZXJ0UmFuZ2VBZnRlcihmaXJzdEJsb2NrLCBmaXJzdFRvSW5zZXJ0KTtcbiAgICB9XG4gICAgY29uc3QgbGFzdEluc2VydGVkQmxvY2sgPSAkZ2V0QW5jZXN0b3Iobm9kZVRvU2VsZWN0LCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgaWYgKGluc2VydGVkUGFyYWdyYXBoICYmICRpc0VsZW1lbnROb2RlKGxhc3RJbnNlcnRlZEJsb2NrKSAmJiAoaXNMSShpbnNlcnRlZFBhcmFncmFwaCkgfHwgSU5URVJOQUxfJGlzQmxvY2sobGFzdFRvSW5zZXJ0KSkpIHtcbiAgICAgIGxhc3RJbnNlcnRlZEJsb2NrLmFwcGVuZCguLi5pbnNlcnRlZFBhcmFncmFwaC5nZXRDaGlsZHJlbigpKTtcbiAgICAgIGluc2VydGVkUGFyYWdyYXBoLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykgJiYgZmlyc3RCbG9jay5pc0VtcHR5KCkpIHtcbiAgICAgIGZpcnN0QmxvY2sucmVtb3ZlKCk7XG4gICAgfVxuICAgIG5vZGVUb1NlbGVjdC5zZWxlY3RFbmQoKTtcblxuICAgIC8vIFRvIHVuZGVyc3RhbmQgdGhpcyB0YWtlIGEgbG9vayBhdCB0aGUgdGVzdCBcImNhbiB3cmFwIHBvc3QtbGluZWJyZWFrIG5vZGVzIGludG8gbmV3IGVsZW1lbnRcIlxuICAgIGNvbnN0IGxhc3RDaGlsZCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spID8gZmlyc3RCbG9jay5nZXRMYXN0Q2hpbGQoKSA6IG51bGw7XG4gICAgaWYgKCRpc0xpbmVCcmVha05vZGUobGFzdENoaWxkKSAmJiBsYXN0SW5zZXJ0ZWRCbG9jayAhPT0gZmlyc3RCbG9jaykge1xuICAgICAgbGFzdENoaWxkLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgbmV3IFBhcmFncmFwaE5vZGUgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlIGN1cnJlbnQgU2VsZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBuZXdseSBpbnNlcnRlZCBub2RlLlxuICAgKi9cbiAgaW5zZXJ0UGFyYWdyYXBoKCkge1xuICAgIGlmICh0aGlzLmFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICRnZXRSb290KCkuc3BsaWNlKHRoaXMuYW5jaG9yLm9mZnNldCwgMCwgW3BhcmFncmFwaF0pO1xuICAgICAgcGFyYWdyYXBoLnNlbGVjdCgpO1xuICAgICAgcmV0dXJuIHBhcmFncmFwaDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSAkcmVtb3ZlVGV4dEFuZFNwbGl0QmxvY2sodGhpcyk7XG4gICAgY29uc3QgYmxvY2sgPSAkZ2V0QW5jZXN0b3IodGhpcy5hbmNob3IuZ2V0Tm9kZSgpLCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShibG9jaykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhbmNlc3RvciB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFRvQXBwZW5kID0gYmxvY2suZ2V0Q2hpbGRBdEluZGV4KGluZGV4KTtcbiAgICBjb25zdCBub2Rlc1RvSW5zZXJ0ID0gZmlyc3RUb0FwcGVuZCA/IFtmaXJzdFRvQXBwZW5kLCAuLi5maXJzdFRvQXBwZW5kLmdldE5leHRTaWJsaW5ncygpXSA6IFtdO1xuICAgIGNvbnN0IG5ld0Jsb2NrID0gYmxvY2suaW5zZXJ0TmV3QWZ0ZXIodGhpcywgZmFsc2UpO1xuICAgIGlmIChuZXdCbG9jaykge1xuICAgICAgbmV3QmxvY2suYXBwZW5kKC4uLm5vZGVzVG9JbnNlcnQpO1xuICAgICAgbmV3QmxvY2suc2VsZWN0U3RhcnQoKTtcbiAgICAgIHJldHVybiBuZXdCbG9jaztcbiAgICB9XG4gICAgLy8gaWYgbmV3QmxvY2sgaXMgbnVsbCwgaXQgbWVhbnMgdGhhdCBibG9jayBpcyBvZiB0eXBlIENvZGVOb2RlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBsb2dpY2FsIGxpbmVicmVhaywgd2hpY2ggbWF5IGJlIGEgbmV3IExpbmVCcmVha05vZGUgb3IgYSBuZXcgUGFyYWdyYXBoTm9kZSwgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlXG4gICAqIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKi9cbiAgaW5zZXJ0TGluZUJyZWFrKHNlbGVjdFN0YXJ0KSB7XG4gICAgY29uc3QgbGluZUJyZWFrID0gJGNyZWF0ZUxpbmVCcmVha05vZGUoKTtcbiAgICB0aGlzLmluc2VydE5vZGVzKFtsaW5lQnJlYWtdKTtcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gTWFjT1Mgd2l0aCB0aGUgY29tbWFuZCAnY3RybC1PJyAob3BlbkxpbmVCcmVhaylcbiAgICBpZiAoc2VsZWN0U3RhcnQpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGxpbmVCcmVhay5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBjb25zdCBpbmRleCA9IGxpbmVCcmVhay5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgcGFyZW50LnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG5vZGVzIHdoZXJlIG5lY2Vzc2FyeVxuICAgKiB0byBnZXQgb2Zmc2V0LWxldmVsIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIGV4dHJhY3QoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWROb2Rlc0xlbmd0aCAtIDE7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBbYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldF0gPSAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cyh0aGlzKTtcbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgIXRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCBub2RlID0gc3RhcnRPZmZzZXQgPT09IDAgPyBzcGxpdE5vZGVzWzBdIDogc3BsaXROb2Rlc1sxXTtcbiAgICAgICAgcmV0dXJuIG5vZGUgIT0gbnVsbCA/IFtub2RlXSA6IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtmaXJzdE5vZGVdO1xuICAgIH1cbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCZWZvcmUgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgICBzZWxlY3RlZE5vZGVzWzBdID0gZmlyc3ROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHQgPSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0TGVuZ3RoID0gbGFzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKGVuZE9mZnNldCAhPT0gbGFzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgICAgc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdID0gbGFzdE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZE5vZGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVzIHRoZSBTZWxlY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBwYXJhbWV0ZXJzIGFuZCBhIHNldCBvZiBoZXVyaXN0aWNzIHRoYXQgYWNjb3VudCBmb3JcbiAgICogdmFyaW91cyBub2RlIHR5cGVzLiBDYW4gYmUgdXNlZCB0byBzYWZlbHkgbW92ZSBvciBleHRlbmQgc2VsZWN0aW9uIGJ5IG9uZSBsb2dpY2FsIFwidW5pdFwiIHdpdGhvdXRcbiAgICogZGVhbGluZyBleHBsaWNpdGx5IHdpdGggYWxsIHRoZSBwb3NzaWJsZSBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYWx0ZXIgdGhlIHR5cGUgb2YgbW9kaWZpY2F0aW9uIHRvIHBlcmZvcm1cbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3Qgc2VsZWN0aW9uIGlzIGJhY2t3YXJkc1xuICAgKiBAcGFyYW0gZ3JhbnVsYXJpdHkgdGhlIGdyYW51bGFyaXR5IGF0IHdoaWNoIHRvIGFwcGx5IHRoZSBtb2RpZmljYXRpb25cbiAgICovXG4gIG1vZGlmeShhbHRlciwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgY29sbGFwc2UgPSBhbHRlciA9PT0gJ21vdmUnO1xuXG4gICAgLy8gSGFuZGxlIHRoZSBzZWxlY3Rpb24gbW92ZW1lbnQgYXJvdW5kIGRlY29yYXRvcnMuXG4gICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSkge1xuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBtb3ZlIHNlbGVjdGlvbiBmcm9tIHJhbmdlIHNlbGVjdGlvbiB0b1xuICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICBpZiAoY29sbGFwc2UgJiYgcG9zc2libGVOb2RlLmlzS2V5Ym9hcmRTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZVNlbGVjdGlvbiA9ICRjcmVhdGVOb2RlU2VsZWN0aW9uKCk7XG4gICAgICAgIG5vZGVTZWxlY3Rpb24uYWRkKHBvc3NpYmxlTm9kZS5fX2tleSk7XG4gICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBpc0JhY2t3YXJkID8gcG9zc2libGVOb2RlLmdldFByZXZpb3VzU2libGluZygpIDogcG9zc2libGVOb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBvc3NpYmxlTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGxldCBlbGVtZW50S2V5O1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICBlbGVtZW50S2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgICAgICBvZmZzZXQgPSBpc0JhY2t3YXJkID8gc2libGluZy5nZXRDaGlsZHJlblNpemUoKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gcG9zc2libGVOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgICAgZWxlbWVudEtleSA9IHBhcmVudC5fX2tleTtcbiAgICAgICAgICBpZiAoIWlzQmFja3dhcmQpIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb2N1cy5zZXQoZWxlbWVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGVsZW1lbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaWJsaW5nS2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IHNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggOiAwO1xuICAgICAgICBmb2N1cy5zZXQoc2libGluZ0tleSwgb2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICAgIC8vIFJlbW92ZSB0aGUgYmxvY2sgY3Vyc29yIGVsZW1lbnQgaWYgaXQgZXhpc3RzLiBUaGlzIHdpbGwgZW5zdXJlIHNlbGVjdGlvblxuICAgIC8vIHdvcmtzIGFzIGludGVuZGVkLiBJZiB3ZSBsZWF2ZSBpdCBpbiB0aGUgRE9NIGFsbCBzb3J0cyBvZiBzdHJhbmdlIGJ1Z3NcbiAgICAvLyBvY2N1ci4gOi9cbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwgJiYgYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpICYmICFwb3NzaWJsZU5vZGUuY2FuQmVFbXB0eSgpKSB7XG4gICAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgLy8gV2UgdXNlIHRoZSBET00gc2VsZWN0aW9uLm1vZGlmeSBBUEkgaGVyZSB0byBcInRlbGxcIiB1cyB3aGF0IHRoZSBzZWxlY3Rpb25cbiAgICAvLyB3aWxsIGJlLiBXZSB0aGVuIHVzZSBpdCB0byB1cGRhdGUgdGhlIExleGljYWwgc2VsZWN0aW9uIGFjY29yZGluZ2x5LiBUaGlzXG4gICAgLy8gaXMgbXVjaCBtb3JlIHJlbGlhYmxlIHRoYW4gd2FpdGluZyBmb3IgYSBiZWZvcmVpbnB1dCBhbmQgdXNpbmcgdGhlIHJhbmdlc1xuICAgIC8vIGZyb20gZ2V0VGFyZ2V0UmFuZ2VzKCksIGFuZCBpcyBhbHNvIGJldHRlciB0aGFuIHRyeWluZyB0byBkbyBpdCBvdXJzZWx2ZXNcbiAgICAvLyB1c2luZyBJbnRsLlNlZ21lbnRlciBvciBvdGhlciB3b3JrYXJvdW5kcyB0aGF0IHN0cnVnZ2xlIHdpdGggd29yZCBzZWdtZW50c1xuICAgIC8vIGFuZCBsaW5lIHNlZ21lbnRzIChlc3BlY2lhbGx5IHdpdGggd29yZCB3cmFwcGluZyBhbmQgbm9uLVJvbWFuIGxhbmd1YWdlcykuXG4gICAgbW92ZU5hdGl2ZVNlbGVjdGlvbihkb21TZWxlY3Rpb24sIGFsdGVyLCBpc0JhY2t3YXJkID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJywgZ3JhbnVsYXJpdHkpO1xuICAgIC8vIEd1YXJkIGFnYWluc3Qgbm8gcmFuZ2VzXG4gICAgaWYgKGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgY29uc3QgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBET00gc2VsZWN0aW9uIHRvIG91ciBMZXhpY2FsIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCByb290ID0gJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgPyBhbmNob3JOb2RlIDogJGdldE5lYXJlc3RSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGUpO1xuICAgICAgdGhpcy5hcHBseURPTVJhbmdlKHJhbmdlKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKCFjb2xsYXBzZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSBzZWxlY3Rpb247IG1ha2Ugc3VyZSB0aGF0IHRoZSBuZXcgZXh0ZW5kZWQgc2VsZWN0aW9uIHJlc3BlY3RzIHNoYWRvdyByb290c1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICAgICAgY29uc3QgdmFsaWROb2RlcyA9IFtdO1xuICAgICAgICBsZXQgc2hyaW5rU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGlmICgkaGFzQW5jZXN0b3IobmV4dE5vZGUsIHJvb3QpKSB7XG4gICAgICAgICAgICB2YWxpZE5vZGVzLnB1c2gobmV4dE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaHJpbmtTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hyaW5rU2VsZWN0aW9uICYmIHZhbGlkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIHZhbGlkTm9kZXMgbGVuZ3RoIGNoZWNrIGlzIGEgc2FmZWd1YXJkIGFnYWluc3QgYW4gaW52YWxpZCBzZWxlY3Rpb247IGFzIGdldE5vZGVzKClcbiAgICAgICAgICAvLyB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheSBpbiB0aGlzIGNhc2VcbiAgICAgICAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RWYWxpZE5vZGUgPSB2YWxpZE5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0VmFsaWROb2RlKSkge1xuICAgICAgICAgICAgICBmaXJzdFZhbGlkTm9kZS5zZWxlY3RTdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlyc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RWYWxpZE5vZGUgPSB2YWxpZE5vZGVzW3ZhbGlkTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdFZhbGlkTm9kZSkpIHtcbiAgICAgICAgICAgICAgbGFzdFZhbGlkTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlY2F1c2UgYSByYW5nZSB3b3JrcyBvbiBzdGFydCBhbmQgZW5kLCB3ZSBtaWdodCBuZWVkIHRvIGZsaXBcbiAgICAgICAgLy8gdGhlIGFuY2hvciBhbmQgZm9jdXMgcG9pbnRzIHRvIG1hdGNoIHdoYXQgdGhlIERPTSBoYXMsIG5vdCB3aGF0XG4gICAgICAgIC8vIHRoZSByYW5nZSBoYXMgc3BlY2lmaWNhbGx5LlxuICAgICAgICBpZiAoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgIT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyIHx8IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQgIT09IHJhbmdlLnN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgJHN3YXBQb2ludHModGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgaGFuZGxpbmcgZm9yd2FyZCBjaGFyYWN0ZXIgYW5kIHdvcmQgZGVsZXRpb24gdGhhdCBwcmV2ZW50cyBlbGVtZW50IG5vZGVzXG4gICAqIGxpa2UgYSB0YWJsZSwgY29sdW1ucyBsYXlvdXQgYmVpbmcgZGVzdHJveWVkXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3IgdGhlIGFuY2hvclxuICAgKiBAcGFyYW0gYW5jaG9yTm9kZSB0aGUgYW5jaG9yIG5vZGUgaW4gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCBzZWxlY3Rpb24gaXMgYmFja3dhcmRzXG4gICAqL1xuICBmb3J3YXJkRGVsZXRpb24oYW5jaG9yLCBhbmNob3JOb2RlLCBpc0JhY2t3YXJkKSB7XG4gICAgaWYgKCFpc0JhY2t3YXJkICYmIChcbiAgICAvLyBEZWxldGUgZm9yd2FyZCBoYW5kbGUgY2FzZVxuICAgIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkgJiYgYW5jaG9yLm9mZnNldCA9PT0gYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKSB8fCBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvci5vZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5nKCkgfHwgKHBhcmVudCA9PT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKSk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpICYmIG5leHRTaWJsaW5nLmlzU2hhZG93Um9vdCgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgb25lIGxvZ2ljYWwgY2hhcmFjdGVyIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZUNoYXJhY3Rlcihpc0JhY2t3YXJkKSB7XG4gICAgY29uc3Qgd2FzQ29sbGFwc2VkID0gdGhpcy5pc0NvbGxhcHNlZCgpO1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgbGV0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMuZm9yd2FyZERlbGV0aW9uKGFuY2hvciwgYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgdGhlIGRlbGV0aW9uIGFyb3VuZCBkZWNvcmF0b3JzLlxuICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG4gICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpKSB7XG4gICAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gbW92ZSBzZWxlY3Rpb24gZnJvbSByYW5nZSBzZWxlY3Rpb24gdG9cbiAgICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICAgIGlmIChwb3NzaWJsZU5vZGUuaXNLZXlib2FyZFNlbGVjdGFibGUoKSAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgYW5jaG9yTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICBjb25zdCBub2RlU2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICBub2RlU2VsZWN0aW9uLmFkZChwb3NzaWJsZU5vZGUuX19rZXkpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zc2libGVOb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzQmFja3dhcmQgJiYgJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmlzRW1wdHkoKSkge1xuICAgICAgICBhbmNob3JOb2RlLnJlbW92ZSgpO1xuICAgICAgICBwb3NzaWJsZU5vZGUuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcbiAgICAgIGlmICghdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLnR5cGUgPT09ICd0ZXh0JyA/IGZvY3VzLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT09IG51bGwgJiYgZm9jdXNOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgY29uc3QgdGV4dENvbnRlbnRTaXplID0gZm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmIChmb2N1c05vZGUuaXMoYW5jaG9yTm9kZSkgfHwgaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICRyZW1vdmVTZWdtZW50KGZvY3VzTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCAmJiBhbmNob3JOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICAgICAgaWYgKGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKSB8fCBpc0JhY2t3YXJkICYmIG9mZnNldCAhPT0gMCB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSkge1xuICAgICAgICAgICAgJHJlbW92ZVNlZ21lbnQoYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHVwZGF0ZUNhcmV0U2VsZWN0aW9uRm9yVW5pY29kZUNoYXJhY3Rlcih0aGlzLCBpc0JhY2t3YXJkKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCYWNrd2FyZCAmJiBhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgYXJvdW5kIHJpY2ggdGV4dCBub2Rlc1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyA/IGFuY2hvci5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuY29sbGFwc2VBdFN0YXJ0KHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuICAgIGlmIChpc0JhY2t3YXJkICYmICF3YXNDb2xsYXBzZWQgJiYgdGhpcy5pc0NvbGxhcHNlZCgpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiB0aGlzLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoYW5jaG9yTm9kZS5pc0VtcHR5KCkgJiYgJGlzUm9vdE5vZGUoYW5jaG9yTm9kZS5nZXRQYXJlbnQoKSkgJiYgYW5jaG9yTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpID09PSAwKSB7XG4gICAgICAgIGFuY2hvck5vZGUuY29sbGFwc2VBdFN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCBsaW5lIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZUxpbmUoaXNCYWNrd2FyZCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIC8vIFNpbmNlIGBkb21TZWxlY3Rpb24ubW9kaWZ5KCdleHRlbmQnLCAuLi4sICdsaW5lYm91bmRhcnknKWAgd29ya3Mgd2VsbCBmb3IgdGV4dCBzZWxlY3Rpb25zXG4gICAgICAvLyBidXQgZG9lc24ndCBwcm9wZXJseSBoYW5kbGUgc2VsZWN0aW9ucyB3aGljaCBlbmQgb24gZWxlbWVudHMsIGEgc3BhY2UgY2hhcmFjdGVyIGlzIGFkZGVkXG4gICAgICAvLyBmb3Igc3VjaCBzZWxlY3Rpb25zIHRyYW5zZm9ybWluZyB0aGVpciBhbmNob3IncyB0eXBlIHRvICd0ZXh0J1xuICAgICAgY29uc3QgYW5jaG9ySXNFbGVtZW50ID0gdGhpcy5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnO1xuICAgICAgaWYgKGFuY2hvcklzRWxlbWVudCkge1xuICAgICAgICB0aGlzLmluc2VydFRleHQoJyAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kaWZ5KCdleHRlbmQnLCBpc0JhY2t3YXJkLCAnbGluZWJvdW5kYXJ5Jyk7XG5cbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBleHRlbmRlZCB0byBjb3ZlciB0ZXh0IGVkZ2UgdGhlbiBleHRlbmQgaXQgb25lIGNoYXJhY3RlciBtb3JlXG4gICAgICAvLyB0byBkZWxldGUgaXRzIHBhcmVudCBlbGVtZW50LiBPdGhlcndpc2UgdGV4dCBjb250ZW50IHdpbGwgYmUgZGVsZXRlZCBidXQgZW1wdHlcbiAgICAgIC8vIHBhcmVudCBub2RlIHdpbGwgcmVtYWluXG4gICAgICBjb25zdCBlbmRQb2ludCA9IGlzQmFja3dhcmQgPyB0aGlzLmZvY3VzIDogdGhpcy5hbmNob3I7XG4gICAgICBpZiAoZW5kUG9pbnQub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHRoaXMubW9kaWZ5KCdleHRlbmQnLCBpc0JhY2t3YXJkLCAnY2hhcmFjdGVyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkanVzdHMgc2VsZWN0aW9uIHRvIGluY2x1ZGUgYW4gZXh0cmEgY2hhcmFjdGVyIGFkZGVkIGZvciBlbGVtZW50IGFuY2hvcnMgdG8gcmVtb3ZlIGl0XG4gICAgICBpZiAoYW5jaG9ySXNFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBpc0JhY2t3YXJkID8gdGhpcy5hbmNob3IgOiB0aGlzLmZvY3VzO1xuICAgICAgICBzdGFydFBvaW50LnNldChzdGFydFBvaW50LmtleSwgc3RhcnRQb2ludC5vZmZzZXQgKyAxLCBzdGFydFBvaW50LnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZVRleHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCB3b3JkIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZVdvcmQoaXNCYWNrd2FyZCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAodGhpcy5mb3J3YXJkRGVsZXRpb24oYW5jaG9yLCBhbmNob3JOb2RlLCBpc0JhY2t3YXJkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGlmeSgnZXh0ZW5kJywgaXNCYWNrd2FyZCwgJ3dvcmQnKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVUZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJiYWNrd2FyZHNcIiwgbWVhbmluZyB0aGUgZm9jdXNcbiAgICogbG9naWNhbGx5IHByZWNlZGVzIHRoZSBhbmNob3IgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgYmFja3dhcmRzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzLmlzQmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfVxuICBnZXRTdGFydEVuZFBvaW50cygpIHtcbiAgICByZXR1cm4gW3RoaXMuYW5jaG9yLCB0aGlzLmZvY3VzXTtcbiAgfVxufVxuZnVuY3Rpb24gJGlzTm9kZVNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGdldENoYXJhY3Rlck9mZnNldChwb2ludCkge1xuICBjb25zdCBvZmZzZXQgPSBwb2ludC5vZmZzZXQ7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IHBvaW50LmdldE5vZGUoKTtcbiAgcmV0dXJuIG9mZnNldCA9PT0gcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID8gcGFyZW50LmdldFRleHRDb250ZW50KCkubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uICRnZXRDaGFyYWN0ZXJPZmZzZXRzKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAoYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IGFuY2hvckFuZEZvY3VzO1xuICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmtleSA9PT0gZm9jdXMua2V5ICYmIGFuY2hvci5vZmZzZXQgPT09IGZvY3VzLm9mZnNldCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgcmV0dXJuIFtnZXRDaGFyYWN0ZXJPZmZzZXQoYW5jaG9yKSwgZ2V0Q2hhcmFjdGVyT2Zmc2V0KGZvY3VzKV07XG59XG5mdW5jdGlvbiAkc3dhcFBvaW50cyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvci5rZXk7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGFuY2hvclR5cGUgPSBhbmNob3IudHlwZTtcbiAgJHNldFBvaW50VmFsdWVzKGFuY2hvciwgZm9jdXMua2V5LCBmb2N1cy5vZmZzZXQsIGZvY3VzLnR5cGUpO1xuICAkc2V0UG9pbnRWYWx1ZXMoZm9jdXMsIGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBhbmNob3JUeXBlKTtcbiAgc2VsZWN0aW9uLl9jYWNoZWROb2RlcyA9IG51bGw7XG59XG5mdW5jdGlvbiBtb3ZlTmF0aXZlU2VsZWN0aW9uKGRvbVNlbGVjdGlvbiwgYWx0ZXIsIGRpcmVjdGlvbiwgZ3JhbnVsYXJpdHkpIHtcbiAgLy8gU2VsZWN0aW9uLm1vZGlmeSgpIG1ldGhvZCBhcHBsaWVzIGEgY2hhbmdlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBvciBjdXJzb3IgcG9zaXRpb24sXG4gIC8vIGJ1dCBpcyBzdGlsbCBub24tc3RhbmRhcmQgaW4gc29tZSBicm93c2Vycy5cbiAgZG9tU2VsZWN0aW9uLm1vZGlmeShhbHRlciwgZGlyZWN0aW9uLCBncmFudWxhcml0eSk7XG59XG5mdW5jdGlvbiAkdXBkYXRlQ2FyZXRTZWxlY3Rpb25Gb3JVbmljb2RlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgaWYgKGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIC8vIEhhbmRsaW5nIG9mIG11bHRpYnl0ZSBjaGFyYWN0ZXJzXG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvck9mZnNldCA8IGZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCZWZvcmUgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBpc0JlZm9yZSA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgIGNvbnN0IGNoYXJhY3Rlck9mZnNldCA9IGVuZE9mZnNldCAtIDE7XG4gICAgaWYgKHN0YXJ0T2Zmc2V0ICE9PSBjaGFyYWN0ZXJPZmZzZXQpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICBpZiAoIWRvZXNDb250YWluR3JhcGhlbWUodGV4dCkpIHtcbiAgICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICBmb2N1cy5vZmZzZXQgPSBjaGFyYWN0ZXJPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yLm9mZnNldCA9IGNoYXJhY3Rlck9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHJlbW92ZVNlZ21lbnQobm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KSB7XG4gIGNvbnN0IHRleHROb2RlID0gbm9kZTtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBzcGxpdCA9IHRleHRDb250ZW50LnNwbGl0KC8oPz1cXHMpL2cpO1xuICBjb25zdCBzcGxpdExlbmd0aCA9IHNwbGl0Lmxlbmd0aDtcbiAgbGV0IHNlZ21lbnRPZmZzZXQgPSAwO1xuICBsZXQgcmVzdG9yZU9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXRMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRleHQgPSBzcGxpdFtpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSBzcGxpdExlbmd0aCAtIDE7XG4gICAgcmVzdG9yZU9mZnNldCA9IHNlZ21lbnRPZmZzZXQ7XG4gICAgc2VnbWVudE9mZnNldCArPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiBzZWdtZW50T2Zmc2V0ID09PSBvZmZzZXQgfHwgc2VnbWVudE9mZnNldCA+IG9mZnNldCB8fCBpc0xhc3QpIHtcbiAgICAgIHNwbGl0LnNwbGljZShpLCAxKTtcbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgcmVzdG9yZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXh0VGV4dENvbnRlbnQgPSBzcGxpdC5qb2luKCcnKS50cmltKCk7XG4gIGlmIChuZXh0VGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgdGV4dE5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dE5vZGUuc2V0VGV4dENvbnRlbnQobmV4dFRleHRDb250ZW50KTtcbiAgICB0ZXh0Tm9kZS5zZWxlY3QocmVzdG9yZU9mZnNldCwgcmVzdG9yZU9mZnNldCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlc29sdmVBbmNlc3RvcihyZXNvbHZlZEVsZW1lbnQsIHJlc29sdmVkT2Zmc2V0LCBsYXN0UG9pbnQpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudCgpO1xuICByZXR1cm4gbGFzdFBvaW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gbnVsbCB8fCAhcGFyZW50LmNhbkJlRW1wdHkoKSB8fCBwYXJlbnQgIT09IGxhc3RQb2ludC5nZXROb2RlKCk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnQoZG9tLCBvZmZzZXQsIGxhc3RQb2ludCwgZWRpdG9yKSB7XG4gIGxldCByZXNvbHZlZE9mZnNldCA9IG9mZnNldDtcbiAgbGV0IHJlc29sdmVkTm9kZTtcbiAgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gb24gYW4gZWxlbWVudCwgd2Ugd2lsbFxuICAvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgKHVzaW5nIHRoZSBvZmZzZXQpIHdoYXQgdGV4dFxuICAvLyBub2RlIHNob3VsZCBiZSBzZWxlY3RlZC5cblxuICBpZiAoZG9tLm5vZGVUeXBlID09PSBET01fRUxFTUVOVF9UWVBFKSB7XG4gICAgLy8gUmVzb2x2ZSBlbGVtZW50IHRvIGEgRWxlbWVudE5vZGUsIG9yIFRleHROb2RlLCBvciBudWxsXG4gICAgbGV0IG1vdmVTZWxlY3Rpb25Ub0VuZCA9IGZhbHNlO1xuICAgIC8vIEdpdmVuIHdlJ3JlIG1vdmluZyBzZWxlY3Rpb24gdG8gYW5vdGhlciBub2RlLCBzZWxlY3Rpb24gaXNcbiAgICAvLyBkZWZpbml0ZWx5IGRpcnR5LlxuICAgIC8vIFdlIHVzZSB0aGUgYW5jaG9yIHRvIGZpbmQgd2hpY2ggY2hpbGQgbm9kZSB0byBzZWxlY3RcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZG9tLmNoaWxkTm9kZXM7XG4gICAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgIC8vIElmIHRoZSBhbmNob3IgaXMgdGhlIHNhbWUgYXMgbGVuZ3RoLCB0aGVuIHRoaXMgbWVhbnMgd2VcbiAgICAvLyBuZWVkIHRvIHNlbGVjdCB0aGUgdmVyeSBsYXN0IHRleHQgbm9kZS5cbiAgICBpZiAocmVzb2x2ZWRPZmZzZXQgPT09IGNoaWxkTm9kZXNMZW5ndGgpIHtcbiAgICAgIG1vdmVTZWxlY3Rpb25Ub0VuZCA9IHRydWU7XG4gICAgICByZXNvbHZlZE9mZnNldCA9IGNoaWxkTm9kZXNMZW5ndGggLSAxO1xuICAgIH1cbiAgICBsZXQgY2hpbGRET00gPSBjaGlsZE5vZGVzW3Jlc29sdmVkT2Zmc2V0XTtcbiAgICBsZXQgaGFzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBpZiAoY2hpbGRET00gPT09IGJsb2NrQ3Vyc29yRWxlbWVudCkge1xuICAgICAgY2hpbGRET00gPSBjaGlsZE5vZGVzW3Jlc29sdmVkT2Zmc2V0ICsgMV07XG4gICAgICBoYXNCbG9ja0N1cnNvciA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudFBhcmVudCA9IGJsb2NrQ3Vyc29yRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKGRvbSA9PT0gYmxvY2tDdXJzb3JFbGVtZW50UGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yT2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChibG9ja0N1cnNvckVsZW1lbnRQYXJlbnQuY2hpbGRyZW4sIGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICAgIGlmIChvZmZzZXQgPiBibG9ja0N1cnNvck9mZnNldCkge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZWROb2RlID0gJGdldE5vZGVGcm9tRE9NKGNoaWxkRE9NKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocmVzb2x2ZWROb2RlKSkge1xuICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBnZXRUZXh0Tm9kZU9mZnNldChyZXNvbHZlZE5vZGUsIG1vdmVTZWxlY3Rpb25Ub0VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXNvbHZlZEVsZW1lbnQgPSAkZ2V0Tm9kZUZyb21ET00oZG9tKTtcbiAgICAgIC8vIEVuc3VyZSByZXNvbHZlZEVsZW1lbnQgaXMgYWN0dWFsbHkgYSBlbGVtZW50LlxuICAgICAgaWYgKHJlc29sdmVkRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gTWF0aC5taW4ocmVzb2x2ZWRFbGVtZW50LmdldENoaWxkcmVuU2l6ZSgpLCByZXNvbHZlZE9mZnNldCk7XG4gICAgICAgIGxldCBjaGlsZCA9IHJlc29sdmVkRWxlbWVudC5nZXRDaGlsZEF0SW5kZXgocmVzb2x2ZWRPZmZzZXQpO1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpICYmIHNob3VsZFJlc29sdmVBbmNlc3RvcihjaGlsZCwgcmVzb2x2ZWRPZmZzZXQsIGxhc3RQb2ludCkpIHtcbiAgICAgICAgICBjb25zdCBkZXNjZW5kYW50ID0gbW92ZVNlbGVjdGlvblRvRW5kID8gY2hpbGQuZ2V0TGFzdERlc2NlbmRhbnQoKSA6IGNoaWxkLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgIGlmIChkZXNjZW5kYW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlZEVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBkZXNjZW5kYW50O1xuICAgICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gJGlzRWxlbWVudE5vZGUoY2hpbGQpID8gY2hpbGQgOiBjaGlsZC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgcmVzb2x2ZWROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IGdldFRleHROb2RlT2Zmc2V0KGNoaWxkLCBtb3ZlU2VsZWN0aW9uVG9FbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkICE9PSByZXNvbHZlZEVsZW1lbnQgJiYgbW92ZVNlbGVjdGlvblRvRW5kICYmICFoYXNCbG9ja0N1cnNvcikge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVzb2x2ZWRFbGVtZW50LmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIC8vIFdoZW4gc2VsZWN0aW5nIGRlY29yYXRvcnMsIHRoZXJlIGNhbiBiZSBzb21lIHNlbGVjdGlvbiBpc3N1ZXMgd2hlbiB1c2luZyByZXNvbHZlZE9mZnNldCxcbiAgICAgICAgLy8gYW5kIGluc3RlYWQgd2Ugc2hvdWxkIGJlIGNoZWNraW5nIGlmIHdlJ3JlIHVzaW5nIHRoZSBvZmZzZXRcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCAmJiAkaXNEZWNvcmF0b3JOb2RlKHJlc29sdmVkRWxlbWVudCkgJiYgJGdldE5vZGVGcm9tRE9NKGRvbSkgPT09IHJlc29sdmVkRWxlbWVudCkge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiAkY3JlYXRlUG9pbnQocmVzb2x2ZWRFbGVtZW50Ll9fa2V5LCByZXNvbHZlZE9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGV4dE5vZGUgb3IgbnVsbFxuICAgIHJlc29sdmVkTm9kZSA9ICRnZXROb2RlRnJvbURPTShkb20pO1xuICB9XG4gIGlmICghJGlzVGV4dE5vZGUocmVzb2x2ZWROb2RlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAkY3JlYXRlUG9pbnQocmVzb2x2ZWROb2RlLl9fa2V5LCByZXNvbHZlZE9mZnNldCwgJ3RleHQnKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb25Qb2ludE9uQm91bmRhcnkocG9pbnQsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKSB7XG4gIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmICghaXNCYWNrd2FyZCkge1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSAmJiAhaXNDb2xsYXBzZWQgJiYgcHJldlNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsXG4gICAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgIWlzQmFja3dhcmQpICYmIHByZXZTaWJsaW5nID09PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBhcmVudCkgJiYgcGFyZW50LmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcGFyZW50U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcGFyZW50U2libGluZy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSBub2RlLmdldFRleHRDb250ZW50KCkubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiAkaXNFbGVtZW50Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgcG9pbnQua2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBwb2ludC5vZmZzZXQgPSAwO1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcbiAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgaXNCYWNrd2FyZCkgJiYgbmV4dFNpYmxpbmcgPT09IG51bGwgJiYgJGlzRWxlbWVudE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNJbmxpbmUoKSAmJiAhcGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcGFyZW50U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKGFuY2hvciwgZm9jdXMsIGxhc3RTZWxlY3Rpb24pIHtcbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgaXNDb2xsYXBzZWQgPSBhbmNob3IuaXMoZm9jdXMpO1xuXG4gICAgLy8gQXR0ZW1wdCB0byBub3JtYWxpemUgdGhlIG9mZnNldCB0byB0aGUgcHJldmlvdXMgc2libGluZyBpZiB3ZSdyZSBhdCB0aGVcbiAgICAvLyBzdGFydCBvZiBhIHRleHQgbm9kZSBhbmQgdGhlIHNpYmxpbmcgaXMgYSB0ZXh0IG5vZGUgb3IgaW5saW5lIGVsZW1lbnQuXG4gICAgcmVzb2x2ZVNlbGVjdGlvblBvaW50T25Cb3VuZGFyeShhbmNob3IsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKTtcbiAgICByZXNvbHZlU2VsZWN0aW9uUG9pbnRPbkJvdW5kYXJ5KGZvY3VzLCAhaXNCYWNrd2FyZCwgaXNDb2xsYXBzZWQpO1xuICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgZm9jdXMua2V5ID0gYW5jaG9yLmtleTtcbiAgICAgIGZvY3VzLm9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBmb2N1cy50eXBlID0gYW5jaG9yLnR5cGU7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSAmJiBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ICE9PSBhbmNob3Iua2V5ICYmICRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsYXN0QW5jaG9yID0gbGFzdFNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGFuY2hvciwgbGFzdEFuY2hvci5rZXksIGxhc3RBbmNob3Iub2Zmc2V0LCBsYXN0QW5jaG9yLnR5cGUpO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGZvY3VzLCBsYXN0Rm9jdXMua2V5LCBsYXN0Rm9jdXMub2Zmc2V0LCBsYXN0Rm9jdXMudHlwZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnRzKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0RPTSwgZm9jdXNPZmZzZXQsIGVkaXRvciwgbGFzdFNlbGVjdGlvbikge1xuICBpZiAoYW5jaG9yRE9NID09PSBudWxsIHx8IGZvY3VzRE9NID09PSBudWxsIHx8ICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRBbmNob3JQb2ludCA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludChhbmNob3JET00sIGFuY2hvck9mZnNldCwgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyBsYXN0U2VsZWN0aW9uLmFuY2hvciA6IG51bGwsIGVkaXRvcik7XG4gIGlmIChyZXNvbHZlZEFuY2hvclBvaW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRGb2N1c1BvaW50ID0gJGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50KGZvY3VzRE9NLCBmb2N1c09mZnNldCwgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyBsYXN0U2VsZWN0aW9uLmZvY3VzIDogbnVsbCwgZWRpdG9yKTtcbiAgaWYgKHJlc29sdmVkRm9jdXNQb2ludCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyZXNvbHZlZEFuY2hvclBvaW50LnR5cGUgPT09ICdlbGVtZW50JyAmJiByZXNvbHZlZEZvY3VzUG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXROb2RlRnJvbURPTShhbmNob3JET00pO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9ICRnZXROb2RlRnJvbURPTShmb2N1c0RPTSk7XG4gICAgLy8gRW5zdXJlIGlmIHdlJ3JlIHNlbGVjdGluZyB0aGUgY29udGVudCBvZiBhIGRlY29yYXRvciB0aGF0IHdlXG4gICAgLy8gcmV0dXJuIG51bGwgZm9yIHRoaXMgcG9pbnQsIGFzIGl0J3Mgbm90IGluIHRoZSBjb250cm9sbGVkIHNjb3BlXG4gICAgLy8gb2YgTGV4aWNhbC5cbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShhbmNob3JOb2RlKSAmJiAkaXNEZWNvcmF0b3JOb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBub3JtYWxpemF0aW9uIG9mIHNlbGVjdGlvbiB3aGVuIGl0IGlzIGF0IHRoZSBib3VuZGFyaWVzLlxuICAkbm9ybWFsaXplU2VsZWN0aW9uUG9pbnRzRm9yQm91bmRhcmllcyhyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnQsIGxhc3RTZWxlY3Rpb24pO1xuICByZXR1cm4gW3Jlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludF07XG59XG5mdW5jdGlvbiAkaXNCbG9ja0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCk7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBtYWtlIGEgc2VsZWN0aW9uIHdoZW4gdGhlIGV4aXN0aW5nXG4vLyBzZWxlY3Rpb24gaXMgbnVsbCwgaS5lLiBmb3JjaW5nIHNlbGVjdGlvbiBvbiB0aGUgZWRpdG9yXG4vLyB3aGVuIGl0IGN1cnJlbnQgZXhpc3RzIG91dHNpZGUgdGhlIGVkaXRvci5cblxuZnVuY3Rpb24gJGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0tleSwgZm9jdXNPZmZzZXQsIGFuY2hvclR5cGUsIGZvY3VzVHlwZSkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQoYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGFuY2hvclR5cGUpLCAkY3JlYXRlUG9pbnQoZm9jdXNLZXksIGZvY3VzT2Zmc2V0LCBmb2N1c1R5cGUpLCAwLCAnJyk7XG4gIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGFuY2hvciA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIGNvbnN0IGZvY3VzID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgcmV0dXJuIG5ldyBSYW5nZVNlbGVjdGlvbihhbmNob3IsIGZvY3VzLCAwLCAnJyk7XG59XG5mdW5jdGlvbiAkY3JlYXRlTm9kZVNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQoKSk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxDcmVhdGVTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBsYXN0U2VsZWN0aW9uID0gY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSB8fCBsYXN0U2VsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gJGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbiwgZG9tU2VsZWN0aW9uLCBlZGl0b3IsIG51bGwpO1xuICB9XG4gIHJldHVybiBsYXN0U2VsZWN0aW9uLmNsb25lKCk7XG59XG5mdW5jdGlvbiAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tKGRvbVNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIHJldHVybiAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihudWxsLCBkb21TZWxlY3Rpb24sIGVkaXRvciwgbnVsbCk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIGVkaXRvciwgZXZlbnQpIHtcbiAgY29uc3Qgd2luZG93T2JqID0gZWRpdG9yLl93aW5kb3c7XG4gIGlmICh3aW5kb3dPYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBXaGVuIHdlIGNyZWF0ZSBhIHNlbGVjdGlvbiwgd2UgdHJ5IHRvIHVzZSB0aGUgcHJldmlvdXNcbiAgLy8gc2VsZWN0aW9uIHdoZXJlIHBvc3NpYmxlLCB1bmxlc3MgYW4gYWN0dWFsIHVzZXIgc2VsZWN0aW9uXG4gIC8vIGNoYW5nZSBoYXMgb2NjdXJyZWQuIFdoZW4gd2UgZG8gbmVlZCB0byBjcmVhdGUgYSBuZXcgc2VsZWN0aW9uXG4gIC8vIHdlIHZhbGlkYXRlIHdlIGNhbiBoYXZlIHRleHQgbm9kZXMgZm9yIGJvdGggYW5jaG9yIGFuZCBmb2N1c1xuICAvLyBub2Rlcy4gSWYgdGhhdCBob2xkcyB0cnVlLCB3ZSB0aGVuIHJldHVybiB0aGF0IHNlbGVjdGlvblxuICAvLyBhcyBhIG11dGFibGUgb2JqZWN0IHRoYXQgd2UgdXNlIGZvciB0aGUgZWRpdG9yIHN0YXRlIGZvciB0aGlzXG4gIC8vIHVwZGF0ZSBjeWNsZS4gSWYgYSBzZWxlY3Rpb24gZ2V0cyBjaGFuZ2VkLCBhbmQgcmVxdWlyZXMgYVxuICAvLyB1cGRhdGUgdG8gbmF0aXZlIERPTSBzZWxlY3Rpb24sIGl0IGdldHMgbWFya2VkIGFzIFwiZGlydHlcIi5cbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBidXQgbWF0Y2hlcyB3aXRoIHRoZSBleGlzdGluZ1xuICAvLyBET00gc2VsZWN0aW9uLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBzeW5jIGl0LiBPdGhlcndpc2UsXG4gIC8vIHdlIGdlbmVyYWxseSBiYWlsIG91dCBvZiBkb2luZyBhbiB1cGRhdGUgdG8gc2VsZWN0aW9uIGR1cmluZ1xuICAvLyByZWNvbmNpbGlhdGlvbiB1bmxlc3MgdGhlcmUgYXJlIGRpcnR5IG5vZGVzIHRoYXQgbmVlZFxuICAvLyByZWNvbmNpbGluZy5cblxuICBjb25zdCB3aW5kb3dFdmVudCA9IGV2ZW50IHx8IHdpbmRvd09iai5ldmVudDtcbiAgY29uc3QgZXZlbnRUeXBlID0gd2luZG93RXZlbnQgPyB3aW5kb3dFdmVudC50eXBlIDogdW5kZWZpbmVkO1xuICBjb25zdCBpc1NlbGVjdGlvbkNoYW5nZSA9IGV2ZW50VHlwZSA9PT0gJ3NlbGVjdGlvbmNoYW5nZSc7XG4gIGNvbnN0IHVzZURPTVNlbGVjdGlvbiA9ICFnZXRJc1Byb2Nlc3NpbmdNdXRhdGlvbnMoKSAmJiAoaXNTZWxlY3Rpb25DaGFuZ2UgfHwgZXZlbnRUeXBlID09PSAnYmVmb3JlaW5wdXQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NvbXBvc2l0aW9uc3RhcnQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NvbXBvc2l0aW9uZW5kJyB8fCBldmVudFR5cGUgPT09ICdjbGljaycgJiYgd2luZG93RXZlbnQgJiYgd2luZG93RXZlbnQuZGV0YWlsID09PSAzIHx8IGV2ZW50VHlwZSA9PT0gJ2Ryb3AnIHx8IGV2ZW50VHlwZSA9PT0gdW5kZWZpbmVkKTtcbiAgbGV0IGFuY2hvckRPTSwgZm9jdXNET00sIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQ7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgfHwgdXNlRE9NU2VsZWN0aW9uKSB7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgIGZvY3VzRE9NID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICAgIGlmIChpc1NlbGVjdGlvbkNoYW5nZSAmJiAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSAmJiAhaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgICAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbiAgfVxuICAvLyBMZXQncyByZXNvbHZlIHRoZSB0ZXh0IG5vZGVzIGZyb20gdGhlIG9mZnNldHMgYW5kIERPTSBub2RlcyB3ZSBoYXZlIGZyb21cbiAgLy8gbmF0aXZlIHNlbGVjdGlvbi5cbiAgY29uc3QgcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPSAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnRzKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0RPTSwgZm9jdXNPZmZzZXQsIGVkaXRvciwgbGFzdFNlbGVjdGlvbik7XG4gIGlmIChyZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFtyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnRdID0gcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHM7XG4gIHJldHVybiBuZXcgUmFuZ2VTZWxlY3Rpb24ocmVzb2x2ZWRBbmNob3JQb2ludCwgcmVzb2x2ZWRGb2N1c1BvaW50LCAhJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyAwIDogbGFzdFNlbGVjdGlvbi5mb3JtYXQsICEkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/ICcnIDogbGFzdFNlbGVjdGlvbi5zdHlsZSk7XG59XG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGdldFByZXZpb3VzU2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50Tm9kZSwgbm9kZU9mZnNldCwgdGltZXMgPSAxKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoIXBhcmVudE5vZGUuaXMoYW5jaG9yTm9kZSkgJiYgIXBhcmVudE5vZGUuaXMoZm9jdXNOb2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnROb2RlLl9fa2V5O1xuICAvLyBTaW5nbGUgbm9kZS4gV2Ugc2hpZnQgc2VsZWN0aW9uIGJ1dCBuZXZlciByZWRpbWVuc2lvbiBpdFxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBjb25zdCBzZWxlY3Rpb25PZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGlmIChub2RlT2Zmc2V0IDw9IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA+IDAgfHwgbm9kZU9mZnNldCA8IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA8IDApIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbk9mZnNldCA9IE1hdGgubWF4KDAsIHNlbGVjdGlvbk9mZnNldCArIHRpbWVzKTtcbiAgICAgIGFuY2hvci5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICBmb2N1cy5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAvLyBUaGUgbmV3IHNlbGVjdGlvbiBtaWdodCBwb2ludCB0byB0ZXh0IG5vZGVzLCB0cnkgdG8gcmVzb2x2ZSB0aGVtXG4gICAgICAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBNdWx0aXBsZSBub2RlcyBzZWxlY3RlZC4gV2Ugc2hpZnQgb3IgcmVkaW1lbnNpb24gc2VsZWN0aW9uXG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGlzQmFja3dhcmQgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBmaXJzdFBvaW50Tm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGlzQmFja3dhcmQgPyBhbmNob3IgOiBmb2N1cztcbiAgICBjb25zdCBsYXN0UG9pbnROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcbiAgICBpZiAocGFyZW50Tm9kZS5pcyhmaXJzdFBvaW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0UG9pbnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICAgIGlmIChub2RlT2Zmc2V0IDw9IGZpcnN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPiAwIHx8IG5vZGVPZmZzZXQgPCBmaXJzdFBvaW50T2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgICBmaXJzdFBvaW50LnNldChwYXJlbnRLZXksIE1hdGgubWF4KDAsIGZpcnN0UG9pbnRPZmZzZXQgKyB0aW1lcyksICdlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlLmlzKGxhc3RQb2ludE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0UG9pbnRPZmZzZXQgPSBsYXN0UG9pbnQub2Zmc2V0O1xuICAgICAgaWYgKG5vZGVPZmZzZXQgPD0gbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzID4gMCB8fCBub2RlT2Zmc2V0IDwgbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgICBsYXN0UG9pbnQuc2V0KHBhcmVudEtleSwgTWF0aC5tYXgoMCwgbGFzdFBvaW50T2Zmc2V0ICsgdGltZXMpLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBUaGUgbmV3IHNlbGVjdGlvbiBtaWdodCBwb2ludCB0byB0ZXh0IG5vZGVzLCB0cnkgdG8gcmVzb2x2ZSB0aGVtXG4gICR1cGRhdGVTZWxlY3Rpb25SZXNvbHZlVGV4dE5vZGVzKHNlbGVjdGlvbik7XG59XG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0QXRFbmQgPSBhbmNob3JPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gYW5jaG9yT2Zmc2V0QXRFbmQgPyBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBhbmNob3Iuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0QXRFbmQgPSBhbmNob3JPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gYW5jaG9yT2Zmc2V0QXRFbmQgPyBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBhbmNob3Iuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRTaXplID0gZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0QXRFbmQgPSBmb2N1c09mZnNldCA+PSBjaGlsZFNpemU7XG4gICAgY29uc3QgY2hpbGQgPSBmb2N1c09mZnNldEF0RW5kID8gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGZvY3VzTm9kZS5nZXRDaGlsZEF0SW5kZXgoZm9jdXNPZmZzZXQpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuICAgICAgaWYgKGZvY3VzT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5U2VsZWN0aW9uVHJhbnNmb3JtcyhuZXh0RWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBwcmV2RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvciA9IG5leHRTZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gbmV4dFNlbGVjdGlvbi5mb2N1cztcbiAgICBsZXQgYW5jaG9yTm9kZTtcbiAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBhbmNob3JOb2RlLnNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKGFuY2hvck5vZGUgIT09IGZvY3VzTm9kZSkge1xuICAgICAgICBmb2N1c05vZGUuc2VsZWN0aW9uVHJhbnNmb3JtKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKHBvaW50LCBub2RlLCBwYXJlbnQsIHByZXZTaWJsaW5nLCBuZXh0U2libGluZykge1xuICBsZXQgc2libGluZ0tleSA9IG51bGw7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgIHNpYmxpbmdLZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBvZmZzZXQgPSBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIG9mZnNldCA9IHByZXZTaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgdHlwZSA9ICdlbGVtZW50JztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nS2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICB0eXBlID0gJ2VsZW1lbnQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2libGluZ0tleSAhPT0gbnVsbCAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgcG9pbnQuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAvLyBNb3ZlIHNlbGVjdGlvbiB0byBlbmQgb2YgcGFyZW50XG4gICAgICBvZmZzZXQgPSBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgfVxuICAgIHBvaW50LnNldChwYXJlbnQuX19rZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKHBvaW50LCBpc0JlZm9yZSwga2V5LCB0YXJnZXQsIHRleHRMZW5ndGgpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHBvaW50LmtleSA9IGtleTtcbiAgICBpZiAoIWlzQmVmb3JlKSB7XG4gICAgICBwb2ludC5vZmZzZXQgKz0gdGV4dExlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocG9pbnQub2Zmc2V0ID4gdGFyZ2V0LmdldEluZGV4V2l0aGluUGFyZW50KCkpIHtcbiAgICBwb2ludC5vZmZzZXQgLT0gMTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRE9NU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24sIGVkaXRvciwgZG9tU2VsZWN0aW9uLCB0YWdzLCByb290RWxlbWVudCwgbm9kZUNvdW50KSB7XG4gIGNvbnN0IGFuY2hvckRPTU5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgY29uc3QgZm9jdXNET01Ob2RlID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBkb21TZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gIC8vIFRPRE86IG1ha2UgdGhpcyBub3QgaGFyZC1jb2RlZCwgYW5kIGFkZCBhbm90aGVyIGNvbmZpZyBvcHRpb25cbiAgLy8gdGhhdCBtYWtlcyB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgaWYgKHRhZ3MuaGFzKCdjb2xsYWJvcmF0aW9uJykgJiYgYWN0aXZlRWxlbWVudCAhPT0gcm9vdEVsZW1lbnQgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dChhY3RpdmVFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgLy8gV2UgZG9uJ3QgcmVtb3ZlIHNlbGVjdGlvbiBpZiB0aGUgcHJldlNlbGVjdGlvbiBpcyBudWxsIGJlY2F1c2VcbiAgICAvLyBvZiBlZGl0b3Iuc2V0Um9vdEVsZW1lbnQoKS4gSWYgdGhpcyBvY2N1cnMgb24gaW5pdCB3aGVuIHRoZVxuICAgIC8vIGVkaXRvciBpcyBhbHJlYWR5IGZvY3VzZWQsIHRoZW4gdGhpcyBjYW4gY2F1c2UgdGhlIGVkaXRvciB0b1xuICAgIC8vIGxvc2UgZm9jdXMuXG4gICAgaWYgKHByZXZTZWxlY3Rpb24gIT09IG51bGwgJiYgaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET01Ob2RlLCBmb2N1c0RPTU5vZGUpKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBuZXh0U2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzLmtleTtcbiAgY29uc3QgYW5jaG9yRE9NID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGFuY2hvcktleSk7XG4gIGNvbnN0IGZvY3VzRE9NID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGZvY3VzS2V5KTtcbiAgY29uc3QgbmV4dEFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IG5leHRGb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgY29uc3QgbmV4dEZvcm1hdCA9IG5leHRTZWxlY3Rpb24uZm9ybWF0O1xuICBjb25zdCBuZXh0U3R5bGUgPSBuZXh0U2VsZWN0aW9uLnN0eWxlO1xuICBjb25zdCBpc0NvbGxhcHNlZCA9IG5leHRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKTtcbiAgbGV0IG5leHRBbmNob3JOb2RlID0gYW5jaG9yRE9NO1xuICBsZXQgbmV4dEZvY3VzTm9kZSA9IGZvY3VzRE9NO1xuICBsZXQgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSBmYWxzZTtcbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICBuZXh0QW5jaG9yTm9kZSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSBhbmNob3JOb2RlLmdldEZvcm1hdCgpICE9PSBuZXh0Rm9ybWF0IHx8IGFuY2hvck5vZGUuZ2V0U3R5bGUoKSAhPT0gbmV4dFN0eWxlO1xuICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGFuY2hvckZvcm1hdE9yU3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgfVxuICBpZiAoZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgbmV4dEZvY3VzTm9kZSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuXG4gIC8vIElmIHdlIGNhbid0IGdldCBhbiB1bmRlcmx5aW5nIHRleHQgbm9kZSBmb3Igc2VsZWN0aW9uLCB0aGVuXG4gIC8vIHdlIHNob3VsZCBhdm9pZCBzZXR0aW5nIHNlbGVjdGlvbiB0byBzb21ldGhpbmcgaW5jb3JyZWN0LlxuICBpZiAobmV4dEFuY2hvck5vZGUgPT09IG51bGwgfHwgbmV4dEZvY3VzTm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNDb2xsYXBzZWQgJiYgKHByZXZTZWxlY3Rpb24gPT09IG51bGwgfHwgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgfHwgJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgKHByZXZTZWxlY3Rpb24uZm9ybWF0ICE9PSBuZXh0Rm9ybWF0IHx8IHByZXZTZWxlY3Rpb24uc3R5bGUgIT09IG5leHRTdHlsZSkpKSB7XG4gICAgbWFya0NvbGxhcHNlZFNlbGVjdGlvbkZvcm1hdChuZXh0Rm9ybWF0LCBuZXh0U3R5bGUsIG5leHRBbmNob3JPZmZzZXQsIGFuY2hvcktleSwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICB9XG5cbiAgLy8gRGlmZiBhZ2FpbnN0IHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiB0byBlbnN1cmUgd2UgZG9uJ3QgZG9cbiAgLy8gYW4gdW5uZWNlc3Nhcnkgc2VsZWN0aW9uIHVwZGF0ZS4gV2UgYWxzbyBza2lwIHRoaXMgY2hlY2sgaWZcbiAgLy8gd2UncmUgbW92aW5nIHNlbGVjdGlvbiB0byB3aXRoaW4gYW4gZWxlbWVudCwgYXMgdGhpcyBjYW5cbiAgLy8gc29tZXRpbWVzIGJlIHByb2JsZW1hdGljIGFyb3VuZCBzY3JvbGxpbmcuXG4gIGlmIChhbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgJiYgZm9jdXNPZmZzZXQgPT09IG5leHRGb2N1c09mZnNldCAmJiBhbmNob3JET01Ob2RlID09PSBuZXh0QW5jaG9yTm9kZSAmJiBmb2N1c0RPTU5vZGUgPT09IG5leHRGb2N1c05vZGUgJiZcbiAgLy8gQmFkbHkgaW50ZXJwcmV0ZWQgcmFuZ2Ugc2VsZWN0aW9uIHdoZW4gY29sbGFwc2VkIC0gIzE0ODJcbiAgIShkb21TZWxlY3Rpb24udHlwZSA9PT0gJ1JhbmdlJyAmJiBpc0NvbGxhcHNlZCkpIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBlbGVtZW50IGRvZXMgbm90IGhhdmUgZm9jdXMsIGVuc3VyZSBpdCBoYXMgZm9jdXNcbiAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gbnVsbCB8fCAhcm9vdEVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHJvb3RFbGVtZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmNob3IudHlwZSAhPT0gJ2VsZW1lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwbHkgdGhlIHVwZGF0ZWQgc2VsZWN0aW9uIHRvIHRoZSBET00uIE5vdGU6IHRoaXMgd2lsbCB0cmlnZ2VyXG4gIC8vIGEgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCwgYWx0aG91Z2ggaXQgd2lsbCBiZSBhc3luY2hyb25vdXMuXG4gIHRyeSB7XG4gICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV4dEFuY2hvck5vZGUsIG5leHRBbmNob3JPZmZzZXQsIG5leHRGb2N1c05vZGUsIG5leHRGb2N1c09mZnNldCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVycm9yLCBjb250aW51ZS4gVGhpcyBjYW4gc29tZXRpbWVzXG4gICAgLy8gb2NjdXIgd2l0aCBGRiBhbmQgdGhlcmUncyBubyBnb29kIHJlYXNvbiBhcyB0byB3aHkgaXRcbiAgICAvLyBzaG91bGQgaGFwcGVuLlxuICAgIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgfVxuICB9XG4gIGlmICghdGFncy5oYXMoJ3NraXAtc2Nyb2xsLWludG8tdmlldycpICYmIG5leHRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiByb290RWxlbWVudCAhPT0gbnVsbCAmJiByb290RWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdGlvblRhcmdldCA9IG5leHRTZWxlY3Rpb24gaW5zdGFuY2VvZiBSYW5nZVNlbGVjdGlvbiAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgPyBuZXh0QW5jaG9yTm9kZS5jaGlsZE5vZGVzW25leHRBbmNob3JPZmZzZXRdIHx8IG51bGwgOiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDAgPyBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG4gICAgaWYgKHNlbGVjdGlvblRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgbGV0IHNlbGVjdGlvblJlY3Q7XG4gICAgICBpZiAoc2VsZWN0aW9uVGFyZ2V0IGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoc2VsZWN0aW9uVGFyZ2V0KTtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWRpdG9yLCBzZWxlY3Rpb25SZWN0LCByb290RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIG1hcmtTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlKCk7XG59XG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgbGV0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSB8fCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbiA9ICRnZXRSb290KCkuc2VsZWN0RW5kKCk7XG4gIH1cbiAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbn1cbmZ1bmN0aW9uICRnZXRUZXh0Q29udGVudCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVUZXh0QW5kU3BsaXRCbG9jayhzZWxlY3Rpb24pIHtcbiAgbGV0IHNlbGVjdGlvbl8gPSBzZWxlY3Rpb247XG4gIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBzZWxlY3Rpb25fLnJlbW92ZVRleHQoKTtcbiAgfVxuICAvLyBBIG5ldyBzZWxlY3Rpb24gY2FuIG9yaWdpbmF0ZSBhcyBhIHJlc3VsdCBvZiBub2RlIHJlcGxhY2VtZW50LCBpbiB3aGljaCBjYXNlIGlzIHJlZ2lzdGVyZWQgdmlhXG4gIC8vICRzZXRTZWxlY3Rpb25cbiAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24obmV3U2VsZWN0aW9uKSkge1xuICAgIHNlbGVjdGlvbl8gPSBuZXdTZWxlY3Rpb247XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb25fKSkge1xuICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIGRpcnR5IHNlbGVjdGlvbiB0byBiZSBudWxsYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uXy5hbmNob3I7XG4gIGxldCBub2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIHdoaWxlICghSU5URVJOQUxfJGlzQmxvY2sobm9kZSkpIHtcbiAgICBbbm9kZSwgb2Zmc2V0XSA9ICRzcGxpdE5vZGVBdFBvaW50KG5vZGUsIG9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGVBdFBvaW50KG5vZGUsIG9mZnNldCkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAoIXBhcmVudCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgJGdldFJvb3QoKS5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICBwYXJhZ3JhcGguc2VsZWN0KCk7XG4gICAgcmV0dXJuIFskZ2V0Um9vdCgpLCAwXTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzcGxpdCA9IG5vZGUuc3BsaXRUZXh0KG9mZnNldCk7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtwYXJlbnQsIG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKV07XG4gICAgfVxuICAgIGNvbnN0IHggPSBvZmZzZXQgPT09IDAgPyAwIDogMTtcbiAgICBjb25zdCBpbmRleCA9IHNwbGl0WzBdLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyB4O1xuICAgIHJldHVybiBbcGFyZW50LCBpbmRleF07XG4gIH1cbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCBvZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gW3BhcmVudCwgbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpXTtcbiAgfVxuICBjb25zdCBmaXJzdFRvQXBwZW5kID0gbm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgaWYgKGZpcnN0VG9BcHBlbmQpIHtcbiAgICBjb25zdCBpbnNlcnRQb2ludCA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQobm9kZS5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpLCAkY3JlYXRlUG9pbnQobm9kZS5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpLCAwLCAnJyk7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IG5vZGUuaW5zZXJ0TmV3QWZ0ZXIoaW5zZXJ0UG9pbnQpO1xuICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICBuZXdFbGVtZW50LmFwcGVuZChmaXJzdFRvQXBwZW5kLCAuLi5maXJzdFRvQXBwZW5kLmdldE5leHRTaWJsaW5ncygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwYXJlbnQsIG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDFdO1xufVxuZnVuY3Rpb24gJHdyYXBJbmxpbmVOb2Rlcyhub2Rlcykge1xuICAvLyBXZSB0ZW1wb3JhcmlseSBpbnNlcnQgdGhlIHRvcExldmVsTm9kZXMgaW50byBhbiBhcmJpdHJhcnkgRWxlbWVudE5vZGUsXG4gIC8vIHNpbmNlIGluc2VydEFmdGVyIGRvZXMgbm90IHdvcmsgb24gbm9kZXMgdGhhdCBoYXZlIG5vIHBhcmVudCAoVE8tRE86IGZpeCB0aGF0KS5cbiAgY29uc3QgdmlydHVhbFJvb3QgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBsZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBjb25zdCBpc0xpbmVCcmVha05vZGUgPSAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpO1xuICAgIGlmIChpc0xpbmVCcmVha05vZGUgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc1RleHROb2RlKG5vZGUpIHx8IG5vZGUuaXNQYXJlbnRSZXF1aXJlZCgpKSB7XG4gICAgICBpZiAoY3VycmVudEJsb2NrID09PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jayA9IG5vZGUuY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKTtcbiAgICAgICAgdmlydHVhbFJvb3QuYXBwZW5kKGN1cnJlbnRCbG9jayk7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIExpbmVCcmVha05vZGUsIHdlIGp1c3QgbmVlZCB0b1xuICAgICAgICAvLyBhZGQgYW4gZW1wdHkgUGFyYWdyYXBoTm9kZSB0byB0aGUgdG9wTGV2ZWxCbG9ja3MuXG4gICAgICAgIGlmIChpc0xpbmVCcmVha05vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRCbG9jayAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50QmxvY2suYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aXJ0dWFsUm9vdC5hcHBlbmQobm9kZSk7XG4gICAgICBjdXJyZW50QmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmlydHVhbFJvb3Q7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxubGV0IGFjdGl2ZUVkaXRvclN0YXRlID0gbnVsbDtcbmxldCBhY3RpdmVFZGl0b3IgPSBudWxsO1xubGV0IGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG5sZXQgaXNBdHRlbXB0aW5nVG9SZWNvdmVyRnJvbVJlY29uY2lsZXJFcnJvciA9IGZhbHNlO1xubGV0IGluZmluaXRlVHJhbnNmb3JtQ291bnQgPSAwO1xuY29uc3Qgb2JzZXJ2ZXJPcHRpb25zID0ge1xuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG5mdW5jdGlvbiBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpIHtcbiAgcmV0dXJuIGlzUmVhZE9ubHlNb2RlIHx8IGFjdGl2ZUVkaXRvclN0YXRlICE9PSBudWxsICYmIGFjdGl2ZUVkaXRvclN0YXRlLl9yZWFkT25seTtcbn1cbmZ1bmN0aW9uIGVycm9yT25SZWFkT25seSgpIHtcbiAgaWYgKGlzUmVhZE9ubHlNb2RlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCB1c2UgbWV0aG9kIGluIHJlYWQtb25seSBtb2RlLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPbkluZmluaXRlVHJhbnNmb3JtcygpIHtcbiAgaWYgKGluZmluaXRlVHJhbnNmb3JtQ291bnQgPiA5OSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBPbmUgb3IgbW9yZSB0cmFuc2Zvcm1zIGFyZSBlbmRsZXNzbHkgdHJpZ2dlcmluZyBhZGRpdGlvbmFsIHRyYW5zZm9ybXMuIE1heSBoYXZlIGVuY291bnRlcmVkIGluZmluaXRlIHJlY3Vyc2lvbiBjYXVzZWQgYnkgdHJhbnNmb3JtcyB0aGF0IGhhdmUgdGhlaXIgcHJlY29uZGl0aW9ucyB0b28gbG9zZSBhbmQvb3IgY29uZmxpY3Qgd2l0aCBlYWNoIG90aGVyLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKSB7XG4gIGlmIChhY3RpdmVFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBhbiBhY3RpdmUgZWRpdG9yIHN0YXRlLiBTdGF0ZSBoZWxwZXJzIG9yIG5vZGUgbWV0aG9kcyBjYW4gb25seSBiZSB1c2VkIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSBjYWxsYmFjayBvZiBlZGl0b3IudXBkYXRlKCkgb3IgZWRpdG9yU3RhdGUucmVhZCgpLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWN0aXZlRWRpdG9yU3RhdGU7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVFZGl0b3IoKSB7XG4gIGlmIChhY3RpdmVFZGl0b3IgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYW4gYWN0aXZlIGVkaXRvci4gVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBzeW5jaHJvbm91c2x5IGR1cmluZyB0aGUgY2FsbGJhY2sgb2YgZWRpdG9yLnVwZGF0ZSgpLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWN0aXZlRWRpdG9yO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxHZXRBY3RpdmVFZGl0b3IoKSB7XG4gIHJldHVybiBhY3RpdmVFZGl0b3I7XG59XG5mdW5jdGlvbiBpbnRlcm5hbEdldEFjdGl2ZUVkaXRvclN0YXRlKCkge1xuICByZXR1cm4gYWN0aXZlRWRpdG9yU3RhdGU7XG59XG5mdW5jdGlvbiAkYXBwbHlUcmFuc2Zvcm1zKGVkaXRvciwgbm9kZSwgdHJhbnNmb3Jtc0NhY2hlKSB7XG4gIGNvbnN0IHR5cGUgPSBub2RlLl9fdHlwZTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBnZXRSZWdpc3RlcmVkTm9kZU9yVGhyb3coZWRpdG9yLCB0eXBlKTtcbiAgbGV0IHRyYW5zZm9ybXNBcnIgPSB0cmFuc2Zvcm1zQ2FjaGUuZ2V0KHR5cGUpO1xuICBpZiAodHJhbnNmb3Jtc0FyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNmb3Jtc0FyciA9IEFycmF5LmZyb20ocmVnaXN0ZXJlZE5vZGUudHJhbnNmb3Jtcyk7XG4gICAgdHJhbnNmb3Jtc0NhY2hlLnNldCh0eXBlLCB0cmFuc2Zvcm1zQXJyKTtcbiAgfVxuICBjb25zdCB0cmFuc2Zvcm1zQXJyTGVuZ3RoID0gdHJhbnNmb3Jtc0Fyci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3Jtc0Fyckxlbmd0aDsgaSsrKSB7XG4gICAgdHJhbnNmb3Jtc0FycltpXShub2RlKTtcbiAgICBpZiAoIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRpc05vZGVWYWxpZEZvclRyYW5zZm9ybShub2RlLCBjb21wb3NpdGlvbktleSkge1xuICByZXR1cm4gbm9kZSAhPT0gdW5kZWZpbmVkICYmXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhbnNmb3JtIG5vZGVzIGJlaW5nIGNvbXBvc2VkXG4gIG5vZGUuX19rZXkgIT09IGNvbXBvc2l0aW9uS2V5ICYmIG5vZGUuaXNBdHRhY2hlZCgpO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZUFsbERpcnR5VGV4dE5vZGVzKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkgJiYgbm9kZS5pc0F0dGFjaGVkKCkgJiYgbm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICAgICRub3JtYWxpemVUZXh0Tm9kZShub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gaGV1cmlzdGljOlxuICogMS4gV2UgdHJhbnNmb3JtIGxlYXZlcyBmaXJzdC4gSWYgdHJhbnNmb3JtcyBnZW5lcmF0ZSBhZGRpdGlvbmFsIGRpcnR5IG5vZGVzIHdlIHJlcGVhdCBzdGVwIDEuXG4gKiBUaGUgcmVhc29uaW5nIGJlaGluZCB0aGlzIGlzIHRoYXQgbWFya2luZyBhIGxlYWYgYXMgZGlydHkgbWFya3MgYWxsIGl0cyBwYXJlbnQgZWxlbWVudHMgYXMgZGlydHkgdG9vLlxuICogMi4gV2UgdHJhbnNmb3JtIGVsZW1lbnRzLiBJZiBlbGVtZW50IHRyYW5zZm9ybXMgZ2VuZXJhdGUgYWRkaXRpb25hbCBkaXJ0eSBub2RlcyB3ZSByZXBlYXQgc3RlcCAxLlxuICogSWYgZWxlbWVudCB0cmFuc2Zvcm1zIG9ubHkgZ2VuZXJhdGUgYWRkaXRpb25hbCBkaXJ0eSBlbGVtZW50cyB3ZSBvbmx5IHJlcGVhdCBzdGVwIDIuXG4gKlxuICogTm90ZSB0aGF0IHRvIGtlZXAgdHJhY2sgb2YgbmV3bHkgZGlydHkgbm9kZXMgYW5kIHN1YnRyZWVzIHdlIGxldmVyYWdlIHRoZSBlZGl0b3IuX2RpcnR5Tm9kZXMgYW5kXG4gKiBlZGl0b3IuX3N1YnRyZWVzIHdoaWNoIHdlIHJlc2V0IGluIGV2ZXJ5IGxvb3AuXG4gKi9cbmZ1bmN0aW9uICRhcHBseUFsbFRyYW5zZm9ybXMoZWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gIGNvbnN0IGRpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgY29uc3QgdHJhbnNmb3Jtc0NhY2hlID0gbmV3IE1hcCgpO1xuICBsZXQgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzID0gZGlydHlMZWF2ZXM7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTtcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzID0gZGlydHlFbGVtZW50cztcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMuc2l6ZTtcbiAgd2hpbGUgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDAgfHwgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHNMZW5ndGggPiAwKSB7XG4gICAgaWYgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDApIHtcbiAgICAgIC8vIFdlIGxldmVyYWdlIGVkaXRvci5fZGlydHlMZWF2ZXMgdG8gdHJhY2sgdGhlIG5ldyBkaXJ0eSBsZWF2ZXMgYWZ0ZXIgdGhlIHRyYW5zZm9ybXNcbiAgICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaXNBdHRhY2hlZCgpICYmIG5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgICAgICAgJG5vcm1hbGl6ZVRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgJGlzTm9kZVZhbGlkRm9yVHJhbnNmb3JtKG5vZGUsIGNvbXBvc2l0aW9uS2V5KSkge1xuICAgICAgICAgICRhcHBseVRyYW5zZm9ybXMoZWRpdG9yLCBub2RlLCB0cmFuc2Zvcm1zQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGRpcnR5TGVhdmVzLmFkZChub2RlS2V5KTtcbiAgICAgIH1cbiAgICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTtcblxuICAgICAgLy8gV2Ugd2FudCB0byBwcmlvcml0aXplIG5vZGUgdHJhbnNmb3JtcyBvdmVyIGVsZW1lbnQgdHJhbnNmb3Jtc1xuICAgICAgaWYgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDApIHtcbiAgICAgICAgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGwgZGlydHkgbGVhdmVzIGhhdmUgYmVlbiBwcm9jZXNzZWQuIExldCdzIGRvIGVsZW1lbnRzIVxuICAgIC8vIFdlIGhhdmUgcHJldmlvdXNseSBwcm9jZXNzZWQgZGlydHkgbGVhdmVzLCBzbyBsZXQncyByZXN0YXJ0IHRoZSBlZGl0b3IgbGVhdmVzIFNldCB0byB0cmFja1xuICAgIC8vIG5ldyBvbmVzIGNhdXNlZCBieSBlbGVtZW50IHRyYW5zZm9ybXNcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRVbnRyYW5zZm9ybWVkRGlydHlFbGVtZW50IG9mIHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBub2RlS2V5ID0gY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRbMF07XG4gICAgICBjb25zdCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSA9IGN1cnJlbnRVbnRyYW5zZm9ybWVkRGlydHlFbGVtZW50WzFdO1xuICAgICAgaWYgKG5vZGVLZXkgIT09ICdyb290JyAmJiAhaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICRpc05vZGVWYWxpZEZvclRyYW5zZm9ybShub2RlLCBjb21wb3NpdGlvbktleSkpIHtcbiAgICAgICAgJGFwcGx5VHJhbnNmb3JtcyhlZGl0b3IsIG5vZGUsIHRyYW5zZm9ybXNDYWNoZSk7XG4gICAgICB9XG4gICAgICBkaXJ0eUVsZW1lbnRzLnNldChub2RlS2V5LCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSk7XG4gICAgfVxuICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzLnNpemU7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cy5zaXplO1xuICAgIGluZmluaXRlVHJhbnNmb3JtQ291bnQrKztcbiAgfVxuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gZGlydHlMZWF2ZXM7XG4gIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IGRpcnR5RWxlbWVudHM7XG59XG5mdW5jdGlvbiAkcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSkge1xuICBjb25zdCBpbnRlcm5hbFNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGU7XG4gIHJldHVybiAkcGFyc2VTZXJpYWxpemVkTm9kZUltcGwoaW50ZXJuYWxTZXJpYWxpemVkTm9kZSwgZ2V0QWN0aXZlRWRpdG9yKCkuX25vZGVzKTtcbn1cbmZ1bmN0aW9uICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChzZXJpYWxpemVkTm9kZSwgcmVnaXN0ZXJlZE5vZGVzKSB7XG4gIGNvbnN0IHR5cGUgPSBzZXJpYWxpemVkTm9kZS50eXBlO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHJlZ2lzdGVyZWROb2Rlcy5nZXQodHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHBhcnNlRWRpdG9yU3RhdGU6IHR5cGUgXCIke3R5cGV9XCIgKyBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9kZUNsYXNzID0gcmVnaXN0ZXJlZE5vZGUua2xhc3M7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaW1wb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICBjb25zdCBub2RlID0gbm9kZUNsYXNzLmltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpO1xuICBjb25zdCBjaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkSlNPTkNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWRKU09OQ2hpbGROb2RlLCByZWdpc3RlcmVkTm9kZXMpO1xuICAgICAgbm9kZS5hcHBlbmQoY2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBwYXJzZUVkaXRvclN0YXRlKHNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSwgZWRpdG9yLCB1cGRhdGVGbikge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNEaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBwcmV2aW91c0RpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgY29uc3QgcHJldmlvdXNDbG9uZU5vdE5lZWRlZCA9IGVkaXRvci5fY2xvbmVOb3ROZWVkZWQ7XG4gIGNvbnN0IHByZXZpb3VzRGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZCA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSAwO1xuICBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGVzID0gZWRpdG9yLl9ub2RlcztcbiAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZWRFZGl0b3JTdGF0ZS5yb290O1xuICAgICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChzZXJpYWxpemVkTm9kZSwgcmVnaXN0ZXJlZE5vZGVzKTtcbiAgICBpZiAodXBkYXRlRm4pIHtcbiAgICAgIHVwZGF0ZUZuKCk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgZWRpdG9yU3RhdGUgaW1tdXRhYmxlXG4gICAgZWRpdG9yU3RhdGUuX3JlYWRPbmx5ID0gdHJ1ZTtcbiAgICB7XG4gICAgICBoYW5kbGVERVZPbmx5UGVuZGluZ1VwZGF0ZUd1YXJhbnRlZXMoZWRpdG9yU3RhdGUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZWRpdG9yLl9vbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gcHJldmlvdXNEaXJ0eUVsZW1lbnRzO1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBwcmV2aW91c0RpcnR5TGVhdmVzO1xuICAgIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQgPSBwcmV2aW91c0Nsb25lTm90TmVlZGVkO1xuICAgIGVkaXRvci5fZGlydHlUeXBlID0gcHJldmlvdXNEaXJ0eVR5cGU7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIGlzUmVhZE9ubHlNb2RlID0gcHJldmlvdXNSZWFkT25seU1vZGU7XG4gICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gIH1cbiAgcmV0dXJuIGVkaXRvclN0YXRlO1xufVxuXG4vLyBUaGlzIHRlY2huaWNhbGx5IGlzbid0IGFuIHVwZGF0ZSBidXQgZ2l2ZW4gd2UgbmVlZFxuLy8gZXhwb3N1cmUgdG8gdGhlIG1vZHVsZSdzIGFjdGl2ZSBiaW5kaW5ncywgd2UgaGF2ZSB0aGlzXG4vLyBmdW5jdGlvbiBoZXJlXG5cbmZ1bmN0aW9uIHJlYWRFZGl0b3JTdGF0ZShlZGl0b3JTdGF0ZSwgY2FsbGJhY2tGbikge1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IHRydWU7XG4gIGFjdGl2ZUVkaXRvciA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrRm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlREVWT25seVBlbmRpbmdVcGRhdGVHdWFyYW50ZWVzKHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICAvLyBHaXZlbiB3ZSBjYW4ndCBPYmplY3QuZnJlZXplIHRoZSBub2RlTWFwIGFzIGl0J3MgYSBNYXAsXG4gIC8vIHdlIGluc3RlYWQgcmVwbGFjZSBpdHMgc2V0LCBjbGVhciBhbmQgZGVsZXRlIG1ldGhvZHMuXG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIG5vZGVNYXAuc2V0ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgc2V0KCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xuICBub2RlTWFwLmNsZWFyID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgY2xlYXIoKSBvbiBhIGZyb3plbiBMZXhpY2FsIG5vZGUgbWFwJyk7XG4gIH07XG4gIG5vZGVNYXAuZGVsZXRlID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgZGVsZXRlKCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xufVxuZnVuY3Rpb24gJGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvciwgcmVjb3ZlcnlFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICBjb25zdCBzaG91bGRTa2lwRE9NID0gZWRpdG9yLl9oZWFkbGVzcyB8fCByb290RWxlbWVudCA9PT0gbnVsbDtcbiAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vID09PT09PVxuICAvLyBSZWNvbmNpbGlhdGlvbiBoYXMgc3RhcnRlZC5cbiAgLy8gPT09PT09XG5cbiAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IG5lZWRzVXBkYXRlID0gZWRpdG9yLl9kaXJ0eVR5cGUgIT09IE5PX0RJUlRZX05PREVTO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGxldCBtdXRhdGVkTm9kZXMgPSBudWxsO1xuICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gIGVkaXRvci5fZWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlmICghc2hvdWxkU2tpcERPTSAmJiBuZWVkc1VwZGF0ZSAmJiBvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdXBkYXRlcyB0byBzeW5jIGJsb2NrIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gICAgICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgICAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRlZE5vZGVzID0gJHJlY29uY2lsZVJvb3QoY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvciwgZGlydHlUeXBlLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFJlcG9ydCBlcnJvcnNcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVkaXRvci5fb25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IGVkaXRvciBhbmQgcmVzdG9yZSBpbmNvbWluZyBlZGl0b3Igc3RhdGUgdG8gdGhlIERPTVxuICAgICAgaWYgKCFpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yKSB7XG4gICAgICAgIHJlc2V0RWRpdG9yKGVkaXRvciwgbnVsbCwgcm9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gICAgICAgIGluaXRNdXRhdGlvbk9ic2VydmVyKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgICAgIGlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IgPSB0cnVlO1xuICAgICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICBpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUbyBhdm9pZCBhIHBvc3NpYmxlIHNpdHVhdGlvbiBvZiBpbmZpbml0ZSBsb29wcywgbGV0cyB0aHJvd1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgfVxuICB9XG4gIGlmICghcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHtcbiAgICAgIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUocGVuZGluZ1NlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHBlbmRpbmdTZWxlY3Rpb24uZm9jdXMpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBub3JtYWxpemVkTm9kZXMgPSBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcztcbiAgY29uc3QgdGFncyA9IGVkaXRvci5fdXBkYXRlVGFncztcbiAgY29uc3QgZGVmZXJyZWQgPSBlZGl0b3IuX2RlZmVycmVkO1xuICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICAgIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQuY2xlYXIoKTtcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gIH1cbiAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKTtcblxuICAvLyA9PT09PT1cbiAgLy8gUmVjb25jaWxpYXRpb24gaGFzIGZpbmlzaGVkLiBOb3cgdXBkYXRlIHNlbGVjdGlvbiBhbmQgdHJpZ2dlciBsaXN0ZW5lcnMuXG4gIC8vID09PT09PVxuXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IHNob3VsZFNraXBET00gPyBudWxsIDogZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICAvLyBBdHRlbXB0IHRvIHVwZGF0ZSB0aGUgRE9NIHNlbGVjdGlvbiwgaW5jbHVkaW5nIGZvY3VzaW5nIG9mIHRoZSByb290IGVsZW1lbnQsXG4gIC8vIGFuZCBzY3JvbGwgaW50byB2aWV3IGlmIG5lZWRlZC5cbiAgaWYgKGVkaXRvci5fZWRpdGFibGUgJiZcbiAgLy8gZG9tU2VsZWN0aW9uIHdpbGwgYmUgbnVsbCBpbiBoZWFkbGVzc1xuICBkb21TZWxlY3Rpb24gIT09IG51bGwgJiYgKG5lZWRzVXBkYXRlIHx8IHBlbmRpbmdTZWxlY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSkpIHtcbiAgICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNVcGRhdGUgfHwgcGVuZGluZ1NlbGVjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nU2VsZWN0aW9uLmRpcnR5KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgICAgICBpZiAoYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlRE9NU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24sIHBlbmRpbmdTZWxlY3Rpb24sIGVkaXRvciwgZG9tU2VsZWN0aW9uLCB0YWdzLCByb290RWxlbWVudCk7XG4gICAgICB9XG4gICAgICB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgcGVuZGluZ1NlbGVjdGlvbik7XG4gICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgfVxuICB9XG4gIGlmIChtdXRhdGVkTm9kZXMgIT09IG51bGwpIHtcbiAgICB0cmlnZ2VyTXV0YXRpb25MaXN0ZW5lcnMoZWRpdG9yLCBtdXRhdGVkTm9kZXMsIHRhZ3MsIGRpcnR5TGVhdmVzLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICB9XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24ocGVuZGluZ1NlbGVjdGlvbikgJiYgcGVuZGluZ1NlbGVjdGlvbiAhPT0gbnVsbCAmJiAoY3VycmVudFNlbGVjdGlvbiA9PT0gbnVsbCB8fCAhY3VycmVudFNlbGVjdGlvbi5pcyhwZW5kaW5nU2VsZWN0aW9uKSkpIHtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcbiAgICogQ2FwdHVyZSBwZW5kaW5nRGVjb3JhdG9ycyBhZnRlciBnYXJiYWdlIGNvbGxlY3RpbmcgZGV0YWNoZWQgZGVjb3JhdG9yc1xuICAgKi9cbiAgY29uc3QgcGVuZGluZ0RlY29yYXRvcnMgPSBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzO1xuICBpZiAocGVuZGluZ0RlY29yYXRvcnMgIT09IG51bGwpIHtcbiAgICBlZGl0b3IuX2RlY29yYXRvcnMgPSBwZW5kaW5nRGVjb3JhdG9ycztcbiAgICBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzID0gbnVsbDtcbiAgICB0cmlnZ2VyTGlzdGVuZXJzKCdkZWNvcmF0b3InLCBlZGl0b3IsIHRydWUsIHBlbmRpbmdEZWNvcmF0b3JzKTtcbiAgfVxuXG4gIC8vIElmIHJlY29uY2lsZXIgZmFpbHMsIHdlIHJlc2V0IHdob2xlIGVkaXRvciAoc28gY3VycmVudCBlZGl0b3Igc3RhdGUgYmVjb21lcyBlbXB0eSlcbiAgLy8gYW5kIGF0dGVtcHQgdG8gcmUtcmVuZGVyIHBlbmRpbmdFZGl0b3JTdGF0ZS4gSWYgdGhhdCBnb2VzIHRocm91Z2ggd2UgdHJpZ2dlclxuICAvLyBsaXN0ZW5lcnMsIGJ1dCBpbnN0ZWFkIHVzZSByZWNvdmVyRWRpdG9yU3RhdGUgd2hpY2ggaXMgY3VycmVudCBlZGl0b3Igc3RhdGUgYmVmb3JlIHJlc2V0XG4gIC8vIFRoaXMgc3BlY2lmaWNhbGx5IGltcG9ydGFudCBmb3IgY29sbGFiIHRoYXQgcmVsaWVzIG9uIHByZXZFZGl0b3JTdGF0ZSBmcm9tIHVwZGF0ZVxuICAvLyBsaXN0ZW5lciB0byBjYWxjdWxhdGUgZGVsdGEgb2YgY2hhbmdlZCBub2Rlcy9wcm9wZXJ0aWVzXG4gIHRyaWdnZXJUZXh0Q29udGVudExpc3RlbmVycyhlZGl0b3IsIHJlY292ZXJ5RWRpdG9yU3RhdGUgfHwgY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICB0cmlnZ2VyTGlzdGVuZXJzKCd1cGRhdGUnLCBlZGl0b3IsIHRydWUsIHtcbiAgICBkaXJ0eUVsZW1lbnRzLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGVkaXRvclN0YXRlOiBwZW5kaW5nRWRpdG9yU3RhdGUsXG4gICAgbm9ybWFsaXplZE5vZGVzLFxuICAgIHByZXZFZGl0b3JTdGF0ZTogcmVjb3ZlcnlFZGl0b3JTdGF0ZSB8fCBjdXJyZW50RWRpdG9yU3RhdGUsXG4gICAgdGFnc1xuICB9KTtcbiAgdHJpZ2dlckRlZmVycmVkVXBkYXRlQ2FsbGJhY2tzKGVkaXRvciwgZGVmZXJyZWQpO1xuICAkdHJpZ2dlckVucXVldWVkVXBkYXRlcyhlZGl0b3IpO1xufVxuZnVuY3Rpb24gdHJpZ2dlclRleHRDb250ZW50TGlzdGVuZXJzKGVkaXRvciwgY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgY3VycmVudFRleHRDb250ZW50ID0gZ2V0RWRpdG9yU3RhdGVUZXh0Q29udGVudChjdXJyZW50RWRpdG9yU3RhdGUpO1xuICBjb25zdCBsYXRlc3RUZXh0Q29udGVudCA9IGdldEVkaXRvclN0YXRlVGV4dENvbnRlbnQocGVuZGluZ0VkaXRvclN0YXRlKTtcbiAgaWYgKGN1cnJlbnRUZXh0Q29udGVudCAhPT0gbGF0ZXN0VGV4dENvbnRlbnQpIHtcbiAgICB0cmlnZ2VyTGlzdGVuZXJzKCd0ZXh0Y29udGVudCcsIGVkaXRvciwgdHJ1ZSwgbGF0ZXN0VGV4dENvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyTXV0YXRpb25MaXN0ZW5lcnMoZWRpdG9yLCBtdXRhdGVkTm9kZXMsIHVwZGF0ZVRhZ3MsIGRpcnR5TGVhdmVzLCBwcmV2RWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gQXJyYXkuZnJvbShlZGl0b3IuX2xpc3RlbmVycy5tdXRhdGlvbik7XG4gIGNvbnN0IGxpc3RlbmVyc0xlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbbGlzdGVuZXIsIGtsYXNzXSA9IGxpc3RlbmVyc1tpXTtcbiAgICBjb25zdCBtdXRhdGVkTm9kZXNCeVR5cGUgPSBtdXRhdGVkTm9kZXMuZ2V0KGtsYXNzKTtcbiAgICBpZiAobXV0YXRlZE5vZGVzQnlUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpc3RlbmVyKG11dGF0ZWROb2Rlc0J5VHlwZSwge1xuICAgICAgICBkaXJ0eUxlYXZlcyxcbiAgICAgICAgcHJldkVkaXRvclN0YXRlLFxuICAgICAgICB1cGRhdGVUYWdzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJMaXN0ZW5lcnModHlwZSwgZWRpdG9yLCBpc0N1cnJlbnRseUVucXVldWluZ1VwZGF0ZXMsIC4uLnBheWxvYWQpIHtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgZWRpdG9yLl91cGRhdGluZyA9IGlzQ3VycmVudGx5RW5xdWV1aW5nVXBkYXRlcztcbiAgdHJ5IHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGVkaXRvci5fbGlzdGVuZXJzW3R5cGVdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KG51bGwsIHBheWxvYWQpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gcHJldmlvdXNseVVwZGF0aW5nO1xuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyQ29tbWFuZExpc3RlbmVycyhlZGl0b3IsIHR5cGUsIHBheWxvYWQpIHtcbiAgaWYgKGVkaXRvci5fdXBkYXRpbmcgPT09IGZhbHNlIHx8IGFjdGl2ZUVkaXRvciAhPT0gZWRpdG9yKSB7XG4gICAgbGV0IHJldHVyblZhbCA9IGZhbHNlO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgcmV0dXJuVmFsID0gdHJpZ2dlckNvbW1hbmRMaXN0ZW5lcnMoZWRpdG9yLCB0eXBlLCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsO1xuICB9XG4gIGNvbnN0IGVkaXRvcnMgPSBnZXRFZGl0b3JzVG9Qcm9wYWdhdGUoZWRpdG9yKTtcbiAgZm9yIChsZXQgaSA9IDQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCBlZGl0b3JzLmxlbmd0aDsgZSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gZWRpdG9yc1tlXTtcbiAgICAgIGNvbnN0IGNvbW1hbmRMaXN0ZW5lcnMgPSBjdXJyZW50RWRpdG9yLl9jb21tYW5kcztcbiAgICAgIGNvbnN0IGxpc3RlbmVySW5Qcmlvcml0eU9yZGVyID0gY29tbWFuZExpc3RlbmVycy5nZXQodHlwZSk7XG4gICAgICBpZiAobGlzdGVuZXJJblByaW9yaXR5T3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnNTZXQgPSBsaXN0ZW5lckluUHJpb3JpdHlPcmRlcltpXTtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1NldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gQXJyYXkuZnJvbShsaXN0ZW5lcnNTZXQpO1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVyc0xlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaXN0ZW5lcnNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tqXShwYXlsb2FkLCBlZGl0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkdHJpZ2dlckVucXVldWVkVXBkYXRlcyhlZGl0b3IpIHtcbiAgY29uc3QgcXVldWVkVXBkYXRlcyA9IGVkaXRvci5fdXBkYXRlcztcbiAgaWYgKHF1ZXVlZFVwZGF0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgcXVldWVkVXBkYXRlID0gcXVldWVkVXBkYXRlcy5zaGlmdCgpO1xuICAgIGlmIChxdWV1ZWRVcGRhdGUpIHtcbiAgICAgIGNvbnN0IFt1cGRhdGVGbiwgb3B0aW9uc10gPSBxdWV1ZWRVcGRhdGU7XG4gICAgICAkYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRGVmZXJyZWRVcGRhdGVDYWxsYmFja3MoZWRpdG9yLCBkZWZlcnJlZCkge1xuICBlZGl0b3IuX2RlZmVycmVkID0gW107XG4gIGlmIChkZWZlcnJlZC5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlZmVycmVkW2ldKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IsIGluaXRpYWxTa2lwVHJhbnNmb3Jtcykge1xuICBjb25zdCBxdWV1ZWRVcGRhdGVzID0gZWRpdG9yLl91cGRhdGVzO1xuICBsZXQgc2tpcFRyYW5zZm9ybXMgPSBpbml0aWFsU2tpcFRyYW5zZm9ybXMgfHwgZmFsc2U7XG5cbiAgLy8gVXBkYXRlcyBtaWdodCBncm93IGFzIHdlIHByb2Nlc3MgdGhlbSwgd2Ugc28gd2UnbGwgbmVlZFxuICAvLyB0byBoYW5kbGUgZWFjaCB1cGRhdGUgYXMgd2UgZ28gdW50aWwgdGhlIHVwZGF0ZXMgYXJyYXkgaXNcbiAgLy8gZW1wdHkuXG4gIHdoaWxlIChxdWV1ZWRVcGRhdGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IHF1ZXVlZFVwZGF0ZSA9IHF1ZXVlZFVwZGF0ZXMuc2hpZnQoKTtcbiAgICBpZiAocXVldWVkVXBkYXRlKSB7XG4gICAgICBjb25zdCBbbmV4dFVwZGF0ZUZuLCBvcHRpb25zXSA9IHF1ZXVlZFVwZGF0ZTtcbiAgICAgIGxldCBvblVwZGF0ZTtcbiAgICAgIGxldCB0YWc7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICAgICAgdGFnID0gb3B0aW9ucy50YWc7XG4gICAgICAgIGlmIChvcHRpb25zLnNraXBUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgc2tpcFRyYW5zZm9ybXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICAgIGVkaXRvci5fZGVmZXJyZWQucHVzaChvblVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgIGVkaXRvci5fdXBkYXRlVGFncy5hZGQodGFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dFVwZGF0ZUZuKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBza2lwVHJhbnNmb3Jtcztcbn1cbmZ1bmN0aW9uICRiZWdpblVwZGF0ZShlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZVRhZ3MgPSBlZGl0b3IuX3VwZGF0ZVRhZ3M7XG4gIGxldCBvblVwZGF0ZTtcbiAgbGV0IHRhZztcbiAgbGV0IHNraXBUcmFuc2Zvcm1zID0gZmFsc2U7XG4gIGxldCBkaXNjcmV0ZSA9IGZhbHNlO1xuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIHRhZyA9IG9wdGlvbnMudGFnO1xuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlVGFncy5hZGQodGFnKTtcbiAgICB9XG4gICAgc2tpcFRyYW5zZm9ybXMgPSBvcHRpb25zLnNraXBUcmFuc2Zvcm1zIHx8IGZhbHNlO1xuICAgIGRpc2NyZXRlID0gb3B0aW9ucy5kaXNjcmV0ZSB8fCBmYWxzZTtcbiAgfVxuICBpZiAob25VcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RlZmVycmVkLnB1c2gob25VcGRhdGUpO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gIGxldCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgbGV0IGVkaXRvclN0YXRlV2FzQ2xvbmVkID0gZmFsc2U7XG4gIGlmIChwZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwgfHwgcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gY2xvbmVFZGl0b3JTdGF0ZShwZW5kaW5nRWRpdG9yU3RhdGUgfHwgY3VycmVudEVkaXRvclN0YXRlKTtcbiAgICBlZGl0b3JTdGF0ZVdhc0Nsb25lZCA9IHRydWU7XG4gIH1cbiAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSBkaXNjcmV0ZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG4gIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHRyeSB7XG4gICAgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICBpZiAoZWRpdG9yLl9oZWFkbGVzcykge1xuICAgICAgICBpZiAoY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gJGludGVybmFsQ3JlYXRlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0aW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIHVwZGF0ZUZuKCk7XG4gICAgc2tpcFRyYW5zZm9ybXMgPSBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IsIHNraXBUcmFuc2Zvcm1zKTtcbiAgICBhcHBseVNlbGVjdGlvblRyYW5zZm9ybXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICAgIGlmIChlZGl0b3IuX2RpcnR5VHlwZSAhPT0gTk9fRElSVFlfTk9ERVMpIHtcbiAgICAgIGlmIChza2lwVHJhbnNmb3Jtcykge1xuICAgICAgICAkbm9ybWFsaXplQWxsRGlydHlUZXh0Tm9kZXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGFwcGx5QWxsVHJhbnNmb3JtcyhwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IpO1xuICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWROb2RlcyhjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yLl9kaXJ0eUxlYXZlcywgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgZW5kaW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIGlmIChzdGFydGluZ0NvbXBvc2l0aW9uS2V5ICE9PSBlbmRpbmdDb21wb3NpdGlvbktleSkge1xuICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwZW5kaW5nTm9kZU1hcCA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICAgIGNvbnN0IGFuY2hvcktleSA9IHBlbmRpbmdTZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICAgIGNvbnN0IGZvY3VzS2V5ID0gcGVuZGluZ1NlbGVjdGlvbi5mb2N1cy5rZXk7XG4gICAgICBpZiAocGVuZGluZ05vZGVNYXAuZ2V0KGFuY2hvcktleSkgPT09IHVuZGVmaW5lZCB8fCBwZW5kaW5nTm9kZU1hcC5nZXQoZm9jdXNLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGB1cGRhdGVFZGl0b3I6IHNlbGVjdGlvbiBoYXMgYmVlbiBsb3N0IGJlY2F1c2UgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZXMgaGF2ZSBiZWVuIHJlbW92ZWQgYW5kIHNlbGVjdGlvbiB3YXNuJ3QgbW92ZWQgdG8gYW5vdGhlciBub2RlLiBFbnN1cmUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgcmVtb3ZpbmcvcmVwbGFjaW5nIGEgc2VsZWN0ZWQgbm9kZS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzTm9kZVNlbGVjdGlvbihwZW5kaW5nU2VsZWN0aW9uKSkge1xuICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsc28gdmFsaWRhdGUgbm9kZSBzZWxlY3Rpb24/XG4gICAgICBpZiAocGVuZGluZ1NlbGVjdGlvbi5fbm9kZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFJlcG9ydCBlcnJvcnNcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZWRpdG9yLl9vbkVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIGV4aXN0aW5nIGVkaXRvciBzdGF0ZSB0byB0aGUgRE9NXG4gICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBjdXJyZW50RWRpdG9yU3RhdGU7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkLmNsZWFyKCk7XG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMuY2xlYXIoKTtcbiAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIGlzUmVhZE9ubHlNb2RlID0gcHJldmlvdXNSZWFkT25seU1vZGU7XG4gICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgZWRpdG9yLl91cGRhdGluZyA9IHByZXZpb3VzbHlVcGRhdGluZztcbiAgICBpbmZpbml0ZVRyYW5zZm9ybUNvdW50ID0gMDtcbiAgfVxuICBjb25zdCBzaG91bGRVcGRhdGUgPSBlZGl0b3IuX2RpcnR5VHlwZSAhPT0gTk9fRElSVFlfTk9ERVMgfHwgZWRpdG9yU3RhdGVIYXNEaXJ0eVNlbGVjdGlvbihwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICBpZiAocGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMpIHtcbiAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICBzY2hlZHVsZU1pY3JvVGFzaygoKSA9PiB7XG4gICAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyhlZGl0b3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICB1cGRhdGVUYWdzLmNsZWFyKCk7XG4gICAgICBlZGl0b3IuX2RlZmVycmVkID0gW107XG4gICAgICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVFZGl0b3IoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucykge1xuICBpZiAoZWRpdG9yLl91cGRhdGluZykge1xuICAgIGVkaXRvci5fdXBkYXRlcy5wdXNoKFt1cGRhdGVGbiwgb3B0aW9uc10pO1xuICB9IGVsc2Uge1xuICAgICRiZWdpblVwZGF0ZShlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBFbGVtZW50Tm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fZmlyc3QgPSBudWxsO1xuICAgIHRoaXMuX19sYXN0ID0gbnVsbDtcbiAgICB0aGlzLl9fc2l6ZSA9IDA7XG4gICAgdGhpcy5fX2Zvcm1hdCA9IDA7XG4gICAgdGhpcy5fX2luZGVudCA9IDA7XG4gICAgdGhpcy5fX2RpciA9IG51bGw7XG4gIH1cbiAgZ2V0Rm9ybWF0KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZm9ybWF0O1xuICB9XG4gIGdldEZvcm1hdFR5cGUoKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRGb3JtYXQoKTtcbiAgICByZXR1cm4gRUxFTUVOVF9GT1JNQVRfVE9fVFlQRVtmb3JtYXRdIHx8ICcnO1xuICB9XG4gIGdldEluZGVudCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2luZGVudDtcbiAgfVxuICBnZXRDaGlsZHJlbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBnZXRDaGlsZHJlbktleXMoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQuX19rZXkpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgZ2V0Q2hpbGRyZW5TaXplKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fc2l6ZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuU2l6ZSgpID09PSAwO1xuICB9XG4gIGlzRGlydHkoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3QgZGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgICByZXR1cm4gZGlydHlFbGVtZW50cyAhPT0gbnVsbCAmJiBkaXJ0eUVsZW1lbnRzLmhhcyh0aGlzLl9fa2V5KTtcbiAgfVxuICBpc0xhc3RDaGlsZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnRMYXN0Q2hpbGQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRMYXN0Q2hpbGQoKTtcbiAgICByZXR1cm4gcGFyZW50TGFzdENoaWxkICE9PSBudWxsICYmIHBhcmVudExhc3RDaGlsZC5pcyhzZWxmKTtcbiAgfVxuICBnZXRBbGxUZXh0Tm9kZXMoKSB7XG4gICAgY29uc3QgdGV4dE5vZGVzID0gW107XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHRleHROb2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgY29uc3Qgc3ViQ2hpbGRyZW5Ob2RlcyA9IGNoaWxkLmdldEFsbFRleHROb2RlcygpO1xuICAgICAgICB0ZXh0Tm9kZXMucHVzaCguLi5zdWJDaGlsZHJlbk5vZGVzKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHROb2RlcztcbiAgfVxuICBnZXRGaXJzdERlc2NlbmRhbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGdldExhc3REZXNjZW5kYW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0RGVzY2VuZGFudEJ5SW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAvLyBGb3Igbm9uLWVtcHR5IGVsZW1lbnQgbm9kZXMsIHdlIHJlc29sdmUgaXRzIGRlc2NlbmRhbnRcbiAgICAvLyAoZWl0aGVyIGEgbGVhZiBub2RlIG9yIHRoZSBib3R0b20tbW9zdCBlbGVtZW50KVxuICAgIGlmIChpbmRleCA+PSBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgY29uc3QgcmVzb2x2ZWROb2RlID0gY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiAkaXNFbGVtZW50Tm9kZShyZXNvbHZlZE5vZGUpICYmIHJlc29sdmVkTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZE5vZGUgPSBjaGlsZHJlbltpbmRleF07XG4gICAgcmV0dXJuICRpc0VsZW1lbnROb2RlKHJlc29sdmVkTm9kZSkgJiYgcmVzb2x2ZWROb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICB9XG4gIGdldEZpcnN0Q2hpbGQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgZmlyc3RLZXkgPSBzZWxmLl9fZmlyc3Q7XG4gICAgcmV0dXJuIGZpcnN0S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkoZmlyc3RLZXkpO1xuICB9XG4gIGdldEZpcnN0Q2hpbGRPclRocm93KCkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSBmaXJzdCBjaGlsZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gIH1cbiAgZ2V0TGFzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGxhc3RLZXkgPSBzZWxmLl9fbGFzdDtcbiAgICByZXR1cm4gbGFzdEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KGxhc3RLZXkpO1xuICB9XG4gIGdldExhc3RDaGlsZE9yVGhyb3coKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAobGFzdENoaWxkID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIGxhc3QgY2hpbGQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXN0Q2hpbGQ7XG4gIH1cbiAgZ2V0Q2hpbGRBdEluZGV4KGluZGV4KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGk7XG4gICAgaWYgKGluZGV4IDwgc2l6ZSAvIDIpIHtcbiAgICAgIG5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgaSA8PSBpbmRleCkge1xuICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbm9kZSA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgaSA9IHNpemUgLSAxO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkgPj0gaW5kZXgpIHtcbiAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB0ZXh0Q29udGVudCArPSBjaGlsZC5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxuICBnZXRUZXh0Q29udGVudFNpemUoKSB7XG4gICAgbGV0IHRleHRDb250ZW50U2l6ZSA9IDA7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGV4dENvbnRlbnRTaXplICs9IGNoaWxkLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnRTaXplICs9IERPVUJMRV9MSU5FX0JSRUFLLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRDb250ZW50U2l6ZTtcbiAgfVxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19kaXI7XG4gIH1cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBFTEVNRU5UX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgICAgcmV0dXJuICh0aGlzLmdldEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE11dGF0b3JzXG5cbiAgc2VsZWN0KF9hbmNob3JPZmZzZXQsIF9mb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gICAgY29uc3QgY2hpbGRyZW5Db3VudCA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgaWYgKCF0aGlzLmNhbkJlRW1wdHkoKSkge1xuICAgICAgaWYgKF9hbmNob3JPZmZzZXQgPT09IDAgJiYgX2ZvY3VzT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQuc2VsZWN0KDAsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfYW5jaG9yT2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgX2FuY2hvck9mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkgJiYgKF9mb2N1c09mZnNldCA9PT0gdW5kZWZpbmVkIHx8IF9mb2N1c09mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkpIHtcbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGxhc3RDaGlsZCkgfHwgJGlzRWxlbWVudE5vZGUobGFzdENoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBsYXN0Q2hpbGQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFuY2hvck9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbmNob3JPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cbiAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9jdXNPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuICRpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihrZXksIGFuY2hvck9mZnNldCwga2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnLCAnZWxlbWVudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChrZXksIGFuY2hvck9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoa2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gdGhpcy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICByZXR1cm4gZmlyc3ROb2RlID8gZmlyc3ROb2RlLnNlbGVjdFN0YXJ0KCkgOiB0aGlzLnNlbGVjdCgpO1xuICB9XG4gIHNlbGVjdEVuZCgpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICByZXR1cm4gbGFzdE5vZGUgPyBsYXN0Tm9kZS5zZWxlY3RFbmQoKSA6IHRoaXMuc2VsZWN0KCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucmVtb3ZlKCkpO1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UodGhpcy5nZXRDaGlsZHJlblNpemUoKSwgMCwgbm9kZXNUb0FwcGVuZCk7XG4gIH1cbiAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2RpciA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzZXRGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IHR5cGUgIT09ICcnID8gRUxFTUVOVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXSA6IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0SW5kZW50KGluZGVudExldmVsKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faW5kZW50ID0gaW5kZW50TGV2ZWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgbm9kZXNUb0luc2VydCkge1xuICAgIGNvbnN0IG5vZGVzVG9JbnNlcnRMZW5ndGggPSBub2Rlc1RvSW5zZXJ0Lmxlbmd0aDtcbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmS2V5ID0gd3JpdGFibGVTZWxmLl9fa2V5O1xuICAgIGNvbnN0IG5vZGVzVG9JbnNlcnRLZXlzID0gW107XG4gICAgY29uc3Qgbm9kZXNUb1JlbW92ZUtleXMgPSBbXTtcbiAgICBjb25zdCBub2RlQWZ0ZXJSYW5nZSA9IHRoaXMuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0ICsgZGVsZXRlQ291bnQpO1xuICAgIGxldCBub2RlQmVmb3JlUmFuZ2UgPSBudWxsO1xuICAgIGxldCBuZXdTaXplID0gb2xkU2l6ZSAtIGRlbGV0ZUNvdW50ICsgbm9kZXNUb0luc2VydExlbmd0aDtcbiAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgIGlmIChzdGFydCA9PT0gb2xkU2l6ZSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0KTtcbiAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWxldGVDb3VudCA+IDApIHtcbiAgICAgIGxldCBub2RlVG9EZWxldGUgPSBub2RlQmVmb3JlUmFuZ2UgPT09IG51bGwgPyB0aGlzLmdldEZpcnN0Q2hpbGQoKSA6IG5vZGVCZWZvcmVSYW5nZS5nZXROZXh0U2libGluZygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlVG9EZWxldGUgPT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgc3BsaWNlOiBzaWJsaW5nIG5vdCBmb3VuZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGVUb0RlbGV0ZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBjb25zdCBub2RlS2V5VG9EZWxldGUgPSBub2RlVG9EZWxldGUuX19rZXk7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvRGVsZXRlID0gbm9kZVRvRGVsZXRlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9EZWxldGUpO1xuICAgICAgICBub2Rlc1RvUmVtb3ZlS2V5cy5wdXNoKG5vZGVLZXlUb0RlbGV0ZSk7XG4gICAgICAgIG5vZGVUb0RlbGV0ZSA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJldk5vZGUgPSBub2RlQmVmb3JlUmFuZ2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvSW5zZXJ0TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVUb0luc2VydCA9IG5vZGVzVG9JbnNlcnRbaV07XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwgJiYgbm9kZVRvSW5zZXJ0LmlzKHByZXZOb2RlKSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBwcmV2Tm9kZSA9IHByZXZOb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlVG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuZ2V0V3JpdGFibGUoKTtcbiAgICAgIGlmICh3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIG5ld1NpemUtLTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgICAgY29uc3Qgbm9kZUtleVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgICAgaWYgKHByZXZOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHdyaXRhYmxlU2VsZi5fX2ZpcnN0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSB3cml0YWJsZVByZXZOb2RlLl9fa2V5O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVUb0luc2VydC5fX2tleSA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgYXBwZW5kOiBhdHRlbXB0aW5nIHRvIGFwcGVuZCBzZWxmYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBjaGlsZCBwYXJlbnQgdG8gc2VsZlxuICAgICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGZLZXk7XG4gICAgICBub2Rlc1RvSW5zZXJ0S2V5cy5wdXNoKG5vZGVLZXlUb0luc2VydCk7XG4gICAgICBwcmV2Tm9kZSA9IG5vZGVUb0luc2VydDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICsgZGVsZXRlQ291bnQgPT09IG9sZFNpemUpIHtcbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZOb2RlID0gcHJldk5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQcmV2Tm9kZS5fX25leHQgPSBudWxsO1xuICAgICAgICB3cml0YWJsZVNlbGYuX19sYXN0ID0gcHJldk5vZGUuX19rZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlQWZ0ZXJSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlQWZ0ZXJSYW5nZSA9IG5vZGVBZnRlclJhbmdlLmdldFdyaXRhYmxlKCk7XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTm9kZUFmdGVyUmFuZ2UuX19wcmV2ID0gcHJldk5vZGUuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbm9kZUFmdGVyUmFuZ2UuX19rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZU5vZGVBZnRlclJhbmdlLl9fcHJldiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRhYmxlU2VsZi5fX3NpemUgPSBuZXdTaXplO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBkZWxldGlvbiB3ZSBuZWVkIHRvIGFkanVzdCBzZWxlY3Rpb24sIHVubGluayByZW1vdmVkIG5vZGVzXG4gICAgLy8gYW5kIGNsZWFuIHVwIG5vZGUgaXRzZWxmIGlmIGl0IGJlY29tZXMgZW1wdHkuIE5vbmUgb2YgdGhlc2UgbmVlZGVkXG4gICAgLy8gZm9yIGluc2VydGlvbi1vbmx5IGNhc2VzXG4gICAgaWYgKG5vZGVzVG9SZW1vdmVLZXlzLmxlbmd0aCkge1xuICAgICAgLy8gQWRqdXN0aW5nIHNlbGVjdGlvbiwgaW4gY2FzZSBub2RlIHRoYXQgd2FzIGFuY2hvci9mb2N1cyB3aWxsIGJlIGRlbGV0ZWRcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmVLZXlTZXQgPSBuZXcgU2V0KG5vZGVzVG9SZW1vdmVLZXlzKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb0luc2VydEtleVNldCA9IG5ldyBTZXQobm9kZXNUb0luc2VydEtleXMpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGZvY3VzXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGlmIChpc1BvaW50UmVtb3ZlZChhbmNob3IsIG5vZGVzVG9SZW1vdmVLZXlTZXQsIG5vZGVzVG9JbnNlcnRLZXlTZXQpKSB7XG4gICAgICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgYW5jaG9yLmdldE5vZGUoKSwgdGhpcywgbm9kZUJlZm9yZVJhbmdlLCBub2RlQWZ0ZXJSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUG9pbnRSZW1vdmVkKGZvY3VzLCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSkge1xuICAgICAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhmb2N1cywgZm9jdXMuZ2V0Tm9kZSgpLCB0aGlzLCBub2RlQmVmb3JlUmFuZ2UsIG5vZGVBZnRlclJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbnVwIGlmIG5vZGUgY2FuJ3QgYmUgZW1wdHlcbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDAgJiYgIXRoaXMuY2FuQmVFbXB0eSgpICYmICEkaXNSb290T3JTaGFkb3dSb290KHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG4gIC8vIEpTT04gc2VyaWFsaXphdGlvblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpLFxuICAgICAgaW5kZW50OiB0aGlzLmdldEluZGVudCgpLFxuICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgLy8gVGhlc2UgYXJlIGludGVuZGVkIHRvIGJlIGV4dGVuZHMgZm9yIHNwZWNpZmljIGVsZW1lbnQgaGV1cmlzdGljcy5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qXG4gICAqIFRoaXMgbWV0aG9kIGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBhIHRoZSBub2RlIGR1cmluZyBiYWNrd2FyZHNcbiAgICogZGVsZXRpb24gKGkuZS4sIGJhY2tzcGFjZSkgd2hlbiBzZWxlY3Rpb24gaXMgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgKiB0aGUgbm9kZSAob2Zmc2V0IDApXG4gICAqL1xuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4Y2x1ZGVGcm9tQ29weShkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhblJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQSBzaGFkb3cgcm9vdCBpcyBhIE5vZGUgdGhhdCBiZWhhdmVzIGxpa2UgUm9vdE5vZGUuIFRoZSBzaGFkb3cgcm9vdCAoYW5kIFJvb3ROb2RlKSBtYXJrIHRoZVxuICAvLyBlbmQgb2YgdGhlIGhpZXJjaGFyY2h5LCBtb3N0IGltcGxlbWVudGF0aW9ucyBzaG91bGQgdHJlYXQgaXQgYXMgdGhlcmUncyBub3RoaW5nICh1cHdhcmRzKVxuICAvLyBiZXlvbmQgdGhpcyBwb2ludC4gRm9yIGV4YW1wbGUsIG5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50KCksIHdoZW4gcGVyZm9ybWVkIGluc2lkZSBhIFRhYmxlQ2VsbE5vZGVcbiAgLy8gd2lsbCByZXR1cm4gdGhlIGltbWVkaWF0ZSBmaXJzdCBjaGlsZCB1bmRlcm5lYXRoIFRhYmxlQ2VsbE5vZGUgaW5zdGVhZCBvZiBSb290Tm9kZS5cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhbk1lcmdlV2l0aChub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRSZW1vdmVkKHBvaW50LCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSB7XG4gIGxldCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGNvbnN0IG5vZGVLZXkgPSBub2RlLl9fa2V5O1xuICAgIGlmIChub2Rlc1RvUmVtb3ZlS2V5U2V0Lmhhcyhub2RlS2V5KSAmJiAhbm9kZXNUb0luc2VydEtleVNldC5oYXMobm9kZUtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgRGVjb3JhdG9yTm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIExleGljYWxFZGl0b3IuX2RlY29yYXRvcnNcbiAgICovXG4gIGRlY29yYXRlKGVkaXRvciwgY29uZmlnKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGRlY29yYXRlOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cbiAgaXNJc29sYXRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNLZXlib2FyZFNlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc0RlY29yYXRvck5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERlY29yYXRvck5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFJvb3ROb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdyb290JztcbiAgfVxuICBzdGF0aWMgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSb290Tm9kZSgpO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdyb290Jyk7XG4gICAgdGhpcy5fX2NhY2hlZFRleHQgPSBudWxsO1xuICB9XG4gIGdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGdldFRvcExldmVsRWxlbWVudE9yVGhyb3c6IHJvb3Qgbm9kZXMgYXJlIG5vdCB0b3AgbGV2ZWwgZWxlbWVudHNgKTtcbiAgICB9XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3QgY2FjaGVkVGV4dCA9IHRoaXMuX19jYWNoZWRUZXh0O1xuICAgIGlmIChpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpIHx8IGdldEFjdGl2ZUVkaXRvcigpLl9kaXJ0eVR5cGUgPT09IE5PX0RJUlRZX05PREVTKSB7XG4gICAgICBpZiAoY2FjaGVkVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkVGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldFRleHRDb250ZW50KCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGByZW1vdmU6IGNhbm5vdCBiZSBjYWxsZWQgb24gcm9vdCBub2Rlc2ApO1xuICAgIH1cbiAgfVxuICByZXBsYWNlKG5vZGUpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcmVwbGFjZTogY2Fubm90IGJlIGNhbGxlZCBvbiByb290IG5vZGVzYCk7XG4gICAgfVxuICB9XG4gIGluc2VydEJlZm9yZShub2RlVG9JbnNlcnQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QmVmb3JlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QWZ0ZXIobm9kZVRvSW5zZXJ0KSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGluc2VydEFmdGVyOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNdXRhdGVcblxuICBhcHBlbmQoLi4ubm9kZXNUb0FwcGVuZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb0FwcGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzVG9BcHBlbmRbaV07XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpICYmICEkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgcm9vdE5vZGUuYXBwZW5kOiBPbmx5IGVsZW1lbnQgb3IgZGVjb3JhdG9yIG5vZGVzIGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgcm9vdCBub2RlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5ub2Rlc1RvQXBwZW5kKTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIC8vIFdlIGRvbid0IGNyZWF0ZSBhIHJvb3QsIGFuZCBpbnN0ZWFkIHVzZSB0aGUgZXhpc3Rpbmcgcm9vdC5cbiAgICBjb25zdCBub2RlID0gJGdldFJvb3QoKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpLFxuICAgICAgaW5kZW50OiB0aGlzLmdldEluZGVudCgpLFxuICAgICAgdHlwZTogJ3Jvb3QnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlUm9vdE5vZGUoKSB7XG4gIHJldHVybiBuZXcgUm9vdE5vZGUoKTtcbn1cbmZ1bmN0aW9uICRpc1Jvb3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBSb290Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBlZGl0b3JTdGF0ZUhhc0RpcnR5U2VsZWN0aW9uKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLl9zZWxlY3Rpb247XG4gIGNvbnN0IHBlbmRpbmdTZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXBkYXRlIGJlY2F1c2Ugb2YgY2hhbmdlcyBpbiBzZWxlY3Rpb25cbiAgaWYgKHBlbmRpbmdTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSB8fCAhcGVuZGluZ1NlbGVjdGlvbi5pcyhjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG9uZUVkaXRvclN0YXRlKGN1cnJlbnQpIHtcbiAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShuZXcgTWFwKGN1cnJlbnQuX25vZGVNYXApKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKSB7XG4gIHJldHVybiBuZXcgRWRpdG9yU3RhdGUobmV3IE1hcChbWydyb290JywgJGNyZWF0ZVJvb3ROb2RlKCldXSkpO1xufVxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IG1hdGNoIHRoZSBzZXJpYWxpemVkIHR5cGUuIENoZWNrIGlmIC5leHBvcnRKU09OKCkgaXMgaW1wbGVtZW50ZWQgYW5kIGl0IGlzIHJldHVybmluZyB0aGUgY29ycmVjdCB0eXBlLmApO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gZXhwb3J0Tm9kZVRvSlNPTihjaGlsZCk7XG4gICAgICBzZXJpYWxpemVkQ2hpbGRyZW4ucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgY29uc3RydWN0b3Iobm9kZU1hcCwgc2VsZWN0aW9uKSB7XG4gICAgdGhpcy5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8IG51bGw7XG4gICAgdGhpcy5fZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlTWFwLnNpemUgPT09IDEgJiYgdGhpcy5fc2VsZWN0aW9uID09PSBudWxsO1xuICB9XG4gIHJlYWQoY2FsbGJhY2tGbikge1xuICAgIHJldHVybiByZWFkRWRpdG9yU3RhdGUodGhpcywgY2FsbGJhY2tGbik7XG4gIH1cbiAgY2xvbmUoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgZWRpdG9yU3RhdGUgPSBuZXcgRWRpdG9yU3RhdGUodGhpcy5fbm9kZU1hcCwgc2VsZWN0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLl9zZWxlY3Rpb24gOiBzZWxlY3Rpb24pO1xuICAgIGVkaXRvclN0YXRlLl9yZWFkT25seSA9IHRydWU7XG4gICAgcmV0dXJuIGVkaXRvclN0YXRlO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gcmVhZEVkaXRvclN0YXRlKHRoaXMsICgpID0+ICh7XG4gICAgICByb290OiBleHBvcnROb2RlVG9KU09OKCRnZXRSb290KCkpXG4gICAgfSkpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUT0RPOiBDbGVhbnVwIEFydGlmaWNpYWxOb2RlX19ET19OT1RfVVNFICM1OTY2XG5jbGFzcyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdhcnRpZmljaWFsJztcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgLy8gdGhpcyBpc250IHN1cHBvc2VkIHRvIGJlIHVzZWQgYW5kIGlzIG5vdCB1c2VkIGFueXdoZXJlIGJ1dCBkZWZpbmluZyBpdCB0byBhcHBlYXNlIHRoZSBBUElcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXR1cm4gZG9tO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFBhcmFncmFwaE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190ZXh0Rm9ybWF0ID0gMDtcbiAgfVxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3BhcmFncmFwaCc7XG4gIH1cbiAgZ2V0VGV4dEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3RleHRGb3JtYXQ7XG4gIH1cbiAgc2V0VGV4dEZvcm1hdCh0eXBlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdGV4dEZvcm1hdCA9IHR5cGU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaGFzVGV4dEZvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuICh0aGlzLmdldFRleHRGb3JtYXQoKSAmIGZvcm1hdEZsYWcpICE9PSAwO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJhZ3JhcGhOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNvbmZpZy50aGVtZSwgJ3BhcmFncmFwaCcpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFBhcmFncmFwaEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGVsZW1lbnQgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgLy8gcGFkZGluZy1pbmxpbmUtc3RhcnQgaXMgbm90IHdpZGVseSBzdXBwb3J0ZWQgaW4gZW1haWwgSFRNTCwgYnV0XG4gICAgICAgIC8vIExleGljYWwgUmVjb25jaWxlciB1c2VzIHBhZGRpbmctaW5saW5lLXN0YXJ0LiBVc2luZyB0ZXh0LWluZGVudCBpbnN0ZWFkLlxuICAgICAgICBlbGVtZW50LnN0eWxlLnRleHRJbmRlbnQgPSBgJHtpbmRlbnQgKiAyMH1weGA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIG5vZGUuc2V0VGV4dEZvcm1hdChzZXJpYWxpemVkTm9kZS50ZXh0Rm9ybWF0KTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0ZXh0Rm9ybWF0OiB0aGlzLmdldFRleHRGb3JtYXQoKSxcbiAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdGlvblxuXG4gIGluc2VydE5ld0FmdGVyKHJhbmdlU2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgbmV3RWxlbWVudC5zZXRUZXh0Rm9ybWF0KHJhbmdlU2VsZWN0aW9uLmZvcm1hdCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdFbGVtZW50LnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIG5ld0VsZW1lbnQuc2V0Rm9ybWF0KHRoaXMuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5ICh0cmltbWVkKSBmaXJzdCBwYXJhZ3JhcGggYW5kIHRyeSBhbmQgcmVtb3ZlIGl0LFxuICAgIC8vIGRlbGV0ZSB0aGUgcGFyYWdyYXBoIGFzIGxvbmcgYXMgd2UgaGF2ZSBhbm90aGVyIHNpYmxpbmcgdG8gZ28gdG9cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICRpc1RleHROb2RlKGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5nZXRUZXh0Q29udGVudCgpLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0TmV4dCgpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0UGFyYWdyYXBoRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBpZiAoZWxlbWVudC5zdHlsZSkge1xuICAgIG5vZGUuc2V0Rm9ybWF0KGVsZW1lbnQuc3R5bGUudGV4dEFsaWduKTtcbiAgICBjb25zdCBpbmRlbnQgPSBwYXJzZUludChlbGVtZW50LnN0eWxlLnRleHRJbmRlbnQsIDEwKSAvIDIwO1xuICAgIGlmIChpbmRlbnQgPiAwKSB7XG4gICAgICBub2RlLnNldEluZGVudChpbmRlbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBQYXJhZ3JhcGhOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzUGFyYWdyYXBoTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUGFyYWdyYXBoTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzg0MVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuY29uc3QgQ09NTUFORF9QUklPUklUWV9FRElUT1IgPSAwO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9MT1cgPSAxO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9OT1JNQUwgPSAyO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9ISUdIID0gMztcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwgPSA0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5cbi8qKlxuICogVHlwZSBoZWxwZXIgZm9yIGV4dHJhY3RpbmcgdGhlIHBheWxvYWQgdHlwZSBmcm9tIGEgY29tbWFuZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IE1ZX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kPFNvbWVUeXBlPigpO1xuICpcbiAqIC8vIC4uLlxuICpcbiAqIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoTVlfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gKiAgIC8vIFR5cGUgb2YgYHBheWxvYWRgIGlzIGluZmVycmVkIGhlcmUuIEJ1dCBsZXRzIHNheSB3ZSB3YW50IHRvIGV4dHJhY3QgYSBmdW5jdGlvbiB0byBkZWxlZ2F0ZSB0b1xuICogICBoYW5kbGVNeUNvbW1hbmQoZWRpdG9yLCBwYXlsb2FkKTtcbiAqICAgcmV0dXJuIHRydWU7XG4gKiB9KTtcbiAqXG4gKiBmdW5jdGlvbiBoYW5kbGVNeUNvbW1hbmQoZWRpdG9yOiBMZXhpY2FsRWRpdG9yLCBwYXlsb2FkOiBDb21tYW5kUGF5bG9hZFR5cGU8dHlwZW9mIE1ZX0NPTU1BTkQ+KSB7XG4gKiAgIC8vIGBwYXlsb2FkYCBpcyBvZiB0eXBlIGBTb21lVHlwZWAsIGV4dHJhY3RlZCBmcm9tIHRoZSBjb21tYW5kLlxuICogfVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRFZGl0b3IoZWRpdG9yLCBwcmV2Um9vdEVsZW1lbnQsIG5leHRSb290RWxlbWVudCwgcGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGtleU5vZGVNYXAgPSBlZGl0b3IuX2tleVRvRE9NTWFwO1xuICBrZXlOb2RlTWFwLmNsZWFyKCk7XG4gIGVkaXRvci5fZWRpdG9yU3RhdGUgPSBjcmVhdGVFbXB0eUVkaXRvclN0YXRlKCk7XG4gIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuICBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ID0gbnVsbDtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBOT19ESVJUWV9OT0RFUztcbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5jbGVhcigpO1xuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX2RpcnR5RWxlbWVudHMuY2xlYXIoKTtcbiAgZWRpdG9yLl9ub3JtYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fdXBkYXRlVGFncyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl91cGRhdGVzID0gW107XG4gIGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50ID0gbnVsbDtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBlZGl0b3IuX29ic2VydmVyO1xuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZWRpdG9yLl9vYnNlcnZlciA9IG51bGw7XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHRoZSBET00gbm9kZXMgZnJvbSB0aGUgcm9vdCBlbGVtZW50XG4gIGlmIChwcmV2Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBwcmV2Um9vdEVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgfVxuICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbmV4dFJvb3RFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAga2V5Tm9kZU1hcC5zZXQoJ3Jvb3QnLCBuZXh0Um9vdEVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiBpbml0aWFsaXplQ29udmVyc2lvbkNhY2hlKG5vZGVzLCBhZGRpdGlvbmFsQ29udmVyc2lvbnMpIHtcbiAgY29uc3QgY29udmVyc2lvbkNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBoYW5kbGVkQ29udmVyc2lvbnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGFkZENvbnZlcnNpb25zVG9DYWNoZSA9IG1hcCA9PiB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsZXQgY3VycmVudENhY2hlID0gY29udmVyc2lvbkNhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKGN1cnJlbnRDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1cnJlbnRDYWNoZSA9IFtdO1xuICAgICAgICBjb252ZXJzaW9uQ2FjaGUuc2V0KGtleSwgY3VycmVudENhY2hlKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDYWNoZS5wdXNoKG1hcFtrZXldKTtcbiAgICB9KTtcbiAgfTtcbiAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICBjb25zdCBpbXBvcnRET00gPSBub2RlLmtsYXNzLmltcG9ydERPTTtcbiAgICBpZiAoaW1wb3J0RE9NID09IG51bGwgfHwgaGFuZGxlZENvbnZlcnNpb25zLmhhcyhpbXBvcnRET00pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZWRDb252ZXJzaW9ucy5hZGQoaW1wb3J0RE9NKTtcbiAgICBjb25zdCBtYXAgPSBpbXBvcnRET00uY2FsbChub2RlLmtsYXNzKTtcbiAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICBhZGRDb252ZXJzaW9uc1RvQ2FjaGUobWFwKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoYWRkaXRpb25hbENvbnZlcnNpb25zKSB7XG4gICAgYWRkQ29udmVyc2lvbnNUb0NhY2hlKGFkZGl0aW9uYWxDb252ZXJzaW9ucyk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnNpb25DYWNoZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExleGljYWxFZGl0b3IgYXR0YWNoZWQgdG8gYSBzaW5nbGUgY29udGVudEVkaXRhYmxlIChwcm92aWRlZCBpbiB0aGUgY29uZmlnKS4gVGhpcyBpc1xuICogdGhlIGxvd2VzdC1sZXZlbCBpbml0aWFsaXphdGlvbiBBUEkgZm9yIGEgTGV4aWNhbEVkaXRvci4gSWYgeW91J3JlIHVzaW5nIFJlYWN0IG9yIGFub3RoZXIgZnJhbWV3b3JrLFxuICogY29uc2lkZXIgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGFic3RyYWN0aW9ucywgc3VjaCBhcyBMZXhpY2FsQ29tcG9zZXJcbiAqIEBwYXJhbSBlZGl0b3JDb25maWcgLSB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyBhIExleGljYWxFZGl0b3IgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRpdG9yKGVkaXRvckNvbmZpZykge1xuICBjb25zdCBjb25maWcgPSBlZGl0b3JDb25maWcgfHwge307XG4gIGNvbnN0IGFjdGl2ZUVkaXRvciA9IGludGVybmFsR2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lIHx8IHt9O1xuICBjb25zdCBwYXJlbnRFZGl0b3IgPSBlZGl0b3JDb25maWcgPT09IHVuZGVmaW5lZCA/IGFjdGl2ZUVkaXRvciA6IGNvbmZpZy5wYXJlbnRFZGl0b3IgfHwgbnVsbDtcbiAgY29uc3QgZGlzYWJsZUV2ZW50cyA9IGNvbmZpZy5kaXNhYmxlRXZlbnRzIHx8IGZhbHNlO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgbmFtZXNwYWNlID0gY29uZmlnLm5hbWVzcGFjZSB8fCAocGFyZW50RWRpdG9yICE9PSBudWxsID8gcGFyZW50RWRpdG9yLl9jb25maWcubmFtZXNwYWNlIDogY3JlYXRlVUlEKCkpO1xuICBjb25zdCBpbml0aWFsRWRpdG9yU3RhdGUgPSBjb25maWcuZWRpdG9yU3RhdGU7XG4gIGNvbnN0IG5vZGVzID0gW1Jvb3ROb2RlLCBUZXh0Tm9kZSwgTGluZUJyZWFrTm9kZSwgVGFiTm9kZSwgUGFyYWdyYXBoTm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsIC4uLihjb25maWcubm9kZXMgfHwgW10pXTtcbiAgY29uc3Qge1xuICAgIG9uRXJyb3IsXG4gICAgaHRtbFxuICB9ID0gY29uZmlnO1xuICBjb25zdCBpc0VkaXRhYmxlID0gY29uZmlnLmVkaXRhYmxlICE9PSB1bmRlZmluZWQgPyBjb25maWcuZWRpdGFibGUgOiB0cnVlO1xuICBsZXQgcmVnaXN0ZXJlZE5vZGVzO1xuICBpZiAoZWRpdG9yQ29uZmlnID09PSB1bmRlZmluZWQgJiYgYWN0aXZlRWRpdG9yICE9PSBudWxsKSB7XG4gICAgcmVnaXN0ZXJlZE5vZGVzID0gYWN0aXZlRWRpdG9yLl9ub2RlcztcbiAgfSBlbHNlIHtcbiAgICByZWdpc3RlcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGtsYXNzID0gbm9kZXNbaV07XG4gICAgICBsZXQgcmVwbGFjZSA9IG51bGw7XG4gICAgICBsZXQgcmVwbGFjZVdpdGhLbGFzcyA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGtsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBrbGFzcztcbiAgICAgICAga2xhc3MgPSBvcHRpb25zLnJlcGxhY2U7XG4gICAgICAgIHJlcGxhY2UgPSBvcHRpb25zLndpdGg7XG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3MgPSBvcHRpb25zLndpdGhLbGFzcyB8fCBudWxsO1xuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIGN1c3RvbSBub2RlcyBpbXBsZW1lbnQgcmVxdWlyZWQgbWV0aG9kcyBhbmQgcmVwbGFjZVdpdGhLbGFzcyBpcyBpbnN0YW5jZSBvZiBiYXNlIGtsYXNzLlxuICAgICAge1xuICAgICAgICAvLyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSBjYW4gZ2V0IHJlbmFtZWQsIHNvIHdlIHVzZSB0aGUgdHlwZVxuICAgICAgICBjb25zdCBub2RlVHlwZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrbGFzcywgJ2dldFR5cGUnKSAmJiBrbGFzcy5nZXRUeXBlKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBrbGFzcy5uYW1lO1xuICAgICAgICBpZiAocmVwbGFjZVdpdGhLbGFzcykge1xuICAgICAgICAgIGlmICghKHJlcGxhY2VXaXRoS2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2Yga2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHtyZXBsYWNlV2l0aEtsYXNzLm5hbWV9IGRvZXNuJ3QgZXh0ZW5kIHRoZSAke25hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSAnUm9vdE5vZGUnICYmIG5vZGVUeXBlICE9PSAncm9vdCcgJiYgbm9kZVR5cGUgIT09ICdhcnRpZmljaWFsJykge1xuICAgICAgICAgIGNvbnN0IHByb3RvID0ga2xhc3MucHJvdG90eXBlO1xuICAgICAgICAgIFsnZ2V0VHlwZScsICdjbG9uZSddLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkobWV0aG9kKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gbXVzdCBpbXBsZW1lbnQgc3RhdGljIFwiJHttZXRob2R9XCIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAha2xhc3MuaGFzT3duUHJvcGVydHkoJ2ltcG9ydERPTScpICYmXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KCdleHBvcnRET00nKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IHNob3VsZCBpbXBsZW1lbnQgXCJpbXBvcnRET01cIiBpZiB1c2luZyBhIGN1c3RvbSBcImV4cG9ydERPTVwiIG1ldGhvZCB0byBlbnN1cmUgSFRNTCBzZXJpYWxpemF0aW9uIChpbXBvcnRhbnQgZm9yIGNvcHkgJiBwYXN0ZSkgd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3RvIGluc3RhbmNlb2YgRGVjb3JhdG9yTm9kZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnZGVjb3JhdGUnKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7cHJvdG8uY29uc3RydWN0b3IubmFtZX0gbXVzdCBpbXBsZW1lbnQgXCJkZWNvcmF0ZVwiIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICFrbGFzcy5oYXNPd25Qcm9wZXJ0eSgnaW1wb3J0SlNPTicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gc2hvdWxkIGltcGxlbWVudCBcImltcG9ydEpTT05cIiBtZXRob2QgdG8gZW5zdXJlIEpTT04gYW5kIGRlZmF1bHQgSFRNTCBzZXJpYWxpemF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgIXByb3RvLmhhc093blByb3BlcnR5KCdleHBvcnRKU09OJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBzaG91bGQgaW1wbGVtZW50IFwiZXhwb3J0SlNPTlwiIG1ldGhvZCB0byBlbnN1cmUgSlNPTiBhbmQgZGVmYXVsdCBIVE1MIHNlcmlhbGl6YXRpb24gd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBrbGFzcy50cmFuc2Zvcm0oKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybXMgPSBuZXcgU2V0KCk7XG4gICAgICBpZiAodHJhbnNmb3JtICE9PSBudWxsKSB7XG4gICAgICAgIHRyYW5zZm9ybXMuYWRkKHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlcmVkTm9kZXMuc2V0KHR5cGUsIHtcbiAgICAgICAgZXhwb3J0RE9NOiBodG1sICYmIGh0bWwuZXhwb3J0ID8gaHRtbC5leHBvcnQuZ2V0KGtsYXNzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAga2xhc3MsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3MsXG4gICAgICAgIHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBlZGl0b3IgPSBuZXcgTGV4aWNhbEVkaXRvcihlZGl0b3JTdGF0ZSwgcGFyZW50RWRpdG9yLCByZWdpc3RlcmVkTm9kZXMsIHtcbiAgICBkaXNhYmxlRXZlbnRzLFxuICAgIG5hbWVzcGFjZSxcbiAgICB0aGVtZVxuICB9LCBvbkVycm9yID8gb25FcnJvciA6IGNvbnNvbGUuZXJyb3IsIGluaXRpYWxpemVDb252ZXJzaW9uQ2FjaGUocmVnaXN0ZXJlZE5vZGVzLCBodG1sID8gaHRtbC5pbXBvcnQgOiB1bmRlZmluZWQpLCBpc0VkaXRhYmxlKTtcbiAgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBpbml0aWFsRWRpdG9yU3RhdGU7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgfVxuICByZXR1cm4gZWRpdG9yO1xufVxuY2xhc3MgTGV4aWNhbEVkaXRvciB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihlZGl0b3JTdGF0ZSwgcGFyZW50RWRpdG9yLCBub2RlcywgY29uZmlnLCBvbkVycm9yLCBodG1sQ29udmVyc2lvbnMsIGVkaXRhYmxlKSB7XG4gICAgdGhpcy5fcGFyZW50RWRpdG9yID0gcGFyZW50RWRpdG9yO1xuICAgIC8vIFRoZSByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWRpdG9yXG4gICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBudWxsO1xuICAgIC8vIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICAgIHRoaXMuX2VkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgLy8gSGFuZGxpbmcgb2YgZHJhZnRzIGFuZCB1cGRhdGVzXG4gICAgdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlID0gbnVsbDtcbiAgICAvLyBVc2VkIHRvIGhlbHAgY28tb3JkaW5hdGUgc2VsZWN0aW9uIGFuZCBldmVudHNcbiAgICB0aGlzLl9jb21wb3NpdGlvbktleSA9IG51bGw7XG4gICAgdGhpcy5fZGVmZXJyZWQgPSBbXTtcbiAgICAvLyBVc2VkIGR1cmluZyByZWNvbmNpbGlhdGlvblxuICAgIHRoaXMuX2tleVRvRE9NTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3VwZGF0ZXMgPSBbXTtcbiAgICB0aGlzLl91cGRhdGluZyA9IGZhbHNlO1xuICAgIC8vIExpc3RlbmVyc1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHtcbiAgICAgIGRlY29yYXRvcjogbmV3IFNldCgpLFxuICAgICAgZWRpdGFibGU6IG5ldyBTZXQoKSxcbiAgICAgIG11dGF0aW9uOiBuZXcgTWFwKCksXG4gICAgICByb290OiBuZXcgU2V0KCksXG4gICAgICB0ZXh0Y29udGVudDogbmV3IFNldCgpLFxuICAgICAgdXBkYXRlOiBuZXcgU2V0KClcbiAgICB9O1xuICAgIC8vIENvbW1hbmRzXG4gICAgdGhpcy5fY29tbWFuZHMgPSBuZXcgTWFwKCk7XG4gICAgLy8gRWRpdG9yIGNvbmZpZ3VyYXRpb24gZm9yIHRoZW1lL2NvbnRleHQuXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIE1hcHBpbmcgb2YgdHlwZXMgdG8gdGhlaXIgbm9kZXNcbiAgICB0aGlzLl9ub2RlcyA9IG5vZGVzO1xuICAgIC8vIFJlYWN0IG5vZGUgZGVjb3JhdG9ycyBmb3IgcG9ydGFsc1xuICAgIHRoaXMuX2RlY29yYXRvcnMgPSB7fTtcbiAgICB0aGlzLl9wZW5kaW5nRGVjb3JhdG9ycyA9IG51bGw7XG4gICAgLy8gVXNlZCB0byBvcHRpbWl6ZSByZWNvbmNpbGlhdGlvblxuICAgIHRoaXMuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICAgIHRoaXMuX2Nsb25lTm90TmVlZGVkID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RpcnR5RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fbm9ybWFsaXplZE5vZGVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gICAgLy8gSGFuZGxpbmcgb2YgRE9NIG11dGF0aW9uc1xuICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICAvLyBVc2VkIGZvciBpZGVudGlmeWluZyBvd25pbmcgZWRpdG9yc1xuICAgIHRoaXMuX2tleSA9IGNyZWF0ZVVJRCgpO1xuICAgIHRoaXMuX29uRXJyb3IgPSBvbkVycm9yO1xuICAgIHRoaXMuX2h0bWxDb252ZXJzaW9ucyA9IGh0bWxDb252ZXJzaW9ucztcbiAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgIHRoaXMuX2hlYWRsZXNzID0gcGFyZW50RWRpdG9yICE9PSBudWxsICYmIHBhcmVudEVkaXRvci5faGVhZGxlc3M7XG4gICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICB0aGlzLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgaW4gXCJjb21wb3NpdGlvblwiIG1vZGUgZHVlIHRvIHJlY2VpdmluZyBpbnB1dFxuICAgKiB0aHJvdWdoIGFuIElNRSwgb3IgM1AgZXh0ZW5zaW9uLCBmb3IgZXhhbXBsZS4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbXBvc2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9zaXRpb25LZXkgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIEVkaXRvciB1cGRhdGUgZXZlbnQuIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAgICogZWFjaCB0aW1lIHRoZSBlZGl0b3IgZ29lcyB0aHJvdWdoIGFuIHVwZGF0ZSAodmlhIHtAbGluayBMZXhpY2FsRWRpdG9yLnVwZGF0ZX0pIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLnVwZGF0ZTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgZm9yIHdoZW4gdGhlIGVkaXRvciBjaGFuZ2VzIGJldHdlZW4gZWRpdGFibGUgYW5kIG5vbi1lZGl0YWJsZSBzdGF0ZXMuXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy5lZGl0YWJsZTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3Igd2hlbiB0aGUgZWRpdG9yJ3MgZGVjb3JhdG9yIG9iamVjdCBjaGFuZ2VzLiBUaGUgZGVjb3JhdG9yIG9iamVjdCBjb250YWluc1xuICAgKiBhbGwgRGVjb3JhdG9yTm9kZSBrZXlzIC0+IHRoZWlyIGRlY29yYXRlZCB2YWx1ZS4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB3aXRoIGV4dGVybmFsIFVJIGZyYW1ld29ya3MuXG4gICAqXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMuZGVjb3JhdG9yO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIExleGljYWwgY29tbWl0cyBhbiB1cGRhdGUgdG8gdGhlIERPTSBhbmQgdGhlIHRleHQgY29udGVudCBvZlxuICAgKiB0aGUgZWRpdG9yIGNoYW5nZXMgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGVkaXRvci4gSWYgdGhlIHRleHQgY29udGVudCBpcyB0aGVcbiAgICogc2FtZSBiZXR3ZWVuIHVwZGF0ZXMsIG5vIG5vdGlmaWNhdGlvbnMgdG8gdGhlIGxpc3RlbmVycyB3aWxsIGhhcHBlbi5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlclRleHRDb250ZW50TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLnRleHRjb250ZW50O1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIHRoZSBlZGl0b3IncyByb290IERPTSBlbGVtZW50ICh0aGUgY29udGVudCBlZGl0YWJsZVxuICAgKiBMZXhpY2FsIGF0dGFjaGVzIHRvKSBjaGFuZ2VzLiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHJvb3RcbiAgICogIGVsZW1lbnQuIFRoZSByb290IGxpc3RlbmVyIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGRpcmVjdGx5IHVwb24gcmVnaXN0cmF0aW9uIGFuZCB0aGVuIG9uXG4gICAqIGFueSBzdWJzZXF1ZW50IHVwZGF0ZS5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlclJvb3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMucm9vdDtcbiAgICBsaXN0ZW5lcih0aGlzLl9yb290RWxlbWVudCwgbnVsbCk7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcihudWxsLCB0aGlzLl9yb290RWxlbWVudCk7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHRyaWdnZXIgYW55dGltZSB0aGUgcHJvdmlkZWQgY29tbWFuZFxuICAgKiBpcyBkaXNwYXRjaGVkLCBzdWJqZWN0IHRvIHByaW9yaXR5LiBMaXN0ZW5lcnMgdGhhdCBydW4gYXQgYSBoaWdoZXIgcHJpb3JpdHkgY2FuIFwiaW50ZXJjZXB0XCJcbiAgICogY29tbWFuZHMgYW5kIHByZXZlbnQgdGhlbSBmcm9tIHByb3BhZ2F0aW5nIHRvIG90aGVyIGhhbmRsZXJzIGJ5IHJldHVybmluZyB0cnVlLlxuICAgKlxuICAgKiBMaXN0ZW5lcnMgcmVnaXN0ZXJlZCBhdCB0aGUgc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIHJ1biBkZXRlcm1pbmlzdGljYWxseSBpbiB0aGUgb3JkZXIgb2YgcmVnaXN0cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29tbWFuZCAtIHRoZSBjb21tYW5kIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIHdoZW4gdGhlIGNvbW1hbmQgaXMgZGlzcGF0Y2hlZC5cbiAgICogQHBhcmFtIHByaW9yaXR5IC0gdGhlIHJlbGF0aXZlIHByaW9yaXR5IG9mIHRoZSBsaXN0ZW5lci4gMCB8IDEgfCAyIHwgMyB8IDRcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGxpc3RlbmVyLCBwcmlvcml0eSkge1xuICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMaXN0ZW5lciBmb3IgdHlwZSBcImNvbW1hbmRcIiByZXF1aXJlcyBhIFwicHJpb3JpdHlcIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29tbWFuZHNNYXAgPSB0aGlzLl9jb21tYW5kcztcbiAgICBpZiAoIWNvbW1hbmRzTWFwLmhhcyhjb21tYW5kKSkge1xuICAgICAgY29tbWFuZHNNYXAuc2V0KGNvbW1hbmQsIFtuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBTZXQoKV0pO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIgPSBjb21tYW5kc01hcC5nZXQoY29tbWFuZCk7XG4gICAgaWYgKGxpc3RlbmVyc0luUHJpb3JpdHlPcmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGByZWdpc3RlckNvbW1hbmQ6IENvbW1hbmQgJHtTdHJpbmcoY29tbWFuZCl9IG5vdCBmb3VuZCBpbiBjb21tYW5kIG1hcGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXJbcHJpb3JpdHldO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIGlmIChsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIuZXZlcnkobGlzdGVuZXJzU2V0ID0+IGxpc3RlbmVyc1NldC5zaXplID09PSAwKSkge1xuICAgICAgICBjb21tYW5kc01hcC5kZWxldGUoY29tbWFuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgcnVuIHdoZW4gYSBMZXhpY2FsIG5vZGUgb2YgdGhlIHByb3ZpZGVkIGNsYXNzIGlzXG4gICAqIG11dGF0ZWQuIFRoZSBsaXN0ZW5lciB3aWxsIHJlY2VpdmUgYSBsaXN0IG9mIG5vZGVzIGFsb25nIHdpdGggdGhlIHR5cGUgb2YgbXV0YXRpb25cbiAgICogdGhhdCB3YXMgcGVyZm9ybWVkIG9uIGVhY2g6IGNyZWF0ZWQsIGRlc3Ryb3llZCwgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogT25lIGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0byBhdHRhY2ggRE9NIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZXMgYXMgTGV4aWNhbCBub2RlcyBhcmUgY3JlYXRlZC5cbiAgICoge0BsaW5rIExleGljYWxFZGl0b3IuZ2V0RWxlbWVudEJ5S2V5fSBjYW4gYmUgdXNlZCBmb3IgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIGtsYXNzIC0gVGhlIGNsYXNzIG9mIHRoZSBub2RlIHRoYXQgeW91IHdhbnQgdG8gbGlzdGVuIHRvIG11dGF0aW9ucyBvbi5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxvZ2ljIHlvdSB3YW50IHRvIHJ1biB3aGVuIHRoZSBub2RlIGlzIG11dGF0ZWQuXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcihrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBsZXQgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoa2xhc3MuZ2V0VHlwZSgpKTtcbiAgICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTm9kZSAke2tsYXNzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLiBFbnN1cmUgbm9kZSBoYXMgYmVlbiBwYXNzZWQgdG8gY3JlYXRlRWRpdG9yLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2xhc3NUb011dGF0ZSA9IGtsYXNzO1xuICAgIGxldCByZXBsYWNlS2xhc3MgPSBudWxsO1xuICAgIHdoaWxlIChyZXBsYWNlS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5yZXBsYWNlV2l0aEtsYXNzKSB7XG4gICAgICBrbGFzc1RvTXV0YXRlID0gcmVwbGFjZUtsYXNzO1xuICAgICAgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQocmVwbGFjZUtsYXNzLmdldFR5cGUoKSk7XG4gICAgICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtyZXBsYWNlS2xhc3MubmFtZX0gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuIEVuc3VyZSBub2RlIGhhcyBiZWVuIHBhc3NlZCB0byBjcmVhdGVFZGl0b3IuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbXV0YXRpb25zID0gdGhpcy5fbGlzdGVuZXJzLm11dGF0aW9uO1xuICAgIG11dGF0aW9ucy5zZXQobGlzdGVuZXIsIGtsYXNzVG9NdXRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtdXRhdGlvbnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWdpc3Rlck5vZGVUcmFuc2Zvcm1Ub0tsYXNzKGtsYXNzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHR5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQodHlwZSk7XG4gICAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtrbGFzcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC4gRW5zdXJlIG5vZGUgaGFzIGJlZW4gcGFzc2VkIHRvIGNyZWF0ZUVkaXRvci5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtcyA9IHJlZ2lzdGVyZWROb2RlLnRyYW5zZm9ybXM7XG4gICAgdHJhbnNmb3Jtcy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiByZWdpc3RlcmVkTm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgcnVuIHdoZW4gYSBMZXhpY2FsIG5vZGUgb2YgdGhlIHByb3ZpZGVkIGNsYXNzIGlzXG4gICAqIG1hcmtlZCBkaXJ0eSBkdXJpbmcgYW4gdXBkYXRlLiBUaGUgbGlzdGVuZXIgd2lsbCBjb250aW51ZSB0byBydW4gYXMgbG9uZyBhcyB0aGUgbm9kZVxuICAgKiBpcyBtYXJrZWQgZGlydHkuIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGFyb3VuZCB0aGUgb3JkZXIgb2YgdHJhbnNmb3JtIGV4ZWN1dGlvbiFcbiAgICpcbiAgICogV2F0Y2ggb3V0IGZvciBpbmZpbml0ZSBsb29wcy4gU2VlIFtOb2RlIFRyYW5zZm9ybXNdKGh0dHBzOi8vbGV4aWNhbC5kZXYvZG9jcy9jb25jZXB0cy90cmFuc2Zvcm1zKVxuICAgKiBAcGFyYW0ga2xhc3MgLSBUaGUgY2xhc3Mgb2YgdGhlIG5vZGUgdGhhdCB5b3Ugd2FudCB0byBydW4gdHJhbnNmb3JtcyBvbi5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxvZ2ljIHlvdSB3YW50IHRvIHJ1biB3aGVuIHRoZSBub2RlIGlzIHVwZGF0ZWQuXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyTm9kZVRyYW5zZm9ybShrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHRoaXMucmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhrbGFzcywgbGlzdGVuZXIpO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlcyA9IFtyZWdpc3RlcmVkTm9kZV07XG4gICAgY29uc3QgcmVwbGFjZVdpdGhLbGFzcyA9IHJlZ2lzdGVyZWROb2RlLnJlcGxhY2VXaXRoS2xhc3M7XG4gICAgaWYgKHJlcGxhY2VXaXRoS2xhc3MgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVnaXN0ZXJlZFJlcGxhY2VXaXRoTm9kZSA9IHRoaXMucmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhyZXBsYWNlV2l0aEtsYXNzLCBsaXN0ZW5lcik7XG4gICAgICByZWdpc3RlcmVkTm9kZXMucHVzaChyZWdpc3RlcmVkUmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG4gICAgbWFya0FsbE5vZGVzQXNEaXJ0eSh0aGlzLCBrbGFzcy5nZXRUeXBlKCkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZWdpc3RlcmVkTm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUudHJhbnNmb3Jtcy5kZWxldGUobGlzdGVuZXIpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXNzZXJ0IHRoYXQgYSBjZXJ0YWluIG5vZGUgaXMgcmVnaXN0ZXJlZCwgdXN1YWxseSBieSBwbHVnaW5zIHRvIGVuc3VyZSBub2RlcyB0aGF0IHRoZXlcbiAgICogZGVwZW5kIG9uIGhhdmUgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlZGl0b3IgaGFzIHJlZ2lzdGVyZWQgdGhlIHByb3ZpZGVkIG5vZGUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmhhcyhub2RlLmdldFR5cGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBhc3NlcnQgdGhhdCBjZXJ0YWluIG5vZGVzIGFyZSByZWdpc3RlcmVkLCB1c3VhbGx5IGJ5IHBsdWdpbnMgdG8gZW5zdXJlIG5vZGVzIHRoYXQgdGhleVxuICAgKiBkZXBlbmQgb24gaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBoYXMgcmVnaXN0ZXJlZCBhbGwgb2YgdGhlIHByb3ZpZGVkIG5vZGUgdHlwZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc05vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLmV2ZXJ5KHRoaXMuaGFzTm9kZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgY29tbWFuZCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgd2l0aCB0aGUgc3BlY2lmaWVkIHBheWxvYWQuXG4gICAqIFRoaXMgdHJpZ2dlcnMgYWxsIGNvbW1hbmQgbGlzdGVuZXJzIChzZXQgYnkge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJDb21tYW5kfSlcbiAgICogZm9yIHRoaXMgdHlwZSwgcGFzc2luZyB0aGVtIHRoZSBwcm92aWRlZCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIGNvbW1hbmQgbGlzdGVuZXJzIHRvIHRyaWdnZXIuXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gdGhlIGRhdGEgdG8gcGFzcyBhcyBhbiBhcmd1bWVudCB0byB0aGUgY29tbWFuZCBsaXN0ZW5lcnMuXG4gICAqL1xuICBkaXNwYXRjaENvbW1hbmQodHlwZSwgcGF5bG9hZCkge1xuICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQodGhpcywgdHlwZSwgcGF5bG9hZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIG1hcCBvZiBhbGwgZGVjb3JhdG9ycyBpbiB0aGUgZWRpdG9yLlxuICAgKiBAcmV0dXJucyBBIG1hcHBpbmcgb2YgY2FsbCBkZWNvcmF0b3Iga2V5cyB0byB0aGVpciBkZWNvcmF0ZWQgY29udGVudFxuICAgKi9cbiAgZ2V0RGVjb3JhdG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjb3JhdG9ycztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCByb290IGVsZW1lbnQgb2YgdGhlIGVkaXRvci4gSWYgeW91IHdhbnQgdG8gcmVnaXN0ZXJcbiAgICogYW4gZXZlbnQgbGlzdGVuZXIsIGRvIGl0IHZpYSB7QGxpbmsgTGV4aWNhbEVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcn0sIHNpbmNlXG4gICAqIHRoaXMgcmVmZXJlbmNlIG1heSBub3QgYmUgc3RhYmxlLlxuICAgKi9cbiAgZ2V0Um9vdEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGtleSBvZiB0aGUgZWRpdG9yXG4gICAqIEByZXR1cm5zIFRoZSBlZGl0b3Iga2V5XG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBlcmF0aXZlbHkgc2V0IHRoZSByb290IGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IHRoYXQgTGV4aWNhbCBsaXN0ZW5zXG4gICAqIGZvciBldmVudHMgb24uXG4gICAqL1xuICBzZXRSb290RWxlbWVudChuZXh0Um9vdEVsZW1lbnQpIHtcbiAgICBjb25zdCBwcmV2Um9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBwcmV2Um9vdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBnZXRDYWNoZWRDbGFzc05hbWVBcnJheSh0aGlzLl9jb25maWcudGhlbWUsICdyb290Jyk7XG4gICAgICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSB0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgfHwgdGhpcy5fZWRpdG9yU3RhdGU7XG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IG5leHRSb290RWxlbWVudDtcbiAgICAgIHJlc2V0RWRpdG9yKHRoaXMsIHByZXZSb290RWxlbWVudCwgbmV4dFJvb3RFbGVtZW50LCBwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICAgICAgaWYgKHByZXZSb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBmbGFnIG9uY2Ugd2Ugbm8gbG9uZ2VyIHVzZSBVRXYyIGludGVybmFsbHlcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuZGlzYWJsZUV2ZW50cykge1xuICAgICAgICAgIHJlbW92ZVJvb3RFbGVtZW50RXZlbnRzKHByZXZSb290RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgIHByZXZSb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd09iaiA9IGdldERlZmF1bHRWaWV3KG5leHRSb290RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gbmV4dFJvb3RFbGVtZW50LnN0eWxlO1xuICAgICAgICBzdHlsZS51c2VyU2VsZWN0ID0gJ3RleHQnO1xuICAgICAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgICAgICAgc3R5bGUud29yZEJyZWFrID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICBuZXh0Um9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZWRpdG9yJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fd2luZG93ID0gd2luZG93T2JqO1xuICAgICAgICB0aGlzLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgICAgICAgaW5pdE11dGF0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRhZ3MuYWRkKCdoaXN0b3J5LW1lcmdlJyk7XG4gICAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyh0aGlzKTtcblxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBmbGFnIG9uY2Ugd2Ugbm8gbG9uZ2VyIHVzZSBVRXYyIGludGVybmFsbHlcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuZGlzYWJsZUV2ZW50cykge1xuICAgICAgICAgIGFkZFJvb3RFbGVtZW50RXZlbnRzKG5leHRSb290RWxlbWVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgIG5leHRSb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBjb250ZW50IGVkaXRhYmxlIGlzIHVubW91bnRlZCB3ZSdsbCByZXNldCBlZGl0b3Igc3RhdGUgYmFjayB0byBvcmlnaW5hbFxuICAgICAgICAvLyAob3IgcGVuZGluZykgZWRpdG9yIHN0YXRlIHNpbmNlIHRoZXJlIHdpbGwgYmUgbm8gcmVjb25jaWxpYXRpb25cbiAgICAgICAgdGhpcy5fZWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyTGlzdGVuZXJzKCdyb290JywgdGhpcywgZmFsc2UsIG5leHRSb290RWxlbWVudCwgcHJldlJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW5kZXJseWluZyBIVE1MRWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIExleGljYWxOb2RlIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgKiBAcmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgcmVuZGVyZWQgYnkgdGhlIExleGljYWxOb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LlxuICAgKiBAcGFyYW0ga2V5IC0gdGhlIGtleSBvZiB0aGUgTGV4aWNhbE5vZGUuXG4gICAqL1xuICBnZXRFbGVtZW50QnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleVRvRE9NTWFwLmdldChrZXkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aXZlIGVkaXRvciBzdGF0ZS5cbiAgICogQHJldHVybnMgVGhlIGVkaXRvciBzdGF0ZVxuICAgKi9cbiAgZ2V0RWRpdG9yU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvclN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGVyYXRpdmVseSBzZXQgdGhlIEVkaXRvclN0YXRlLiBUcmlnZ2VycyByZWNvbmNpbGlhdGlvbiBsaWtlIGFuIHVwZGF0ZS5cbiAgICogQHBhcmFtIGVkaXRvclN0YXRlIC0gdGhlIHN0YXRlIHRvIHNldCB0aGUgZWRpdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZS5cbiAgICovXG4gIHNldEVkaXRvclN0YXRlKGVkaXRvclN0YXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgc2V0RWRpdG9yU3RhdGU6IHRoZSBlZGl0b3Igc3RhdGUgaXMgZW1wdHkuIEVuc3VyZSB0aGUgZWRpdG9yIHN0YXRlJ3Mgcm9vdCBub2RlIG5ldmVyIGJlY29tZXMgZW1wdHkuYCk7XG4gICAgICB9XG4gICAgfVxuICAgICRmbHVzaFJvb3RNdXRhdGlvbnModGhpcyk7XG4gICAgY29uc3QgcGVuZGluZ0VkaXRvclN0YXRlID0gdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlO1xuICAgIGNvbnN0IHRhZ3MgPSB0aGlzLl91cGRhdGVUYWdzO1xuICAgIGNvbnN0IHRhZyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGFnIDogbnVsbDtcbiAgICBpZiAocGVuZGluZ0VkaXRvclN0YXRlICE9PSBudWxsICYmICFwZW5kaW5nRWRpdG9yU3RhdGUuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGFnICE9IG51bGwpIHtcbiAgICAgICAgdGFncy5hZGQodGFnKTtcbiAgICAgIH1cbiAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgdGhpcy5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgdGhpcy5fZGlydHlFbGVtZW50cy5zZXQoJ3Jvb3QnLCBmYWxzZSk7XG4gICAgdGhpcy5fY29tcG9zaXRpb25LZXkgPSBudWxsO1xuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdGFncy5hZGQodGFnKTtcbiAgICB9XG4gICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSAodXN1YWxseSBwcm9kdWNlZCBieSB7QGxpbmsgRWRpdG9yU3RhdGUudG9KU09OfSkgYW5kIHJldHVybnNcbiAgICogYW5kIEVkaXRvclN0YXRlIG9iamVjdCB0aGF0IGNhbiBiZSwgZm9yIGV4YW1wbGUsIHBhc3NlZCB0byB7QGxpbmsgTGV4aWNhbEVkaXRvci5zZXRFZGl0b3JTdGF0ZX0uIFR5cGljYWxseSxcbiAgICogZGVzZXJsaWF6YXRpb24gZnJvbSBKU09OIHN0b3JlZCBpbiBhIGRhdGFiYXNlIHVzZXMgdGhpcyBtZXRob2QuXG4gICAqIEBwYXJhbSBtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGVcbiAgICogQHBhcmFtIHVwZGF0ZUZuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBwYXJzZUVkaXRvclN0YXRlKG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSwgdXBkYXRlRm4pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkRWRpdG9yU3RhdGUgPSB0eXBlb2YgbWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlKSA6IG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZTtcbiAgICByZXR1cm4gcGFyc2VFZGl0b3JTdGF0ZShzZXJpYWxpemVkRWRpdG9yU3RhdGUsIHRoaXMsIHVwZGF0ZUZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiB1cGRhdGUgdG8gdGhlIGVkaXRvciBzdGF0ZS4gVGhlIHVwZGF0ZUZuIGNhbGxiYWNrIGlzIHRoZSBPTkxZIHBsYWNlXG4gICAqIHdoZXJlIExleGljYWwgZWRpdG9yIHN0YXRlIGNhbiBiZSBzYWZlbHkgbXV0YXRlZC5cbiAgICogQHBhcmFtIHVwZGF0ZUZuIC0gQSBmdW5jdGlvbiB0aGF0IGhhcyBhY2Nlc3MgdG8gd3JpdGFibGUgZWRpdG9yIHN0YXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEgYmFnIG9mIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhlIHVwZGF0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMub25VcGRhdGUgLSBBIGZ1bmN0aW9uIHRvIHJ1biBvbmNlIHRoZSB1cGRhdGUgaXMgY29tcGxldGUuXG4gICAqIFVzZWZ1bCBmb3Igc3luY2hyb25pemluZyB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNraXBUcmFuc2Zvcm1zIC0gU2V0dGluZyB0aGlzIHRvIHRydWUgd2lsbCBzdXBwcmVzcyBhbGwgbm9kZVxuICAgKiB0cmFuc2Zvcm1zIGZvciB0aGlzIHVwZGF0ZSBjeWNsZS5cbiAgICogQHBhcmFtIG9wdGlvbnMudGFnIC0gQSB0YWcgdG8gaWRlbnRpZnkgdGhpcyB1cGRhdGUsIGluIGFuIHVwZGF0ZSBsaXN0ZW5lciwgZm9yIGluc3RhbmNlLlxuICAgKiBTb21lIHRhZ3MgYXJlIHJlc2VydmVkIGJ5IHRoZSBjb3JlIGFuZCBjb250cm9sIHVwZGF0ZSBiZWhhdmlvciBpbiBkaWZmZXJlbnQgd2F5cy5cbiAgICogQHBhcmFtIG9wdGlvbnMuZGlzY3JldGUgLSBJZiB0cnVlLCBwcmV2ZW50cyB0aGlzIHVwZGF0ZSBmcm9tIGJlaW5nIGJhdGNoZWQsIGZvcmNpbmcgaXQgdG9cbiAgICogcnVuIHN5bmNocm9ub3VzbHkuXG4gICAqL1xuICB1cGRhdGUodXBkYXRlRm4sIG9wdGlvbnMpIHtcbiAgICB1cGRhdGVFZGl0b3IodGhpcywgdXBkYXRlRm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIGVkaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2tGbiAtIEEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBIGJhZyBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gLSBXaGVyZSB0byBtb3ZlIHNlbGVjdGlvbiB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICogZm9jdXNlZC4gQ2FuIGJlIHJvb3RTdGFydCwgcm9vdEVuZCwgb3IgdW5kZWZpbmVkLiBEZWZhdWx0cyB0byByb290RW5kLlxuICAgKi9cbiAgZm9jdXMoY2FsbGJhY2tGbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlPUyBkb2VzIG5vdCB0cmlnZ2VyIGNhcHMgbG9jayB1cG9uIGZvY3VzXG4gICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgICAgdXBkYXRlRWRpdG9yKHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1hcmtpbmcgdGhlIHNlbGVjdGlvbiBkaXJ0eSB3aWxsIGZvcmNlIHRoZSBzZWxlY3Rpb24gYmFjayB0byBpdFxuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdC5nZXRDaGlsZHJlblNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gPT09ICdyb290U3RhcnQnKSB7XG4gICAgICAgICAgICByb290LnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgICAgIGlmIChjYWxsYmFja0ZuKSB7XG4gICAgICAgICAgICBjYWxsYmFja0ZuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0YWc6ICdmb2N1cydcbiAgICAgIH0pO1xuICAgICAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgb25VcGRhdGUgZG9lc24ndCBmaXJlIChkdWUgdG8gdGhlIGZvY3VzIHVwZGF0ZSBub3RcbiAgICAgIC8vIG9jY3VyaW5nKS5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICovXG4gIGJsdXIoKSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuX3dpbmRvdyk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRpdGFibGUgcHJvcGVydHkgb2YgdGhlIGVkaXRvci4gV2hlbiBmYWxzZSwgdGhlXG4gICAqIGVkaXRvciB3aWxsIG5vdCBsaXN0ZW4gZm9yIHVzZXIgZXZlbnRzIG9uIHRoZSB1bmRlcmxpbmcgY29udGVudGVkaXRhYmxlLlxuICAgKiBAcGFyYW0gZWRpdGFibGUgLSB0aGUgdmFsdWUgdG8gc2V0IHRoZSBlZGl0YWJsZSBtb2RlIHRvLlxuICAgKi9cbiAgc2V0RWRpdGFibGUoZWRpdGFibGUpIHtcbiAgICBpZiAodGhpcy5fZWRpdGFibGUgIT09IGVkaXRhYmxlKSB7XG4gICAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgICAgdHJpZ2dlckxpc3RlbmVycygnZWRpdGFibGUnLCB0aGlzLCB0cnVlLCBlZGl0YWJsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgamF2YXNjcmlwdCBvYmplY3QgTk9UIGEgSlNPTiBzdHJpbmcuXG4gICAqIFlvdSBzdGlsbCBtdXN0IGNhbGwgSlNPTi5zdHJpbmdpZnkgKG9yIHNvbWV0aGluZyBlbHNlKSB0byB0dXJuIHRoZVxuICAgKiBzdGF0ZSBpbnRvIGEgc3RyaW5nIHlvdSBjYW4gdHJhbnNmZXIgb3ZlciB0aGUgd2lyZSBhbmQgc3RvcmUgaW4gYSBkYXRhYmFzZS5cbiAgICpcbiAgICogU2VlIHtAbGluayBMZXhpY2FsTm9kZS5leHBvcnRKU09OfVxuICAgKlxuICAgKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRvclN0YXRlOiB0aGlzLl9lZGl0b3JTdGF0ZS50b0pTT04oKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHsgJGFkZFVwZGF0ZVRhZywgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkY29weU5vZGUsICRjcmVhdGVMaW5lQnJlYWtOb2RlLCAkY3JlYXRlTm9kZVNlbGVjdGlvbiwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRjcmVhdGVQb2ludCwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tLCAkY3JlYXRlVGFiTm9kZSwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0QWRqYWNlbnROb2RlLCAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cywgJGdldEVkaXRvciwgJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUsICRnZXROZWFyZXN0Um9vdE9yU2hhZG93Um9vdCwgJGdldE5vZGVCeUtleSwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkZ2V0Um9vdCwgJGdldFNlbGVjdGlvbiwgJGdldFRleHRDb250ZW50LCAkaGFzQW5jZXN0b3IsICRoYXNVcGRhdGVUYWcsICRpbnNlcnROb2RlcywgJGlzQmxvY2tFbGVtZW50Tm9kZSwgJGlzRGVjb3JhdG9yTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUsICRpc0xlYWZOb2RlLCAkaXNMaW5lQnJlYWtOb2RlLCAkaXNOb2RlU2VsZWN0aW9uLCAkaXNQYXJhZ3JhcGhOb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE5vZGUsICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRpc1RhYk5vZGUsICRpc1RleHROb2RlLCAkbm9kZXNPZlR5cGUsICRub3JtYWxpemVTZWxlY3Rpb24gYXMgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkcGFyc2VTZXJpYWxpemVkTm9kZSwgJHNlbGVjdEFsbCwgJHNldENvbXBvc2l0aW9uS2V5LCAkc2V0U2VsZWN0aW9uLCAkc3BsaXROb2RlLCBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSwgQkxVUl9DT01NQU5ELCBDQU5fUkVET19DT01NQU5ELCBDQU5fVU5ET19DT01NQU5ELCBDTEVBUl9FRElUT1JfQ09NTUFORCwgQ0xFQVJfSElTVE9SWV9DT01NQU5ELCBDTElDS19DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgQ09NTUFORF9QUklPUklUWV9ISUdILCBDT01NQU5EX1BSSU9SSVRZX0xPVywgQ09NTUFORF9QUklPUklUWV9OT1JNQUwsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgQ09QWV9DT01NQU5ELCBDVVRfQ09NTUFORCwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfV09SRF9DT01NQU5ELCBEUkFHRU5EX0NPTU1BTkQsIERSQUdPVkVSX0NPTU1BTkQsIERSQUdTVEFSVF9DT01NQU5ELCBEUk9QX0NPTU1BTkQsIERlY29yYXRvck5vZGUsIEVsZW1lbnROb2RlLCBGT0NVU19DT01NQU5ELCBGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBGT1JNQVRfVEVYVF9DT01NQU5ELCBJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIElOU0VSVF9UQUJfQ09NTUFORCwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIEtFWV9BUlJPV19VUF9DT01NQU5ELCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORCwgS0VZX0RPV05fQ09NTUFORCwgS0VZX0VOVEVSX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgS0VZX01PRElGSUVSX0NPTU1BTkQsIEtFWV9TUEFDRV9DT01NQU5ELCBLRVlfVEFCX0NPTU1BTkQsIExpbmVCcmVha05vZGUsIE1PVkVfVE9fRU5ELCBNT1ZFX1RPX1NUQVJULCBPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgUEFTVEVfQ09NTUFORCwgUGFyYWdyYXBoTm9kZSwgUkVET19DT01NQU5ELCBSRU1PVkVfVEVYVF9DT01NQU5ELCBSb290Tm9kZSwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCBTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCBTRUxFQ1RfQUxMX0NPTU1BTkQsIFRhYk5vZGUsIFRleHROb2RlLCBVTkRPX0NPTU1BTkQsIGNyZWF0ZUNvbW1hbmQsIGNyZWF0ZUVkaXRvciwgZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlLCBpc0Jsb2NrRG9tTm9kZSwgaXNDdXJyZW50bHlSZWFkT25seU1vZGUsIGlzSFRNTEFuY2hvckVsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzSW5saW5lRG9tTm9kZSwgaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQsIGlzU2VsZWN0aW9uV2l0aGluRWRpdG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/lexical/Lexical.dev.mjs\n");

/***/ })

};
;