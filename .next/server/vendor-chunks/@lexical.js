"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical";
exports.ids = ["vendor-chunks/@lexical"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: () => (/* binding */ $generateJSONFromSelectedNodes),\n/* harmony export */   $generateNodesFromSerializedNodes: () => (/* binding */ $generateNodesFromSerializedNodes),\n/* harmony export */   $getHtmlContent: () => (/* binding */ $getHtmlContent),\n/* harmony export */   $getLexicalContent: () => (/* binding */ $getLexicalContent),\n/* harmony export */   $insertDataTransferForPlainText: () => (/* binding */ $insertDataTransferForPlainText),\n/* harmony export */   $insertDataTransferForRichText: () => (/* binding */ $insertDataTransferForRichText),\n/* harmony export */   $insertGeneratedNodes: () => (/* binding */ $insertGeneratedNodes),\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEU7QUFDMEI7QUFDckQ7QUFDaU07O0FBRXBQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0EsU0FBUyxxRUFBc0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQXFCO0FBQ3pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLGlDQUFpQyxzREFBYTtBQUM5QyxZQUFZLDBEQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osMENBQTBDLHVEQUFjO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkVBQXdDO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQSxnQkFBZ0Isd0VBQW9CO0FBQ3BDLFlBQVksb0RBQVcsZ0NBQWdDLGlGQUE2QjtBQUNwRjtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBLGlCQUFpQiw2REFBb0I7QUFDckMsUUFBUSxvREFBVztBQUNuQixNQUFNLGlFQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaURBQVk7QUFDOUQsVUFBVSxpRUFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLDhEQUF5QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdFQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYubWpzPzlhMDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00gfSBmcm9tICdAbGV4aWNhbC9odG1sJztcbmltcG9ydCB7ICRhZGROb2RlU3R5bGUsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBvYmplY3RLbGFzc0VxdWFscyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkY3JlYXRlVGFiTm9kZSwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFJvb3QsICRwYXJzZVNlcmlhbGl6ZWROb2RlLCAkaXNUZXh0Tm9kZSwgQ09QWV9DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMLCBpc1NlbGVjdGlvbldpdGhpbkVkaXRvciwgJGlzRWxlbWVudE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZ2V0RE9NU2VsZWN0aW9uID0gdGFyZ2V0V2luZG93ID0+IENBTl9VU0VfRE9NID8gKHRhcmdldFdpbmRvdyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpIDogbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAqY3VycmVudGx5IHNlbGVjdGVkKiBMZXhpY2FsIGNvbnRlbnQgYXMgYW4gSFRNTCBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRET00gbWV0aG9kcyBvbiB0aGUgTGV4aWNhbE5vZGUgY2xhc3Nlcy4gTm90ZSB0aGF0XG4gKiB0aGlzIHdpbGwgbm90IHJldHVybiB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBlbnRpcmUgZWRpdG9yICh1bmxlc3MgYWxsIHRoZSBjb250ZW50IGlzIGluY2x1ZGVkXG4gKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgLSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGdldCBIVE1MIGNvbnRlbnQgZnJvbVxuICogQHJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uICRnZXRIdG1sQ29udGVudChlZGl0b3IpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdmFsaWQgTGV4aWNhbFNlbGVjdGlvbmApO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGhhdmVuJ3Qgc2VsZWN0ZWQgYW55dGhpbmdcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgc2VsZWN0aW9uLmdldE5vZGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAqY3VycmVudGx5IHNlbGVjdGVkKiBMZXhpY2FsIGNvbnRlbnQgYXMgYSBKU09OIHN0cmluZywgcmVseWluZyBvbiB0aGVcbiAqIGxvZ2ljIGRlZmluZWQgaW4gdGhlIGV4cG9ydEpTT04gbWV0aG9kcyBvbiB0aGUgTGV4aWNhbE5vZGUgY2xhc3Nlcy4gTm90ZSB0aGF0XG4gKiB0aGlzIHdpbGwgbm90IHJldHVybiB0aGUgSlNPTiBjb250ZW50IG9mIHRoZSBlbnRpcmUgZWRpdG9yICh1bmxlc3MgYWxsIHRoZSBjb250ZW50IGlzIGluY2x1ZGVkXG4gKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgIC0gTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkZ2V0TGV4aWNhbENvbnRlbnQoZWRpdG9yKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSgkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgY29udGVudCBvZiB0aGUgbWltZS10eXBlcyB0ZXh0L3BsYWluIG9yIHRleHQvdXJpLWxpc3QgZnJvbVxuICogdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlciBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKiB0ZXh0L3VyaS1saXN0IGlzIG9ubHkgdXNlZCBpZiB0ZXh0L3BsYWluIGlzIG5vdCBhbHNvIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciwgdGV4dC9odG1sLFxuICogdGV4dC9wbGFpbiwgb3IgdGV4dC91cmktbGlzdCAoaW4gZGVzY2VuZGluZyBvcmRlciBvZiBwcmlvcml0eSkgZnJvbSB0aGUgcHJvdmlkZWQgRGF0YVRyYW5zZmVyXG4gKiBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRhdGFUcmFuc2ZlciBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgW0RhdGFUcmFuc2ZlciBpbnRlcmZhY2VdIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kbmQuaHRtbCN0aGUtZGF0YXRyYW5zZmVyLWludGVyZmFjZSlcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byB1c2UgYXMgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIGNvbnRlbnQgaW4gdGhlIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgdGhlIGNvbnRlbnQgaXMgYmVpbmcgaW5zZXJ0ZWQgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJyk7XG4gIGlmIChsZXhpY2FsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGxleGljYWxTdHJpbmcpO1xuICAgICAgaWYgKHBheWxvYWQubmFtZXNwYWNlID09PSBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLm5vZGVzKSkge1xuICAgICAgICBjb25zdCBub2RlcyA9ICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcyhwYXlsb2FkLm5vZGVzKTtcbiAgICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIGlmIChodG1sU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IGRvbSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaHRtbFN0cmluZywgJ3RleHQvaHRtbCcpO1xuICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00oZWRpdG9yLCBkb20pO1xuICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuXG4gIC8vIE11bHRpLWxpbmUgcGxhaW4gdGV4dCBpbiByaWNoIHRleHQgbW9kZSBwYXN0ZWQgYXMgc2VwYXJhdGUgcGFyYWdyYXBoc1xuICAvLyBpbnN0ZWFkIG9mIHNpbmdsZSBwYXJhZ3JhcGggd2l0aCBsaW5lYnJlYWtzLlxuICAvLyBXZWJraXQtc3BlY2lmaWM6IFN1cHBvcnRzIHJlYWQgJ3RleHQvdXJpLWxpc3QnIGluIGNsaXBib2FyZC5cbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnROb2RlcyhbJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydFRleHQocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluc2VydHMgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgdXNpbmcgZGlmZmVyZW50IHN0cmF0ZWdpZXMgZGVwZW5kaW5nIG9uXG4gKiBzb21lIHNpbXBsZSBzZWxlY3Rpb24tYmFzZWQgaGV1cmlzdGljcy4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgZ2VuZXJpYyB3YXkgdG9cbiAqIHRvIGluc2VydCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgYXQgYSBzcGVjaWZpYyBzZWxlY3Rpb24gcG9pbnQsIHlvdSBwcm9iYWJseSB3YW50XG4gKiB7QGxpbmsgbGV4aWNhbC4kaW5zZXJ0Tm9kZXN9XG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHNlbGVjdGlvbiBUaGUgc2VsZWN0aW9uIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbikge1xuICBpZiAoIWVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwge1xuICAgIG5vZGVzLFxuICAgIHNlbGVjdGlvblxuICB9KSkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuZXhwb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY3VycmVudE5vZGUsIHRhcmdldEFycmF5ID0gW10pIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24gIT09IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmV4Y2x1ZGVGcm9tQ29weSgnaHRtbCcpO1xuICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSAkaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uICE9PSBudWxsID8gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuICBjb25zdCBjaGlsZHJlbiA9ICRpc0VsZW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQuZ2V0Q2hpbGRyZW4oKSA6IFtdO1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IGV4cG9ydE5vZGVUb0pTT04odGFyZ2V0KTtcblxuICAvLyBUT0RPOiBUZXh0Tm9kZSBjYWxscyBnZXRUZXh0Q29udGVudCgpIChOT1Qgbm9kZS5fX3RleHQpIHdpdGhpbiBpdCdzIGV4cG9ydEpTT04gbWV0aG9kXG4gIC8vIHdoaWNoIHVzZXMgZ2V0TGF0ZXN0KCkgdG8gZ2V0IHRoZSB0ZXh0IGZyb20gdGhlIG9yaWdpbmFsIG5vZGUgd2l0aCB0aGUgc2FtZSBrZXkuXG4gIC8vIFRoaXMgaXMgYSBkZWVwZXIgaXNzdWUgd2l0aCB0aGUgd29yZCBcImNsb25lXCIgaGVyZSwgaXQncyBzdGlsbCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgLy8gc2FtZSBub2RlIGFzIGZhciBhcyB0aGUgTGV4aWNhbEVkaXRvciBpcyBjb25jZXJuZWQgc2luY2UgaXQgc2hhcmVzIGEga2V5LlxuICAvLyBXZSBuZWVkIGEgd2F5IHRvIGNyZWF0ZSBhIGNsb25lIG9mIGEgTm9kZSBpbiBtZW1vcnkgd2l0aCBpdCdzIG93biBrZXksIGJ1dFxuICAvLyB1bnRpbCB0aGVuIHRoaXMgaGFjayB3aWxsIHdvcmsgZm9yIHRoZSBzZWxlY3RlZCB0ZXh0IGV4dHJhY3QgdXNlIGNhc2UuXG4gIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXQpKSB7XG4gICAgY29uc3QgdGV4dCA9IHRhcmdldC5fX3RleHQ7XG4gICAgLy8gSWYgYW4gdW5jb2xsYXBzZWQgc2VsZWN0aW9uIGVuZHMgb3Igc3RhcnRzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIG9mIHNwZWNpYWxpemVkLFxuICAgIC8vIFRleHROb2Rlcywgc3VjaCBhcyBjb2RlIHRva2Vucywgd2Ugd2lsbCBnZXQgYSAnYmxhbmsnIFRleHROb2RlIGhlcmUsIGkuZS4sIG9uZVxuICAgIC8vIHdpdGggdGV4dCBvZiBsZW5ndGggMC4gV2UgZG9uJ3Qgd2FudCB0aGlzLCBpdCBtYWtlcyBhIGNvbmZ1c2luZyBtZXNzLiBSZXNldCFcbiAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBzZXJpYWxpemVkTm9kZS50ZXh0ID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNoaWxkID0gJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCBjaGlsZE5vZGUsIHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuKTtcbiAgICBpZiAoIXNob3VsZEluY2x1ZGUgJiYgJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIHNob3VsZEluY2x1ZGVDaGlsZCAmJiBjdXJyZW50Tm9kZS5leHRyYWN0V2l0aENoaWxkKGNoaWxkTm9kZSwgc2VsZWN0aW9uLCAnY2xvbmUnKSkge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRJbmNsdWRlICYmICFzaG91bGRFeGNsdWRlKSB7XG4gICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkTm9kZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXJpYWxpemVkTm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW5baV07XG4gICAgICB0YXJnZXRBcnJheS5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2hvdWxkSW5jbHVkZTtcbn1cblxuLy8gVE9ETyB3aHkgJCBmdW5jdGlvbiB3aXRoIEVkaXRvciBpbnN0YW5jZT9cbi8qKlxuICogR2V0cyB0aGUgTGV4aWNhbCBKU09OIG9mIHRoZSBub2RlcyBpbnNpZGUgdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIExleGljYWxFZGl0b3IgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gU2VsZWN0aW9uIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZWRpdG9yIG5hbWVzcGFjZSBhbmQgYSBsaXN0IG9mIHNlcmlhbGl6YWJsZSBub2RlcyBhcyBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyhlZGl0b3IsIHNlbGVjdGlvbikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BMZXZlbENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gdG9wTGV2ZWxDaGlsZHJlbltpXTtcbiAgICAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24sIHRvcExldmVsTm9kZSwgbm9kZXMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZXNwYWNlOiBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UsXG4gICAgbm9kZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJhbGl6ZWROb2RlIGludGVyZmFjZSBhbmQgcmV0dXJuc1xuICogYW4gQXJyYXkgY29udGFpbmluZyBpbnN0YW5jZXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgTGV4aWNhbE5vZGUgY2xhc3NlcyByZWdpc3RlcmVkIG9uIHRoZSBlZGl0b3IuXG4gKiBOb3JtYWxseSwgeW91J2QgZ2V0IGFuIEFycmF5IG9mIEJhc2VTZXJpYWxpemVkIG5vZGVzIGZyb20ge0BsaW5rICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2Rlc31cbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZE5vZGVzIGFuIEFycmF5IG9mIG9iamVjdHMgY29uZm9ybWluZyB0byB0aGUgQmFzZVNlcmlhbGl6ZWROb2RlIGludGVyZmFjZS5cbiAqIEByZXR1cm5zIGFuIEFycmF5IG9mIExleGljYWwgTm9kZSBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMoc2VyaWFsaXplZE5vZGVzKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVkTm9kZXNbaV07XG4gICAgY29uc3Qgbm9kZSA9ICRwYXJzZVNlcmlhbGl6ZWROb2RlKHNlcmlhbGl6ZWROb2RlKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICRhZGROb2RlU3R5bGUobm9kZSk7XG4gICAgfVxuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuY29uc3QgRVZFTlRfTEFURU5DWSA9IDUwO1xubGV0IGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG5cbi8vIFRPRE8gY3VzdG9tIHNlbGVjdGlvblxuLy8gVE9ETyBwb3RlbnRpYWxseSBoYXZlIGEgbm9kZSBjdXN0b21pemFibGUgdmVyc2lvbiBmb3IgcGxhaW4gdGV4dFxuLyoqXG4gKiBDb3BpZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBjbGlwYm9hcmQgaW5cbiAqIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgYW5kIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IgKExleGljYWwgSlNPTilcbiAqIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciB0aGUgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBjb3B5IGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIGV2ZW50IHRoZSBuYXRpdmUgYnJvd3NlciBDbGlwYm9hcmRFdmVudCB0byBhZGQgdGhlIGNvbnRlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICovXG5hc3luYyBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBldmVudCkge1xuICBpZiAoY2xpcGJvYXJkRXZlbnRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgLy8gUHJldmVudCB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgdGhhdCBjYW4gaGFwcGVuIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBydW4gbXVsdGlwbGUgdGltZXNcbiAgICAvLyBzeW5jaHJvbm91c2x5LiBJbiB0aGUgZnV0dXJlLCB3ZSBjYW4gZG8gYmV0dGVyLCB3ZSBjYW4gY2FuY2VsL292ZXJyaWRlIHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgam9iLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXZlbnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgZXZlbnQpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGNvbnN0IHdpbmRvd0RvY3VtZW50ID0gZWRpdG9yLl93aW5kb3cgPT0gbnVsbCA/IHdpbmRvdy5kb2N1bWVudCA6IGVkaXRvci5fd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB3aW5kb3dEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTEwMDBweDsnO1xuICBlbGVtZW50LmFwcGVuZCh3aW5kb3dEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIycpKTtcbiAgcm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChlbGVtZW50LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVsZW1lbnQsIDEpO1xuICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIGRvbVNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPUFlfQ09NTUFORCwgc2Vjb25kRXZlbnQgPT4ge1xuICAgICAgaWYgKG9iamVjdEtsYXNzRXF1YWxzKHNlY29uZEV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpcGJvYXJkRXZlbnRUaW1lb3V0KTtcbiAgICAgICAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgc2Vjb25kRXZlbnQpKTtcbiAgICAgIH1cbiAgICAgIC8vIEJsb2NrIHRoZSBlbnRpcmUgY29weSBmbG93IHdoaWxlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IENsaXBib2FyZEV2ZW50XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKTtcbiAgICAvLyBJZiB0aGUgYWJvdmUgaGFjayBleGVjQ29tbWFuZCBoYWNrIHdvcmtzLCB0aGlzIHRpbWVvdXQgY29kZSBzaG91bGQgbmV2ZXIgZmlyZS4gT3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBsaXN0ZW5lciB3aWxsIGJlIHF1aWNrbHkgZnJlZWQgc28gdGhhdCB0aGUgdXNlciBjYW4gcmV1c2UgaXQgYWdhaW5cbiAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH0sIEVWRU5UX0xBVEVOQ1kpO1xuICAgIHdpbmRvd0RvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfSk7XG59XG5cbi8vIFRPRE8gc2hvdWxkbid0IHBhc3MgZWRpdG9yIChwYXNzIG5hbWVzcGFjZSBkaXJlY3RseSlcbmZ1bmN0aW9uICRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50KSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBjb25zdCBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIGlmIChhbmNob3JET00gIT09IG51bGwgJiYgZm9jdXNET00gIT09IG51bGwgJiYgIWlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NLCBmb2N1c0RPTSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKGNsaXBib2FyZERhdGEgPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxTdHJpbmcgPSAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yKTtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9ICRnZXRMZXhpY2FsQ29udGVudChlZGl0b3IpO1xuICBsZXQgcGxhaW5TdHJpbmcgPSAnJztcbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIHBsYWluU3RyaW5nID0gc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCk7XG4gIH1cbiAgaWYgKGh0bWxTdHJpbmcgIT09IG51bGwpIHtcbiAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGh0bWxTdHJpbmcpO1xuICB9XG4gIGlmIChsZXhpY2FsU3RyaW5nICE9PSBudWxsKSB7XG4gICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJywgbGV4aWNhbFN0cmluZyk7XG4gIH1cbiAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgcGxhaW5TdHJpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMsICRnZXRIdG1sQ29udGVudCwgJGdldExleGljYWxDb250ZW50LCAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0LCAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQsICRpbnNlcnRHZW5lcmF0ZWROb2RlcywgY29weVRvQ2xpcGJvYXJkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/code/LexicalCode.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createCodeHighlightNode: () => (/* binding */ $createCodeHighlightNode),\n/* harmony export */   $createCodeNode: () => (/* binding */ $createCodeNode),\n/* harmony export */   $isCodeHighlightNode: () => (/* binding */ $isCodeHighlightNode),\n/* harmony export */   $isCodeNode: () => (/* binding */ $isCodeNode),\n/* harmony export */   CODE_LANGUAGE_FRIENDLY_NAME_MAP: () => (/* binding */ CODE_LANGUAGE_FRIENDLY_NAME_MAP),\n/* harmony export */   CODE_LANGUAGE_MAP: () => (/* binding */ CODE_LANGUAGE_MAP),\n/* harmony export */   CodeHighlightNode: () => (/* binding */ CodeHighlightNode),\n/* harmony export */   CodeNode: () => (/* binding */ CodeNode),\n/* harmony export */   DEFAULT_CODE_LANGUAGE: () => (/* binding */ DEFAULT_CODE_LANGUAGE),\n/* harmony export */   PrismTokenizer: () => (/* binding */ PrismTokenizer),\n/* harmony export */   getCodeLanguages: () => (/* binding */ getCodeLanguages),\n/* harmony export */   getDefaultCodeLanguage: () => (/* binding */ getDefaultCodeLanguage),\n/* harmony export */   getEndOfCodeInLine: () => (/* binding */ getEndOfCodeInLine),\n/* harmony export */   getFirstCodeNodeOfLine: () => (/* binding */ getFirstCodeNodeOfLine),\n/* harmony export */   getLanguageFriendlyName: () => (/* binding */ getLanguageFriendlyName),\n/* harmony export */   getLastCodeNodeOfLine: () => (/* binding */ getLastCodeNodeOfLine),\n/* harmony export */   getStartOfCodeInLine: () => (/* binding */ getStartOfCodeInLine),\n/* harmony export */   normalizeCodeLang: () => (/* binding */ normalizeCodeLang),\n/* harmony export */   registerCodeHighlighting: () => (/* binding */ registerCodeHighlighting)\n/* harmony export */ });\n/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prismjs */ \"(ssr)/./node_modules/prismjs/prism.js\");\n/* harmony import */ var prismjs_components_prism_clike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prismjs/components/prism-clike.js */ \"(ssr)/./node_modules/prismjs/components/prism-clike.js\");\n/* harmony import */ var prismjs_components_prism_javascript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prismjs/components/prism-javascript.js */ \"(ssr)/./node_modules/prismjs/components/prism-javascript.js\");\n/* harmony import */ var prismjs_components_prism_markup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prismjs/components/prism-markup.js */ \"(ssr)/./node_modules/prismjs/components/prism-markup.js\");\n/* harmony import */ var prismjs_components_prism_markdown_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prismjs/components/prism-markdown.js */ \"(ssr)/./node_modules/prismjs/components/prism-markdown.js\");\n/* harmony import */ var prismjs_components_prism_c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prismjs/components/prism-c.js */ \"(ssr)/./node_modules/prismjs/components/prism-c.js\");\n/* harmony import */ var prismjs_components_prism_css_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prismjs/components/prism-css.js */ \"(ssr)/./node_modules/prismjs/components/prism-css.js\");\n/* harmony import */ var prismjs_components_prism_objectivec_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prismjs/components/prism-objectivec.js */ \"(ssr)/./node_modules/prismjs/components/prism-objectivec.js\");\n/* harmony import */ var prismjs_components_prism_sql_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prismjs/components/prism-sql.js */ \"(ssr)/./node_modules/prismjs/components/prism-sql.js\");\n/* harmony import */ var prismjs_components_prism_powershell_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prismjs/components/prism-powershell.js */ \"(ssr)/./node_modules/prismjs/components/prism-powershell.js\");\n/* harmony import */ var prismjs_components_prism_python_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prismjs/components/prism-python.js */ \"(ssr)/./node_modules/prismjs/components/prism-python.js\");\n/* harmony import */ var prismjs_components_prism_rust_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! prismjs/components/prism-rust.js */ \"(ssr)/./node_modules/prismjs/components/prism-rust.js\");\n/* harmony import */ var prismjs_components_prism_swift_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! prismjs/components/prism-swift.js */ \"(ssr)/./node_modules/prismjs/components/prism-swift.js\");\n/* harmony import */ var prismjs_components_prism_typescript_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! prismjs/components/prism-typescript.js */ \"(ssr)/./node_modules/prismjs/components/prism-typescript.js\");\n/* harmony import */ var prismjs_components_prism_java_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! prismjs/components/prism-java.js */ \"(ssr)/./node_modules/prismjs/components/prism-java.js\");\n/* harmony import */ var prismjs_components_prism_cpp_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! prismjs/components/prism-cpp.js */ \"(ssr)/./node_modules/prismjs/components/prism-cpp.js\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && window.Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.isHTMLElement)(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createParagraphNode)();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTextNode)(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node)) {\n          insertNodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n}\nfunction $createCodeNode(language) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$applyNodeReplacement)(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(window.Prism.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof window.Prism.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.TextNode {\n  /** @internal */\n\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.removeClassNamesFromElement)(dom, prevClassName);\n      }\n      if (nextClassName) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text, highlightType) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$applyNodeReplacement)(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return window.Prism.tokenize(code, window.Prism.languages[language || ''] || window.Prism.languages[this.defaultLanguage]);\n  }\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n  if (!!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTextNode)(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = $getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction $getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)());\n        } else if (part === '\\t') {\n          nodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$getHighlightNodes(content, token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTextNode)(_node);\n    if (isText || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(nodeA) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(nodeB) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(nodeA) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(nodeB);\n}\nfunction $isSelectionInCode(selection) {\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = lines[0];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND : _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INSERT_TAB_COMMAND : _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND;\n  // 1. If multiple lines selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  }\n  // 2. If entire line selected: indent/outdent\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  }\n  // 3. Else: tab/outdent\n  return tabOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n  // Multiple lines selection\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n      if (line.length > 0) {\n        let firstOfLine = line[0];\n        // First and last lines might not be complete\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n        if (firstOfLine !== null) {\n          if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n          } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n    return true;\n  }\n  // Just one line\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)()]);\n    }\n    return true;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n  if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(firstOfLine)) {\n      firstOfLine.insertAfter((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n    } else {\n      firstOfLine.insertBefore((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n    }\n  } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstOfLine)) {\n    firstOfLine.remove();\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(anchorNode)) || !($isCodeHighlightNode(focusNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) && !(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(sibling) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START;\n  if (!($isCodeHighlightNode(anchorNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(anchorNode)) || !($isCodeHighlightNode(focusNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.mergeRegister)(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(key);\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INSERT_TAB_COMMAND, () => {\n    const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$insertNodes)([(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)()]);\n    return true;\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND, payload => $handleShiftLines(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_DOWN_COMMAND, payload => $handleShiftLines(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_DOWN_COMMAND, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_END, payload => $handleMoveTo(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_END, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START, payload => $handleMoveTo(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUI7QUFDMEI7QUFDSztBQUNKO0FBQ0U7QUFDUDtBQUNFO0FBQ087QUFDUDtBQUNPO0FBQ0o7QUFDRjtBQUNDO0FBQ0s7QUFDTjtBQUNEO0FBQzBFO0FBQ2lVOztBQUVwYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix3REFBVztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUVBQW9CO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFVO0FBQ3RCLDJCQUEyQiwrREFBYztBQUN6QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxRUFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRDQUE0QyxxRUFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0VBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxxREFBUTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1RUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEVBQTJCO0FBQ25DO0FBQ0E7QUFDQSxRQUFRLHVFQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUFBdUIsb0NBQW9DLG9FQUF1QixHQUFHLGlFQUFvQiwwQkFBMEIsaUVBQW9CLCtCQUErQixpRUFBb0IsWUFBWSxpRUFBb0IsMEJBQTBCLG1FQUFzQiwrQkFBK0IsbUVBQXNCLFlBQVksaUVBQW9CLDBCQUEwQix3REFBVywyQkFBMkIsd0RBQVcsWUFBWSxpRUFBb0IsMEJBQTBCLDBEQUFhLDJCQUEyQiwwREFBYSxZQUFZLGlFQUFvQjtBQUM3dkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jb2RlL0xleGljYWxDb2RlLmRldi5tanM/ZmMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCAncHJpc21qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jbGlrZS5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qYXZhc2NyaXB0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cC5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrZG93bi5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzcy5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1vYmplY3RpdmVjLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNxbC5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1wb3dlcnNoZWxsLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXB5dGhvbi5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1ydXN0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXN3aWZ0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXR5cGVzY3JpcHQuanMnO1xuaW1wb3J0ICdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YS5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jcHAuanMnO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50LCBtZXJnZVJlZ2lzdGVyIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgRWxlbWVudE5vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkaXNUZXh0Tm9kZSwgJGlzVGFiTm9kZSwgJGNyZWF0ZVRhYk5vZGUsICRjcmVhdGVMaW5lQnJlYWtOb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsIFRleHROb2RlLCAkaXNMaW5lQnJlYWtOb2RlLCAkY3JlYXRlVGV4dE5vZGUsICRnZXROb2RlQnlLZXksICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCBJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgSU5TRVJUX1RBQl9DT01NQU5ELCBLRVlfQVJST1dfVVBfQ09NTUFORCwgTU9WRV9UT19TVEFSVCwgS0VZX1RBQl9DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0xPVywgJGluc2VydE5vZGVzLCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBNT1ZFX1RPX0VORCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkgd2lsbCByZWZpbmUgdHlwZXMgYmFzZWQgb24gXCJjb25kaXRpb25cIiwgYW5kXG4vLyBpZiBcImNvbmRpdGlvblwiIGlzIGZhbHNlIHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgZnVuY3Rpb24gaXMgc3BlY2lhbC1jYXNlZFxuLy8gaW4gZmxvdyBpdHNlbGYsIHNvIHdlIGNhbid0IG5hbWUgaXQgYW55dGhpbmcgZWxzZS5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kLCBtZXNzYWdlLCAuLi5hcmdzKSB7XG4gIGlmIChjb25kKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgTGV4aWNhbCBlcnJvcjogaW52YXJpYW50KCkgaXMgbWVhbnQgdG8gYmUgcmVwbGFjZWQgYXQgY29tcGlsZSAnICsgJ3RpbWUuIFRoZXJlIGlzIG5vIHJ1bnRpbWUgdmVyc2lvbi4gRXJyb3I6ICcgKyBtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBtYXBUb1ByaXNtTGFuZ3VhZ2UgPSBsYW5ndWFnZSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgcmV0dXJuIGxhbmd1YWdlICE9IG51bGwgJiYgd2luZG93LlByaXNtLmxhbmd1YWdlcy5oYXNPd25Qcm9wZXJ0eShsYW5ndWFnZSkgPyBsYW5ndWFnZSA6IHVuZGVmaW5lZDtcbn07XG5mdW5jdGlvbiBoYXNDaGlsZERPTU5vZGVUYWcobm9kZSwgdGFnTmFtZSkge1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGNoaWxkKSAmJiBjaGlsZC50YWdOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFzQ2hpbGRET01Ob2RlVGFnKGNoaWxkLCB0YWdOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSA9ICdkYXRhLWhpZ2hsaWdodC1sYW5ndWFnZSc7XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBDb2RlTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnY29kZSc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IENvZGVOb2RlKG5vZGUuX19sYW5ndWFnZSwgbm9kZS5fX2tleSk7XG4gIH1cbiAgY29uc3RydWN0b3IobGFuZ3VhZ2UsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2xhbmd1YWdlID0gbWFwVG9QcmlzbUxhbmd1YWdlKGxhbmd1YWdlKTtcbiAgfVxuXG4gIC8vIFZpZXdcbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUuY29kZSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IHRoaXMuZ2V0TGFuZ3VhZ2UoKTtcbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFLCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBsYW5ndWFnZSA9IHRoaXMuX19sYW5ndWFnZTtcbiAgICBjb25zdCBwcmV2TGFuZ3VhZ2UgPSBwcmV2Tm9kZS5fX2xhbmd1YWdlO1xuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgaWYgKGxhbmd1YWdlICE9PSBwcmV2TGFuZ3VhZ2UpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldkxhbmd1YWdlKSB7XG4gICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJyk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS5jb2RlKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5nZXRMYW5ndWFnZSgpO1xuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFR5cGljYWxseSA8cHJlPiBpcyB1c2VkIGZvciBjb2RlIGJsb2NrcywgYW5kIDxjb2RlPiBmb3IgaW5saW5lIGNvZGUgc3R5bGVzXG4gICAgICAvLyBidXQgaWYgaXQncyBhIG11bHRpIGxpbmUgPGNvZGU+IHdlJ2xsIGNyZWF0ZSBhIGJsb2NrLiBQYXNzIHRocm91Z2ggdG9cbiAgICAgIC8vIGlubGluZSBmb3JtYXQgaGFuZGxlZCBieSBUZXh0Tm9kZSBvdGhlcndpc2UuXG4gICAgICBjb2RlOiBub2RlID0+IHtcbiAgICAgICAgY29uc3QgaXNNdWx0aUxpbmUgPSBub2RlLnRleHRDb250ZW50ICE9IG51bGwgJiYgKC9cXHI/XFxuLy50ZXN0KG5vZGUudGV4dENvbnRlbnQpIHx8IGhhc0NoaWxkRE9NTm9kZVRhZyhub2RlLCAnQlInKSk7XG4gICAgICAgIHJldHVybiBpc011bHRpTGluZSA/IHtcbiAgICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFByZUVsZW1lbnQsXG4gICAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgICAgfSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZGl2OiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydERpdkVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KSxcbiAgICAgIHByZTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRQcmVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB0YWJsZTogbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gbm9kZTtcbiAgICAgICAgLy8gZG9tTm9kZSBpcyBhIDx0YWJsZT4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBpZiAoaXNHaXRIdWJDb2RlVGFibGUodGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRkOiBub2RlID0+IHtcbiAgICAgICAgLy8gZWxlbWVudCBpcyBhIDx0ZD4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBjb25zdCB0ZCA9IG5vZGU7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGQuY2xvc2VzdCgndGFibGUnKTtcbiAgICAgICAgaWYgKGlzR2l0SHViQ29kZUNlbGwodGQpIHx8IHRhYmxlICYmIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIC8vIFJldHVybiBhIG5vLW9wIGlmIGl0J3MgYSB0YWJsZSBjZWxsIGluIGEgY29kZSB0YWJsZSwgYnV0IG5vdCBhIGNvZGUgbGluZS5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgaXQnbGwgZmFsbCBiYWNrIHRvIHRoZSBUXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRDb2RlTm9vcCxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cjogbm9kZSA9PiB7XG4gICAgICAgIC8vIGVsZW1lbnQgaXMgYSA8dHI+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgICAgICAgY29uc3QgdHIgPSBub2RlO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRyLmNsb3Nlc3QoJ3RhYmxlJyk7XG4gICAgICAgIGlmICh0YWJsZSAmJiBpc0dpdEh1YkNvZGVUYWJsZSh0YWJsZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogY29udmVydENvZGVOb29wLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUNvZGVOb2RlKHNlcmlhbGl6ZWROb2RlLmxhbmd1YWdlKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsYW5ndWFnZTogdGhpcy5nZXRMYW5ndWFnZSgpLFxuICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdGlvblxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID49IDIgJiYgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5nZXRUZXh0Q29udGVudCgpID09PSAnXFxuJyAmJiBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDJdLmdldFRleHRDb250ZW50KCkgPT09ICdcXG4nICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5hbmNob3Iua2V5ID09PSB0aGlzLl9fa2V5ICYmIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5yZW1vdmUoKTtcbiAgICAgIGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMl0ucmVtb3ZlKCk7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrLCBmaW5kIGFsbCBsZWFkaW5nIHRhYnMgYW5kXG4gICAgLy8gc3BhY2VzIG9mIHRoZSBjdXJyZW50IGxpbmUuIENyZWF0ZSBhIG5ldyBsaW5lIHRoYXQgaGFzIGFsbCB0aG9zZVxuICAgIC8vIHRhYnMgYW5kIHNwYWNlcywgc3VjaCB0aGF0IGxlYWRpbmcgaW5kZW50YXRpb24gaXMgcHJlc2VydmVkLlxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKSA/IGFuY2hvciA6IGZvY3VzO1xuICAgIGNvbnN0IGZpcnN0U2VsZWN0aW9uTm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdFNlbGVjdGlvbk5vZGUpKSB7XG4gICAgICBsZXQgbm9kZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3RTZWxlY3Rpb25Ob2RlKTtcbiAgICAgIGNvbnN0IGluc2VydE5vZGVzID0gW107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoJGlzVGFiTm9kZShub2RlKSkge1xuICAgICAgICAgIGluc2VydE5vZGVzLnB1c2goJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCBzcGFjZXMgPSAwO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgdGV4dFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIHdoaWxlIChzcGFjZXMgPCB0ZXh0U2l6ZSAmJiB0ZXh0W3NwYWNlc10gPT09ICcgJykge1xuICAgICAgICAgICAgc3BhY2VzKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGFjZXMgIT09IDApIHtcbiAgICAgICAgICAgIGluc2VydE5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKCcgJy5yZXBlYXQoc3BhY2VzKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BhY2VzICE9PSB0ZXh0U2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwbGl0ID0gZmlyc3RTZWxlY3Rpb25Ob2RlLnNwbGl0VGV4dChhbmNob3Iub2Zmc2V0KVswXTtcbiAgICAgIGNvbnN0IHggPSBhbmNob3Iub2Zmc2V0ID09PSAwID8gMCA6IDE7XG4gICAgICBjb25zdCBpbmRleCA9IHNwbGl0LmdldEluZGV4V2l0aGluUGFyZW50KCkgKyB4O1xuICAgICAgY29uc3QgY29kZU5vZGUgPSBmaXJzdFNlbGVjdGlvbk5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgY29uc3Qgbm9kZXNUb0luc2VydCA9IFskY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5pbnNlcnROb2Rlc107XG4gICAgICBjb2RlTm9kZS5zcGxpY2UoaW5kZXgsIDAsIG5vZGVzVG9JbnNlcnQpO1xuICAgICAgY29uc3QgbGFzdCA9IGluc2VydE5vZGVzW2luc2VydE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgbGFzdC5zZWxlY3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgICBzcGxpdC5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaXQuZ2V0TmV4dFNpYmxpbmcoKS5zZWxlY3ROZXh0KDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzQ29kZU5vZGUoZmlyc3RTZWxlY3Rpb25Ob2RlKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgZmlyc3RTZWxlY3Rpb25Ob2RlLnNwbGljZShvZmZzZXQsIDAsIFskY3JlYXRlTGluZUJyZWFrTm9kZSgpXSk7XG4gICAgICBmaXJzdFNlbGVjdGlvbk5vZGUuc2VsZWN0KG9mZnNldCArIDEsIG9mZnNldCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gcGFyYWdyYXBoLmFwcGVuZChjaGlsZCkpO1xuICAgIHRoaXMucmVwbGFjZShwYXJhZ3JhcGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldExhbmd1YWdlKGxhbmd1YWdlKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19sYW5ndWFnZSA9IG1hcFRvUHJpc21MYW5ndWFnZShsYW5ndWFnZSk7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19sYW5ndWFnZTtcbiAgfVxufVxuZnVuY3Rpb24gJGNyZWF0ZUNvZGVOb2RlKGxhbmd1YWdlKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IENvZGVOb2RlKGxhbmd1YWdlKSk7XG59XG5mdW5jdGlvbiAkaXNDb2RlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29kZU5vZGU7XG59XG5mdW5jdGlvbiAkY29udmVydFByZUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBsYW5ndWFnZSA9IGRvbU5vZGUuZ2V0QXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFKTtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlQ29kZU5vZGUobGFuZ3VhZ2UpXG4gIH07XG59XG5mdW5jdGlvbiAkY29udmVydERpdkVsZW1lbnQoZG9tTm9kZSkge1xuICAvLyBkb21Ob2RlIGlzIGEgPGRpdj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBkaXYgPSBkb21Ob2RlO1xuICBjb25zdCBpc0NvZGUgPSBpc0NvZGVFbGVtZW50KGRpdik7XG4gIGlmICghaXNDb2RlICYmICFpc0NvZGVDaGlsZEVsZW1lbnQoZGl2KSkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGU6IGlzQ29kZSA/ICRjcmVhdGVDb2RlTm9kZSgpIDogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRUYWJsZUVsZW1lbnQoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUNvZGVOb2RlKClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb2RlTm9vcCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBpc0NvZGVFbGVtZW50KGRpdikge1xuICByZXR1cm4gZGl2LnN0eWxlLmZvbnRGYW1pbHkubWF0Y2goJ21vbm9zcGFjZScpICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNDb2RlQ2hpbGRFbGVtZW50KG5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0NvZGVFbGVtZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0dpdEh1YkNvZGVDZWxsKGNlbGwpIHtcbiAgcmV0dXJuIGNlbGwuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcy1maWxlLWxpbmUnKTtcbn1cbmZ1bmN0aW9uIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSB7XG4gIHJldHVybiB0YWJsZS5jbGFzc0xpc3QuY29udGFpbnMoJ2pzLWZpbGUtbGluZS1jb250YWluZXInKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBERUZBVUxUX0NPREVfTEFOR1VBR0UgPSAnamF2YXNjcmlwdCc7XG5jb25zdCBDT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQID0ge1xuICBjOiAnQycsXG4gIGNsaWtlOiAnQy1saWtlJyxcbiAgY3BwOiAnQysrJyxcbiAgY3NzOiAnQ1NTJyxcbiAgaHRtbDogJ0hUTUwnLFxuICBqYXZhOiAnSmF2YScsXG4gIGpzOiAnSmF2YVNjcmlwdCcsXG4gIG1hcmtkb3duOiAnTWFya2Rvd24nLFxuICBvYmpjOiAnT2JqZWN0aXZlLUMnLFxuICBwbGFpbjogJ1BsYWluIFRleHQnLFxuICBwb3dlcnNoZWxsOiAnUG93ZXJTaGVsbCcsXG4gIHB5OiAnUHl0aG9uJyxcbiAgcnVzdDogJ1J1c3QnLFxuICBzcWw6ICdTUUwnLFxuICBzd2lmdDogJ1N3aWZ0JyxcbiAgdHlwZXNjcmlwdDogJ1R5cGVTY3JpcHQnLFxuICB4bWw6ICdYTUwnXG59O1xuY29uc3QgQ09ERV9MQU5HVUFHRV9NQVAgPSB7XG4gIGNwcDogJ2NwcCcsXG4gIGphdmE6ICdqYXZhJyxcbiAgamF2YXNjcmlwdDogJ2pzJyxcbiAgbWQ6ICdtYXJrZG93bicsXG4gIHBsYWludGV4dDogJ3BsYWluJyxcbiAgcHl0aG9uOiAncHknLFxuICB0ZXh0OiAncGxhaW4nLFxuICB0czogJ3R5cGVzY3JpcHQnXG59O1xuZnVuY3Rpb24gbm9ybWFsaXplQ29kZUxhbmcobGFuZykge1xuICByZXR1cm4gQ09ERV9MQU5HVUFHRV9NQVBbbGFuZ10gfHwgbGFuZztcbn1cbmZ1bmN0aW9uIGdldExhbmd1YWdlRnJpZW5kbHlOYW1lKGxhbmcpIHtcbiAgY29uc3QgX2xhbmcgPSBub3JtYWxpemVDb2RlTGFuZyhsYW5nKTtcbiAgcmV0dXJuIENPREVfTEFOR1VBR0VfRlJJRU5ETFlfTkFNRV9NQVBbX2xhbmddIHx8IF9sYW5nO1xufVxuY29uc3QgZ2V0RGVmYXVsdENvZGVMYW5ndWFnZSA9ICgpID0+IERFRkFVTFRfQ09ERV9MQU5HVUFHRTtcbmNvbnN0IGdldENvZGVMYW5ndWFnZXMgPSAoKSA9PiBPYmplY3Qua2V5cyh3aW5kb3cuUHJpc20ubGFuZ3VhZ2VzKS5maWx0ZXIoXG4vLyBQcmlzbSBoYXMgc2V2ZXJhbCBsYW5ndWFnZSBoZWxwZXJzIG1peGVkIGludG8gbGFuZ3VhZ2VzIG9iamVjdFxuLy8gc28gZmlsdGVyaW5nIHRoZW0gb3V0IGhlcmUgdG8gZ2V0IGxhbmdzIGxpc3Rcbmxhbmd1YWdlID0+IHR5cGVvZiB3aW5kb3cuUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXSAhPT0gJ2Z1bmN0aW9uJykuc29ydCgpO1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgQ29kZUhpZ2hsaWdodE5vZGUgZXh0ZW5kcyBUZXh0Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBjb25zdHJ1Y3Rvcih0ZXh0LCBoaWdobGlnaHRUeXBlLCBrZXkpIHtcbiAgICBzdXBlcih0ZXh0LCBrZXkpO1xuICAgIHRoaXMuX19oaWdobGlnaHRUeXBlID0gaGlnaGxpZ2h0VHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2NvZGUtaGlnaGxpZ2h0JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQ29kZUhpZ2hsaWdodE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19oaWdobGlnaHRUeXBlIHx8IHVuZGVmaW5lZCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0VHlwZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2hpZ2hsaWdodFR5cGU7XG4gIH1cbiAgY2FuSGF2ZUZvcm1hdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBzdXBlci5jcmVhdGVET00oY29uZmlnKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgdGhpcy5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgdXBkYXRlID0gc3VwZXIudXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZyk7XG4gICAgY29uc3QgcHJldkNsYXNzTmFtZSA9IGdldEhpZ2hsaWdodFRoZW1lQ2xhc3MoY29uZmlnLnRoZW1lLCBwcmV2Tm9kZS5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIGNvbnN0IG5leHRDbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgdGhpcy5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIGlmIChwcmV2Q2xhc3NOYW1lICE9PSBuZXh0Q2xhc3NOYW1lKSB7XG4gICAgICBpZiAocHJldkNsYXNzTmFtZSkge1xuICAgICAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBwcmV2Q2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Q2xhc3NOYW1lKSB7XG4gICAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCBuZXh0Q2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUoc2VyaWFsaXplZE5vZGUudGV4dCwgc2VyaWFsaXplZE5vZGUuaGlnaGxpZ2h0VHlwZSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpO1xuICAgIG5vZGUuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWROb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBoaWdobGlnaHRUeXBlOiB0aGlzLmdldEhpZ2hsaWdodFR5cGUoKSxcbiAgICAgIHR5cGU6ICdjb2RlLWhpZ2hsaWdodCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgZm9ybWF0dGluZyAoYm9sZCwgdW5kZXJsaW5lLCBldGMpXG4gIHNldEZvcm1hdChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlQ29kZU5vZGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyh0aGVtZSwgaGlnaGxpZ2h0VHlwZSkge1xuICByZXR1cm4gaGlnaGxpZ2h0VHlwZSAmJiB0aGVtZSAmJiB0aGVtZS5jb2RlSGlnaGxpZ2h0ICYmIHRoZW1lLmNvZGVIaWdobGlnaHRbaGlnaGxpZ2h0VHlwZV07XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUodGV4dCwgaGlnaGxpZ2h0VHlwZSkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBDb2RlSGlnaGxpZ2h0Tm9kZSh0ZXh0LCBoaWdobGlnaHRUeXBlKSk7XG59XG5mdW5jdGlvbiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29kZUhpZ2hsaWdodE5vZGU7XG59XG5mdW5jdGlvbiBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGFuY2hvcikge1xuICBsZXQgcHJldmlvdXNOb2RlID0gYW5jaG9yO1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcbiAgd2hpbGUgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8ICRpc1RhYk5vZGUobm9kZSkpIHtcbiAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICB9XG4gIHJldHVybiBwcmV2aW91c05vZGU7XG59XG5mdW5jdGlvbiBnZXRMYXN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yKSB7XG4gIGxldCBuZXh0Tm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGUgPSBhbmNob3I7XG4gIHdoaWxlICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCAkaXNUYWJOb2RlKG5vZGUpKSB7XG4gICAgbmV4dE5vZGUgPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIH1cbiAgcmV0dXJuIG5leHROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFByaXNtVG9rZW5pemVyID0ge1xuICBkZWZhdWx0TGFuZ3VhZ2U6IERFRkFVTFRfQ09ERV9MQU5HVUFHRSxcbiAgdG9rZW5pemUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gd2luZG93LlByaXNtLnRva2VuaXplKGNvZGUsIHdpbmRvdy5QcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2UgfHwgJyddIHx8IHdpbmRvdy5QcmlzbS5sYW5ndWFnZXNbdGhpcy5kZWZhdWx0TGFuZ3VhZ2VdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFN0YXJ0T2ZDb2RlSW5MaW5lKGFuY2hvciwgb2Zmc2V0KSB7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgbGV0IGxhc3ROb25CbGFuayA9IG51bGw7XG4gIGxldCBub2RlID0gYW5jaG9yO1xuICBsZXQgbm9kZU9mZnNldCA9IG9mZnNldDtcbiAgbGV0IG5vZGVUZXh0Q29udGVudCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGVPZmZzZXQgPT09IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCAkaXNUYWJOb2RlKG5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUobm9kZSkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIHZhbGlkIENvZGUgTm9kZTogQ29kZUhpZ2hsaWdodE5vZGUsIFRhYk5vZGUsIExpbmVCcmVha05vZGVgKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGxhc3QgPSB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlT2Zmc2V0ID0gTWF0aC5tYXgoMCwgbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAtIDEpO1xuICAgICAgbm9kZVRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlT2Zmc2V0LS07XG4gICAgfVxuICAgIGNvbnN0IGNoYXJhY3RlciA9IG5vZGVUZXh0Q29udGVudFtub2RlT2Zmc2V0XTtcbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgJiYgY2hhcmFjdGVyICE9PSAnICcpIHtcbiAgICAgIGxhc3ROb25CbGFuayA9IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvLyBsYXN0Tm9uQmxhbmsgIT09IG51bGw6IGFuY2hvciBpbiB0aGUgbWlkZGxlIG9mIGNvZGU7IG1vdmUgdG8gbGluZSBiZWdpbm5pbmdcbiAgaWYgKGxhc3ROb25CbGFuayAhPT0gbnVsbCkge1xuICAgIHJldHVybiBsYXN0Tm9uQmxhbms7XG4gIH1cbiAgLy8gU3BhY2VzLCB0YWJzIG9yIG5vdGhpbmcgYWhlYWQgb2YgYW5jaG9yXG4gIGxldCBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgPSBudWxsO1xuICBpZiAob2Zmc2V0IDwgYW5jaG9yLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvcikpIHtcbiAgICAgIGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpW29mZnNldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gYW5jaG9yLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgY29kZUNoYXJhY3RlckF0QW5jaG9yT2Zmc2V0ID0gbmV4dFNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKVswXTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCAhPT0gbnVsbCAmJiBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgIT09ICcgJykge1xuICAgIC8vIEJvcmRlcmxpbmUgd2hpdGVzcGFjZSBhbmQgY29kZSwgbW92ZSB0byBsaW5lIGJlZ2lubmluZ1xuICAgIHJldHVybiBsYXN0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHROb25CbGFuayA9IGZpbmROZXh0Tm9uQmxhbmtJbkxpbmUoYW5jaG9yLCBvZmZzZXQpO1xuICAgIGlmIChuZXh0Tm9uQmxhbmsgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0Tm9uQmxhbms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluZE5leHROb25CbGFua0luTGluZShhbmNob3IsIG9mZnNldCkge1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGVPZmZzZXQgPSBvZmZzZXQ7XG4gIGxldCBub2RlVGV4dENvbnRlbnQgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnQoKTtcbiAgbGV0IG5vZGVUZXh0Q29udGVudFNpemUgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoISRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8IG5vZGVPZmZzZXQgPT09IG5vZGVUZXh0Q29udGVudFNpemUpIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICAgIG5vZGVPZmZzZXQgPSAwO1xuICAgICAgICBub2RlVGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIG5vZGVUZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgIGlmIChub2RlVGV4dENvbnRlbnRbbm9kZU9mZnNldF0gIT09ICcgJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBub2RlT2Zmc2V0Kys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFbmRPZkNvZGVJbkxpbmUoYW5jaG9yKSB7XG4gIGNvbnN0IGxhc3ROb2RlID0gZ2V0TGFzdENvZGVOb2RlT2ZMaW5lKGFuY2hvcik7XG4gIGlmICghISRpc0xpbmVCcmVha05vZGUobGFzdE5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbGluZUJyZWFrTm9kZSBpbiBnZXRFbmRPZkNvZGVJbkxpbmVgKTtcbiAgfVxuICByZXR1cm4gbGFzdE5vZGU7XG59XG5mdW5jdGlvbiAkdGV4dE5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgLy8gU2luY2UgQ29kZU5vZGUgaGFzIGZsYXQgY2hpbGRyZW4gc3RydWN0dXJlIHdlIG9ubHkgbmVlZCB0byBjaGVja1xuICAvLyBpZiBub2RlJ3MgcGFyZW50IGlzIGEgY29kZSBub2RlIGFuZCBydW4gaGlnaGxpZ2h0aW5nIGlmIHNvXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAoJGlzQ29kZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICBjb2RlTm9kZVRyYW5zZm9ybShwYXJlbnROb2RlLCBlZGl0b3IsIHRva2VuaXplcik7XG4gIH0gZWxzZSBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAvLyBXaGVuIGNvZGUgYmxvY2sgY29udmVydGVkIGludG8gcGFyYWdyYXBoIG9yIG90aGVyIGVsZW1lbnRcbiAgICAvLyBjb2RlIGhpZ2hsaWdodCBub2RlcyBjb252ZXJ0ZWQgYmFjayB0byBub3JtYWwgdGV4dFxuICAgIG5vZGUucmVwbGFjZSgkY3JlYXRlVGV4dE5vZGUobm9kZS5fX3RleHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29kZUd1dHRlcihub2RlLCBlZGl0b3IpIHtcbiAgY29uc3QgY29kZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5vZGUuZ2V0S2V5KCkpO1xuICBpZiAoY29kZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAvLyBAdHMtaWdub3JlOiBpbnRlcm5hbCBmaWVsZFxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IGNvZGVFbGVtZW50Ll9fY2FjaGVkQ2hpbGRyZW5MZW5ndGgpIHtcbiAgICAvLyBBdm9pZCB1cGRhdGluZyB0aGUgYXR0cmlidXRlIGlmIHRoZSBjaGlsZHJlbiBsZW5ndGggaGFzbid0IGNoYW5nZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEB0cy1pZ25vcmU6OiBpbnRlcm5hbCBmaWVsZFxuICBjb2RlRWxlbWVudC5fX2NhY2hlZENoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gIGxldCBndXR0ZXIgPSAnMSc7XG4gIGxldCBjb3VudCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGNoaWxkcmVuW2ldKSkge1xuICAgICAgZ3V0dGVyICs9ICdcXG4nICsgKytjb3VudDtcbiAgICB9XG4gIH1cbiAgY29kZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWd1dHRlcicsIGd1dHRlcik7XG59XG5cbi8vIFVzaW5nIGBza2lwVHJhbnNmb3Jtc2AgdG8gcHJldmVudCBleHRyYSB0cmFuc2Zvcm1zIHNpbmNlIHJlZm9ybWF0dGluZyB0aGUgY29kZVxuLy8gd2lsbCBub3QgYWZmZWN0IGNvZGUgYmxvY2sgY29udGVudCBpdHNlbGYuXG4vL1xuLy8gVXNpbmcgZXh0cmEgY2FjaGUgKGBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZ2ApIHNpbmNlIGJvdGggQ29kZU5vZGUgYW5kIENvZGVIaWdobGlnaHROb2RlXG4vLyB0cmFuc2Zvcm1zIG1pZ2h0IGJlIGNhbGxlZCBhdCB0aGUgc2FtZSB0aW1lIChlLmcuIG5ldyBDb2RlSGlnaGxpZ2h0IG5vZGUgaW5zZXJ0ZWQpIGFuZFxuLy8gaW4gYm90aCBjYXNlcyB3ZSdsbCByZXJ1biB3aG9sZSByZWZvcm1hdHRpbmcgb3ZlciBDb2RlTm9kZSwgd2hpY2ggaXMgcmVkdW5kYW50LlxuLy8gRXNwZWNpYWxseSB3aGVuIHBhc3RpbmcgY29kZSBpbnRvIENvZGVCbG9jay5cblxuY29uc3Qgbm9kZXNDdXJyZW50bHlIaWdobGlnaHRpbmcgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjb2RlTm9kZVRyYW5zZm9ybShub2RlLCBlZGl0b3IsIHRva2VuaXplcikge1xuICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgaWYgKG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmhhcyhub2RlS2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5hZGQobm9kZUtleSk7XG5cbiAgLy8gV2hlbiBuZXcgY29kZSBibG9jayBpbnNlcnRlZCBpdCBtaWdodCBub3QgaGF2ZSBsYW5ndWFnZSBzZWxlY3RlZFxuICBpZiAobm9kZS5nZXRMYW5ndWFnZSgpID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLnNldExhbmd1YWdlKHRva2VuaXplci5kZWZhdWx0TGFuZ3VhZ2UpO1xuICB9XG5cbiAgLy8gVXNpbmcgbmVzdGVkIHVwZGF0ZSBjYWxsIHRvIHBhc3MgYHNraXBUcmFuc2Zvcm1zYCBzaW5jZSB3ZSBkb24ndCB3YW50XG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBjb2RlaGlnaGxpZ2h0IG5vZGUgdG8gYmUgdHJhbnNmb3JtZWQgYWdhaW4gYXMgaXQncyBhbHJlYWR5XG4gIC8vIGluIGl0cyBmaW5hbCBzdGF0ZVxuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAkdXBkYXRlQW5kUmV0YWluU2VsZWN0aW9uKG5vZGVLZXksICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgIGlmICghJGlzQ29kZU5vZGUoY3VycmVudE5vZGUpIHx8ICFjdXJyZW50Tm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZSA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoY29kZSwgY3VycmVudE5vZGUuZ2V0TGFuZ3VhZ2UoKSB8fCB0b2tlbml6ZXIuZGVmYXVsdExhbmd1YWdlKTtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodE5vZGVzID0gJGdldEhpZ2hsaWdodE5vZGVzKHRva2Vucyk7XG4gICAgICBjb25zdCBkaWZmUmFuZ2UgPSBnZXREaWZmUmFuZ2UoY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSwgaGlnaGxpZ2h0Tm9kZXMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgbm9kZXNGb3JSZXBsYWNlbWVudFxuICAgICAgfSA9IGRpZmZSYW5nZTtcbiAgICAgIGlmIChmcm9tICE9PSB0byB8fCBub2Rlc0ZvclJlcGxhY2VtZW50Lmxlbmd0aCkge1xuICAgICAgICBub2RlLnNwbGljZShmcm9tLCB0byAtIGZyb20sIG5vZGVzRm9yUmVwbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSwge1xuICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5kZWxldGUobm9kZUtleSk7XG4gICAgfSxcbiAgICBza2lwVHJhbnNmb3JtczogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uICRnZXRIaWdobGlnaHROb2Rlcyh0b2tlbnMsIHR5cGUpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgcGFydGlhbHMgPSB0b2tlbi5zcGxpdCgvKFxcbnxcXHQpLyk7XG4gICAgICBjb25zdCBwYXJ0aWFsc0xlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGlhbHNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydGlhbHNbaV07XG4gICAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKHBhcnQsIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRlbnRcbiAgICAgIH0gPSB0b2tlbjtcbiAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi4kZ2V0SGlnaGxpZ2h0Tm9kZXMoW2NvbnRlbnRdLCB0b2tlbi50eXBlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi4kZ2V0SGlnaGxpZ2h0Tm9kZXMoY29udGVudCwgdG9rZW4udHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbi8vIFdyYXBwaW5nIHVwZGF0ZSBmdW5jdGlvbiBpbnRvIHNlbGVjdGlvbiByZXRhaW5lciwgdGhhdCB0cmllcyB0byBrZWVwIGN1cnNvciBhdCB0aGUgc2FtZVxuLy8gcG9zaXRpb24gYXMgYmVmb3JlLlxuZnVuY3Rpb24gJHVwZGF0ZUFuZFJldGFpblNlbGVjdGlvbihub2RlS2V5LCB1cGRhdGVGbikge1xuICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgaWYgKCEkaXNDb2RlTm9kZShub2RlKSB8fCAhbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAvLyBJZiBpdCdzIG5vdCByYW5nZSBzZWxlY3Rpb24gKG9yIG51bGwgc2VsZWN0aW9uKSB0aGVyZSdzIG5vIG5lZWQgdG8gY2hhbmdlIGl0LFxuICAvLyBidXQgd2UgY2FuIHN0aWxsIHJ1biBoaWdobGlnaHRpbmcgbG9naWNcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgdXBkYXRlRm4oKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgaXNOZXdMaW5lQW5jaG9yID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvci5vZmZzZXQgLSAxKSk7XG4gIGxldCB0ZXh0T2Zmc2V0ID0gMDtcblxuICAvLyBDYWxjdWxhdGluZyBwcmV2aW91cyB0ZXh0IG9mZnNldCAoYWxsIHRleHQgbm9kZSBwcmlvciB0byBhbmNob3IgKyBhbmNob3Igb3duIHRleHQgb2Zmc2V0KVxuICBpZiAoIWlzTmV3TGluZUFuY2hvcikge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIHRleHRPZmZzZXQgPSBhbmNob3JPZmZzZXQgKyBhbmNob3JOb2RlLmdldFByZXZpb3VzU2libGluZ3MoKS5yZWR1Y2UoKG9mZnNldCwgX25vZGUpID0+IHtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBfbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICB9LCAwKTtcbiAgfVxuICBjb25zdCBoYXNDaGFuZ2VzID0gdXBkYXRlRm4oKTtcbiAgaWYgKCFoYXNDaGFuZ2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm9uLXRleHQgYW5jaG9ycyBvbmx5IGhhcHBlbiBmb3IgbGluZSBicmVha3MsIG90aGVyd2lzZVxuICAvLyBzZWxlY3Rpb24gd2lsbCBiZSB3aXRoaW4gdGV4dCBub2RlIChjb2RlIGhpZ2hsaWdodCBub2RlKVxuICBpZiAoaXNOZXdMaW5lQW5jaG9yKSB7XG4gICAgYW5jaG9yLmdldE5vZGUoKS5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBhbmNob3JPZmZzZXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGl0IHdhcyBub24tZWxlbWVudCBhbmNob3IgdGhlbiB3ZSB3YWxrIHRocm91Z2ggY2hpbGQgbm9kZXNcbiAgLy8gYW5kIGxvb2tpbmcgZm9yIGEgcG9zaXRpb24gb2Ygb3JpZ2luYWwgdGV4dCBvZmZzZXRcbiAgbm9kZS5nZXRDaGlsZHJlbigpLnNvbWUoX25vZGUgPT4ge1xuICAgIGNvbnN0IGlzVGV4dCA9ICRpc1RleHROb2RlKF9ub2RlKTtcbiAgICBpZiAoaXNUZXh0IHx8ICRpc0xpbmVCcmVha05vZGUoX25vZGUpKSB7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBfbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGlmIChpc1RleHQgJiYgdGV4dENvbnRlbnRTaXplID49IHRleHRPZmZzZXQpIHtcbiAgICAgICAgX25vZGUuc2VsZWN0KHRleHRPZmZzZXQsIHRleHRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRleHRPZmZzZXQgLT0gdGV4dENvbnRlbnRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuXG4vLyBGaW5kcyBtaW5pbWFsIGRpZmYgcmFuZ2UgYmV0d2VlbiB0d28gbm9kZXMgbGlzdHMuIEl0IHJldHVybnMgZnJvbS90byByYW5nZSBib3VuZGFyaWVzIG9mIHByZXZOb2Rlc1xuLy8gdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGBub2Rlc2AgKHN1YnNldCBvZiBuZXh0Tm9kZXMpIHRvIG1ha2UgcHJldk5vZGVzIGVxdWFsIHRvIG5leHROb2Rlcy5cbmZ1bmN0aW9uIGdldERpZmZSYW5nZShwcmV2Tm9kZXMsIG5leHROb2Rlcykge1xuICBsZXQgbGVhZGluZ01hdGNoID0gMDtcbiAgd2hpbGUgKGxlYWRpbmdNYXRjaCA8IHByZXZOb2Rlcy5sZW5ndGgpIHtcbiAgICBpZiAoIWlzRXF1YWwocHJldk5vZGVzW2xlYWRpbmdNYXRjaF0sIG5leHROb2Rlc1tsZWFkaW5nTWF0Y2hdKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxlYWRpbmdNYXRjaCsrO1xuICB9XG4gIGNvbnN0IHByZXZOb2Rlc0xlbmd0aCA9IHByZXZOb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IG5leHROb2Rlc0xlbmd0aCA9IG5leHROb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IG1heFRyYWlsaW5nTWF0Y2ggPSBNYXRoLm1pbihwcmV2Tm9kZXNMZW5ndGgsIG5leHROb2Rlc0xlbmd0aCkgLSBsZWFkaW5nTWF0Y2g7XG4gIGxldCB0cmFpbGluZ01hdGNoID0gMDtcbiAgd2hpbGUgKHRyYWlsaW5nTWF0Y2ggPCBtYXhUcmFpbGluZ01hdGNoKSB7XG4gICAgdHJhaWxpbmdNYXRjaCsrO1xuICAgIGlmICghaXNFcXVhbChwcmV2Tm9kZXNbcHJldk5vZGVzTGVuZ3RoIC0gdHJhaWxpbmdNYXRjaF0sIG5leHROb2Rlc1tuZXh0Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoXSkpIHtcbiAgICAgIHRyYWlsaW5nTWF0Y2gtLTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBmcm9tID0gbGVhZGluZ01hdGNoO1xuICBjb25zdCB0byA9IHByZXZOb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2g7XG4gIGNvbnN0IG5vZGVzRm9yUmVwbGFjZW1lbnQgPSBuZXh0Tm9kZXMuc2xpY2UobGVhZGluZ01hdGNoLCBuZXh0Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tLFxuICAgIG5vZGVzRm9yUmVwbGFjZW1lbnQsXG4gICAgdG9cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwobm9kZUEsIG5vZGVCKSB7XG4gIC8vIE9ubHkgY2hlY2tpbmcgZm9yIGNvZGUgaGlnbGlnaHQgbm9kZXMsIHRhYnMgYW5kIGxpbmVicmVha3MuIElmIGl0J3MgcmVndWxhciB0ZXh0IG5vZGVcbiAgLy8gcmV0dXJuaW5nIGZhbHNlIHNvIHRoYXQgaXQncyB0cmFuc2Zvcm1lZCBpbnRvIGNvZGUgaGlnaGxpZ2h0IG5vZGVcbiAgcmV0dXJuICRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGVBKSAmJiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlQikgJiYgbm9kZUEuX190ZXh0ID09PSBub2RlQi5fX3RleHQgJiYgbm9kZUEuX19oaWdobGlnaHRUeXBlID09PSBub2RlQi5fX2hpZ2hsaWdodFR5cGUgfHwgJGlzVGFiTm9kZShub2RlQSkgJiYgJGlzVGFiTm9kZShub2RlQikgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlQSkgJiYgJGlzTGluZUJyZWFrTm9kZShub2RlQik7XG59XG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSB7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGlmIChhbmNob3JOb2RlLmlzKGZvY3VzTm9kZSkgJiYgJGlzQ29kZU5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhbmNob3JQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICByZXR1cm4gJGlzQ29kZU5vZGUoYW5jaG9yUGFyZW50KSAmJiBhbmNob3JQYXJlbnQuaXMoZm9jdXNOb2RlLmdldFBhcmVudCgpKTtcbn1cbmZ1bmN0aW9uICRnZXRDb2RlTGluZXMoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGxpbmVzID0gW1tdXTtcbiAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiAkaXNDb2RlTm9kZShub2Rlc1swXSkpIHtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgbGV0IGxhc3RMaW5lID0gbGluZXNbMF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCEoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgfHwgJGlzVGFiTm9kZShub2RlKSB8fCAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNlbGVjdGlvbiB0byBiZSBpbnNpZGUgQ29kZUJsb2NrIGFuZCBjb25zaXN0aW5nIG9mIENvZGVIaWdobGlnaHROb2RlLCBUYWJOb2RlIGFuZCBMaW5lQnJlYWtOb2RlYCk7XG4gICAgfVxuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAoaSAhPT0gMCAmJiBsYXN0TGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxhc3RMaW5lID0gW107XG4gICAgICAgIGxpbmVzLnB1c2gobGFzdExpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TGluZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZXM7XG59XG5mdW5jdGlvbiAkaGFuZGxlVGFiKHNoaWZ0S2V5KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluZGVudE9yT3V0ZGVudCA9ICFzaGlmdEtleSA/IElOREVOVF9DT05URU5UX0NPTU1BTkQgOiBPVVRERU5UX0NPTlRFTlRfQ09NTUFORDtcbiAgY29uc3QgdGFiT3JPdXRkZW50ID0gIXNoaWZ0S2V5ID8gSU5TRVJUX1RBQl9DT01NQU5EIDogT1VUREVOVF9DT05URU5UX0NPTU1BTkQ7XG4gIC8vIDEuIElmIG11bHRpcGxlIGxpbmVzIHNlbGVjdGVkOiBpbmRlbnQvb3V0ZGVudFxuICBjb25zdCBjb2RlTGluZXMgPSAkZ2V0Q29kZUxpbmVzKHNlbGVjdGlvbik7XG4gIGlmIChjb2RlTGluZXMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBpbmRlbnRPck91dGRlbnQ7XG4gIH1cbiAgLy8gMi4gSWYgZW50aXJlIGxpbmUgc2VsZWN0ZWQ6IGluZGVudC9vdXRkZW50XG4gIGNvbnN0IHNlbGVjdGlvbk5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IHNlbGVjdGlvbk5vZGVzWzBdO1xuICBpZiAoISgkaXNDb2RlTm9kZShmaXJzdE5vZGUpIHx8ICRpc0NvZGVIaWdobGlnaHROb2RlKGZpcnN0Tm9kZSkgfHwgJGlzVGFiTm9kZShmaXJzdE5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUoZmlyc3ROb2RlKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgc2VsZWN0aW9uIGZpcnN0Tm9kZSB0byBiZSBDb2RlSGlnaGxpZ2h0Tm9kZSBvciBUYWJOb2RlYCk7XG4gIH1cbiAgaWYgKCRpc0NvZGVOb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICByZXR1cm4gaW5kZW50T3JPdXRkZW50O1xuICB9XG4gIGNvbnN0IGZpcnN0T2ZMaW5lID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmaXJzdE5vZGUpO1xuICBjb25zdCBsYXN0T2ZMaW5lID0gZ2V0TGFzdENvZGVOb2RlT2ZMaW5lKGZpcnN0Tm9kZSk7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBsZXQgc2VsZWN0aW9uRmlyc3Q7XG4gIGxldCBzZWxlY3Rpb25MYXN0O1xuICBpZiAoZm9jdXMuaXNCZWZvcmUoYW5jaG9yKSkge1xuICAgIHNlbGVjdGlvbkZpcnN0ID0gZm9jdXM7XG4gICAgc2VsZWN0aW9uTGFzdCA9IGFuY2hvcjtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25GaXJzdCA9IGFuY2hvcjtcbiAgICBzZWxlY3Rpb25MYXN0ID0gZm9jdXM7XG4gIH1cbiAgaWYgKGZpcnN0T2ZMaW5lICE9PSBudWxsICYmIGxhc3RPZkxpbmUgIT09IG51bGwgJiYgc2VsZWN0aW9uRmlyc3Qua2V5ID09PSBmaXJzdE9mTGluZS5nZXRLZXkoKSAmJiBzZWxlY3Rpb25GaXJzdC5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uTGFzdC5rZXkgPT09IGxhc3RPZkxpbmUuZ2V0S2V5KCkgJiYgc2VsZWN0aW9uTGFzdC5vZmZzZXQgPT09IGxhc3RPZkxpbmUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICByZXR1cm4gaW5kZW50T3JPdXRkZW50O1xuICB9XG4gIC8vIDMuIEVsc2U6IHRhYi9vdXRkZW50XG4gIHJldHVybiB0YWJPck91dGRlbnQ7XG59XG5mdW5jdGlvbiAkaGFuZGxlTXVsdGlsaW5lSW5kZW50KHR5cGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc1NlbGVjdGlvbkluQ29kZShzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNvZGVMaW5lcyA9ICRnZXRDb2RlTGluZXMoc2VsZWN0aW9uKTtcbiAgY29uc3QgY29kZUxpbmVzTGVuZ3RoID0gY29kZUxpbmVzLmxlbmd0aDtcbiAgLy8gTXVsdGlwbGUgbGluZXMgc2VsZWN0aW9uXG4gIGlmIChjb2RlTGluZXMubGVuZ3RoID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZUxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBjb2RlTGluZXNbaV07XG4gICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBmaXJzdE9mTGluZSA9IGxpbmVbMF07XG4gICAgICAgIC8vIEZpcnN0IGFuZCBsYXN0IGxpbmVzIG1pZ2h0IG5vdCBiZSBjb21wbGV0ZVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGZpcnN0T2ZMaW5lID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmaXJzdE9mTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0T2ZMaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICAgICAgICAgIGZpcnN0T2ZMaW5lLmluc2VydEJlZm9yZSgkY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRpc1RhYk5vZGUoZmlyc3RPZkxpbmUpKSB7XG4gICAgICAgICAgICBmaXJzdE9mTGluZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSnVzdCBvbmUgbGluZVxuICBjb25zdCBzZWxlY3Rpb25Ob2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBmaXJzdE5vZGUgPSBzZWxlY3Rpb25Ob2Rlc1swXTtcbiAgaWYgKCEoJGlzQ29kZU5vZGUoZmlyc3ROb2RlKSB8fCAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShmaXJzdE5vZGUpIHx8ICRpc1RhYk5vZGUoZmlyc3ROb2RlKSB8fCAkaXNMaW5lQnJlYWtOb2RlKGZpcnN0Tm9kZSkpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNlbGVjdGlvbiBmaXJzdE5vZGUgdG8gYmUgQ29kZUhpZ2hsaWdodE5vZGUgb3IgQ29kZVRhYk5vZGVgKTtcbiAgfVxuICBpZiAoJGlzQ29kZU5vZGUoZmlyc3ROb2RlKSkge1xuICAgIC8vIENvZGVOb2RlIGlzIGVtcHR5XG4gICAgaWYgKHR5cGUgPT09IElOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnROb2RlcyhbJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBmaXJzdE9mTGluZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3ROb2RlKTtcbiAgaWYgKCEoZmlyc3RPZkxpbmUgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdldEZpcnN0Q29kZU5vZGVPZkxpbmUgdG8gcmV0dXJuIGEgdmFsaWQgQ29kZSBOb2RlYCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IElOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICBpZiAoJGlzTGluZUJyZWFrTm9kZShmaXJzdE9mTGluZSkpIHtcbiAgICAgIGZpcnN0T2ZMaW5lLmluc2VydEFmdGVyKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdE9mTGluZS5pbnNlcnRCZWZvcmUoJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCRpc1RhYk5vZGUoZmlyc3RPZkxpbmUpKSB7XG4gICAgZmlyc3RPZkxpbmUucmVtb3ZlKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkaGFuZGxlU2hpZnRMaW5lcyh0eXBlLCBldmVudCkge1xuICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGFsdCthcnJvdyBrZXlzXG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSSdtIG5vdCBxdWl0ZSBzdXJlIHdoeSwgYnV0IGl0IHNlZW1zIGxpa2UgY2FsbGluZyBhbmNob3IuZ2V0Tm9kZSgpIGNvbGxhcHNlcyB0aGUgc2VsZWN0aW9uIGhlcmVcbiAgLy8gU28gZmlyc3QsIGdldCB0aGUgYW5jaG9yIGFuZCB0aGUgZm9jdXMsIHRoZW4gZ2V0IHRoZWlyIG5vZGVzXG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IGFycm93SXNVcCA9IHR5cGUgPT09IEtFWV9BUlJPV19VUF9DT01NQU5EO1xuXG4gIC8vIEVuc3VyZSB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrXG4gIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikgfHwgISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShhbmNob3JOb2RlKSB8fCAkaXNUYWJOb2RlKGFuY2hvck5vZGUpKSB8fCAhKCRpc0NvZGVIaWdobGlnaHROb2RlKGZvY3VzTm9kZSkgfHwgJGlzVGFiTm9kZShmb2N1c05vZGUpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWV2ZW50LmFsdEtleSkge1xuICAgIC8vIEhhbmRsZSBtb3Zpbmcgc2VsZWN0aW9uIG91dCBvZiB0aGUgY29kZSBibG9jaywgZ2l2ZW4gdGhlcmUgYXJlIG5vXG4gICAgLy8gc2libGluZyB0aGF0cyBjYW4gbmF0aXZlbHkgdGFrZSB0aGUgc2VsZWN0aW9uLlxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgY29kZU5vZGUgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGlmIChhcnJvd0lzVXAgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZU5vZGVTaWJsaW5nID0gY29kZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmIChjb2RlTm9kZVNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWFycm93SXNVcCAmJiBhbmNob3JPZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgJiYgYW5jaG9yTm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvZGVOb2RlU2libGluZyA9IGNvZGVOb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIGlmIChjb2RlTm9kZVNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBpZiAoYW5jaG9yTm9kZS5pc0JlZm9yZShmb2N1c05vZGUpKSB7XG4gICAgc3RhcnQgPSBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGFuY2hvck5vZGUpO1xuICAgIGVuZCA9IGdldExhc3RDb2RlTm9kZU9mTGluZShmb2N1c05vZGUpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmb2N1c05vZGUpO1xuICAgIGVuZCA9IGdldExhc3RDb2RlTm9kZU9mTGluZShhbmNob3JOb2RlKTtcbiAgfVxuICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByYW5nZSA9IHN0YXJ0LmdldE5vZGVzQmV0d2VlbihlbmQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IHJhbmdlW2ldO1xuICAgIGlmICghJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgJiYgISRpc1RhYk5vZGUobm9kZSkgJiYgISRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBBZnRlciB0aGlzIHBvaW50LCB3ZSBrbm93IHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBjb2RlYmxvY2suIFdlIG1heSBub3QgYmUgYWJsZSB0b1xuICAvLyBhY3R1YWxseSBtb3ZlIHRoZSBsaW5lcyBhcm91bmQsIGJ1dCB3ZSB3YW50IHRvIHJldHVybiB0cnVlIGVpdGhlciB3YXkgdG8gcHJldmVudFxuICAvLyB0aGUgZXZlbnQncyBkZWZhdWx0IGJlaGF2aW9yXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyByZXF1aXJlZCB0byBzdG9wIGN1cnNvciBtb3ZlbWVudCB1bmRlciBGaXJlZm94XG5cbiAgY29uc3QgbGluZWJyZWFrID0gYXJyb3dJc1VwID8gc3RhcnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBlbmQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgaWYgKCEkaXNMaW5lQnJlYWtOb2RlKGxpbmVicmVhaykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzaWJsaW5nID0gYXJyb3dJc1VwID8gbGluZWJyZWFrLmdldFByZXZpb3VzU2libGluZygpIDogbGluZWJyZWFrLmdldE5leHRTaWJsaW5nKCk7XG4gIGlmIChzaWJsaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBtYXliZUluc2VydGlvblBvaW50ID0gJGlzQ29kZUhpZ2hsaWdodE5vZGUoc2libGluZykgfHwgJGlzVGFiTm9kZShzaWJsaW5nKSB8fCAkaXNMaW5lQnJlYWtOb2RlKHNpYmxpbmcpID8gYXJyb3dJc1VwID8gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShzaWJsaW5nKSA6IGdldExhc3RDb2RlTm9kZU9mTGluZShzaWJsaW5nKSA6IG51bGw7XG4gIGxldCBpbnNlcnRpb25Qb2ludCA9IG1heWJlSW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCA/IG1heWJlSW5zZXJ0aW9uUG9pbnQgOiBzaWJsaW5nO1xuICBsaW5lYnJlYWsucmVtb3ZlKCk7XG4gIHJhbmdlLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgaWYgKHR5cGUgPT09IEtFWV9BUlJPV19VUF9DT01NQU5EKSB7XG4gICAgcmFuZ2UuZm9yRWFjaChub2RlID0+IGluc2VydGlvblBvaW50Lmluc2VydEJlZm9yZShub2RlKSk7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QmVmb3JlKGxpbmVicmVhayk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobGluZWJyZWFrKTtcbiAgICBpbnNlcnRpb25Qb2ludCA9IGxpbmVicmVhaztcbiAgICByYW5nZS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgICBpbnNlcnRpb25Qb2ludCA9IG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkaGFuZGxlTW92ZVRvKHR5cGUsIGV2ZW50KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgaXNNb3ZlVG9TdGFydCA9IHR5cGUgPT09IE1PVkVfVE9fU1RBUlQ7XG4gIGlmICghKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvck5vZGUpIHx8ICRpc1RhYk5vZGUoYW5jaG9yTm9kZSkpIHx8ICEoJGlzQ29kZUhpZ2hsaWdodE5vZGUoZm9jdXNOb2RlKSB8fCAkaXNUYWJOb2RlKGZvY3VzTm9kZSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc01vdmVUb1N0YXJ0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRTdGFydE9mQ29kZUluTGluZShmb2N1c05vZGUsIGZvY3VzLm9mZnNldCk7XG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHN0YXJ0O1xuICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgICAgbm9kZS5zZWxlY3ROZXh0KDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uobm9kZSwgb2Zmc2V0LCBub2RlLCBvZmZzZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGUgPSBnZXRFbmRPZkNvZGVJbkxpbmUoZm9jdXNOb2RlKTtcbiAgICBub2RlLnNlbGVjdCgpO1xuICB9XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29kZUhpZ2hsaWdodGluZyhlZGl0b3IsIHRva2VuaXplcikge1xuICBpZiAoIWVkaXRvci5oYXNOb2RlcyhbQ29kZU5vZGUsIENvZGVIaWdobGlnaHROb2RlXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVIaWdobGlnaHRQbHVnaW46IENvZGVOb2RlIG9yIENvZGVIaWdobGlnaHROb2RlIG5vdCByZWdpc3RlcmVkIG9uIGVkaXRvcicpO1xuICB9XG4gIGlmICh0b2tlbml6ZXIgPT0gbnVsbCkge1xuICAgIHRva2VuaXplciA9IFByaXNtVG9rZW5pemVyO1xuICB9XG4gIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoQ29kZU5vZGUsIG11dGF0aW9ucyA9PiB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHR5cGVdIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAodHlwZSAhPT0gJ2Rlc3Ryb3llZCcpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVDb2RlR3V0dGVyKG5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKENvZGVOb2RlLCBub2RlID0+IGNvZGVOb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGV4dE5vZGUsIG5vZGUgPT4gJHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oQ29kZUhpZ2hsaWdodE5vZGUsIG5vZGUgPT4gJHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX1RBQl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgY29tbWFuZCA9ICRoYW5kbGVUYWIoZXZlbnQuc2hpZnRLZXkpO1xuICAgIGlmIChjb21tYW5kID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChjb21tYW5kLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1RBQl9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgJGluc2VydE5vZGVzKFskY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBwYXlsb2FkID0+ICRoYW5kbGVNdWx0aWxpbmVJbmRlbnQoSU5ERU5UX0NPTlRFTlRfQ09NTUFORCksIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgcGF5bG9hZCA9PiAkaGFuZGxlTXVsdGlsaW5lSW5kZW50KE9VVERFTlRfQ09OVEVOVF9DT01NQU5EKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBwYXlsb2FkID0+ICRoYW5kbGVTaGlmdExpbmVzKEtFWV9BUlJPV19VUF9DT01NQU5ELCBwYXlsb2FkKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIHBheWxvYWQgPT4gJGhhbmRsZVNoaWZ0TGluZXMoS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgcGF5bG9hZCksIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChNT1ZFX1RPX0VORCwgcGF5bG9hZCA9PiAkaGFuZGxlTW92ZVRvKE1PVkVfVE9fRU5ELCBwYXlsb2FkKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKE1PVkVfVE9fU1RBUlQsIHBheWxvYWQgPT4gJGhhbmRsZU1vdmVUbyhNT1ZFX1RPX1NUQVJULCBwYXlsb2FkKSwgQ09NTUFORF9QUklPUklUWV9MT1cpKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5leHBvcnQgeyAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUsICRjcmVhdGVDb2RlTm9kZSwgJGlzQ29kZUhpZ2hsaWdodE5vZGUsICRpc0NvZGVOb2RlLCBDT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQLCBDT0RFX0xBTkdVQUdFX01BUCwgQ29kZUhpZ2hsaWdodE5vZGUsIENvZGVOb2RlLCBERUZBVUxUX0NPREVfTEFOR1VBR0UsIFByaXNtVG9rZW5pemVyLCBnZXRDb2RlTGFuZ3VhZ2VzLCBnZXREZWZhdWx0Q29kZUxhbmd1YWdlLCBnZXRFbmRPZkNvZGVJbkxpbmUsIGdldEZpcnN0Q29kZU5vZGVPZkxpbmUsIGdldExhbmd1YWdlRnJpZW5kbHlOYW1lLCBnZXRMYXN0Q29kZU5vZGVPZkxpbmUsIGdldFN0YXJ0T2ZDb2RlSW5MaW5lLCBub3JtYWxpemVDb2RlTGFuZywgcmVnaXN0ZXJDb2RlSGlnaGxpZ2h0aW5nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/code/LexicalCode.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerDragonSupport: () => (/* binding */ registerDragonSupport)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n              if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBYTtBQUM3QyxrQkFBa0IsMERBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2Lm1qcz9mNzNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1RleHROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJEcmFnb25TdXBwb3J0KGVkaXRvcikge1xuICBjb25zdCBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICBjb25zdCBoYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5vcmlnaW4gIT09IG9yaWdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSByb290RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkRGF0YSAmJiBwYXJzZWREYXRhLnByb3RvY29sID09PSAnbnVhbnJpYV9tZXNzYWdpbmcnICYmIHBhcnNlZERhdGEudHlwZSA9PT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBwYXJzZWREYXRhLnBheWxvYWQ7XG4gICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuZnVuY3Rpb25JZCA9PT0gJ21ha2VDaGFuZ2VzJykge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXlsb2FkLmFyZ3M7XG4gICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFtlbGVtZW50U3RhcnQsIGVsZW1lbnRMZW5ndGgsIHRleHQsIHNlbFN0YXJ0LCBzZWxMZW5ndGgsIGZvcm1hdENvbW1hbmRdID0gYXJncztcbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgICAgICBsZXQgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHNldFNlbFN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgc2V0U2VsRW5kID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRTdGFydCA+PSAwICYmIGVsZW1lbnRMZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IGVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gZWxlbWVudFN0YXJ0ICsgZWxlbWVudExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9mZnNldCBpcyBtb3JlIHRoYW4gdGhlIGVuZCwgbWFrZSBpdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0U2VsU3RhcnQgIT09IHNldFNlbEVuZCB8fCB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgZmluYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2VsU3RhcnQgKyBzZWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlVGV4dExlbmd0aCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGlzIG1vcmUgdGhhbiB0aGUgZW5kLCBtYWtlIGl0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgIHNldFNlbFN0YXJ0ID0gc2V0U2VsU3RhcnQgPiBhbmNob3JOb2RlVGV4dExlbmd0aCA/IGFuY2hvck5vZGVUZXh0TGVuZ3RoIDogc2V0U2VsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBzZXRTZWxFbmQgPSBzZXRTZWxFbmQgPiBhbmNob3JOb2RlVGV4dExlbmd0aCA/IGFuY2hvck5vZGVUZXh0TGVuZ3RoIDogc2V0U2VsRW5kO1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgc2V0U2VsU3RhcnQsIGFuY2hvck5vZGUsIHNldFNlbEVuZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYmxvY2sgdGhlIGNocm9tZSBleHRlbnNpb24gZnJvbSBoYW5kbGluZyB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIsIHRydWUpO1xuICB9O1xufVxuXG5leHBvcnQgeyByZWdpc3RlckRyYWdvblN1cHBvcnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/headless/LexicalHeadless.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/headless/LexicalHeadless.dev.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHeadlessEditor: () => (/* binding */ createHeadlessEditor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Generates a headless editor that allows lexical to be used without the need for a DOM, eg in Node.js.\n * Throws an error when unsupported methods are used.\n * @param editorConfig - The optional lexical editor configuration.\n * @returns - The configured headless editor.\n */\nfunction createHeadlessEditor(editorConfig) {\n  const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createEditor)(editorConfig);\n  editor._headless = true;\n  const unsupportedMethods = ['registerDecoratorListener', 'registerRootListener', 'registerMutationListener', 'getRootElement', 'setRootElement', 'getElementByKey', 'focus', 'blur'];\n  unsupportedMethods.forEach(method => {\n    editor[method] = () => {\n      throw new Error(`${method} is not supported in headless mode`);\n    };\n  });\n  return editor;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGVhZGxlc3MvTGV4aWNhbEhlYWRsZXNzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oZWFkbGVzcy9MZXhpY2FsSGVhZGxlc3MuZGV2Lm1qcz8wMzkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlRWRpdG9yIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGhlYWRsZXNzIGVkaXRvciB0aGF0IGFsbG93cyBsZXhpY2FsIHRvIGJlIHVzZWQgd2l0aG91dCB0aGUgbmVlZCBmb3IgYSBET00sIGVnIGluIE5vZGUuanMuXG4gKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiB1bnN1cHBvcnRlZCBtZXRob2RzIGFyZSB1c2VkLlxuICogQHBhcmFtIGVkaXRvckNvbmZpZyAtIFRoZSBvcHRpb25hbCBsZXhpY2FsIGVkaXRvciBjb25maWd1cmF0aW9uLlxuICogQHJldHVybnMgLSBUaGUgY29uZmlndXJlZCBoZWFkbGVzcyBlZGl0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRsZXNzRWRpdG9yKGVkaXRvckNvbmZpZykge1xuICBjb25zdCBlZGl0b3IgPSBjcmVhdGVFZGl0b3IoZWRpdG9yQ29uZmlnKTtcbiAgZWRpdG9yLl9oZWFkbGVzcyA9IHRydWU7XG4gIGNvbnN0IHVuc3VwcG9ydGVkTWV0aG9kcyA9IFsncmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcicsICdyZWdpc3RlclJvb3RMaXN0ZW5lcicsICdyZWdpc3Rlck11dGF0aW9uTGlzdGVuZXInLCAnZ2V0Um9vdEVsZW1lbnQnLCAnc2V0Um9vdEVsZW1lbnQnLCAnZ2V0RWxlbWVudEJ5S2V5JywgJ2ZvY3VzJywgJ2JsdXInXTtcbiAgdW5zdXBwb3J0ZWRNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICBlZGl0b3JbbWV0aG9kXSA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHttZXRob2R9IGlzIG5vdCBzdXBwb3J0ZWQgaW4gaGVhZGxlc3MgbW9kZWApO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5leHBvcnQgeyBjcmVhdGVIZWFkbGVzc0VkaXRvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/headless/LexicalHeadless.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyHistoryState: () => (/* binding */ createEmptyHistoryState),\n/* harmony export */   registerHistory: () => (/* binding */ registerHistory)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevDirtyNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n  if (!isDeletingLine && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDNko7O0FBRTVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9EQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBEQUFpQixvQkFBb0IsMERBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsb0RBQVc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvREFBVyxvQkFBb0Isb0RBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQWlCLG1CQUFtQiwwREFBaUI7QUFDM0Q7QUFDQTtBQUNBLHlCQUF5QixvREFBVyxjQUFjLG9EQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQixxREFBZ0I7QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQWEsd0JBQXdCLGlEQUFZO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixpREFBWTtBQUNsRTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIseURBQW9CO0FBQzFFO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiwwREFBcUI7QUFDM0U7QUFDQSwyQkFBMkIscURBQWdCO0FBQzNDLDJCQUEyQixxREFBZ0I7QUFDM0M7QUFDQSxHQUFHLEVBQUUsNERBQXVCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2hpc3RvcnkvTGV4aWNhbEhpc3RvcnkuZGV2Lm1qcz82NGJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IFVORE9fQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9FRElUT1IsIFJFRE9fQ09NTUFORCwgQ0xFQVJfRURJVE9SX0NPTU1BTkQsIENMRUFSX0hJU1RPUllfQ09NTUFORCwgQ0FOX1JFRE9fQ09NTUFORCwgQ0FOX1VORE9fQ09NTUFORCwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1RleHROb2RlLCAkaXNSb290Tm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IEhJU1RPUllfTUVSR0UgPSAwO1xuY29uc3QgSElTVE9SWV9QVVNIID0gMTtcbmNvbnN0IERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEUgPSAyO1xuY29uc3QgT1RIRVIgPSAwO1xuY29uc3QgQ09NUE9TSU5HX0NIQVJBQ1RFUiA9IDE7XG5jb25zdCBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTiA9IDI7XG5jb25zdCBERUxFVEVfQ0hBUkFDVEVSX0JFRk9SRV9TRUxFQ1RJT04gPSAzO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT04gPSA0O1xuZnVuY3Rpb24gZ2V0RGlydHlOb2RlcyhlZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMpIHtcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGRpcnR5TGVhZktleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IGRpcnR5TGVhZiA9IG5vZGVNYXAuZ2V0KGRpcnR5TGVhZktleSk7XG4gICAgaWYgKGRpcnR5TGVhZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5TGVhZik7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgW2RpcnR5RWxlbWVudEtleSwgaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHldIG9mIGRpcnR5RWxlbWVudHMpIHtcbiAgICBpZiAoIWludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZGlydHlFbGVtZW50ID0gbm9kZU1hcC5nZXQoZGlydHlFbGVtZW50S2V5KTtcbiAgICBpZiAoZGlydHlFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgISRpc1Jvb3ROb2RlKGRpcnR5RWxlbWVudCkpIHtcbiAgICAgIG5vZGVzLnB1c2goZGlydHlFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gZ2V0Q2hhbmdlVHlwZShwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXNTZXQsIGRpcnR5RWxlbWVudHNTZXQsIGlzQ29tcG9zaW5nKSB7XG4gIGlmIChwcmV2RWRpdG9yU3RhdGUgPT09IG51bGwgfHwgZGlydHlMZWF2ZXNTZXQuc2l6ZSA9PT0gMCAmJiBkaXJ0eUVsZW1lbnRzU2V0LnNpemUgPT09IDAgJiYgIWlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IG5leHRTZWxlY3Rpb24gPSBuZXh0RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICByZXR1cm4gQ09NUE9TSU5HX0NIQVJBQ1RFUjtcbiAgfVxuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pIHx8ICEkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSB8fCAhcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICFuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgZGlydHlOb2RlcyA9IGdldERpcnR5Tm9kZXMobmV4dEVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlc1NldCwgZGlydHlFbGVtZW50c1NldCk7XG4gIGlmIChkaXJ0eU5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuXG4gIC8vIENhdGNoaW5nIHRoZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIG5ldyB0ZXh0IG5vZGUgaW50byBhbiBlbGVtZW50IChlLmcuIGZpcnN0IGNoYXIgaW4gcGFyYWdyYXBoL2xpc3QpLFxuICAvLyBvciBhZnRlciBleGlzdGluZyBub2RlLlxuICBpZiAoZGlydHlOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgbmV4dE5vZGVNYXAgPSBuZXh0RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gICAgY29uc3QgbmV4dEFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQobmV4dFNlbGVjdGlvbi5hbmNob3Iua2V5KTtcbiAgICBjb25zdCBwcmV2QW5jaG9yTm9kZSA9IG5leHROb2RlTWFwLmdldChwcmV2U2VsZWN0aW9uLmFuY2hvci5rZXkpO1xuICAgIGlmIChuZXh0QW5jaG9yTm9kZSAmJiBwcmV2QW5jaG9yTm9kZSAmJiAhcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmhhcyhuZXh0QW5jaG9yTm9kZS5fX2tleSkgJiYgJGlzVGV4dE5vZGUobmV4dEFuY2hvck5vZGUpICYmIG5leHRBbmNob3JOb2RlLl9fdGV4dC5sZW5ndGggPT09IDEgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAxKSB7XG4gICAgICByZXR1cm4gSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gICAgfVxuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0RGlydHlOb2RlID0gZGlydHlOb2Rlc1swXTtcbiAgY29uc3QgcHJldkRpcnR5Tm9kZSA9IHByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQobmV4dERpcnR5Tm9kZS5fX2tleSk7XG4gIGlmICghJGlzVGV4dE5vZGUocHJldkRpcnR5Tm9kZSkgfHwgISRpc1RleHROb2RlKG5leHREaXJ0eU5vZGUpIHx8IHByZXZEaXJ0eU5vZGUuX19tb2RlICE9PSBuZXh0RGlydHlOb2RlLl9fbW9kZSkge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBwcmV2VGV4dCA9IHByZXZEaXJ0eU5vZGUuX190ZXh0O1xuICBjb25zdCBuZXh0VGV4dCA9IG5leHREaXJ0eU5vZGUuX190ZXh0O1xuICBpZiAocHJldlRleHQgPT09IG5leHRUZXh0KSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IG5leHRBbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgcHJldkFuY2hvciA9IHByZXZTZWxlY3Rpb24uYW5jaG9yO1xuICBpZiAobmV4dEFuY2hvci5rZXkgIT09IHByZXZBbmNob3Iua2V5IHx8IG5leHRBbmNob3IudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IG5leHRBbmNob3JPZmZzZXQgPSBuZXh0QW5jaG9yLm9mZnNldDtcbiAgY29uc3QgcHJldkFuY2hvck9mZnNldCA9IHByZXZBbmNob3Iub2Zmc2V0O1xuICBjb25zdCB0ZXh0RGlmZiA9IG5leHRUZXh0Lmxlbmd0aCAtIHByZXZUZXh0Lmxlbmd0aDtcbiAgaWYgKHRleHREaWZmID09PSAxICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgLSAxKSB7XG4gICAgcmV0dXJuIElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICB9XG4gIGlmICh0ZXh0RGlmZiA9PT0gLTEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCArIDEpIHtcbiAgICByZXR1cm4gREVMRVRFX0NIQVJBQ1RFUl9CRUZPUkVfU0VMRUNUSU9OO1xuICB9XG4gIGlmICh0ZXh0RGlmZiA9PT0gLTEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCkge1xuICAgIHJldHVybiBERUxFVEVfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuICByZXR1cm4gT1RIRVI7XG59XG5mdW5jdGlvbiBpc1RleHROb2RlVW5jaGFuZ2VkKGtleSwgcHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgcHJldk5vZGUgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGtleSk7XG4gIGNvbnN0IG5leHROb2RlID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IG5leHRTZWxlY3Rpb24gPSBuZXh0RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgbGV0IGlzRGVsZXRpbmdMaW5lID0gZmFsc2U7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiAkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSkge1xuICAgIGlzRGVsZXRpbmdMaW5lID0gcHJldlNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHByZXZTZWxlY3Rpb24uZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBuZXh0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICd0ZXh0JztcbiAgfVxuICBpZiAoIWlzRGVsZXRpbmdMaW5lICYmICRpc1RleHROb2RlKHByZXZOb2RlKSAmJiAkaXNUZXh0Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICByZXR1cm4gcHJldk5vZGUuX190eXBlID09PSBuZXh0Tm9kZS5fX3R5cGUgJiYgcHJldk5vZGUuX190ZXh0ID09PSBuZXh0Tm9kZS5fX3RleHQgJiYgcHJldk5vZGUuX19tb2RlID09PSBuZXh0Tm9kZS5fX21vZGUgJiYgcHJldk5vZGUuX19kZXRhaWwgPT09IG5leHROb2RlLl9fZGV0YWlsICYmIHByZXZOb2RlLl9fc3R5bGUgPT09IG5leHROb2RlLl9fc3R5bGUgJiYgcHJldk5vZGUuX19mb3JtYXQgPT09IG5leHROb2RlLl9fZm9ybWF0ICYmIHByZXZOb2RlLl9fcGFyZW50ID09PSBuZXh0Tm9kZS5fX3BhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KSB7XG4gIGxldCBwcmV2Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XG4gIGxldCBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICByZXR1cm4gKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBjdXJyZW50SGlzdG9yeUVudHJ5LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncykgPT4ge1xuICAgIGNvbnN0IGNoYW5nZVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gSWYgYXBwbHlpbmcgY2hhbmdlcyBmcm9tIGhpc3Rvcnkgc3RhY2sgdGhlcmUncyBubyBuZWVkXG4gICAgLy8gdG8gcnVuIGhpc3RvcnkgbG9naWMgYWdhaW4sIGFzIGhpc3RvcnkgZW50cmllcyBhbHJlYWR5IGNhbGN1bGF0ZWRcbiAgICBpZiAodGFncy5oYXMoJ2hpc3RvcmljJykpIHtcbiAgICAgIHByZXZDaGFuZ2VUeXBlID0gT1RIRVI7XG4gICAgICBwcmV2Q2hhbmdlVGltZSA9IGNoYW5nZVRpbWU7XG4gICAgICByZXR1cm4gRElTQ0FSRF9ISVNUT1JZX0NBTkRJREFURTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlVHlwZSA9IGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzLCBlZGl0b3IuaXNDb21wb3NpbmcoKSk7XG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSAoKCkgPT4ge1xuICAgICAgY29uc3QgaXNTYW1lRWRpdG9yID0gY3VycmVudEhpc3RvcnlFbnRyeSA9PT0gbnVsbCB8fCBjdXJyZW50SGlzdG9yeUVudHJ5LmVkaXRvciA9PT0gZWRpdG9yO1xuICAgICAgY29uc3Qgc2hvdWxkUHVzaEhpc3RvcnkgPSB0YWdzLmhhcygnaGlzdG9yeS1wdXNoJyk7XG4gICAgICBjb25zdCBzaG91bGRNZXJnZUhpc3RvcnkgPSAhc2hvdWxkUHVzaEhpc3RvcnkgJiYgaXNTYW1lRWRpdG9yICYmIHRhZ3MuaGFzKCdoaXN0b3J5LW1lcmdlJyk7XG4gICAgICBpZiAoc2hvdWxkTWVyZ2VIaXN0b3J5KSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9QVVNIO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgICBjb25zdCBoYXNEaXJ0eU5vZGVzID0gZGlydHlMZWF2ZXMuc2l6ZSA+IDAgfHwgZGlydHlFbGVtZW50cy5zaXplID4gMDtcbiAgICAgIGlmICghaGFzRGlydHlOb2Rlcykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUHVzaEhpc3RvcnkgPT09IGZhbHNlICYmIGNoYW5nZVR5cGUgIT09IE9USEVSICYmIGNoYW5nZVR5cGUgPT09IHByZXZDaGFuZ2VUeXBlICYmIGNoYW5nZVRpbWUgPCBwcmV2Q2hhbmdlVGltZSArIGRlbGF5ICYmIGlzU2FtZUVkaXRvcikge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cblxuICAgICAgLy8gQSBzaW5nbGUgbm9kZSBtaWdodCBoYXZlIGJlZW4gbWFya2VkIGFzIGRpcnR5LCBidXQgbm90IGhhdmUgY2hhbmdlZFxuICAgICAgLy8gZHVlIHRvIHNvbWUgbm9kZSB0cmFuc2Zvcm0gcmV2ZXJ0aW5nIHRoZSBjaGFuZ2UuXG4gICAgICBpZiAoZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBkaXJ0eUxlYWZLZXkgPSBBcnJheS5mcm9tKGRpcnR5TGVhdmVzKVswXTtcbiAgICAgICAgaWYgKGlzVGV4dE5vZGVVbmNoYW5nZWQoZGlydHlMZWFmS2V5LCBwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEhJU1RPUllfUFVTSDtcbiAgICB9KSgpO1xuICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICBwcmV2Q2hhbmdlVHlwZSA9IGNoYW5nZVR5cGU7XG4gICAgcmV0dXJuIG1lcmdlQWN0aW9uO1xuICB9O1xufVxuZnVuY3Rpb24gcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSkge1xuICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2sgPSBoaXN0b3J5U3RhdGUudW5kb1N0YWNrO1xuICBpZiAocmVkb1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdW5kb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAocmVkb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5kbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSkge1xuICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2sgPSBoaXN0b3J5U3RhdGUudW5kb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2tMZW5ndGggPSB1bmRvU3RhY2subGVuZ3RoO1xuICBpZiAodW5kb1N0YWNrTGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGhpc3RvcnlTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IGhpc3RvcnlTdGF0ZUVudHJ5ID0gdW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICByZWRvU3RhY2sucHVzaChjdXJyZW50KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICB9XG4gICAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSBoaXN0b3J5U3RhdGVFbnRyeSB8fCBudWxsO1xuICAgIGlmIChoaXN0b3J5U3RhdGVFbnRyeSkge1xuICAgICAgaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yLnNldEVkaXRvclN0YXRlKGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvclN0YXRlLCB7XG4gICAgICAgIHRhZzogJ2hpc3RvcmljJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGVhckhpc3RvcnkoaGlzdG9yeVN0YXRlKSB7XG4gIGhpc3RvcnlTdGF0ZS51bmRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IG51bGw7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIG5lY2Vzc2FyeSBsaXN0ZW5lcnMgdG8gbWFuYWdlIHVuZG8vcmVkbyBoaXN0b3J5IHN0YWNrIGFuZCByZWxhdGVkIGVkaXRvciBjb21tYW5kcy5cbiAqIEl0IHJldHVybnMgYHVucmVnaXN0ZXJgIGNhbGxiYWNrIHRoYXQgY2xlYW5zIHVwIGFsbCBsaXN0ZW5lcnMgYW5kIHNob3VsZCBiZSBjYWxsZWQgb24gZWRpdG9yIHVubW91bnQuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGhpc3RvcnlTdGF0ZSAtIFRoZSBoaXN0b3J5IHN0YXRlLCBjb250YWluaW5nIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0aGUgdW5kby9yZWRvIHN0YWNrLlxuICogQHBhcmFtIGRlbGF5IC0gVGhlIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGVkaXRvciBzaG91bGQgZGVsYXkgZ2VuZXJhdGluZyBhIG5ldyBoaXN0b3J5IHN0YWNrLFxuICogaW5zdGVhZCBvZiBtZXJnaW5nIHRoZSBjdXJyZW50IGNoYW5nZXMgd2l0aCB0aGUgY3VycmVudCBzdGFjay5cbiAqIEByZXR1cm5zIFRoZSBsaXN0ZW5lcnMgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJIaXN0b3J5KGVkaXRvciwgaGlzdG9yeVN0YXRlLCBkZWxheSkge1xuICBjb25zdCBnZXRNZXJnZUFjdGlvbiA9IGNyZWF0ZU1lcmdlQWN0aW9uR2V0dGVyKGVkaXRvciwgZGVsYXkpO1xuICBjb25zdCBhcHBseUNoYW5nZSA9ICh7XG4gICAgZWRpdG9yU3RhdGUsXG4gICAgcHJldkVkaXRvclN0YXRlLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGRpcnR5RWxlbWVudHMsXG4gICAgdGFnc1xuICB9KSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IGhpc3RvcnlTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gICAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBjdXJyZW50ID09PSBudWxsID8gbnVsbCA6IGN1cnJlbnQuZWRpdG9yU3RhdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgZWRpdG9yU3RhdGUgPT09IGN1cnJlbnRFZGl0b3JTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZUFjdGlvbiA9IGdldE1lcmdlQWN0aW9uKHByZXZFZGl0b3JTdGF0ZSwgZWRpdG9yU3RhdGUsIGN1cnJlbnQsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzLCB0YWdzKTtcbiAgICBpZiAobWVyZ2VBY3Rpb24gPT09IEhJU1RPUllfUFVTSCkge1xuICAgICAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9SRURPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHVuZG9TdGFjay5wdXNoKHtcbiAgICAgICAgICAuLi5jdXJyZW50XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVyZ2VBY3Rpb24gPT09IERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFbHNlIHdlIG1lcmdlXG4gICAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSB7XG4gICAgICBlZGl0b3IsXG4gICAgICBlZGl0b3JTdGF0ZVxuICAgIH07XG4gIH07XG4gIGNvbnN0IHVucmVnaXN0ZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoVU5ET19DT01NQU5ELCAoKSA9PiB7XG4gICAgdW5kbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRURPX0NPTU1BTkQsICgpID0+IHtcbiAgICByZWRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENMRUFSX0VESVRPUl9DT01NQU5ELCAoKSA9PiB7XG4gICAgY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xFQVJfSElTVE9SWV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoYXBwbHlDaGFuZ2UpKTtcbiAgcmV0dXJuIHVucmVnaXN0ZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBoaXN0b3J5IHN0YXRlLlxuICogQHJldHVybnMgLSBUaGUgZW1wdHkgaGlzdG9yeSBzdGF0ZSwgYXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgdW5kb1N0YWNrOiBbXVxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSwgcmVnaXN0ZXJIaXN0b3J5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateHtmlFromNodes: () => (/* binding */ $generateHtmlFromNodes),\n/* harmony export */   $generateNodesFromDOM: () => (/* binding */ $generateNodesFromDOM)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(currentLexicalNode) ? false : currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode)(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(node)) {\n      node.setFormat(textAlign);\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE) {\n      node.insertAfter((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUY7QUFDMUI7QUFDbUg7O0FBRWxMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQWM7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQix3RUFBb0I7QUFDcEMsWUFBWSxvREFBVyxnQ0FBZ0MsaUZBQTZCO0FBQ3BGO0FBQ0E7QUFDQSxtQkFBbUIsdURBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNERBQW1CLDZEQUE2RCw0REFBbUI7QUFDbEwsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBLHlFQUF5RSx5REFBb0I7QUFDN0YsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLCtEQUEwQjtBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELDREQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQTBCO0FBQ25FLHVCQUF1Qiw2REFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2h0bWwvTGV4aWNhbEh0bWwuZGV2Lm1qcz83ZDg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGNsb25lV2l0aFByb3BlcnRpZXMsICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50IH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzQmxvY2tEb21Ob2RlIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgJGdldFJvb3QsICRpc0VsZW1lbnROb2RlLCAkaXNUZXh0Tm9kZSwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGlzQmxvY2tFbGVtZW50Tm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsICRjcmVhdGVMaW5lQnJlYWtOb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLyoqXG4gKiBIb3cgeW91IHBhcnNlIHlvdXIgaHRtbCBzdHJpbmcgdG8gZ2V0IGEgZG9jdW1lbnQgaXMgbGVmdCB1cCB0byB5b3UuIEluIHRoZSBicm93c2VyIHlvdSBjYW4gdXNlIHRoZSBuYXRpdmVcbiAqIERPTVBhcnNlciBBUEkgdG8gZ2VuZXJhdGUgYSBkb2N1bWVudCAoc2VlIGNsaXBib2FyZC50cyksIGJ1dCB0byB1c2UgaW4gYSBoZWFkbGVzcyBlbnZpcm9ubWVudCB5b3UgY2FuIHVzZSBKU0RvbVxuICogb3IgYW4gZXF1aXZhbGVudCBsaWJyYXJ5IGFuZCBwYXNzIGluIHRoZSBkb2N1bWVudCBoZXJlLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00oZWRpdG9yLCBkb20pIHtcbiAgY29uc3QgZWxlbWVudHMgPSBkb20uYm9keSA/IGRvbS5ib2R5LmNoaWxkTm9kZXMgOiBbXTtcbiAgbGV0IGxleGljYWxOb2RlcyA9IFtdO1xuICBjb25zdCBhbGxBcnRpZmljaWFsTm9kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICBpZiAoIUlHTk9SRV9UQUdTLmhhcyhlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgY29uc3QgbGV4aWNhbE5vZGUgPSAkY3JlYXRlTm9kZXNGcm9tRE9NKGVsZW1lbnQsIGVkaXRvciwgYWxsQXJ0aWZpY2lhbE5vZGVzLCBmYWxzZSk7XG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbGV4aWNhbE5vZGVzID0gbGV4aWNhbE5vZGVzLmNvbmNhdChsZXhpY2FsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICR1bndyYXBBcnRpZmljYWxOb2RlcyhhbGxBcnRpZmljaWFsTm9kZXMpO1xuICByZXR1cm4gbGV4aWNhbE5vZGVzO1xufVxuZnVuY3Rpb24gJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IsIHNlbGVjdGlvbikge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLndpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzIGluIGhlYWRsZXNzIG1vZGUgcGxlYXNlIGluaXRpYWxpemUgYSBoZWFkbGVzcyBicm93c2VyIGltcGxlbWVudGF0aW9uIHN1Y2ggYXMgSlNEb20gYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4nKTtcbiAgfVxuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IHRvcExldmVsQ2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgdG9wTGV2ZWxOb2RlLCBjb250YWluZXIsIHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5mdW5jdGlvbiAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCBjdXJyZW50Tm9kZSwgcGFyZW50RWxlbWVudCwgc2VsZWN0aW9uID0gbnVsbCkge1xuICBsZXQgc2hvdWxkSW5jbHVkZSA9IHNlbGVjdGlvbiAhPT0gbnVsbCA/IGN1cnJlbnROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSA6IHRydWU7XG4gIGNvbnN0IHNob3VsZEV4Y2x1ZGUgPSAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgY3VycmVudE5vZGUuZXhjbHVkZUZyb21Db3B5KCdodG1sJyk7XG4gIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGxldCBjbG9uZSA9ICRjbG9uZVdpdGhQcm9wZXJ0aWVzKGN1cnJlbnROb2RlKTtcbiAgICBjbG9uZSA9ICRpc1RleHROb2RlKGNsb25lKSAmJiBzZWxlY3Rpb24gIT09IG51bGwgPyAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24sIGNsb25lKSA6IGNsb25lO1xuICAgIHRhcmdldCA9IGNsb25lO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gJGlzRWxlbWVudE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRDaGlsZHJlbigpIDogW107XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZWRpdG9yLl9ub2Rlcy5nZXQodGFyZ2V0LmdldFR5cGUoKSk7XG4gIGxldCBleHBvcnRPdXRwdXQ7XG5cbiAgLy8gVXNlIEhUTUxDb25maWcgb3ZlcnJpZGVzLCBpZiBhdmFpbGFibGUuXG4gIGlmIChyZWdpc3RlcmVkTm9kZSAmJiByZWdpc3RlcmVkTm9kZS5leHBvcnRET00gIT09IHVuZGVmaW5lZCkge1xuICAgIGV4cG9ydE91dHB1dCA9IHJlZ2lzdGVyZWROb2RlLmV4cG9ydERPTShlZGl0b3IsIHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0T3V0cHV0ID0gdGFyZ2V0LmV4cG9ydERPTShlZGl0b3IpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50LFxuICAgIGFmdGVyXG4gIH0gPSBleHBvcnRPdXRwdXQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIGNoaWxkTm9kZSwgZnJhZ21lbnQsIHNlbGVjdGlvbik7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiwgJ2h0bWwnKSkge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRJbmNsdWRlICYmICFzaG91bGRFeGNsdWRlKSB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGZyYWdtZW50KTtcbiAgICB9XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgaWYgKGFmdGVyKSB7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gYWZ0ZXIuY2FsbCh0YXJnZXQsIGVsZW1lbnQpO1xuICAgICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChuZXdFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICB9XG4gIHJldHVybiBzaG91bGRJbmNsdWRlO1xufVxuZnVuY3Rpb24gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKGRvbU5vZGUsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9kZU5hbWVcbiAgfSA9IGRvbU5vZGU7XG4gIGNvbnN0IGNhY2hlZENvbnZlcnNpb25zID0gZWRpdG9yLl9odG1sQ29udmVyc2lvbnMuZ2V0KG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICBsZXQgY3VycmVudENvbnZlcnNpb24gPSBudWxsO1xuICBpZiAoY2FjaGVkQ29udmVyc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgY2FjaGVkQ29udmVyc2lvbiBvZiBjYWNoZWRDb252ZXJzaW9ucykge1xuICAgICAgY29uc3QgZG9tQ29udmVyc2lvbiA9IGNhY2hlZENvbnZlcnNpb24oZG9tTm9kZSk7XG4gICAgICBpZiAoZG9tQ29udmVyc2lvbiAhPT0gbnVsbCAmJiAoY3VycmVudENvbnZlcnNpb24gPT09IG51bGwgfHwgKGN1cnJlbnRDb252ZXJzaW9uLnByaW9yaXR5IHx8IDApIDwgKGRvbUNvbnZlcnNpb24ucHJpb3JpdHkgfHwgMCkpKSB7XG4gICAgICAgIGN1cnJlbnRDb252ZXJzaW9uID0gZG9tQ29udmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRDb252ZXJzaW9uICE9PSBudWxsID8gY3VycmVudENvbnZlcnNpb24uY29udmVyc2lvbiA6IG51bGw7XG59XG5jb25zdCBJR05PUkVfVEFHUyA9IG5ldyBTZXQoWydTVFlMRScsICdTQ1JJUFQnXSk7XG5mdW5jdGlvbiAkY3JlYXRlTm9kZXNGcm9tRE9NKG5vZGUsIGVkaXRvciwgYWxsQXJ0aWZpY2lhbE5vZGVzLCBoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGUsIGZvckNoaWxkTWFwID0gbmV3IE1hcCgpLCBwYXJlbnRMZXhpY2FsTm9kZSkge1xuICBsZXQgbGV4aWNhbE5vZGVzID0gW107XG4gIGlmIChJR05PUkVfVEFHUy5oYXMobm9kZS5ub2RlTmFtZSkpIHtcbiAgICByZXR1cm4gbGV4aWNhbE5vZGVzO1xuICB9XG4gIGxldCBjdXJyZW50TGV4aWNhbE5vZGUgPSBudWxsO1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jdGlvbiA9IGdldENvbnZlcnNpb25GdW5jdGlvbihub2RlLCBlZGl0b3IpO1xuICBjb25zdCB0cmFuc2Zvcm1PdXRwdXQgPSB0cmFuc2Zvcm1GdW5jdGlvbiA/IHRyYW5zZm9ybUZ1bmN0aW9uKG5vZGUpIDogbnVsbDtcbiAgbGV0IHBvc3RUcmFuc2Zvcm0gPSBudWxsO1xuICBpZiAodHJhbnNmb3JtT3V0cHV0ICE9PSBudWxsKSB7XG4gICAgcG9zdFRyYW5zZm9ybSA9IHRyYW5zZm9ybU91dHB1dC5hZnRlcjtcbiAgICBjb25zdCB0cmFuc2Zvcm1Ob2RlcyA9IHRyYW5zZm9ybU91dHB1dC5ub2RlO1xuICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IEFycmF5LmlzQXJyYXkodHJhbnNmb3JtTm9kZXMpID8gdHJhbnNmb3JtTm9kZXNbdHJhbnNmb3JtTm9kZXMubGVuZ3RoIC0gMV0gOiB0cmFuc2Zvcm1Ob2RlcztcbiAgICBpZiAoY3VycmVudExleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGZvckNoaWxkRnVuY3Rpb25dIG9mIGZvckNoaWxkTWFwKSB7XG4gICAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IGZvckNoaWxkRnVuY3Rpb24oY3VycmVudExleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSk7XG4gICAgICAgIGlmICghY3VycmVudExleGljYWxOb2RlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgbGV4aWNhbE5vZGVzLnB1c2goLi4uKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtTm9kZXMpID8gdHJhbnNmb3JtTm9kZXMgOiBbY3VycmVudExleGljYWxOb2RlXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtT3V0cHV0LmZvckNoaWxkICE9IG51bGwpIHtcbiAgICAgIGZvckNoaWxkTWFwLnNldChub2RlLm5vZGVOYW1lLCB0cmFuc2Zvcm1PdXRwdXQuZm9yQ2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBET00gbm9kZSBkb2Vzbid0IGhhdmUgYSB0cmFuc2Zvcm1lciwgd2UgZG9uJ3Qga25vdyB3aGF0XG4gIC8vIHRvIGRvIHdpdGggaXQgYnV0IHdlIHN0aWxsIG5lZWQgdG8gcHJvY2VzcyBhbnkgY2hpbGROb2Rlcy5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gIGxldCBjaGlsZExleGljYWxOb2RlcyA9IFtdO1xuICBjb25zdCBoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGVGb3JDaGlsZHJlbiA9IGN1cnJlbnRMZXhpY2FsTm9kZSAhPSBudWxsICYmICRpc1Jvb3RPclNoYWRvd1Jvb3QoY3VycmVudExleGljYWxOb2RlKSA/IGZhbHNlIDogY3VycmVudExleGljYWxOb2RlICE9IG51bGwgJiYgJGlzQmxvY2tFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpIHx8IGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzLnB1c2goLi4uJGNyZWF0ZU5vZGVzRnJvbURPTShjaGlsZHJlbltpXSwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuLCBuZXcgTWFwKGZvckNoaWxkTWFwKSwgY3VycmVudExleGljYWxOb2RlKSk7XG4gIH1cbiAgaWYgKHBvc3RUcmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzID0gcG9zdFRyYW5zZm9ybShjaGlsZExleGljYWxOb2Rlcyk7XG4gIH1cbiAgaWYgKGlzQmxvY2tEb21Ob2RlKG5vZGUpKSB7XG4gICAgaWYgKCFoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGVGb3JDaGlsZHJlbikge1xuICAgICAgY2hpbGRMZXhpY2FsTm9kZXMgPSB3cmFwQ29udGludW91c0lubGluZXMobm9kZSwgY2hpbGRMZXhpY2FsTm9kZXMsICRjcmVhdGVQYXJhZ3JhcGhOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRMZXhpY2FsTm9kZXMgPSB3cmFwQ29udGludW91c0lubGluZXMobm9kZSwgY2hpbGRMZXhpY2FsTm9kZXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgYXJ0aWZpY2lhbE5vZGUgPSBuZXcgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UoKTtcbiAgICAgICAgYWxsQXJ0aWZpY2lhbE5vZGVzLnB1c2goYXJ0aWZpY2lhbE5vZGUpO1xuICAgICAgICByZXR1cm4gYXJ0aWZpY2lhbE5vZGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSA9PSBudWxsKSB7XG4gICAgLy8gSWYgaXQgaGFzbid0IGJlZW4gY29udmVydGVkIHRvIGEgTGV4aWNhbE5vZGUsIHdlIGhvaXN0IGl0cyBjaGlsZHJlblxuICAgIC8vIHVwIHRvIHRoZSBzYW1lIGxldmVsIGFzIGl0LlxuICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQoY2hpbGRMZXhpY2FsTm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgRWxlbWVudE5vZGUgYWZ0ZXIgY29udmVyc2lvbixcbiAgICAgIC8vIHdlIGNhbiBhcHBlbmQgYWxsIHRoZSBjaGlsZHJlbiB0byBpdC5cbiAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZS5hcHBlbmQoLi4uY2hpbGRMZXhpY2FsTm9kZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV4aWNhbE5vZGVzO1xufVxuZnVuY3Rpb24gd3JhcENvbnRpbnVvdXNJbmxpbmVzKGRvbU5vZGUsIG5vZGVzLCBjcmVhdGVXcmFwcGVyRm4pIHtcbiAgY29uc3QgdGV4dEFsaWduID0gZG9tTm9kZS5zdHlsZS50ZXh0QWxpZ247XG4gIGNvbnN0IG91dCA9IFtdO1xuICBsZXQgY29udGludW91c0lubGluZXMgPSBbXTtcbiAgLy8gd3JhcCBjb250aWd1b3VzIGlubGluZSBjaGlsZCBub2RlcyBpbiBwYXJhXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIG5vZGUuc2V0Rm9ybWF0KHRleHRBbGlnbik7XG4gICAgICBvdXQucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludW91c0lubGluZXMucHVzaChub2RlKTtcbiAgICAgIGlmIChpID09PSBub2Rlcy5sZW5ndGggLSAxIHx8IGkgPCBub2Rlcy5sZW5ndGggLSAxICYmICRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZXNbaSArIDFdKSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlV3JhcHBlckZuKCk7XG4gICAgICAgIHdyYXBwZXIuc2V0Rm9ybWF0KHRleHRBbGlnbik7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKC4uLmNvbnRpbnVvdXNJbmxpbmVzKTtcbiAgICAgICAgb3V0LnB1c2god3JhcHBlcik7XG4gICAgICAgIGNvbnRpbnVvdXNJbmxpbmVzID0gW107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiAkdW53cmFwQXJ0aWZpY2FsTm9kZXMoYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBhbGxBcnRpZmljaWFsTm9kZXMpIHtcbiAgICBpZiAobm9kZS5nZXROZXh0U2libGluZygpIGluc3RhbmNlb2YgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UpIHtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgfVxuICB9XG4gIC8vIFJlcGxhY2UgYXJ0aWZpY2lhbCBub2RlIHdpdGggaXQncyBjaGlsZHJlblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgIH1cbiAgICBub2RlLnJlbW92ZSgpO1xuICB9XG59XG5cbmV4cG9ydCB7ICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMsICRnZW5lcmF0ZU5vZGVzRnJvbURPTSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/link/LexicalLink.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createAutoLinkNode: () => (/* binding */ $createAutoLinkNode),\n/* harmony export */   $createLinkNode: () => (/* binding */ $createLinkNode),\n/* harmony export */   $isAutoLinkNode: () => (/* binding */ $isAutoLinkNode),\n/* harmony export */   $isLinkNode: () => (/* binding */ $isLinkNode),\n/* harmony export */   $toggleLink: () => (/* binding */ $toggleLink),\n/* harmony export */   AutoLinkNode: () => (/* binding */ AutoLinkNode),\n/* harmony export */   LinkNode: () => (/* binding */ LinkNode),\n/* harmony export */   TOGGLE_LINK_COMMAND: () => (/* binding */ TOGGLE_LINK_COMMAND),\n/* harmony export */   toggleLink: () => (/* binding */ toggleLink)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    const title = this.__title;\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n    if (title !== prevNode.__title) {\n      if (title) {\n        anchor.title = title;\n      } else {\n        anchor.removeAttribute('title');\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement)(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes { target, rel, title }\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url, attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url, attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('TOGGLE_LINK_COMMAND');\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $getAncestor(firstNode, $isLinkNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target,\n          title\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZFO0FBQ2lEOztBQUU5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixnREFBVztBQUNsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNERBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFhOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakMsT0FBTywwREFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVEQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9KIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saW5rL0xleGljYWxMaW5rLmRldi5tanM/ZmVjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEFuY2hvckVsZW1lbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVDb21tYW5kLCBFbGVtZW50Tm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRhcHBseU5vZGVSZXBsYWNlbWVudCwgJGlzRWxlbWVudE5vZGUsICRnZXRTZWxlY3Rpb24gfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBTVVBQT1JURURfVVJMX1BST1RPQ09MUyA9IG5ldyBTZXQoWydodHRwOicsICdodHRwczonLCAnbWFpbHRvOicsICdzbXM6JywgJ3RlbDonXSk7XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaW5rTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluayc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IExpbmtOb2RlKG5vZGUuX191cmwsIHtcbiAgICAgIHJlbDogbm9kZS5fX3JlbCxcbiAgICAgIHRhcmdldDogbm9kZS5fX3RhcmdldCxcbiAgICAgIHRpdGxlOiBub2RlLl9fdGl0bGVcbiAgICB9LCBub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih1cmwsIGF0dHJpYnV0ZXMgPSB7fSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgcmVsID0gbnVsbCxcbiAgICAgIHRpdGxlID0gbnVsbFxuICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuX191cmwgPSB1cmw7XG4gICAgdGhpcy5fX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9fcmVsID0gcmVsO1xuICAgIHRoaXMuX190aXRsZSA9IHRpdGxlO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGVsZW1lbnQuaHJlZiA9IHRoaXMuc2FuaXRpemVVcmwodGhpcy5fX3VybCk7XG4gICAgaWYgKHRoaXMuX190YXJnZXQgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQudGFyZ2V0ID0gdGhpcy5fX3RhcmdldDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19yZWwgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQucmVsID0gdGhpcy5fX3JlbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX190aXRsZSAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC50aXRsZSA9IHRoaXMuX190aXRsZTtcbiAgICB9XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUubGluayk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBhbmNob3IsIGNvbmZpZykge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuX191cmw7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fX3RhcmdldDtcbiAgICBjb25zdCByZWwgPSB0aGlzLl9fcmVsO1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fX3RpdGxlO1xuICAgIGlmICh1cmwgIT09IHByZXZOb2RlLl9fdXJsKSB7XG4gICAgICBhbmNob3IuaHJlZiA9IHVybDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCAhPT0gcHJldk5vZGUuX190YXJnZXQpIHtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgYW5jaG9yLnRhcmdldCA9IHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVsICE9PSBwcmV2Tm9kZS5fX3JlbCkge1xuICAgICAgaWYgKHJlbCkge1xuICAgICAgICBhbmNob3IucmVsID0gcmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgncmVsJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aXRsZSAhPT0gcHJldk5vZGUuX190aXRsZSkge1xuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGFuY2hvci50aXRsZSA9IHRpdGxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRBbmNob3JFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVMaW5rTm9kZShzZXJpYWxpemVkTm9kZS51cmwsIHtcbiAgICAgIHJlbDogc2VyaWFsaXplZE5vZGUucmVsLFxuICAgICAgdGFyZ2V0OiBzZXJpYWxpemVkTm9kZS50YXJnZXQsXG4gICAgICB0aXRsZTogc2VyaWFsaXplZE5vZGUudGl0bGVcbiAgICB9KTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBzYW5pdGl6ZVVybCh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNjcmlwdC11cmxcbiAgICAgIGlmICghU1VQUE9SVEVEX1VSTF9QUk9UT0NPTFMuaGFzKHBhcnNlZFVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgcmV0dXJuICdhYm91dDpibGFuayc7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICByZWw6IHRoaXMuZ2V0UmVsKCksXG4gICAgICB0YXJnZXQ6IHRoaXMuZ2V0VGFyZ2V0KCksXG4gICAgICB0aXRsZTogdGhpcy5nZXRUaXRsZSgpLFxuICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgdXJsOiB0aGlzLmdldFVSTCgpLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgZ2V0VVJMKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdXJsO1xuICB9XG4gIHNldFVSTCh1cmwpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3VybCA9IHVybDtcbiAgfVxuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190YXJnZXQ7XG4gIH1cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG4gIGdldFJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3JlbDtcbiAgfVxuICBzZXRSZWwocmVsKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19yZWwgPSByZWw7XG4gIH1cbiAgZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190aXRsZTtcbiAgfVxuICBzZXRUaXRsZSh0aXRsZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdGl0bGUgPSB0aXRsZTtcbiAgfVxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlKHRoaXMuX191cmwsIHtcbiAgICAgIHJlbDogdGhpcy5fX3JlbCxcbiAgICAgIHRhcmdldDogdGhpcy5fX3RhcmdldCxcbiAgICAgIHRpdGxlOiB0aGlzLl9fdGl0bGVcbiAgICB9KTtcbiAgICB0aGlzLmluc2VydEFmdGVyKGxpbmtOb2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbGlua05vZGU7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCkubGVuZ3RoID4gMDtcbiAgfVxufVxuZnVuY3Rpb24gJGNvbnZlcnRBbmNob3JFbGVtZW50KGRvbU5vZGUpIHtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBkb21Ob2RlLnRleHRDb250ZW50O1xuICAgIGlmIChjb250ZW50ICE9PSBudWxsICYmIGNvbnRlbnQgIT09ICcnIHx8IGRvbU5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaW5rTm9kZShkb21Ob2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnLCB7XG4gICAgICAgIHJlbDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3JlbCcpLFxuICAgICAgICB0YXJnZXQ6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSxcbiAgICAgICAgdGl0bGU6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0aXRsZScpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBub2RlXG4gIH07XG59XG5cbi8qKlxuICogVGFrZXMgYSBVUkwgYW5kIGNyZWF0ZXMgYSBMaW5rTm9kZS5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRoZSBMaW5rTm9kZSBzaG91bGQgZGlyZWN0IHRvLlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBPcHRpb25hbCBIVE1MIGEgdGFnIGF0dHJpYnV0ZXMgeyB0YXJnZXQsIHJlbCwgdGl0bGUgfVxuICogQHJldHVybnMgVGhlIExpbmtOb2RlLlxuICovXG5mdW5jdGlvbiAkY3JlYXRlTGlua05vZGUodXJsLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmtOb2RlKHVybCwgYXR0cmlidXRlcykpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbm9kZSBpcyBhIExpbmtOb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGEgTGlua05vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlua05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpbmtOb2RlO1xufVxuLy8gQ3VzdG9tIG5vZGUgdHlwZSB0byBvdmVycmlkZSBgY2FuSW5zZXJ0VGV4dEFmdGVyYCB0aGF0IHdpbGxcbi8vIGFsbG93IHR5cGluZyB3aXRoaW4gdGhlIGxpbmtcbmNsYXNzIEF1dG9MaW5rTm9kZSBleHRlbmRzIExpbmtOb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdhdXRvbGluayc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IEF1dG9MaW5rTm9kZShub2RlLl9fdXJsLCB7XG4gICAgICByZWw6IG5vZGUuX19yZWwsXG4gICAgICB0YXJnZXQ6IG5vZGUuX190YXJnZXQsXG4gICAgICB0aXRsZTogbm9kZS5fX3RpdGxlXG4gICAgfSwgbm9kZS5fX2tleSk7XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUF1dG9MaW5rTm9kZShzZXJpYWxpemVkTm9kZS51cmwsIHtcbiAgICAgIHJlbDogc2VyaWFsaXplZE5vZGUucmVsLFxuICAgICAgdGFyZ2V0OiBzZXJpYWxpemVkTm9kZS50YXJnZXQsXG4gICAgICB0aXRsZTogc2VyaWFsaXplZE5vZGUudGl0bGVcbiAgICB9KTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIC8vIFRPRE86IFNob3VsZCBsaW5rIG5vZGUgc2hvdWxkIGhhbmRsZSB0aGUgaW1wb3J0IG92ZXIgYXV0b2xpbms/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ2F1dG9saW5rJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUF1dG9MaW5rTm9kZSh0aGlzLl9fdXJsLCB7XG4gICAgICAgIHJlbDogdGhpcy5fX3JlbCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl9fdGFyZ2V0LFxuICAgICAgICB0aXRsZTogdGhpcy5fX3RpdGxlXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGxpbmtOb2RlKTtcbiAgICAgIHJldHVybiBsaW5rTm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhIFVSTCBhbmQgY3JlYXRlcyBhbiBBdXRvTGlua05vZGUuIEF1dG9MaW5rTm9kZXMgYXJlIGdlbmVyYWxseSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZFxuICogZHVyaW5nIHR5cGluZywgd2hpY2ggaXMgZXNwZWNpYWxseSB1c2VmdWwgd2hlbiBhIGJ1dHRvbiB0byBnZW5lcmF0ZSBhIExpbmtOb2RlIGlzIG5vdCBwcmFjdGljYWwuXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0aGUgTGlua05vZGUgc2hvdWxkIGRpcmVjdCB0by5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgSFRNTCBhIHRhZyBhdHRyaWJ1dGVzLiB7IHRhcmdldCwgcmVsLCB0aXRsZSB9XG4gKiBAcmV0dXJucyBUaGUgTGlua05vZGUuXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVBdXRvTGlua05vZGUodXJsLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEF1dG9MaW5rTm9kZSh1cmwsIGF0dHJpYnV0ZXMpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG5vZGUgaXMgYW4gQXV0b0xpbmtOb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGFuIEF1dG9MaW5rTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNBdXRvTGlua05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEF1dG9MaW5rTm9kZTtcbn1cbmNvbnN0IFRPR0dMRV9MSU5LX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdUT0dHTEVfTElOS19DT01NQU5EJyk7XG5cbi8qKlxuICogR2VuZXJhdGVzIG9yIHVwZGF0ZXMgYSBMaW5rTm9kZS4gSXQgY2FuIGFsc28gZGVsZXRlIGEgTGlua05vZGUgaWYgdGhlIFVSTCBpcyBudWxsLFxuICogYnV0IHNhdmVzIGFueSBjaGlsZHJlbiBhbmQgYnJpbmdzIHRoZW0gdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIGxpbmsgZGlyZWN0cyB0by5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgSFRNTCBhIHRhZyBhdHRyaWJ1dGVzLiB7IHRhcmdldCwgcmVsLCB0aXRsZSB9XG4gKi9cbmZ1bmN0aW9uICR0b2dnbGVMaW5rKHVybCwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXQsXG4gICAgdGl0bGVcbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IHJlbCA9IGF0dHJpYnV0ZXMucmVsID09PSB1bmRlZmluZWQgPyAnbm9yZWZlcnJlcicgOiBhdHRyaWJ1dGVzLnJlbDtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZXh0cmFjdCgpO1xuICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgLy8gUmVtb3ZlIExpbmtOb2Rlc1xuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc0xpbmtOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgb3IgbWVyZ2UgTGlua05vZGVzXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gICAgICAvLyBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBhIExpbmtOb2RlIG9yIGlmIGl0c1xuICAgICAgLy8gcGFyZW50IGlzIGEgTGlua05vZGUsIHdlIHVwZGF0ZSB0aGUgVVJMLCB0YXJnZXQgYW5kIHJlbC5cbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGdldEFuY2VzdG9yKGZpcnN0Tm9kZSwgJGlzTGlua05vZGUpO1xuICAgICAgaWYgKGxpbmtOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGxpbmtOb2RlLnNldFVSTCh1cmwpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgbGlua05vZGUuc2V0UmVsKHJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJldlBhcmVudCA9IG51bGw7XG4gICAgbGV0IGxpbmtOb2RlID0gbnVsbDtcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmIChwYXJlbnQgPT09IGxpbmtOb2RlIHx8IHBhcmVudCA9PT0gbnVsbCB8fCAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNMaW5rTm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGxpbmtOb2RlID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQuc2V0VVJMKHVybCk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudC5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgbGlua05vZGUuc2V0UmVsKHJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJlbnQuaXMocHJldlBhcmVudCkpIHtcbiAgICAgICAgcHJldlBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodXJsLCB7XG4gICAgICAgICAgcmVsLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICB0aXRsZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCRpc0xpbmtOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICBpZiAobm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShsaW5rTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRBZnRlcihsaW5rTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGxpbmtOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmlzKGxpbmtOb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlua05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaW5rTm9kZS5hcHBlbmQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobGlua05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbGlua05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vKiogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJHRvZ2dsZUxpbmt9IGJ5IEBsZXhpY2FsL2VzbGludC1wbHVnaW4gcnVsZXMtb2YtbGV4aWNhbCAqL1xuY29uc3QgdG9nZ2xlTGluayA9ICR0b2dnbGVMaW5rO1xuZnVuY3Rpb24gJGdldEFuY2VzdG9yKG5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZ2V0UGFyZW50KCkgIT09IG51bGwgJiYgIXByZWRpY2F0ZShwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcHJlZGljYXRlKHBhcmVudCkgPyBwYXJlbnQgOiBudWxsO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlQXV0b0xpbmtOb2RlLCAkY3JlYXRlTGlua05vZGUsICRpc0F1dG9MaW5rTm9kZSwgJGlzTGlua05vZGUsICR0b2dnbGVMaW5rLCBBdXRvTGlua05vZGUsIExpbmtOb2RlLCBUT0dHTEVfTElOS19DT01NQU5ELCB0b2dnbGVMaW5rIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/link/LexicalLink.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/list/LexicalList.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createListItemNode: () => (/* binding */ $createListItemNode),\n/* harmony export */   $createListNode: () => (/* binding */ $createListNode),\n/* harmony export */   $getListDepth: () => (/* binding */ $getListDepth),\n/* harmony export */   $handleListInsertParagraph: () => (/* binding */ $handleListInsertParagraph),\n/* harmony export */   $isListItemNode: () => (/* binding */ $isListItemNode),\n/* harmony export */   $isListNode: () => (/* binding */ $isListNode),\n/* harmony export */   INSERT_CHECK_LIST_COMMAND: () => (/* binding */ INSERT_CHECK_LIST_COMMAND),\n/* harmony export */   INSERT_ORDERED_LIST_COMMAND: () => (/* binding */ INSERT_ORDERED_LIST_COMMAND),\n/* harmony export */   INSERT_UNORDERED_LIST_COMMAND: () => (/* binding */ INSERT_UNORDERED_LIST_COMMAND),\n/* harmony export */   ListItemNode: () => (/* binding */ ListItemNode),\n/* harmony export */   ListNode: () => (/* binding */ ListNode),\n/* harmony export */   REMOVE_LIST_COMMAND: () => (/* binding */ REMOVE_LIST_COMMAND),\n/* harmony export */   insertList: () => (/* binding */ insertList),\n/* harmony export */   removeList: () => (/* binding */ removeList)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n            const listItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestNodeOfType)(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getChecked() != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandparent)) {\n    replacementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('REMOVE_LIST_COMMAND');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeU47QUFDOUY7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0E7QUFDQSxVQUFVLDBEQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFtQjtBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EsWUFBWSx1REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0IsNERBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLGNBQWMsb0RBQVc7QUFDekIsaUNBQWlDLHFFQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBb0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5REFBZ0I7QUFDM0I7QUFDQTtBQUNBLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnREFBVztBQUNsQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLHNEQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLHVEQUFjO0FBQ2pDLDJCQUEyQix3REFBZTtBQUMxQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxzREFBYTtBQUNuRCxvQ0FBb0Msc0RBQWE7QUFDakQsa0NBQWtDLHNEQUFhO0FBQy9DLDRCQUE0QixzREFBYTs7QUFFNE8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcz82OTA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRpc0VsZW1lbnROb2RlLCAkaXNMZWFmTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRpc1BhcmFncmFwaE5vZGUsIEVsZW1lbnROb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsICRjcmVhdGVUZXh0Tm9kZSwgY3JlYXRlQ29tbWFuZCB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIENoZWNrcyB0aGUgZGVwdGggb2YgbGlzdE5vZGUgZnJvbSB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGxpc3ROb2RlIC0gVGhlIExpc3ROb2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUaGUgZGVwdGggb2YgdGhlIExpc3ROb2RlLlxuICovXG5mdW5jdGlvbiAkZ2V0TGlzdERlcHRoKGxpc3ROb2RlKSB7XG4gIGxldCBkZXB0aCA9IDE7XG4gIGxldCBwYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnQoKTtcbiAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBwYXJlbnRMaXN0ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudExpc3QpKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudExpc3QuZ2V0UGFyZW50KCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmV0dXJucyBpdCwgdGhyb3dzIGFuIGludmFyaWFudCBpZiBsaXN0SXRlbSBpcyBub3QgYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW0gLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIExpc3ROb2RlIGZvdW5kLlxuICovXG5mdW5jdGlvbiAkZ2V0VG9wTGlzdE5vZGUobGlzdEl0ZW0pIHtcbiAgbGV0IGxpc3QgPSBsaXN0SXRlbS5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gICAgfVxuICB9XG4gIGxldCBwYXJlbnQgPSBsaXN0O1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBsaXN0ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBEZXB0aC1GaXJzdCBTZWFyY2ggKFBvc3RvcmRlciBUcmF2ZXJzYWwpIHRoYXQgZmluZHMgYWxsIG9mIGEgbm9kZSdzIGNoaWxkcmVuXG4gKiB0aGF0IGFyZSBvZiB0eXBlIExpc3RJdGVtTm9kZSBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5LlxuICogQHBhcmFtIG5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIG9mIHR5cGUgTGlzdEl0ZW1Ob2RlIGZvdW5kLlxuICovXG4vLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSAkZ2V0QWxsQ2hpbGRyZW5PZlR5cGVcbmZ1bmN0aW9uICRnZXRBbGxMaXN0SXRlbXMobm9kZSkge1xuICBsZXQgbGlzdEl0ZW1Ob2RlcyA9IFtdO1xuICBjb25zdCBsaXN0Q2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCkuZmlsdGVyKCRpc0xpc3RJdGVtTm9kZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gbGlzdENoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgbGlzdEl0ZW1Ob2RlcyA9IGxpc3RJdGVtTm9kZXMuY29uY2F0KCRnZXRBbGxMaXN0SXRlbXMoZmlyc3RDaGlsZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0SXRlbU5vZGVzLnB1c2gobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3RJdGVtTm9kZXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcGFzc2VkIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUgYW5kIGhhcyBhIExpc3ROb2RlIGFzIGEgY2hpbGQuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBjaGlsZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc05lc3RlZExpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAkaXNMaXN0Tm9kZShub2RlLmdldEZpcnN0Q2hpbGQoKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBkZWVwbHkgbmVzdGVkIExpc3ROb2RlIG9yIExpc3RJdGVtTm9kZSBhbmQgdHJhdmVyc2VzIHVwIHRoZSBicmFuY2ggdG8gZGVsZXRlIHRoZSBmaXJzdFxuICogYW5jZXN0cmFsIExpc3ROb2RlICh3aGljaCBjb3VsZCBiZSB0aGUgcm9vdCBMaXN0Tm9kZSkgb3IgTGlzdEl0ZW1Ob2RlIHdpdGggc2libGluZ3MsIGVzc2VudGlhbGx5XG4gKiBicmluZ2luZyB0aGUgZGVlcGx5IG5lc3RlZCBub2RlIHVwIHRoZSBicmFuY2ggb25jZS4gV291bGQgcmVtb3ZlIHN1Ymxpc3QgaWYgaXQgaGFzIHNpYmxpbmdzLlxuICogU2hvdWxkIG5vdCBicmVhayBMaXN0SXRlbSAtPiBMaXN0IC0+IExpc3RJdGVtIGNoYWluIGFzIGVtcHR5IExpc3QvSXRlbU5vZGVzIHNob3VsZCBiZSByZW1vdmVkIG9uIC5yZW1vdmUoKS5cbiAqIEBwYXJhbSBzdWJsaXN0IC0gVGhlIG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgdG8gYmUgYnJvdWdodCB1cCB0aGUgYnJhbmNoLlxuICovXG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGVzdEVtcHR5TGlzdFBhcmVudChzdWJsaXN0KSB7XG4gIC8vIE5vZGVzIG1heSBiZSByZXBlYXRlZGx5IGluZGVudGVkLCB0byBjcmVhdGUgZGVlcGx5IG5lc3RlZCBsaXN0cyB0aGF0IGVhY2hcbiAgLy8gY29udGFpbiBqdXN0IG9uZSBidWxsZXQuXG4gIC8vIE91ciBnb2FsIGlzIHRvIHJlbW92ZSB0aGVzZSAoZW1wdHkpIGRlZXBseSBuZXN0ZWQgbGlzdHMuIFRoZSBlYXNpZXN0XG4gIC8vIHdheSB0byBkbyB0aGF0IGlzIGNyYXdsIGJhY2sgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIG5vZGUgdGhhdCBoYXMgc2libGluZ3NcbiAgLy8gKGUuZy4gaXMgYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBjb250ZW50cykgYW5kIGRlbGV0ZSB0aGF0LCBvciBkZWxldGVcbiAgLy8gdGhlIHJvb3Qgb2YgdGhlIGxpc3QgKGlmIG5vIGxpc3Qgbm9kZXMgaGF2ZSBzaWJsaW5ncy4pXG4gIGxldCBlbXB0eUxpc3RQdHIgPSBzdWJsaXN0O1xuICB3aGlsZSAoZW1wdHlMaXN0UHRyLmdldE5leHRTaWJsaW5nKCkgPT0gbnVsbCAmJiBlbXB0eUxpc3RQdHIuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGVtcHR5TGlzdFB0ci5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09IG51bGwgfHwgISgkaXNMaXN0SXRlbU5vZGUoZW1wdHlMaXN0UHRyKSB8fCAkaXNMaXN0Tm9kZShlbXB0eUxpc3RQdHIpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVtcHR5TGlzdFB0ciA9IHBhcmVudDtcbiAgfVxuICBlbXB0eUxpc3RQdHIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogV3JhcHMgYSBub2RlIGludG8gYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIHdyYXBwZWQgaW50byBhIExpc3RJdGVtTm9kZVxuICogQHJldHVybnMgVGhlIExpc3RJdGVtTm9kZSB3aGljaCB0aGUgcGFzc2VkIG5vZGUgaXMgd3JhcHBlZCBpbi5cbiAqL1xuZnVuY3Rpb24gJHdyYXBJbkxpc3RJdGVtKG5vZGUpIHtcbiAgY29uc3QgbGlzdEl0ZW1XcmFwcGVyID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICByZXR1cm4gbGlzdEl0ZW1XcmFwcGVyLmFwcGVuZChub2RlKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSB7XG4gIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkgJiYgKG5vZGVzLmxlbmd0aCA9PT0gMCB8fCBub2Rlcy5sZW5ndGggPT09IDEgJiYgYW5jaG9yTm9kZS5pcyhub2Rlc1swXSkgJiYgYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCk7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBMaXN0Tm9kZS4gSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZSBhbmQgaXMgYSBjaGlsZCBvZlxuICogdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgcmVwbGFjZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpdGggYSBMaXN0Tm9kZSBhbmQgdGhlIG9sZCBMaXN0SXRlbU5vZGUuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCByZXBsYWNlIGl0cyBwYXJlbnQgd2l0aCBhIG5ldyBMaXN0Tm9kZSBhbmQgcmUtaW5zZXJ0IHRoZSBMaXN0SXRlbU5vZGUgYW5kIGFueSBwcmV2aW91cyBjaGlsZHJlbi5cbiAqIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBub3QgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlLCBpdCB3aWxsIGFkZCBhIG5ldyBMaXN0Tm9kZSBvciBtZXJnZSBhbiBleGlzdGluZyBMaXN0Tm9kZSxcbiAqIHVubGVzcyB0aGUgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBMaXN0Tm9kZSB1cCB0aGUgYnJhbmNoIGFuZCByZXBsYWNlIGl0IHdpdGhcbiAqIGEgbmV3IExpc3ROb2RlLCBvciBjcmVhdGUgYSBuZXcgTGlzdE5vZGUgYXQgdGhlIG5lYXJlc3Qgcm9vdC9zaGFkb3cgcm9vdC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0LCBcIm51bWJlclwiIHwgXCJidWxsZXRcIiB8IFwiY2hlY2tcIi5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0TGlzdChlZGl0b3IsIGxpc3RUeXBlKSB7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgICAgICAgaWYgKCEoYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGluc2VydExpc3Q6IGFuY2hvciBzaG91bGQgYmUgZGVmaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthbmNob3JdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpKSB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZVBhcmVudCkpIHtcbiAgICAgICAgICAgIGFuY2hvck5vZGUucmVwbGFjZShsaXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgIGxpc3RJdGVtLnNldEZvcm1hdChhbmNob3JOb2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgICAgICAgIGxpc3RJdGVtLnNldEluZGVudChhbmNob3JOb2RlLmdldEluZGVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgICBhcHBlbmQobGlzdCwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2UobGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaGFuZGxlZCA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgJiYgISRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAhaGFuZGxlZC5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAkY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNMZWFmTm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgICAgICAgICAgIGFwcGVuZChuZXdMaXN0Tm9kZSwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlKG5ld0xpc3ROb2RlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QobmV4dFBhcmVudCkgJiYgIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgICAgICRjcmVhdGVMaXN0T3JNZXJnZShwYXJlbnQsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnQgPSBuZXh0UGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhcHBlbmQobm9kZSwgbm9kZXNUb0FwcGVuZCkge1xuICBub2RlLnNwbGljZShub2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBub2Rlc1RvQXBwZW5kKTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVMaXN0T3JNZXJnZShub2RlLCBsaXN0VHlwZSkge1xuICBpZiAoJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gIGxpc3RJdGVtLnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gIGxpc3RJdGVtLnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgYXBwZW5kKGxpc3RJdGVtLCBub2RlLmdldENoaWxkcmVuKCkpO1xuICBpZiAoJGlzTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gcHJldmlvdXNTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBwcmV2aW91c1NpYmxpbmcuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIC8vIGlmIHRoZSBzYW1lIHR5cGUgb2YgbGlzdCBpcyBvbiBib3RoIHNpZGVzLCBtZXJnZSB0aGVtLlxuXG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgICAgYXBwZW5kKHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzU2libGluZztcbiAgfSBlbHNlIGlmICgkaXNMaXN0Tm9kZShuZXh0U2libGluZykgJiYgbGlzdFR5cGUgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmluc2VydEJlZm9yZShsaXN0SXRlbSk7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dFNpYmxpbmc7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgIG5vZGUucmVwbGFjZShsaXN0KTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxufVxuXG4vKipcbiAqIEEgcmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgZ29lcyB0aHJvdWdoIGVhY2ggbGlzdCBhbmQgdGhlaXIgY2hpbGRyZW4sIGluY2x1ZGluZyBuZXN0ZWQgbGlzdHMsXG4gKiBhcHBlbmRpbmcgbGlzdDIgY2hpbGRyZW4gYWZ0ZXIgbGlzdDEgY2hpbGRyZW4gYW5kIHVwZGF0aW5nIExpc3RJdGVtTm9kZSB2YWx1ZXMuXG4gKiBAcGFyYW0gbGlzdDEgLSBUaGUgZmlyc3QgbGlzdCB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0gbGlzdDIgLSBUaGUgc2Vjb25kIGxpc3QgdG8gYmUgbWVyZ2VkLlxuICovXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBjb25zdCBsaXN0SXRlbTEgPSBsaXN0MS5nZXRMYXN0Q2hpbGQoKTtcbiAgY29uc3QgbGlzdEl0ZW0yID0gbGlzdDIuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAobGlzdEl0ZW0xICYmIGxpc3RJdGVtMiAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMSkgJiYgaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbTIpKSB7XG4gICAgbWVyZ2VMaXN0cyhsaXN0SXRlbTEuZ2V0Rmlyc3RDaGlsZCgpLCBsaXN0SXRlbTIuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICBsaXN0SXRlbTIucmVtb3ZlKCk7XG4gIH1cbiAgY29uc3QgdG9NZXJnZSA9IGxpc3QyLmdldENoaWxkcmVuKCk7XG4gIGlmICh0b01lcmdlLmxlbmd0aCA+IDApIHtcbiAgICBsaXN0MS5hcHBlbmQoLi4udG9NZXJnZSk7XG4gIH1cbiAgbGlzdDIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmVtb3ZlcyBpdC4gSWYgc2VsZWN0aW9uIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZVxuICogaXQgd2lsbCByZW1vdmUgdGhlIHdob2xlIGxpc3QsIGluY2x1ZGluZyB0aGUgTGlzdEl0ZW1Ob2RlLiBGb3IgZWFjaCBMaXN0SXRlbU5vZGUgaW4gdGhlIExpc3ROb2RlLFxuICogcmVtb3ZlTGlzdCB3aWxsIGFsc28gZ2VuZXJhdGUgbmV3IFBhcmFncmFwaE5vZGVzIGluIHRoZSByZW1vdmVkIExpc3ROb2RlJ3MgcGxhY2UuIEFueSBjaGlsZCBub2RlXG4gKiBpbnNpZGUgYSBMaXN0SXRlbU5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgbmV3IFBhcmFncmFwaE5vZGVzLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdChlZGl0b3IpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsaXN0Tm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKCRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpKSB7XG4gICAgICAgIGxpc3ROb2Rlcy5hZGQoJGdldFRvcExpc3ROb2RlKGFuY2hvck5vZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKCRpc0xlYWZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUobm9kZSwgTGlzdEl0ZW1Ob2RlKTtcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBsaXN0Tm9kZXMuYWRkKCRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbU5vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbGlzdE5vZGUgb2YgbGlzdE5vZGVzKSB7XG4gICAgICAgIGxldCBpbnNlcnRpb25Qb2ludCA9IGxpc3ROb2RlO1xuICAgICAgICBjb25zdCBsaXN0SXRlbXMgPSAkZ2V0QWxsTGlzdEl0ZW1zKGxpc3ROb2RlKTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgbGlzdEl0ZW1zKSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICBhcHBlbmQocGFyYWdyYXBoLCBsaXN0SXRlbU5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoKTtcbiAgICAgICAgICBpbnNlcnRpb25Qb2ludCA9IHBhcmFncmFwaDtcblxuICAgICAgICAgIC8vIFdoZW4gdGhlIGFuY2hvciBhbmQgZm9jdXMgZmFsbCBvbiB0aGUgdGV4dE5vZGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgdGhlIHRleHROb2RlIHdpbGwgYmUgYXBwZW5kZWQgdG9cbiAgICAgICAgICAvLyB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaC5cbiAgICAgICAgICAvLyBXaGVuIHNlbGVjdGlvbiBpcyBpbiBlbXB0eSBuZXN0ZWQgbGlzdCBpdGVtLCBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgb24gdGhlIGxpc3RJdGVtTm9kZS5cbiAgICAgICAgICAvLyBXaGVuIHRoZSBjb3JyZXNwb25kaW5nIGxpc3RJdGVtTm9kZSBpcyBkZWxldGVkIGFuZCByZXBsYWNlZCBieSB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaFxuICAgICAgICAgIC8vIHdlIHNob3VsZCBtYW51YWxseSBzZXQgdGhlIHNlbGVjdGlvbidzIGZvY3VzIGFuZCBhbmNob3IgdG8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KHBhcmFncmFwaC5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldChwYXJhZ3JhcGguZ2V0S2V5KCksIDAsICdlbGVtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3RJdGVtTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSB2YWx1ZSBvZiBhIGNoaWxkIExpc3RJdGVtTm9kZSBhbmQgbWFrZXMgaXQgdGhlIHZhbHVlIHRoZSBMaXN0SXRlbU5vZGVcbiAqIHNob3VsZCBiZSBpZiBpdCBpc24ndCBhbHJlYWR5LiBBbHNvIGVuc3VyZXMgdGhhdCBjaGVja2VkIGlzIHVuZGVmaW5lZCBpZiB0aGVcbiAqIHBhcmVudCBkb2VzIG5vdCBoYXZlIGEgbGlzdCB0eXBlIG9mICdjaGVjaycuXG4gKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IHdob3NlIGNoaWxkcmVuIGFyZSB1cGRhdGVkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdCkge1xuICBjb25zdCBpc05vdENoZWNrbGlzdCA9IGxpc3QuZ2V0TGlzdFR5cGUoKSAhPT0gJ2NoZWNrJztcbiAgbGV0IHZhbHVlID0gbGlzdC5nZXRTdGFydCgpO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpc3QuZ2V0Q2hpbGRyZW4oKSkge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQuZ2V0VmFsdWUoKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY2hpbGQuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTm90Q2hlY2tsaXN0ICYmIGNoaWxkLmdldENoZWNrZWQoKSAhPSBudWxsKSB7XG4gICAgICAgIGNoaWxkLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGlmICghJGlzTGlzdE5vZGUoY2hpbGQuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgICAgICB2YWx1ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHRoZSBuZXh0IHNpYmxpbmcgbGlzdCBpZiBzYW1lIHR5cGUuXG4gKiA8dWw+IHdpbGwgbWVyZ2Ugd2l0aCA8dWw+LCBidXQgTk9UIDx1bD4gd2l0aCA8b2w+LlxuICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCB3aG9zZSBuZXh0IHNpYmxpbmcgc2hvdWxkIGJlIHBvdGVudGlhbGx5IG1lcmdlZFxuICovXG5mdW5jdGlvbiBtZXJnZU5leHRTaWJsaW5nTGlzdElmU2FtZVR5cGUobGlzdCkge1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3QuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0LmdldExpc3RUeXBlKCkgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBtZXJnZUxpc3RzKGxpc3QsIG5leHRTaWJsaW5nKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZW1wdHkgTGlzdE5vZGUvTGlzdEl0ZW1Ob2RlIGNoYWluIGF0IGxpc3RJdGVtTm9kZSwgc28gYXMgdG9cbiAqIGNyZWF0ZSBhbiBpbmRlbnQgZWZmZWN0LiBXb24ndCBpbmRlbnQgTGlzdEl0ZW1Ob2RlcyB0aGF0IGhhdmUgYSBMaXN0Tm9kZSBhc1xuICogYSBjaGlsZCwgYnV0IGRvZXMgbWVyZ2Ugc2libGluZyBMaXN0SXRlbU5vZGVzIGlmIG9uZSBoYXMgYSBuZXN0ZWQgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW1Ob2RlIC0gVGhlIExpc3RJdGVtTm9kZSB0byBiZSBpbmRlbnRlZC5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZUluZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuICBjb25zdCByZW1vdmVkID0gbmV3IFNldCgpO1xuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpIHx8IHJlbW92ZWQuaGFzKGxpc3RJdGVtTm9kZS5nZXRLZXkoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuXG4gIC8vIFdlIGNhbiBjYXN0IGJvdGggb2YgdGhlIGJlbG93IGBpc05lc3RlZExpc3ROb2RlYCBvbmx5IHJldHVybnMgYSBib29sZWFuIHR5cGUgaW5zdGVhZCBvZiBhIHVzZXItZGVmaW5lZCB0eXBlIGd1YXJkc1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIC8vIGlmIHRoZXJlIGFyZSBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUsIG1lcmdlIHRoZW0gYWxsIHRvZ2V0aGVyLlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBpbm5lckxpc3QuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgICBjb25zdCBuZXh0SW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKG5leHRJbm5lckxpc3QpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbmV4dElubmVyTGlzdC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBhcHBlbmQoaW5uZXJMaXN0LCBjaGlsZHJlbik7XG4gICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgICByZW1vdmVkLmFkZChuZXh0U2libGluZy5nZXRLZXkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgLy8gaWYgdGhlIExpc3RJdGVtTm9kZSBpcyBuZXh0IHRvIGEgbmVzdGVkIExpc3ROb2RlLCBtZXJnZSB0aGVtXG4gICAgY29uc3QgaW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gaW5uZXJMaXN0LmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBuZXN0ZWQgTGlzdE5vZGVcblxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nLmluc2VydEFmdGVyKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QmVmb3JlKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmQobmV3TGlzdEl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYW4gaW5kZW50IGJ5IHJlbW92aW5nIGFuIGVtcHR5IExpc3ROb2RlL0xpc3RJdGVtTm9kZSBjaGFpbi4gQW4gaW5kZW50ZWQgTGlzdEl0ZW1Ob2RlXG4gKiBoYXMgYSBncmVhdCBncmFuZHBhcmVudCBub2RlIG9mIHR5cGUgTGlzdE5vZGUsIHdoaWNoIGlzIHdoZXJlIHRoZSBMaXN0SXRlbU5vZGUgd2lsbCByZXNpZGVcbiAqIHdpdGhpbiBhcyBhIGNoaWxkLlxuICogQHBhcmFtIGxpc3RJdGVtTm9kZSAtIFRoZSBMaXN0SXRlbU5vZGUgdG8gcmVtb3ZlIHRoZSBpbmRlbnQgKG91dGRlbnQpLlxuICovXG5mdW5jdGlvbiAkaGFuZGxlT3V0ZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50TGlzdCA9IGxpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcbiAgY29uc3QgZ3JhbmRwYXJlbnRMaXN0SXRlbSA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBncmVhdEdyYW5kcGFyZW50TGlzdCA9IGdyYW5kcGFyZW50TGlzdEl0ZW0gPyBncmFuZHBhcmVudExpc3RJdGVtLmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICAvLyBJZiBpdCBkb2Vzbid0IGhhdmUgdGhlc2UgYW5jZXN0b3JzLCBpdCdzIG5vdCBpbmRlbnRlZC5cblxuICBpZiAoJGlzTGlzdE5vZGUoZ3JlYXRHcmFuZHBhcmVudExpc3QpICYmICRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudExpc3RJdGVtKSAmJiAkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGNoaWxkIGluIGl0J3MgcGFyZW50IGxpc3QsIGluc2VydCBpdCBpbnRvIHRoZVxuICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYmVmb3JlIHRoZSBncmFuZHBhcmVudFxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRGaXJzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0TGFzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGxpc3RJdGVtTm9kZS5pcyhmaXJzdENoaWxkKSkge1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgLy8gaWYgaXQncyB0aGUgbGFzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50LlxuICAgIH0gZWxzZSBpZiAobGlzdEl0ZW1Ob2RlLmlzKGxhc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QWZ0ZXIobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gc3BsaXQgdGhlIHNpYmxpbmdzIGludG8gdHdvIG5ldyBuZXN0ZWQgbGlzdHNcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gcGFyZW50TGlzdC5nZXRMaXN0VHlwZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChwcmV2aW91c1NpYmxpbmdzTGlzdCk7XG4gICAgICBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5ncygpLmZvckVhY2goc2libGluZyA9PiBwcmV2aW91c1NpYmxpbmdzTGlzdC5hcHBlbmQoc2libGluZykpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIG5leHRTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChuZXh0U2libGluZ3NMaXN0KTtcbiAgICAgIGFwcGVuZChuZXh0U2libGluZ3NMaXN0LCBsaXN0SXRlbU5vZGUuZ2V0TmV4dFNpYmxpbmdzKCkpO1xuICAgICAgLy8gcHV0IHRoZSBzaWJsaW5nIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZ3JhbmRwYXJlbnQgbGlzdCBpdGVtIGluIHRoZSBncmVhdCBncmFuZHBhcmVudC5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSk7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKG5leHRTaWJsaW5nc0xpc3RJdGVtKTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSAobm93IGJldHdlZW4gdGhlIHNpYmxpbmdzKSB3aXRoIHRoZSBvdXRkZW50ZWQgbGlzdCBpdGVtLlxuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZXBsYWNlKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGEgUGFyYWdyYXBoTm9kZSBhdCBzZWxlY3Rpb24gYW5kIHNlbGVjdHMgdGhlIG5ldyBub2RlLiBUaGUgc2VsZWN0aW9uIG11c3QgY29udGFpbiBhIExpc3RJdGVtTm9kZVxuICogb3IgYSBub2RlIHRoYXQgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIHRleHQuIElmIGl0cyBncmFuZHBhcmVudCBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCBnZXQgdGhlIExpc3ROb2RlXG4gKiAod2hpY2ggc2hvdWxkIGJlIHRoZSBwYXJlbnQgbm9kZSkgYW5kIGluc2VydCB0aGUgUGFyYWdyYXBoTm9kZSBhcyBhIHNpYmxpbmcgdG8gdGhlIExpc3ROb2RlLiBJZiB0aGUgTGlzdE5vZGUgaXNcbiAqIG5lc3RlZCBpbiBhIExpc3RJdGVtTm9kZSBpbnN0ZWFkLCBpdCB3aWxsIGFkZCB0aGUgUGFyYWdyYXBoTm9kZSBhZnRlciB0aGUgZ3JhbmRwYXJlbnQgTGlzdEl0ZW1Ob2RlLlxuICogVGhyb3dzIGFuIGludmFyaWFudCBpZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBhIGNoaWxkIG9mIGEgTGlzdE5vZGUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgUGFyYWdyYXBoTm9kZSB3YXMgaW5zZXJ0ZWQgc3VjY2VzZnVsbHksIGZhbHNlIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvblxuICogb3IgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIGEgTGlzdEl0ZW1Ob2RlIG9yIHRoZSBub2RlIGFscmVhZHkgaG9sZHMgdGV4dC5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPbmx5IHJ1biB0aGlzIGNvZGUgb24gZW1wdHkgbGlzdCBpdGVtc1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCEkaXNMaXN0SXRlbU5vZGUoYW5jaG9yKSB8fCBhbmNob3IuZ2V0Q2hpbGRyZW5TaXplKCkgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9wTGlzdE5vZGUgPSAkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yKTtcbiAgY29uc3QgcGFyZW50ID0gYW5jaG9yLmdldFBhcmVudCgpO1xuICBpZiAoISRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICB9XG4gIGNvbnN0IGdyYW5kcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICBsZXQgcmVwbGFjZW1lbnROb2RlO1xuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZHBhcmVudCkpIHtcbiAgICByZXBsYWNlbWVudE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIHRvcExpc3ROb2RlLmluc2VydEFmdGVyKHJlcGxhY2VtZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICBncmFuZHBhcmVudC5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlbWVudE5vZGUuc2VsZWN0KCk7XG4gIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvci5nZXROZXh0U2libGluZ3MoKTtcbiAgaWYgKG5leHRTaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShwYXJlbnQuZ2V0TGlzdFR5cGUoKSk7XG4gICAgaWYgKCRpc1BhcmFncmFwaE5vZGUocmVwbGFjZW1lbnROb2RlKSkge1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZChuZXdMaXN0KTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgfVxuICAgIG5leHRTaWJsaW5ncy5mb3JFYWNoKHNpYmxpbmcgPT4ge1xuICAgICAgc2libGluZy5yZW1vdmUoKTtcbiAgICAgIG5ld0xpc3QuYXBwZW5kKHNpYmxpbmcpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRG9uJ3QgbGVhdmUgaGFuZ2luZyBuZXN0ZWQgZW1wdHkgbGlzdHNcbiAgJHJlbW92ZUhpZ2hlc3RFbXB0eUxpc3RQYXJlbnQoYW5jaG9yKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaXN0SXRlbU5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaXN0aXRlbSc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IExpc3RJdGVtTm9kZShub2RlLl9fdmFsdWUsIG5vZGUuX19jaGVja2VkLCBub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hlY2tlZCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuICAgIHRoaXMuX19jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJykge1xuICAgICAgdXBkYXRlTGlzdEl0ZW1DaGVja2VkKGVsZW1lbnQsIHRoaXMsIG51bGwpO1xuICAgIH1cbiAgICBlbGVtZW50LnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhlbGVtZW50LCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snKSB7XG4gICAgICB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCB0aGlzLCBwcmV2Tm9kZSk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGFsd2F5cyBIVE1MTGlzdEl0ZW1FbGVtZW50XG4gICAgZG9tLnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgaWYgKCEkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG5vZGUgaXMgbm90IGEgTGlzdEl0ZW1Ob2RlYCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5fX2NoZWNrZWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKHBhcmVudC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snICYmIG5vZGUuZ2V0Q2hlY2tlZCgpICE9IG51bGwpIHtcbiAgICAgICAgICBub2RlLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGk6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICBub2RlLnNldENoZWNrZWQoc2VyaWFsaXplZE5vZGUuY2hlY2tlZCk7XG4gICAgbm9kZS5zZXRWYWx1ZShzZXJpYWxpemVkTm9kZS52YWx1ZSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jcmVhdGVET00oZWRpdG9yLl9jb25maWcpO1xuICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNoZWNrZWQ6IHRoaXMuZ2V0Q2hlY2tlZCgpLFxuICAgICAgdHlwZTogJ2xpc3RpdGVtJyxcbiAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuICBhcHBlbmQoLi4ubm9kZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdGhpcy5jYW5NZXJnZVdpdGgobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZShyZXBsYWNlV2l0aE5vZGUsIGluY2x1ZGVDaGlsZHJlbikge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbmRlbnQoMCk7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gICAgfVxuICAgIGlmIChsaXN0Ll9fZmlyc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QmVmb3JlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0Ll9fbGFzdCA9PT0gdGhpcy5nZXRLZXkoKSkge1xuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTcGxpdCB0aGUgbGlzdFxuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0LmdldExpc3RUeXBlKCkpO1xuICAgICAgbGV0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUb0FwcGVuZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIG5ld0xpc3QuYXBwZW5kKG5vZGVUb0FwcGVuZCk7XG4gICAgICB9XG4gICAgICBsaXN0Lmluc2VydEFmdGVyKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgICByZXBsYWNlV2l0aE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5jbHVkZUNoaWxkcmVuIHNob3VsZCBvbmx5IGJlIHRydWUgZm9yIEVsZW1lbnROb2Rlc2ApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICByZXBsYWNlV2l0aE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIGlmIChsaXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBsaXN0LnJlbW92ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZVdpdGhOb2RlO1xuICB9XG4gIGluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbGlzdE5vZGUgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QWZ0ZXI6IGxpc3Qgbm9kZSBpcyBub3QgcGFyZW50IG9mIGxpc3QgaXRlbSBub2RlYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5leHRTaWJsaW5ncygpO1xuXG4gICAgLy8gU3BsaXQgdGhlIGxpc3RzIGFuZCBpbnNlcnQgdGhlIG5vZGUgaW4gYmV0d2VlbiB0aGVtXG4gICAgbGlzdE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgaWYgKHNpYmxpbmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdE5vZGUuZ2V0TGlzdFR5cGUoKSk7XG4gICAgICBzaWJsaW5ncy5mb3JFYWNoKHNpYmxpbmcgPT4gbmV3TGlzdE5vZGUuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdE5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBzdXBlci5yZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCk7XG4gICAgaWYgKHByZXZTaWJsaW5nICYmIG5leHRTaWJsaW5nICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldlNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBtZXJnZUxpc3RzKHByZXZTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSwgbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKHRoaXMuX19jaGVja2VkID09IG51bGwgPyB1bmRlZmluZWQgOiBmYWxzZSk7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGlzSW5kZW50ZWQgPSAkaXNMaXN0SXRlbU5vZGUobGlzdE5vZGVQYXJlbnQpO1xuICAgIGlmIChsaXN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgaWYgKGlzSW5kZW50ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxpc3Qgbm9kZSBpcyBuZXN0ZWQsIHdlIGp1c3Qgd2FudCB0byByZW1vdmUgaXQsXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IHVuaW5kZW50aW5nIGl0LlxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgbGlzdE5vZGVQYXJlbnQuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIG9uIHRoZSBsaXN0IGl0ZW0sIHdlJ2xsIG5lZWQgdG8gbW92ZSBpdFxuICAgICAgICAvLyB0byB0aGUgcGFyYWdyYXBoXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJhZ3JhcGguZ2V0S2V5KCk7XG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5nZXROb2RlKCkuaXModGhpcykpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGtleSwgYW5jaG9yLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGZvY3VzLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGZvY3VzLnNldChrZXksIGZvY3VzLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdmFsdWU7XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX192YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldENoZWNrZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19jaGVja2VkO1xuICB9XG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2NoZWNrZWQgPSBjaGVja2VkO1xuICB9XG4gIHRvZ2dsZUNoZWNrZWQoKSB7XG4gICAgdGhpcy5zZXRDaGVja2VkKCF0aGlzLl9fY2hlY2tlZCk7XG4gIH1cbiAgZ2V0SW5kZW50KCkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIHdlIGFyZSBsaWtlbHkgc2VyaWFsaXppbmdcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faW5kZW50O1xuICAgIH1cbiAgICAvLyBMaXN0SXRlbU5vZGUgc2hvdWxkIGFsd2F5cyBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LlxuICAgIGxldCBsaXN0Tm9kZVBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IGluZGVudExldmVsID0gMDtcbiAgICB3aGlsZSAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3ROb2RlUGFyZW50KSkge1xuICAgICAgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZVBhcmVudC5nZXRQYXJlbnRPclRocm93KCkuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgaW5kZW50TGV2ZWwrKztcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudExldmVsO1xuICB9XG4gIHNldEluZGVudChpbmRlbnQpIHtcbiAgICBpZiAoISh0eXBlb2YgaW5kZW50ID09PSAnbnVtYmVyJyAmJiBpbmRlbnQgPiAtMSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGluZGVudCB2YWx1ZS5gKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZW50ICE9PSBpbmRlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZW50IDwgaW5kZW50KSB7XG4gICAgICAgICRoYW5kbGVJbmRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRoYW5kbGVPdXRkZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50SW5kZW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgKi9cbiAgY2FuUmVwbGFjZVdpdGgocmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VtZW50KTtcbiAgfVxuICBjYW5NZXJnZVdpdGgobm9kZSkge1xuICAgIHJldHVybiAkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpIHx8ICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoID09PSBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gIH1cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgfVxufVxuZnVuY3Rpb24gJHNldExpc3RJdGVtVGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG4gIGNvbnN0IGxpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lID8gbGlzdFRoZW1lLmxpc3RpdGVtIDogdW5kZWZpbmVkO1xuICBsZXQgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWU7XG4gIGlmIChsaXN0VGhlbWUgJiYgbGlzdFRoZW1lLm5lc3RlZCkge1xuICAgIG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lLm5lc3RlZC5saXN0aXRlbTtcbiAgfVxuICBpZiAobGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5vcm1hbGl6ZUNsYXNzTmFtZXMobGlzdEl0ZW1DbGFzc05hbWUpKTtcbiAgfVxuICBpZiAobGlzdFRoZW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgY29uc3QgaXNDaGVja0xpc3QgPSAkaXNMaXN0Tm9kZShwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlLmdldExpc3RUeXBlKCkgPT09ICdjaGVjayc7XG4gICAgY29uc3QgY2hlY2tlZCA9IG5vZGUuZ2V0Q2hlY2tlZCgpO1xuICAgIGlmICghaXNDaGVja0xpc3QgfHwgY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtVW5jaGVja2VkKTtcbiAgICB9XG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCAhY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrTGlzdCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goY2hlY2tlZCA/IGxpc3RUaGVtZS5saXN0aXRlbUNoZWNrZWQgOiBsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cbiAgfVxuICBpZiAobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUpO1xuICAgIGlmIChub2RlLmdldENoaWxkcmVuKCkuc29tZShjaGlsZCA9PiAkaXNMaXN0Tm9kZShjaGlsZCkpKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH1cbiAgfVxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCBsaXN0SXRlbU5vZGUsIHByZXZMaXN0SXRlbU5vZGUsIGxpc3ROb2RlKSB7XG4gIC8vIE9ubHkgYWRkIGF0dHJpYnV0ZXMgZm9yIGxlYWYgbGlzdCBpdGVtc1xuICBpZiAoJGlzTGlzdE5vZGUobGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcbiAgICBpZiAoIXByZXZMaXN0SXRlbU5vZGUgfHwgbGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCAhPT0gcHJldkxpc3RJdGVtTm9kZS5fX2NoZWNrZWQpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIGxpc3RJdGVtTm9kZS5nZXRDaGVja2VkKCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNHaXRIdWJDaGVja0xpc3QgPSBkb21Ob2RlLmNsYXNzTGlzdC5jb250YWlucygndGFzay1saXN0LWl0ZW0nKTtcbiAgaWYgKGlzR2l0SHViQ2hlY2tMaXN0KSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBkb21Ob2RlLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICByZXR1cm4gJGNvbnZlcnRDaGVja2JveElucHV0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYXJpYUNoZWNrZWRBdHRyID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpO1xuICBjb25zdCBjaGVja2VkID0gYXJpYUNoZWNrZWRBdHRyID09PSAndHJ1ZScgPyB0cnVlIDogYXJpYUNoZWNrZWRBdHRyID09PSAnZmFsc2UnID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRDaGVja2JveElucHV0KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNDaGVja2JveElucHV0ID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94JztcbiAgaWYgKCFpc0NoZWNrYm94SW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgY2hlY2tlZCA9IGRvbU5vZGUuaGFzQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGlzdCBJdGVtIG5vZGUsIHBhc3NpbmcgdHJ1ZS9mYWxzZSB3aWxsIGNvbnZlcnQgaXQgdG8gYSBjaGVja2JveCBpbnB1dC5cbiAqIEBwYXJhbSBjaGVja2VkIC0gSXMgdGhlIExpc3QgSXRlbSBhIGNoZWNrYm94IGFuZCwgaWYgc28sIGlzIGl0IGNoZWNrZWQ/IHVuZGVmaW5lZC9udWxsOiBub3QgYSBjaGVja2JveCwgdHJ1ZS9mYWxzZSBpcyBhIGNoZWNrYm94IGFuZCBjaGVja2VkL3VuY2hlY2tlZCwgcmVzcGVjdGl2ZWx5LlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0IEl0ZW0uXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVMaXN0SXRlbU5vZGUoY2hlY2tlZCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0SXRlbU5vZGUodW5kZWZpbmVkLCBjaGVja2VkKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0SXRlbU5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3ROb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpc3QnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgY29uc3QgbGlzdFR5cGUgPSBub2RlLl9fbGlzdFR5cGUgfHwgVEFHX1RPX0xJU1RfVFlQRVtub2RlLl9fdGFnXTtcbiAgICByZXR1cm4gbmV3IExpc3ROb2RlKGxpc3RUeXBlLCBub2RlLl9fc3RhcnQsIG5vZGUuX19rZXkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGxpc3RUeXBlLCBzdGFydCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCBfbGlzdFR5cGUgPSBUQUdfVE9fTElTVF9UWVBFW2xpc3RUeXBlXSB8fCBsaXN0VHlwZTtcbiAgICB0aGlzLl9fbGlzdFR5cGUgPSBfbGlzdFR5cGU7XG4gICAgdGhpcy5fX3RhZyA9IF9saXN0VHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgICB0aGlzLl9fc3RhcnQgPSBzdGFydDtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190YWc7XG4gIH1cbiAgc2V0TGlzdFR5cGUodHlwZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGlzdFR5cGUgPSB0eXBlO1xuICAgIHdyaXRhYmxlLl9fdGFnID0gdHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgfVxuICBnZXRMaXN0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2xpc3RUeXBlO1xuICB9XG4gIGdldFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9fc3RhcnQ7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgX2VkaXRvcikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX190YWc7XG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEludGVybmFsIGZpZWxkLlxuICAgIGRvbS5fX2xleGljYWxMaXN0VHlwZSA9IHRoaXMuX19saXN0VHlwZTtcbiAgICAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgaWYgKHByZXZOb2RlLl9fdGFnICE9PSB0aGlzLl9fdGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgJHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgIGlmICghJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG5vZGUgaXMgbm90IGEgTGlzdE5vZGVgKTtcbiAgICAgIH1cbiAgICAgIG1lcmdlTmV4dFNpYmxpbmdMaXN0SWZTYW1lVHlwZShub2RlKTtcbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShub2RlKTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9sOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydExpc3ROb2RlLFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB1bDogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoc2VyaWFsaXplZE5vZGUubGlzdFR5cGUsIHNlcmlhbGl6ZWROb2RlLnN0YXJ0KTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoZWxlbWVudCAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXJ0ICE9PSAxKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGFydCcsIFN0cmluZyh0aGlzLl9fc3RhcnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbExpc3RUeXBlJywgJ2NoZWNrJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsaXN0VHlwZTogdGhpcy5nZXRMaXN0VHlwZSgpLFxuICAgICAgc3RhcnQ6IHRoaXMuZ2V0U3RhcnQoKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKSxcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzVG9BcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbm9kZXNUb0FwcGVuZFtpXTtcbiAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChjdXJyZW50Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoY2hpbGQpO1xuICB9XG59XG5mdW5jdGlvbiAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGVkaXRvclRoZW1lQ2xhc3Nlcywgbm9kZSkge1xuICBjb25zdCBjbGFzc2VzVG9BZGQgPSBbXTtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gW107XG4gIGNvbnN0IGxpc3RUaGVtZSA9IGVkaXRvclRoZW1lQ2xhc3Nlcy5saXN0O1xuICBpZiAobGlzdFRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsaXN0TGV2ZWxzQ2xhc3NOYW1lcyA9IGxpc3RUaGVtZVtgJHtub2RlLl9fdGFnfURlcHRoYF0gfHwgW107XG4gICAgY29uc3QgbGlzdERlcHRoID0gJGdldExpc3REZXB0aChub2RlKSAtIDE7XG4gICAgY29uc3Qgbm9ybWFsaXplZExpc3REZXB0aCA9IGxpc3REZXB0aCAlIGxpc3RMZXZlbHNDbGFzc05hbWVzLmxlbmd0aDtcbiAgICBjb25zdCBsaXN0TGV2ZWxDbGFzc05hbWUgPSBsaXN0TGV2ZWxzQ2xhc3NOYW1lc1tub3JtYWxpemVkTGlzdERlcHRoXTtcbiAgICBjb25zdCBsaXN0Q2xhc3NOYW1lID0gbGlzdFRoZW1lW25vZGUuX190YWddO1xuICAgIGxldCBuZXN0ZWRMaXN0Q2xhc3NOYW1lO1xuICAgIGNvbnN0IG5lc3RlZExpc3RUaGVtZSA9IGxpc3RUaGVtZS5uZXN0ZWQ7XG4gICAgY29uc3QgY2hlY2tsaXN0Q2xhc3NOYW1lID0gbGlzdFRoZW1lLmNoZWNrbGlzdDtcbiAgICBpZiAobmVzdGVkTGlzdFRoZW1lICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkTGlzdFRoZW1lLmxpc3QpIHtcbiAgICAgIG5lc3RlZExpc3RDbGFzc05hbWUgPSBuZXN0ZWRMaXN0VGhlbWUubGlzdDtcbiAgICB9XG4gICAgaWYgKGxpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2gobGlzdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChjaGVja2xpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCAmJiBub2RlLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGNoZWNrbGlzdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChsaXN0TGV2ZWxDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubm9ybWFsaXplQ2xhc3NOYW1lcyhsaXN0TGV2ZWxDbGFzc05hbWUpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExldmVsc0NsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT09IG5vcm1hbGl6ZWRMaXN0RGVwdGgpIHtcbiAgICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChub2RlLl9fdGFnICsgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lc3RlZExpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1DbGFzc2VzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhuZXN0ZWRMaXN0Q2xhc3NOYW1lKTtcbiAgICAgIGlmIChsaXN0RGVwdGggPiAxKSB7XG4gICAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIG5vcm1hbGl6ZXMgdGhlIGNoaWxkcmVuIG9mIGEgTGlzdE5vZGUgYWZ0ZXIgdGhlIGNvbnZlcnNpb24gZnJvbSBIVE1MLFxuICogZW5zdXJpbmcgdGhhdCB0aGV5IGFyZSBhbGwgTGlzdEl0ZW1Ob2RlcyBhbmQgY29udGFpbiBlaXRoZXIgYSBzaW5nbGUgbmVzdGVkIExpc3ROb2RlXG4gKiBvciBzb21lIG90aGVyIGlubGluZSBjb250ZW50LlxuICovXG5mdW5jdGlvbiAkbm9ybWFsaXplQ2hpbGRyZW4obm9kZXMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZExpc3RJdGVtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaChub2RlKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKCR3cmFwSW5MaXN0SXRlbShjaGlsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaCgkd3JhcEluTGlzdEl0ZW0obm9kZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZExpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGlzRG9tQ2hlY2tsaXN0KGRvbU5vZGUpIHtcbiAgaWYgKGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdfX2xleGljYWxsaXN0dHlwZScpID09PSAnY2hlY2snIHx8XG4gIC8vIGlzIGdpdGh1YiBjaGVja2xpc3RcbiAgZG9tTm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbnRhaW5zLXRhc2stbGlzdCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gaWYgY2hpbGRyZW4gYXJlIGNoZWNrbGlzdCBpdGVtcywgdGhlIG5vZGUgaXMgYSBjaGVja2xpc3QgdWwuIEFwcGxpY2FibGUgZm9yIGdvb2dsZWRvYyBjaGVja2xpc3QgcGFzdGluZy5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBkb21Ob2RlLmNoaWxkTm9kZXMpIHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuaGFzQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGlzdE5vZGUoZG9tTm9kZSkge1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBpZiAobm9kZU5hbWUgPT09ICdvbCcpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3RhcnQgPSBkb21Ob2RlLnN0YXJ0O1xuICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ251bWJlcicsIHN0YXJ0KTtcbiAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ3VsJykge1xuICAgIGlmIChpc0RvbUNoZWNrbGlzdChkb21Ob2RlKSkge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnY2hlY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnYnVsbGV0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6ICRub3JtYWxpemVDaGlsZHJlbixcbiAgICBub2RlXG4gIH07XG59XG5jb25zdCBUQUdfVE9fTElTVF9UWVBFID0ge1xuICBvbDogJ251bWJlcicsXG4gIHVsOiAnYnVsbGV0J1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgTGlzdE5vZGUgb2YgbGlzdFR5cGUuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0IHRvIGJlIGNyZWF0ZWQuIENhbiBiZSAnbnVtYmVyJywgJ2J1bGxldCcsIG9yICdjaGVjaycuXG4gKiBAcGFyYW0gc3RhcnQgLSBXaGVyZSBhbiBvcmRlcmVkIGxpc3Qgc3RhcnRzIGl0cyBjb3VudCwgc3RhcnQgPSAxIGlmIGxlZnQgdW5kZWZpbmVkLlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0Tm9kZVxuICovXG5mdW5jdGlvbiAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUsIHN0YXJ0ID0gMSkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0Tm9kZShsaXN0VHlwZSwgc3RhcnQpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpc3ROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IFJFTU9WRV9MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRU1PVkVfTElTVF9DT01NQU5EJyk7XG5cbmV4cG9ydCB7ICRjcmVhdGVMaXN0SXRlbU5vZGUsICRjcmVhdGVMaXN0Tm9kZSwgJGdldExpc3REZXB0aCwgJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgsICRpc0xpc3RJdGVtTm9kZSwgJGlzTGlzdE5vZGUsIElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQsIElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQsIExpc3RJdGVtTm9kZSwgTGlzdE5vZGUsIFJFTU9WRV9MSVNUX0NPTU1BTkQsIGluc2VydExpc3QsIHJlbW92ZUxpc3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/list/LexicalList.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createMarkNode: () => (/* binding */ $createMarkNode),\n/* harmony export */   $getMarkIDs: () => (/* binding */ $getMarkIDs),\n/* harmony export */   $isMarkNode: () => (/* binding */ $isMarkNode),\n/* harmony export */   $unwrapMarkNode: () => (/* binding */ $unwrapMarkNode),\n/* harmony export */   $wrapSelectionInMarkNode: () => (/* binding */ $wrapSelectionInMarkNode),\n/* harmony export */   MarkNode: () => (/* binding */ MarkNode)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    const ids = this.getIDs();\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n  addID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) {\n          return;\n        }\n      }\n      ids.push(id);\n    }\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n\n      continue;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZHO0FBQ3hCOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnREFBVztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBLE1BQU0sc0VBQXNCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0VBQXNCO0FBQ2hDO0FBQ0EsUUFBUTtBQUNSLFFBQVEsMkVBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0EsUUFBUSx1REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxTQUFTLHVEQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxvREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrL0xleGljYWxNYXJrLmRldi5tanM/YWEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IEVsZW1lbnROb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkaXNFbGVtZW50Tm9kZSwgJGlzVGV4dE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTWFya05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ21hcmsnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrTm9kZShBcnJheS5mcm9tKG5vZGUuX19pZHMpLCBub2RlLl9fa2V5KTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVNYXJrTm9kZShzZXJpYWxpemVkTm9kZS5pZHMpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGlkczogdGhpcy5nZXRJRHMoKSxcbiAgICAgIHR5cGU6ICdtYXJrJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKGlkcywga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faWRzID0gaWRzIHx8IFtdO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWFyaycpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLm1hcmspO1xuICAgIGlmICh0aGlzLl9faWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLm1hcmtPdmVybGFwKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBlbGVtZW50LCBjb25maWcpIHtcbiAgICBjb25zdCBwcmV2SURzID0gcHJldk5vZGUuX19pZHM7XG4gICAgY29uc3QgbmV4dElEcyA9IHRoaXMuX19pZHM7XG4gICAgY29uc3QgcHJldklEc0NvdW50ID0gcHJldklEcy5sZW5ndGg7XG4gICAgY29uc3QgbmV4dElEc0NvdW50ID0gbmV4dElEcy5sZW5ndGg7XG4gICAgY29uc3Qgb3ZlcmxhcFRoZW1lID0gY29uZmlnLnRoZW1lLm1hcmtPdmVybGFwO1xuICAgIGlmIChwcmV2SURzQ291bnQgIT09IG5leHRJRHNDb3VudCkge1xuICAgICAgaWYgKHByZXZJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICBpZiAobmV4dElEc0NvdW50ID09PSAyKSB7XG4gICAgICAgICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBvdmVybGFwVGhlbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZWxlbWVudCwgb3ZlcmxhcFRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhc0lEKGlkKSB7XG4gICAgY29uc3QgaWRzID0gdGhpcy5nZXRJRHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkID09PSBpZHNbaV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRJRHMoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuICRpc01hcmtOb2RlKHNlbGYpID8gc2VsZi5fX2lkcyA6IFtdO1xuICB9XG4gIGFkZElEKGlkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBpZiAoJGlzTWFya05vZGUoc2VsZikpIHtcbiAgICAgIGNvbnN0IGlkcyA9IHNlbGYuX19pZHM7XG4gICAgICBzZWxmLl9faWRzID0gaWRzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGl0LCBkb24ndCBhZGQgYWdhaW5cbiAgICAgICAgaWYgKGlkID09PSBpZHNbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH1cbiAgZGVsZXRlSUQoaWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGlmICgkaXNNYXJrTm9kZShzZWxmKSkge1xuICAgICAgY29uc3QgaWRzID0gc2VsZi5fX2lkcztcbiAgICAgIHNlbGYuX19pZHMgPSBpZHM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWQgPT09IGlkc1tpXSkge1xuICAgICAgICAgIGlkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBtYXJrTm9kZSA9ICRjcmVhdGVNYXJrTm9kZSh0aGlzLl9faWRzKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG1hcmtOb2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbWFya05vZGU7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGRlc3RpbmF0aW9uID09PSAnaHRtbCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uTGVuZ3RoID0gaXNCYWNrd2FyZCA/IGFuY2hvci5vZmZzZXQgLSBmb2N1cy5vZmZzZXQgOiBmb2N1cy5vZmZzZXQgLSBhbmNob3Iub2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA9PT0gc2VsZWN0aW9uTGVuZ3RoO1xuICB9XG4gIGV4Y2x1ZGVGcm9tQ29weShkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbiAhPT0gJ2Nsb25lJztcbiAgfVxufVxuZnVuY3Rpb24gJGNyZWF0ZU1hcmtOb2RlKGlkcykge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBNYXJrTm9kZShpZHMpKTtcbn1cbmZ1bmN0aW9uICRpc01hcmtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBNYXJrTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkdW53cmFwTWFya05vZGUobm9kZSkge1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgbGV0IHRhcmdldCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gY2hpbGQ7XG4gIH1cbiAgbm9kZS5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uICR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZShzZWxlY3Rpb24sIGlzQmFja3dhcmQsIGlkLCBjcmVhdGVOb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICBjb25zdCBzdGFydE9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICBsZXQgY3VycmVudE5vZGVQYXJlbnQ7XG4gIGxldCBsYXN0Q3JlYXRlZE1hcmtOb2RlO1xuXG4gIC8vIFdlIG9ubHkgd2FudCB3cmFwIGFkamFjZW50IHRleHQgbm9kZXMsIGxpbmUgYnJlYWsgbm9kZXNcbiAgLy8gYW5kIGlubGluZSBlbGVtZW50IG5vZGVzLiBGb3IgZGVjb3JhdG9yIG5vZGVzIGFuZCBibG9ja1xuICAvLyBlbGVtZW50IG5vZGVzLCB3ZSBzdGVwIG91dCBvZiB0aGVpciBib3VuZGFyeSBhbmQgc3RhcnRcbiAgLy8gYWdhaW4gYWZ0ZXIsIGlmIHRoZXJlIGFyZSBtb3JlIG5vZGVzLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3RDcmVhdGVkTWFya05vZGUpICYmIGxhc3RDcmVhdGVkTWFya05vZGUuaXNQYXJlbnRPZihub2RlKSkge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIGNoaWxkIG9mIHRoZSBsYXN0IGNyZWF0ZWQgbWFyayBub2RlLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGhlcmVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpc0ZpcnN0Tm9kZSA9IGkgPT09IDA7XG4gICAgY29uc3QgaXNMYXN0Tm9kZSA9IGkgPT09IG5vZGVzTGVuZ3RoIC0gMTtcbiAgICBsZXQgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAvLyBDYXNlIDE6IFRoZSBub2RlIGlzIGEgdGV4dCBub2RlIGFuZCB3ZSBjYW4gc3BsaXQgaXRcbiAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICBjb25zdCBzdGFydFRleHRPZmZzZXQgPSBpc0ZpcnN0Tm9kZSA/IHN0YXJ0T2Zmc2V0IDogMDtcbiAgICAgIGNvbnN0IGVuZFRleHRPZmZzZXQgPSBpc0xhc3ROb2RlID8gZW5kT2Zmc2V0IDogdGV4dENvbnRlbnRTaXplO1xuICAgICAgaWYgKHN0YXJ0VGV4dE9mZnNldCA9PT0gMCAmJiBlbmRUZXh0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BsaXROb2RlcyA9IG5vZGUuc3BsaXRUZXh0KHN0YXJ0VGV4dE9mZnNldCwgZW5kVGV4dE9mZnNldCk7XG4gICAgICB0YXJnZXROb2RlID0gc3BsaXROb2Rlcy5sZW5ndGggPiAxICYmIChzcGxpdE5vZGVzLmxlbmd0aCA9PT0gMyB8fCBpc0ZpcnN0Tm9kZSAmJiAhaXNMYXN0Tm9kZSB8fCBlbmRUZXh0T2Zmc2V0ID09PSB0ZXh0Q29udGVudFNpemUpID8gc3BsaXROb2Rlc1sxXSA6IHNwbGl0Tm9kZXNbMF07XG4gICAgfSBlbHNlIGlmICgkaXNNYXJrTm9kZShub2RlKSkge1xuICAgICAgLy8gQ2FzZSAyOiB0aGUgbm9kZSBpcyBhIG1hcmsgbm9kZSBhbmQgd2UgY2FuIGlnbm9yZSBpdCBhcyBhIHRhcmdldCxcbiAgICAgIC8vIG1vdmluZyBvbiB0byBpdHMgY2hpbGRyZW4uIE5vdGUgdGhhdCB3aGVuIHdlIG1ha2UgYSBtYXJrIGluc2lkZVxuICAgICAgLy8gYW5vdGhlciBtYXJrLCBpdCBtYXkgdXRsaW1hdGVseSBiZSB1bm5lc3RlZCBieSBhIGNhbGwgdG9cbiAgICAgIC8vIGByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcjxNYXJrTm9kZT5gIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgLy8gY29kZWJhc2UuXG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAvLyBDYXNlIDM6IGlubGluZSBlbGVtZW50IG5vZGVzIGNhbiBiZSBhZGRlZCBpbiB0aGVpciBlbnRpcmV0eSB0byB0aGUgbmV3XG4gICAgICAvLyBtYXJrXG4gICAgICB0YXJnZXROb2RlID0gbm9kZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldE5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgYSB0YXJnZXQgbm9kZSBmb3Igd3JhcHBpbmcgd2l0aCBhIG1hcmssIHdlIGNhbiBydW5cbiAgICAgIC8vIHRocm91Z2ggc3BlY2lhbCBjYXNlcy5cbiAgICAgIGlmICh0YXJnZXROb2RlICYmIHRhcmdldE5vZGUuaXMoY3VycmVudE5vZGVQYXJlbnQpKSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IG5vZGUgaXMgYSBjaGlsZCBvZiB0aGUgdGFyZ2V0IG5vZGUgdG8gYmUgd3JhcHBlZCwgdGhlcmVcbiAgICAgICAgLy8gaXMgbm90aGluZyB0byBkbyBoZXJlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCB8fCAhcGFyZW50Tm9kZS5pcyhjdXJyZW50Tm9kZVBhcmVudCkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0aGUgY3VycmVudCBub2RlJ3MgcGFyZW50IG5vZGUsIHdlIGNhblxuICAgICAgICAvLyBjbGVhciB0aGUgbGFzdCBjcmVhdGVkIG1hcmsgbm9kZS5cbiAgICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnROb2RlUGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICAgIGlmIChsYXN0Q3JlYXRlZE1hcmtOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNyZWF0ZWQgbWFyayBub2RlLCB3ZSBjYW4gbWFrZSBvbmVcbiAgICAgICAgY29uc3QgY3JlYXRlTWFya05vZGUgPSBjcmVhdGVOb2RlIHx8ICRjcmVhdGVNYXJrTm9kZTtcbiAgICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IGNyZWF0ZU1hcmtOb2RlKFtpZF0pO1xuICAgICAgICB0YXJnZXROb2RlLmluc2VydEJlZm9yZShsYXN0Q3JlYXRlZE1hcmtOb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSB0YXJnZXQgbm9kZSB0byBiZSB3cmFwcGVkIGluIHRoZSBsYXRlc3QgY3JlYXRlZCBtYXJrIG5vZGVcbiAgICAgIGxhc3RDcmVhdGVkTWFya05vZGUuYXBwZW5kKHRhcmdldE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgdGFyZ2V0IG5vZGUgdG8gd3JhcCB3ZSBjYW4gY2xlYXIgb3VyIHN0YXRlIGFuZFxuICAgICAgLy8gY29udGludWUgb24gd2l0aCB0aGUgbmV4dCBub2RlXG4gICAgICBjdXJyZW50Tm9kZVBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGxhc3RDcmVhdGVkTWFya05vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIC8vIE1ha2Ugc2VsZWN0aW9uIGNvbGxhcHNlZCBhdCB0aGUgZW5kXG4gIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0Q3JlYXRlZE1hcmtOb2RlKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICBpc0JhY2t3YXJkID8gbGFzdENyZWF0ZWRNYXJrTm9kZS5zZWxlY3RTdGFydCgpIDogbGFzdENyZWF0ZWRNYXJrTm9kZS5zZWxlY3RFbmQoKTtcbiAgfVxufVxuZnVuY3Rpb24gJGdldE1hcmtJRHMobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNNYXJrTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5nZXRJRHMoKTtcbiAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKGN1cnJlbnROb2RlKSAmJiBvZmZzZXQgPT09IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IGN1cnJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzTWFya05vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHJldHVybiBuZXh0U2libGluZy5nZXRJRHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgJGNyZWF0ZU1hcmtOb2RlLCAkZ2V0TWFya0lEcywgJGlzTWFya05vZGUsICR1bndyYXBNYXJrTm9kZSwgJHdyYXBTZWxlY3Rpb25Jbk1hcmtOb2RlLCBNYXJrTm9kZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $convertFromMarkdownString: () => (/* binding */ $convertFromMarkdownString),\n/* harmony export */   $convertToMarkdownString: () => (/* binding */ $convertToMarkdownString),\n/* harmony export */   BOLD_ITALIC_STAR: () => (/* binding */ BOLD_ITALIC_STAR),\n/* harmony export */   BOLD_ITALIC_UNDERSCORE: () => (/* binding */ BOLD_ITALIC_UNDERSCORE),\n/* harmony export */   BOLD_STAR: () => (/* binding */ BOLD_STAR),\n/* harmony export */   BOLD_UNDERSCORE: () => (/* binding */ BOLD_UNDERSCORE),\n/* harmony export */   CHECK_LIST: () => (/* binding */ CHECK_LIST),\n/* harmony export */   CODE: () => (/* binding */ CODE),\n/* harmony export */   ELEMENT_TRANSFORMERS: () => (/* binding */ ELEMENT_TRANSFORMERS),\n/* harmony export */   HEADING: () => (/* binding */ HEADING),\n/* harmony export */   HIGHLIGHT: () => (/* binding */ HIGHLIGHT),\n/* harmony export */   INLINE_CODE: () => (/* binding */ INLINE_CODE),\n/* harmony export */   ITALIC_STAR: () => (/* binding */ ITALIC_STAR),\n/* harmony export */   ITALIC_UNDERSCORE: () => (/* binding */ ITALIC_UNDERSCORE),\n/* harmony export */   LINK: () => (/* binding */ LINK),\n/* harmony export */   ORDERED_LIST: () => (/* binding */ ORDERED_LIST),\n/* harmony export */   QUOTE: () => (/* binding */ QUOTE),\n/* harmony export */   STRIKETHROUGH: () => (/* binding */ STRIKETHROUGH),\n/* harmony export */   TEXT_FORMAT_TRANSFORMERS: () => (/* binding */ TEXT_FORMAT_TRANSFORMERS),\n/* harmony export */   TEXT_MATCH_TRANSFORMERS: () => (/* binding */ TEXT_MATCH_TRANSFORMERS),\n/* harmony export */   TRANSFORMERS: () => (/* binding */ TRANSFORMERS),\n/* harmony export */   UNORDERED_LIST: () => (/* binding */ UNORDERED_LIST),\n/* harmony export */   registerMarkdownShortcuts: () => (/* binding */ registerMarkdownShortcuts)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/code */ \"(ssr)/./node_modules/@lexical/code/LexicalCode.dev.mjs\");\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // seperate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are atleast \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(child)) {\n      output.push('\\n');\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n      // Prevent adding opening tag is already opened by the previous sibling\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      }\n\n      // Prevent adding closing tag if next sibling will do it\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  }\n\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return textContent.replace(frozenString, () => output);\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(sibling)) {\n      return sibling;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CODE_BLOCK_REG_EXP = /^[ \\t]*```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n      const [codeBlockNode, shiftedIndex] = $importCodeBlock(lines, i, root);\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() !== null) {\n      root.selectEnd();\n    }\n  };\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(lineTextTrimmed);\n  const elementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(previousNode) || (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.$isQuoteNode)(previousNode) || (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(previousNode)) {\n      let targetNode = previousNode;\n      if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.$findMatchingParent)(lastDescendant, _lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction $importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n      if (closeMatch) {\n        const codeBlockNode = (0,_lexical_code__WEBPACK_IMPORTED_MODULE_4__.$createCodeNode)(openMatch[1]);\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n  return [null, startLineIndex];\n}\n\n// Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  }\n\n  // Recursively run over inner text if it's not inline code\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  // Run over leading/remaining text if any\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, newTextNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [, replaceNode, newTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n      if (newTextNode) {\n        importTextMatchTransformers(newTextNode, textMatchTransformers);\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(sibling)) {\n        break;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const nextSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has('collaboration') || tags.has('historic')) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read(lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection);\n    const prevSelection = prevEditorState.read(lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection);\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || (0,_lexical_code__WEBPACK_IMPORTED_MODULE_4__.$isCodeNode)(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$createListItemNode)(listType === 'check' ? match[3] === 'x' : undefined);\n    if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$createListNode)(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListItemNode)(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.$isHeadingNode)(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.$createHeadingNode)(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.$isQuoteNode)(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ((0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.$isQuoteNode)(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.$createQuoteNode)();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [_lexical_code__WEBPACK_IMPORTED_MODULE_4__.CodeNode],\n  export: node => {\n    if (!(0,_lexical_code__WEBPACK_IMPORTED_MODULE_4__.$isCodeNode)(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^[ \\t]*```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return (0,_lexical_code__WEBPACK_IMPORTED_MODULE_4__.$createCodeNode)(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [_lexical_link__WEBPACK_IMPORTED_MODULE_5__.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!(0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$isLinkNode)(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild();\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = (0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$createLinkNode)(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(markdown, node);\n}\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFya2Rvd24vTGV4aWNhbE1hcmtkb3duLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ1I7QUFDek07QUFDb0Q7QUFDSztBQUMzRTtBQUNrQjs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0EsT0FBTyx5REFBZ0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsK0RBQStELG9EQUFXO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFRO0FBQ3RDLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWM7QUFDcEI7QUFDQSxJQUFJLFNBQVMseURBQWdCO0FBQzdCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBLE1BQU0sU0FBUyxvREFBVztBQUMxQjtBQUNBLE1BQU0sU0FBUyx1REFBYztBQUM3QjtBQUNBO0FBQ0EsTUFBTSxTQUFTLHlEQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQSxTQUFTLHVEQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQVc7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFRO0FBQ2pDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQWU7QUFDbEMsc0JBQXNCLDZEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWdCLGtCQUFrQixnRUFBWSxrQkFBa0IsMERBQVc7QUFDbkY7QUFDQSxVQUFVLDBEQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1QkFBdUIsbUVBQW1CLGlCQUFpQiwwREFBZTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNkRBQW9CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFlO0FBQzdDLHlCQUF5Qix3REFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVUsT0FBTyxVQUFVLGFBQWEsVUFBVSxPQUFPLFVBQVUsS0FBSyxVQUFVO0FBQ25JLE1BQU07QUFDTix5REFBeUQsVUFBVSxLQUFLLFVBQVUsU0FBUyxVQUFVLFNBQVMsVUFBVSxXQUFXLFVBQVUsK0JBQStCLFVBQVUsV0FBVyxVQUFVO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixhQUFhO0FBQzlGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyw0REFBbUI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBZ0I7QUFDMUI7QUFDQTtBQUNBLFVBQVUsb0RBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkMsMEJBQTBCLDhEQUFxQjtBQUMvQyxJQUFJLHNEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWE7QUFDcEQsK0NBQStDLGtEQUFhO0FBQzVELFNBQVMsMERBQWlCLG9CQUFvQiwwREFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQW1CO0FBQ3hDLFFBQVEsMERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLDBEQUFXO0FBQzFCO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLDhEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBZTtBQUN2QjtBQUNBO0FBQ0EsWUFBWSwwREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNEJBQTRCLG1DQUFtQyxzQ0FBc0M7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQVc7QUFDNUI7QUFDQSxTQUFTLGtFQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxzRUFBa0I7QUFDN0IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBUztBQUMxQjtBQUNBLFNBQVMsZ0VBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQVk7QUFDdEIsZ0VBQWdFLDZEQUFvQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9FQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFRO0FBQ3pCO0FBQ0EsU0FBUywwREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsS0FBSztBQUM5QjtBQUNBLFdBQVcsOERBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUSxFQUFFLHVEQUFZO0FBQ3ZDO0FBQ0EsV0FBVywwREFBVztBQUN0QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUSxFQUFFLHVEQUFZO0FBQ3ZDO0FBQ0EsV0FBVywwREFBVztBQUN0QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUSxFQUFFLHVEQUFZO0FBQ3ZDO0FBQ0EsV0FBVywwREFBVztBQUN0QixHQUFHO0FBQ0gscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQVE7QUFDekI7QUFDQSxTQUFTLDBEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0IsSUFBSSxlQUFlLEdBQUcsTUFBTSxVQUFVLHNCQUFzQixJQUFJLGNBQWM7QUFDeEk7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9EQUFXO0FBQ25EO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOERBQWU7QUFDcEM7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLHdEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxWSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFya2Rvd24vTGV4aWNhbE1hcmtkb3duLmRldi5tanM/NGJmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRpc1BhcmFncmFwaE5vZGUsICRpc1RleHROb2RlLCAkZ2V0Um9vdCwgJGlzRWxlbWVudE5vZGUsICRpc0RlY29yYXRvck5vZGUsICRpc0xpbmVCcmVha05vZGUsICRnZXRTZWxlY3Rpb24sICRjcmVhdGVUZXh0Tm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRjcmVhdGVMaW5lQnJlYWtOb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkc2V0U2VsZWN0aW9uIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyAkY3JlYXRlQ29kZU5vZGUsICRpc0NvZGVOb2RlLCBDb2RlTm9kZSB9IGZyb20gJ0BsZXhpY2FsL2NvZGUnO1xuaW1wb3J0IHsgJGlzTGlzdE5vZGUsICRpc0xpc3RJdGVtTm9kZSwgTGlzdE5vZGUsIExpc3RJdGVtTm9kZSwgJGNyZWF0ZUxpc3RJdGVtTm9kZSwgJGNyZWF0ZUxpc3ROb2RlIH0gZnJvbSAnQGxleGljYWwvbGlzdCc7XG5pbXBvcnQgeyAkaXNRdW90ZU5vZGUsIEhlYWRpbmdOb2RlLCAkaXNIZWFkaW5nTm9kZSwgUXVvdGVOb2RlLCAkY3JlYXRlUXVvdGVOb2RlLCAkY3JlYXRlSGVhZGluZ05vZGUgfSBmcm9tICdAbGV4aWNhbC9yaWNoLXRleHQnO1xuaW1wb3J0IHsgJGZpbmRNYXRjaGluZ1BhcmVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IExpbmtOb2RlLCAkaXNMaW5rTm9kZSwgJGNyZWF0ZUxpbmtOb2RlIH0gZnJvbSAnQGxleGljYWwvbGluayc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhCeShsaXN0LCBjYWxsYmFjaykge1xuICBjb25zdCBpbmRleCA9IHt9O1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgIGNvbnN0IGtleSA9IGNhbGxiYWNrKGl0ZW0pO1xuICAgIGlmIChpbmRleFtrZXldKSB7XG4gICAgICBpbmRleFtrZXldLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4W2tleV0gPSBbaXRlbV07XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gaW5kZXhCeSh0cmFuc2Zvcm1lcnMsIHQgPT4gdC50eXBlKTtcbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50OiBieVR5cGUuZWxlbWVudCB8fCBbXSxcbiAgICB0ZXh0Rm9ybWF0OiBieVR5cGVbJ3RleHQtZm9ybWF0J10gfHwgW10sXG4gICAgdGV4dE1hdGNoOiBieVR5cGVbJ3RleHQtbWF0Y2gnXSB8fCBbXVxuICB9O1xufVxuY29uc3QgUFVOQ1RVQVRJT05fT1JfU1BBQ0UgPSAvWyEtLzotQFstYHstflxcc10vO1xuY29uc3QgTUFSS0RPV05fRU1QVFlfTElORV9SRUdfRVhQID0gL15cXHN7MCwzfSQvO1xuZnVuY3Rpb24gaXNFbXB0eVBhcmFncmFwaChub2RlKSB7XG4gIGlmICghJGlzUGFyYWdyYXBoTm9kZShub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gIHJldHVybiBmaXJzdENoaWxkID09IG51bGwgfHwgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSAmJiAkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSAmJiBNQVJLRE9XTl9FTVBUWV9MSU5FX1JFR19FWFAudGVzdChmaXJzdENoaWxkLmdldFRleHRDb250ZW50KCkpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtkb3duRXhwb3J0KHRyYW5zZm9ybWVycywgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyA9IGZhbHNlKSB7XG4gIGNvbnN0IGJ5VHlwZSA9IHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpO1xuICBjb25zdCBpc05ld2xpbmVEZWxpbWl0ZWQgPSAhc2hvdWxkUHJlc2VydmVOZXdMaW5lcztcblxuICAvLyBFeHBvcnQgb25seSB1c2VzIHRleHQgZm9ybWF0cyB0aGF0IGFyZSByZXNwb25zaWJsZSBmb3Igc2luZ2xlIGZvcm1hdFxuICAvLyBlLmcuIGl0IHdpbGwgZmlsdGVyIG91dCAqKiogKGJvbGQsIGl0YWxpYykgYW5kIGluc3RlYWQgdXNlIHNlcGFyYXRlICoqIGFuZCAqXG4gIGNvbnN0IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnMgPSBieVR5cGUudGV4dEZvcm1hdC5maWx0ZXIodHJhbnNmb3JtZXIgPT4gdHJhbnNmb3JtZXIuZm9ybWF0Lmxlbmd0aCA9PT0gMSk7XG4gIHJldHVybiBub2RlID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IChub2RlIHx8ICRnZXRSb290KCkpLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4cG9ydFRvcExldmVsRWxlbWVudHMoY2hpbGQsIGJ5VHlwZS5lbGVtZW50LCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzLCBieVR5cGUudGV4dE1hdGNoKTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgLy8gc2VwZXJhdGUgY29uc2VjdXRpdmUgZ3JvdXAgb2YgdGV4dHMgd2l0aCBhIGxpbmUgYnJlYWs6IGVnLiBbXCJoZWxsb1wiLCBcIndvcmxkXCJdIC0+IFtcImhlbGxvXCIsIFwiL253b3JsZFwiXVxuICAgICAgICBpc05ld2xpbmVEZWxpbWl0ZWQgJiYgaSA+IDAgJiYgIWlzRW1wdHlQYXJhZ3JhcGgoY2hpbGQpICYmICFpc0VtcHR5UGFyYWdyYXBoKGNoaWxkcmVuW2kgLSAxXSkgPyAnXFxuJy5jb25jYXQocmVzdWx0KSA6IHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSBjb25zZWN1dGl2ZSBncm91cHMgb2YgdGV4dHMgYXJlIGF0bGVhc3QgXFxuXFxuIGFwYXJ0IHdoaWxlIGVhY2ggZW1wdHkgcGFyYWdyYXBoIHJlbmRlciBhcyBhIG5ld2xpbmUuXG4gICAgLy8gRWcuIFtcImhlbGxvXCIsIFwiXCIsIFwiXCIsIFwiaGlcIiwgXCJcXG53b3JsZFwiXSAtPiBcImhlbGxvXFxuXFxuXFxuaGlcXG5cXG53b3JsZFwiXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cG9ydFRvcExldmVsRWxlbWVudHMobm9kZSwgZWxlbWVudFRyYW5zZm9ybWVycywgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtZXIuZXhwb3J0KG5vZGUsIF9ub2RlID0+IGV4cG9ydENoaWxkcmVuKF9ub2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykpO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIGV4cG9ydENoaWxkcmVuKG5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfSBlbHNlIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3J0Q2hpbGRyZW4obm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICBtYWluTG9vcDogZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm1lci5leHBvcnQoY2hpbGQsIHBhcmVudE5vZGUgPT4gZXhwb3J0Q2hpbGRyZW4ocGFyZW50Tm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpLCAodGV4dE5vZGUsIHRleHRDb250ZW50KSA9PiBleHBvcnRUZXh0Rm9ybWF0KHRleHROb2RlLCB0ZXh0Q29udGVudCwgdGV4dFRyYW5zZm9ybWVyc0luZGV4KSk7XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goJ1xcbicpO1xuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICBvdXRwdXQucHVzaChleHBvcnRUZXh0Rm9ybWF0KGNoaWxkLCBjaGlsZC5nZXRUZXh0Q29udGVudCgpLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgpKTtcbiAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgLy8gZW1wdHkgcGFyYWdyYXBoIHJldHVybnMgXCJcIlxuICAgICAgb3V0cHV0LnB1c2goZXhwb3J0Q2hpbGRyZW4oY2hpbGQsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSk7XG4gICAgfSBlbHNlIGlmICgkaXNEZWNvcmF0b3JOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goY2hpbGQuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5mdW5jdGlvbiBleHBvcnRUZXh0Rm9ybWF0KG5vZGUsIHRleHRDb250ZW50LCB0ZXh0VHJhbnNmb3JtZXJzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0aGUgY2FzZSBvZiBhIHN0cmluZyBsb29raW5nIGxpa2UgdGhpczogXCIgICBmb28gICBcIlxuICAvLyBXaGVyZSBpdCB3b3VsZCBiZSBpbnZhbGlkIG1hcmtkb3duIHRvIGdlbmVyYXRlOiBcIioqICAgZm9vICAgKipcIlxuICAvLyBXZSBpbnN0ZWFkIHdhbnQgdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBvdXQsIGFwcGx5IGZvcm1hdHRpbmcsIGFuZCB0aGVuXG4gIC8vIGJyaW5nIHRoZSB3aGl0ZXNwYWNlIGJhY2suIFNvIG91ciByZXR1cm5lZCBzdHJpbmcgbG9va3MgbGlrZSB0aGlzOiBcIiAgICoqZm9vKiogICBcIlxuICBjb25zdCBmcm96ZW5TdHJpbmcgPSB0ZXh0Q29udGVudC50cmltKCk7XG4gIGxldCBvdXRwdXQgPSBmcm96ZW5TdHJpbmc7XG4gIGNvbnN0IGFwcGxpZWQgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRyYW5zZm9ybWVyLmZvcm1hdFswXTtcbiAgICBjb25zdCB0YWcgPSB0cmFuc2Zvcm1lci50YWc7XG4gICAgaWYgKGhhc0Zvcm1hdChub2RlLCBmb3JtYXQpICYmICFhcHBsaWVkLmhhcyhmb3JtYXQpKSB7XG4gICAgICAvLyBNdWx0aXBsZSB0YWdzIG1pZ2h0IGJlIHVzZWQgZm9yIHRoZSBzYW1lIGZvcm1hdCAoKiwgXylcbiAgICAgIGFwcGxpZWQuYWRkKGZvcm1hdCk7XG4gICAgICAvLyBQcmV2ZW50IGFkZGluZyBvcGVuaW5nIHRhZyBpcyBhbHJlYWR5IG9wZW5lZCBieSB0aGUgcHJldmlvdXMgc2libGluZ1xuICAgICAgY29uc3QgcHJldmlvdXNOb2RlID0gZ2V0VGV4dFNpYmxpbmcobm9kZSwgdHJ1ZSk7XG4gICAgICBpZiAoIWhhc0Zvcm1hdChwcmV2aW91c05vZGUsIGZvcm1hdCkpIHtcbiAgICAgICAgb3V0cHV0ID0gdGFnICsgb3V0cHV0O1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2ZW50IGFkZGluZyBjbG9zaW5nIHRhZyBpZiBuZXh0IHNpYmxpbmcgd2lsbCBkbyBpdFxuICAgICAgY29uc3QgbmV4dE5vZGUgPSBnZXRUZXh0U2libGluZyhub2RlLCBmYWxzZSk7XG4gICAgICBpZiAoIWhhc0Zvcm1hdChuZXh0Tm9kZSwgZm9ybWF0KSkge1xuICAgICAgICBvdXRwdXQgKz0gdGFnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlcGxhY2UgdHJpbW1lZCB2ZXJzaW9uIG9mIHRleHRDb250ZW50IGVuc3VyaW5nIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UgaXMgbm90IG1vZGlmaWVkXG4gIHJldHVybiB0ZXh0Q29udGVudC5yZXBsYWNlKGZyb3plblN0cmluZywgKCkgPT4gb3V0cHV0KTtcbn1cblxuLy8gR2V0IG5leHQgb3IgcHJldmlvdXMgdGV4dCBzaWJsaW5nIGEgdGV4dCBub2RlLCBpbmNsdWRpbmcgY2FzZXNcbi8vIHdoZW4gaXQncyBhIGNoaWxkIG9mIGlubGluZSBlbGVtZW50IChlLmcuIGxpbmspXG5mdW5jdGlvbiBnZXRUZXh0U2libGluZyhub2RlLCBiYWNrd2FyZCkge1xuICBsZXQgc2libGluZyA9IGJhY2t3YXJkID8gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgaWYgKCFzaWJsaW5nKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKHBhcmVudC5pc0lubGluZSgpKSB7XG4gICAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHNpYmxpbmcpIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgIGlmICghc2libGluZy5pc0lubGluZSgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVzY2VuZGFudCA9IGJhY2t3YXJkID8gc2libGluZy5nZXRMYXN0RGVzY2VuZGFudCgpIDogc2libGluZy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShkZXNjZW5kYW50KSkge1xuICAgICAgICByZXR1cm4gZGVzY2VuZGFudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IHNpYmxpbmcuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBzaWJsaW5nLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShzaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgfVxuICAgIGlmICghJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhc0Zvcm1hdChub2RlLCBmb3JtYXQpIHtcbiAgcmV0dXJuICRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaGFzRm9ybWF0KGZvcm1hdCk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbkNBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDT0RFX0JMT0NLX1JFR19FWFAgPSAvXlsgXFx0XSpgYGAoXFx3ezEsMTB9KT9cXHM/JC87XG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkltcG9ydCh0cmFuc2Zvcm1lcnMsIHNob3VsZFByZXNlcnZlTmV3TGluZXMgPSBmYWxzZSkge1xuICBjb25zdCBieVR5cGUgPSB0cmFuc2Zvcm1lcnNCeVR5cGUodHJhbnNmb3JtZXJzKTtcbiAgY29uc3QgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4ID0gY3JlYXRlVGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KGJ5VHlwZS50ZXh0Rm9ybWF0KTtcbiAgcmV0dXJuIChtYXJrZG93blN0cmluZywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gbWFya2Rvd25TdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGxpbmVzTGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuICAgIGNvbnN0IHJvb3QgPSBub2RlIHx8ICRnZXRSb290KCk7XG4gICAgcm9vdC5jbGVhcigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZVRleHQgPSBsaW5lc1tpXTtcbiAgICAgIC8vIENvZGVibG9ja3MgYXJlIHByb2Nlc3NlZCBmaXJzdCBhcyBhbnl0aGluZyBpbnNpZGUgc3VjaCBibG9ja1xuICAgICAgLy8gaXMgaWdub3JlZCBmb3IgZnVydGhlciBwcm9jZXNzaW5nXG4gICAgICAvLyBUT0RPOlxuICAgICAgLy8gQWJzdHJhY3QgaXQgdG8gYmUgZHluYW1pYyBhcyBvdGhlciB0cmFuc2Zvcm1lcnMgKGFkZCBtdWx0aWxpbmUgbWF0Y2ggb3B0aW9uKVxuICAgICAgY29uc3QgW2NvZGVCbG9ja05vZGUsIHNoaWZ0ZWRJbmRleF0gPSAkaW1wb3J0Q29kZUJsb2NrKGxpbmVzLCBpLCByb290KTtcbiAgICAgIGlmIChjb2RlQmxvY2tOb2RlICE9IG51bGwpIHtcbiAgICAgICAgaSA9IHNoaWZ0ZWRJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAkaW1wb3J0QmxvY2tzKGxpbmVUZXh0LCByb290LCBieVR5cGUuZWxlbWVudCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCBieVR5cGUudGV4dE1hdGNoKTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCByZW1vdmluZyBlbXB0eSBwYXJhZ3JhcGhzIGFzIG1kIGRvZXMgbm90IHJlYWxseVxuICAgIC8vIGFsbG93IGVtcHR5IGxpbmVzIGFuZCB1c2VzIHRoZW0gYXMgZGVsaW1pdGVyLlxuICAgIC8vIElmIHlvdSBuZWVkIGVtcHR5IGxpbmVzIHNldCBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzID0gdHJ1ZS5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIXNob3VsZFByZXNlcnZlTmV3TGluZXMgJiYgaXNFbXB0eVBhcmFncmFwaChjaGlsZCkgJiYgcm9vdC5nZXRDaGlsZHJlblNpemUoKSA+IDEpIHtcbiAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwpIHtcbiAgICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gJGltcG9ydEJsb2NrcyhsaW5lVGV4dCwgcm9vdE5vZGUsIGVsZW1lbnRUcmFuc2Zvcm1lcnMsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGxpbmVUZXh0VHJpbW1lZCA9IGxpbmVUZXh0LnRyaW0oKTtcbiAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUobGluZVRleHRUcmltbWVkKTtcbiAgY29uc3QgZWxlbWVudE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBlbGVtZW50Tm9kZS5hcHBlbmQodGV4dE5vZGUpO1xuICByb290Tm9kZS5hcHBlbmQoZWxlbWVudE5vZGUpO1xuICBmb3IgKGNvbnN0IHtcbiAgICByZWdFeHAsXG4gICAgcmVwbGFjZVxuICB9IG9mIGVsZW1lbnRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IGxpbmVUZXh0Lm1hdGNoKHJlZ0V4cCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0ZXh0Tm9kZS5zZXRUZXh0Q29udGVudChsaW5lVGV4dC5zbGljZShtYXRjaFswXS5sZW5ndGgpKTtcbiAgICAgIHJlcGxhY2UoZWxlbWVudE5vZGUsIFt0ZXh0Tm9kZV0sIG1hdGNoLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKHRleHROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG5cbiAgLy8gSWYgbm8gdHJhbnNmb3JtZXIgZm91bmQgYW5kIHdlIGxlZnQgd2l0aCBvcmlnaW5hbCBwYXJhZ3JhcGggbm9kZVxuICAvLyBjYW4gY2hlY2sgaWYgaXRzIGNvbnRlbnQgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91cyBub2RlXG4gIC8vIGlmIGl0J3MgYSBwYXJhZ3JhcGgsIHF1b3RlIG9yIGxpc3RcbiAgaWYgKGVsZW1lbnROb2RlLmlzQXR0YWNoZWQoKSAmJiBsaW5lVGV4dFRyaW1tZWQubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IGVsZW1lbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmICgkaXNQYXJhZ3JhcGhOb2RlKHByZXZpb3VzTm9kZSkgfHwgJGlzUXVvdGVOb2RlKHByZXZpb3VzTm9kZSkgfHwgJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgbGV0IHRhcmdldE5vZGUgPSBwcmV2aW91c05vZGU7XG4gICAgICBpZiAoJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHByZXZpb3VzTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICBpZiAobGFzdERlc2NlbmRhbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldE5vZGUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGxhc3REZXNjZW5kYW50LCAkaXNMaXN0SXRlbU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0Tm9kZSAhPSBudWxsICYmIHRhcmdldE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgPiAwKSB7XG4gICAgICAgIHRhcmdldE5vZGUuc3BsaWNlKHRhcmdldE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIFskY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5lbGVtZW50Tm9kZS5nZXRDaGlsZHJlbigpXSk7XG4gICAgICAgIGVsZW1lbnROb2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGltcG9ydENvZGVCbG9jayhsaW5lcywgc3RhcnRMaW5lSW5kZXgsIHJvb3ROb2RlKSB7XG4gIGNvbnN0IG9wZW5NYXRjaCA9IGxpbmVzW3N0YXJ0TGluZUluZGV4XS5tYXRjaChDT0RFX0JMT0NLX1JFR19FWFApO1xuICBpZiAob3Blbk1hdGNoKSB7XG4gICAgbGV0IGVuZExpbmVJbmRleCA9IHN0YXJ0TGluZUluZGV4O1xuICAgIGNvbnN0IGxpbmVzTGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2VuZExpbmVJbmRleCA8IGxpbmVzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBjbG9zZU1hdGNoID0gbGluZXNbZW5kTGluZUluZGV4XS5tYXRjaChDT0RFX0JMT0NLX1JFR19FWFApO1xuICAgICAgaWYgKGNsb3NlTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgY29kZUJsb2NrTm9kZSA9ICRjcmVhdGVDb2RlTm9kZShvcGVuTWF0Y2hbMV0pO1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsaW5lcy5zbGljZShzdGFydExpbmVJbmRleCArIDEsIGVuZExpbmVJbmRleCkuam9pbignXFxuJykpO1xuICAgICAgICBjb2RlQmxvY2tOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgIHJvb3ROb2RlLmFwcGVuZChjb2RlQmxvY2tOb2RlKTtcbiAgICAgICAgcmV0dXJuIFtjb2RlQmxvY2tOb2RlLCBlbmRMaW5lSW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW251bGwsIHN0YXJ0TGluZUluZGV4XTtcbn1cblxuLy8gUHJvY2Vzc2luZyB0ZXh0IGNvbnRlbnQgYW5kIHJlcGxhY2VzIHRleHQgZm9ybWF0IHRhZ3MuXG4vLyBJdCB0YWtlcyBvdXRlcm1vc3QgdGFnIG1hdGNoIGFuZCBpdHMgY29udGVudCwgY3JlYXRlcyB0ZXh0IG5vZGUgd2l0aFxuLy8gZm9ybWF0IGJhc2VkIG9uIHRhZyBhbmQgdGhlbiByZWN1cnNpdmVseSBleGVjdXRlZCBvdmVyIG5vZGUncyBjb250ZW50XG4vL1xuLy8gRS5nLiBmb3IgXCIqSGVsbG8gKip3b3JsZCoqISpcIiBzdHJpbmcgaXQgd2lsbCBjcmVhdGUgdGV4dCBub2RlIHdpdGhcbi8vIFwiSGVsbG8gKip3b3JsZCoqIVwiIGNvbnRlbnQgYW5kIGl0YWxpYyBmb3JtYXQgYW5kIHJ1biByZWN1cnNpdmVseSBvdmVyXG4vLyBpdHMgY29udGVudCB0byB0cmFuc2Zvcm0gXCIqKndvcmxkKipcIiBwYXJ0XG5mdW5jdGlvbiBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKHRleHROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRleHROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IG1hdGNoID0gZmluZE91dGVybW9zdE1hdGNoKHRleHRDb250ZW50LCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgLy8gT25jZSB0ZXh0IGZvcm1hdCBwcm9jZXNzaW5nIGlzIGRvbmUgcnVuIHRleHQgbWF0Y2ggdHJhbnNmb3JtZXJzLCBhcyBpdFxuICAgIC8vIG9ubHkgY2FuIHNwYW4gd2l0aGluIHNpbmdsZSB0ZXh0IG5vZGUgKHVubGluZSBmb3JtYXRzIHRoYXQgY2FuIGNvdmVyIG11bHRpcGxlIG5vZGVzKVxuICAgIGltcG9ydFRleHRNYXRjaFRyYW5zZm9ybWVycyh0ZXh0Tm9kZSwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGN1cnJlbnROb2RlLCByZW1haW5kZXJOb2RlLCBsZWFkaW5nTm9kZTtcblxuICAvLyBJZiBtYXRjaGluZyBmdWxsIGNvbnRlbnQgdGhlcmUncyBubyBuZWVkIHRvIHJ1biBzcGxpdFRleHQgYW5kIGNhbiByZXVzZSBleGlzdGluZyB0ZXh0Tm9kZVxuICAvLyB0byB1cGRhdGUgaXRzIGNvbnRlbnQgYW5kIGFwcGx5IGZvcm1hdC4gRS5nLiBmb3IgKipfSGVsbG9fKiogc3RyaW5nIGFmdGVyIGFwcGx5aW5nIGJvbGRcbiAgLy8gZm9ybWF0ICgqKikgaXQgd2lsbCByZXVzZSB0aGUgc2FtZSB0ZXh0IG5vZGUgdG8gYXBwbHkgaXRhbGljIChfKVxuICBpZiAobWF0Y2hbMF0gPT09IHRleHRDb250ZW50KSB7XG4gICAgY3VycmVudE5vZGUgPSB0ZXh0Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gbWF0Y2guaW5kZXggfHwgMDtcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgIFtjdXJyZW50Tm9kZSwgcmVtYWluZGVyTm9kZV0gPSB0ZXh0Tm9kZS5zcGxpdFRleHQoZW5kSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBbbGVhZGluZ05vZGUsIGN1cnJlbnROb2RlLCByZW1haW5kZXJOb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnROb2RlLnNldFRleHRDb250ZW50KG1hdGNoWzJdKTtcbiAgY29uc3QgdHJhbnNmb3JtZXIgPSB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgudHJhbnNmb3JtZXJzQnlUYWdbbWF0Y2hbMV1dO1xuICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiB0cmFuc2Zvcm1lci5mb3JtYXQpIHtcbiAgICAgIGlmICghY3VycmVudE5vZGUuaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgY3VycmVudE5vZGUudG9nZ2xlRm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVjdXJzaXZlbHkgcnVuIG92ZXIgaW5uZXIgdGV4dCBpZiBpdCdzIG5vdCBpbmxpbmUgY29kZVxuICBpZiAoIWN1cnJlbnROb2RlLmhhc0Zvcm1hdCgnY29kZScpKSB7XG4gICAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyhjdXJyZW50Tm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICB9XG5cbiAgLy8gUnVuIG92ZXIgbGVhZGluZy9yZW1haW5pbmcgdGV4dCBpZiBhbnlcbiAgaWYgKGxlYWRpbmdOb2RlKSB7XG4gICAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyhsZWFkaW5nTm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICB9XG4gIGlmIChyZW1haW5kZXJOb2RlKSB7XG4gICAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyhyZW1haW5kZXJOb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGltcG9ydFRleHRNYXRjaFRyYW5zZm9ybWVycyh0ZXh0Tm9kZV8sIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBsZXQgdGV4dE5vZGUgPSB0ZXh0Tm9kZV87XG4gIG1haW5Mb29wOiB3aGlsZSAodGV4dE5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICAgICAgY29uc3QgbWF0Y2ggPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpLm1hdGNoKHRyYW5zZm9ybWVyLmltcG9ydFJlZ0V4cCk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBsZXQgcmVwbGFjZU5vZGUsIG5ld1RleHROb2RlO1xuICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgW3JlcGxhY2VOb2RlLCB0ZXh0Tm9kZV0gPSB0ZXh0Tm9kZS5zcGxpdFRleHQoZW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWywgcmVwbGFjZU5vZGUsIG5ld1RleHROb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAobmV3VGV4dE5vZGUpIHtcbiAgICAgICAgaW1wb3J0VGV4dE1hdGNoVHJhbnNmb3JtZXJzKG5ld1RleHROb2RlLCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtZXIucmVwbGFjZShyZXBsYWNlTm9kZSwgbWF0Y2gpO1xuICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG59XG5cbi8vIEZpbmRzIGZpcnN0IFwiPHRhZz5jb250ZW50PHRhZz5cIiBtYXRjaCB0aGF0IGlzIG5vdCBuZXN0ZWQgaW50byBhbm90aGVyIHRhZ1xuZnVuY3Rpb24gZmluZE91dGVybW9zdE1hdGNoKHRleHRDb250ZW50LCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgpIHtcbiAgY29uc3Qgb3BlblRhZ3NNYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHRleHRUcmFuc2Zvcm1lcnNJbmRleC5vcGVuVGFnc1JlZ0V4cCk7XG4gIGlmIChvcGVuVGFnc01hdGNoID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG9wZW5UYWdzTWF0Y2gpIHtcbiAgICAvLyBPcGVuIHRhZ3MgcmVnIGV4cCBtaWdodCBjYXB0dXJlIGxlYWRpbmcgc3BhY2Ugc28gcmVtb3ZpbmcgaXRcbiAgICAvLyBiZWZvcmUgdXNpbmcgbWF0Y2ggdG8gZmluZCB0cmFuc2Zvcm1lclxuICAgIGNvbnN0IHRhZyA9IG1hdGNoLnJlcGxhY2UoL15cXHMvLCAnJyk7XG4gICAgY29uc3QgZnVsbE1hdGNoUmVnRXhwID0gdGV4dFRyYW5zZm9ybWVyc0luZGV4LmZ1bGxNYXRjaFJlZ0V4cEJ5VGFnW3RhZ107XG4gICAgaWYgKGZ1bGxNYXRjaFJlZ0V4cCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZnVsbE1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2goZnVsbE1hdGNoUmVnRXhwKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHRleHRUcmFuc2Zvcm1lcnNJbmRleC50cmFuc2Zvcm1lcnNCeVRhZ1t0YWddO1xuICAgIGlmIChmdWxsTWF0Y2ggIT0gbnVsbCAmJiB0cmFuc2Zvcm1lciAhPSBudWxsKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXIuaW50cmF3b3JkICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZnVsbE1hdGNoO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3Igbm9uLWludHJhd29yZCB0cmFuc2Zvcm1lcnMgY2hlY2tpbmcgaWYgaXQncyB3aXRoaW4gYSB3b3JkXG4gICAgICAvLyBvciBzdXJyb3VuZGVkIHdpdGggc3BhY2UvcHVuY3R1YXRpb24vbmV3bGluZVxuICAgICAgY29uc3Qge1xuICAgICAgICBpbmRleCA9IDBcbiAgICAgIH0gPSBmdWxsTWF0Y2g7XG4gICAgICBjb25zdCBiZWZvcmVDaGFyID0gdGV4dENvbnRlbnRbaW5kZXggLSAxXTtcbiAgICAgIGNvbnN0IGFmdGVyQ2hhciA9IHRleHRDb250ZW50W2luZGV4ICsgZnVsbE1hdGNoWzBdLmxlbmd0aF07XG4gICAgICBpZiAoKCFiZWZvcmVDaGFyIHx8IFBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYmVmb3JlQ2hhcikpICYmICghYWZ0ZXJDaGFyIHx8IFBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYWZ0ZXJDaGFyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGxNYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgodGV4dFRyYW5zZm9ybWVycykge1xuICBjb25zdCB0cmFuc2Zvcm1lcnNCeVRhZyA9IHt9O1xuICBjb25zdCBmdWxsTWF0Y2hSZWdFeHBCeVRhZyA9IHt9O1xuICBjb25zdCBvcGVuVGFnc1JlZ0V4cCA9IFtdO1xuICBjb25zdCBlc2NhcGVSZWdFeHAgPSBgKD88IVtcXFxcXFxcXF0pYDtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0ZXh0VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnXG4gICAgfSA9IHRyYW5zZm9ybWVyO1xuICAgIHRyYW5zZm9ybWVyc0J5VGFnW3RhZ10gPSB0cmFuc2Zvcm1lcjtcbiAgICBjb25zdCB0YWdSZWdFeHAgPSB0YWcucmVwbGFjZSgvKFxcKnxcXF58XFwrKS9nLCAnXFxcXCQxJyk7XG4gICAgb3BlblRhZ3NSZWdFeHAucHVzaCh0YWdSZWdFeHApO1xuICAgIGlmIChJU19TQUZBUkkgfHwgSVNfSU9TIHx8IElTX0FQUExFX1dFQktJVCkge1xuICAgICAgZnVsbE1hdGNoUmVnRXhwQnlUYWdbdGFnXSA9IG5ldyBSZWdFeHAoYCgke3RhZ1JlZ0V4cH0pKD8hWyR7dGFnUmVnRXhwfVxcXFxzXSkoLio/W14ke3RhZ1JlZ0V4cH1cXFxcc10pJHt0YWdSZWdFeHB9KD8hJHt0YWdSZWdFeHB9KWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxsTWF0Y2hSZWdFeHBCeVRhZ1t0YWddID0gbmV3IFJlZ0V4cChgKD88IVtcXFxcXFxcXCR7dGFnUmVnRXhwfV0pKCR7dGFnUmVnRXhwfSkoKFxcXFxcXFxcJHt0YWdSZWdFeHB9KT8uKj9bXiR7dGFnUmVnRXhwfVxcXFxzXShcXFxcXFxcXCR7dGFnUmVnRXhwfSk/KSgoPzwhXFxcXFxcXFwpfCg/PD1cXFxcXFxcXFxcXFxcXFxcKSkoJHt0YWdSZWdFeHB9KSg/IVtcXFxcXFxcXCR7dGFnUmVnRXhwfV0pYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUmVnIGV4cCB0byBmaW5kIG9wZW4gdGFnICsgY29udGVudCArIGNsb3NlIHRhZ1xuICAgIGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnLFxuICAgIC8vIFJlZyBleHAgdG8gZmluZCBvcGVuaW5nIHRhZ3NcbiAgICBvcGVuVGFnc1JlZ0V4cDogbmV3IFJlZ0V4cCgoSVNfU0FGQVJJIHx8IElTX0lPUyB8fCBJU19BUFBMRV9XRUJLSVQgPyAnJyA6IGAke2VzY2FwZVJlZ0V4cH1gKSArICcoJyArIG9wZW5UYWdzUmVnRXhwLmpvaW4oJ3wnKSArICcpJywgJ2cnKSxcbiAgICB0cmFuc2Zvcm1lcnNCeVRhZ1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHJ1bkVsZW1lbnRUcmFuc2Zvcm1lcnMocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGdyYW5kUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZFBhcmVudE5vZGUpIHx8IHBhcmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBhbmNob3JOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gIC8vIENoZWNraW5nIGZvciBhbmNob3JPZmZzZXQgcG9zaXRpb24gdG8gcHJldmVudCBhbnkgY2hlY2tzIGZvciBjYXNlcyB3aGVuIGNhcmV0IGlzIHRvbyBmYXJcbiAgLy8gZnJvbSBhIGxpbmUgc3RhcnQgdG8gYmUgYSBwYXJ0IG9mIGJsb2NrLWxldmVsIG1hcmtkb3duIHRyaWdnZXIuXG4gIC8vXG4gIC8vIFRPRE86XG4gIC8vIENhbiBoYXZlIGEgcXVpY2sgY2hlY2sgaWYgY2FyZXQgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyAoZS5nLiBvZmZzZXQgbGVzcyB0aGFuIDEwLTIwKVxuICAvLyBzaW5jZSBvdGhlcndpc2UgaXQgd29uJ3QgYmUgYSBtYXJrZG93biBzaG9ydGN1dCwgYnV0IHRhYmxlcyBhcmUgZXhjZXB0aW9uXG4gIGlmICh0ZXh0Q29udGVudFthbmNob3JPZmZzZXQgLSAxXSAhPT0gJyAnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qge1xuICAgIHJlZ0V4cCxcbiAgICByZXBsYWNlXG4gIH0gb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IG1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2gocmVnRXhwKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICBjb25zdCBbbGVhZGluZ05vZGUsIHJlbWFpbmRlck5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoYW5jaG9yT2Zmc2V0KTtcbiAgICAgIGxlYWRpbmdOb2RlLnJlbW92ZSgpO1xuICAgICAgY29uc3Qgc2libGluZ3MgPSByZW1haW5kZXJOb2RlID8gW3JlbWFpbmRlck5vZGUsIC4uLm5leHRTaWJsaW5nc10gOiBuZXh0U2libGluZ3M7XG4gICAgICByZXBsYWNlKHBhcmVudE5vZGUsIHNpYmxpbmdzLCBtYXRjaCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJ1blRleHRNYXRjaFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRyYW5zZm9ybWVyc0J5VHJpZ2dlcikge1xuICBsZXQgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGxhc3RDaGFyID0gdGV4dENvbnRlbnRbYW5jaG9yT2Zmc2V0IC0gMV07XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IHRyYW5zZm9ybWVyc0J5VHJpZ2dlcltsYXN0Q2hhcl07XG4gIGlmICh0cmFuc2Zvcm1lcnMgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIHR5cGluZyBpbiB0aGUgbWlkZGxlIG9mIGNvbnRlbnQsIHJlbW92ZSB0aGUgdGFpbCB0byBkb1xuICAvLyByZWcgZXhwIG1hdGNoIHVwIHRvIGEgc3RyaW5nIGVuZCAoY2FyZXQgcG9zaXRpb24pXG4gIGlmIChhbmNob3JPZmZzZXQgPCB0ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIGFuY2hvck9mZnNldCk7XG4gIH1cbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHRyYW5zZm9ybWVyLnJlZ0V4cCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIGxldCByZXBsYWNlTm9kZTtcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgW3JlcGxhY2VOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGVuZEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgWywgcmVwbGFjZU5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cbiAgICByZXBsYWNlTm9kZS5zZWxlY3ROZXh0KDAsIDApO1xuICAgIHRyYW5zZm9ybWVyLnJlcGxhY2UocmVwbGFjZU5vZGUsIG1hdGNoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkcnVuVGV4dEZvcm1hdFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGNsb3NlVGFnRW5kSW5kZXggPSBhbmNob3JPZmZzZXQgLSAxO1xuICBjb25zdCBjbG9zZUNoYXIgPSB0ZXh0Q29udGVudFtjbG9zZVRhZ0VuZEluZGV4XTtcbiAgLy8gUXVpY2sgY2hlY2sgaWYgd2UncmUgcG9zc2libHkgYXQgdGhlIGVuZCBvZiBpbmxpbmUgbWFya2Rvd24gc3R5bGVcbiAgY29uc3QgbWF0Y2hlcnMgPSB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzW2Nsb3NlQ2hhcl07XG4gIGlmICghbWF0Y2hlcnMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaGVyIG9mIG1hdGNoZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnXG4gICAgfSA9IG1hdGNoZXI7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gdGFnLmxlbmd0aDtcbiAgICBjb25zdCBjbG9zZVRhZ1N0YXJ0SW5kZXggPSBjbG9zZVRhZ0VuZEluZGV4IC0gdGFnTGVuZ3RoICsgMTtcblxuICAgIC8vIElmIHRhZyBpcyBub3Qgc2luZ2xlIGNoYXIgY2hlY2sgaWYgcmVzdCBvZiBpdCBtYXRjaGVzIHdpdGggdGV4dCBjb250ZW50XG4gICAgaWYgKHRhZ0xlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghaXNFcXVhbFN1YlN0cmluZyh0ZXh0Q29udGVudCwgY2xvc2VUYWdTdGFydEluZGV4LCB0YWcsIDAsIHRhZ0xlbmd0aCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BhY2UgYmVmb3JlIGNsb3NpbmcgdGFnIGNhbmNlbHMgaW5saW5lIG1hcmtkb3duXG4gICAgaWYgKHRleHRDb250ZW50W2Nsb3NlVGFnU3RhcnRJbmRleCAtIDFdID09PSAnICcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gbm90IGJlIHVzZWQgd2l0aGluIHdvcmRzLCBoZW5jZSBzaG91bGQgaGF2ZSBuZXdsaW5lL3NwYWNlL3B1bmN0dWF0aW9uIGFmdGVyIGl0XG4gICAgY29uc3QgYWZ0ZXJDbG9zZVRhZ0NoYXIgPSB0ZXh0Q29udGVudFtjbG9zZVRhZ0VuZEluZGV4ICsgMV07XG4gICAgaWYgKG1hdGNoZXIuaW50cmF3b3JkID09PSBmYWxzZSAmJiBhZnRlckNsb3NlVGFnQ2hhciAmJiAhUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChhZnRlckNsb3NlVGFnQ2hhcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjbG9zZU5vZGUgPSBhbmNob3JOb2RlO1xuICAgIGxldCBvcGVuTm9kZSA9IGNsb3NlTm9kZTtcbiAgICBsZXQgb3BlblRhZ1N0YXJ0SW5kZXggPSBnZXRPcGVuVGFnU3RhcnRJbmRleCh0ZXh0Q29udGVudCwgY2xvc2VUYWdTdGFydEluZGV4LCB0YWcpO1xuXG4gICAgLy8gR28gdGhyb3VnaCB0ZXh0IG5vZGUgc2libGluZ3MgYW5kIHNlYXJjaCBmb3Igb3BlbmluZyB0YWdcbiAgICAvLyBpZiBoYXZlbid0IGZvdW5kIGl0IHdpdGhpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgYXMgY2xvc2luZyB0YWdcbiAgICBsZXQgc2libGluZyA9IG9wZW5Ob2RlO1xuICAgIHdoaWxlIChvcGVuVGFnU3RhcnRJbmRleCA8IDAgJiYgKHNpYmxpbmcgPSBzaWJsaW5nLmdldFByZXZpb3VzU2libGluZygpKSkge1xuICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUoc2libGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc2libGluZykpIHtcbiAgICAgICAgY29uc3Qgc2libGluZ1RleHRDb250ZW50ID0gc2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBvcGVuTm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIG9wZW5UYWdTdGFydEluZGV4ID0gZ2V0T3BlblRhZ1N0YXJ0SW5kZXgoc2libGluZ1RleHRDb250ZW50LCBzaWJsaW5nVGV4dENvbnRlbnQubGVuZ3RoLCB0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wZW5pbmcgdGFnIGlzIG5vdCBmb3VuZFxuICAgIGlmIChvcGVuVGFnU3RhcnRJbmRleCA8IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE5vIGNvbnRlbnQgYmV0d2VlbiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ1xuICAgIGlmIChvcGVuTm9kZSA9PT0gY2xvc2VOb2RlICYmIG9wZW5UYWdTdGFydEluZGV4ICsgdGFnTGVuZ3RoID09PSBjbG9zZVRhZ1N0YXJ0SW5kZXgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNraW5nIGxvbmdlciB0YWdzIGZvciByZXBlYXRpbmcgY2hhcnMgKGUuZy4gKioqIHZzICoqKVxuICAgIGNvbnN0IHByZXZPcGVuTm9kZVRleHQgPSBvcGVuTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmIChvcGVuVGFnU3RhcnRJbmRleCA+IDAgJiYgcHJldk9wZW5Ob2RlVGV4dFtvcGVuVGFnU3RhcnRJbmRleCAtIDFdID09PSBjbG9zZUNoYXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gbm90IGJlIHVzZWQgd2l0aGluIHdvcmRzLCBoZW5jZSBzaG91bGQgaGF2ZSBuZXdsaW5lL3NwYWNlL3B1bmN0dWF0aW9uIGJlZm9yZSBpdFxuICAgIGNvbnN0IGJlZm9yZU9wZW5UYWdDaGFyID0gcHJldk9wZW5Ob2RlVGV4dFtvcGVuVGFnU3RhcnRJbmRleCAtIDFdO1xuICAgIGlmIChtYXRjaGVyLmludHJhd29yZCA9PT0gZmFsc2UgJiYgYmVmb3JlT3BlblRhZ0NoYXIgJiYgIVBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYmVmb3JlT3BlblRhZ0NoYXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB0ZXh0IGZyb20gb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIChzdGFydGluZyBmcm9tIGNsb3NpbmcgdGFnXG4gICAgLy8gdG8gcHJldmVudCBhbnkgb2Zmc2V0IHNoaWZ0cyBpZiB3ZSBzdGFydCBmcm9tIG9wZW5pbmcgb25lKVxuICAgIGNvbnN0IHByZXZDbG9zZU5vZGVUZXh0ID0gY2xvc2VOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgY2xvc2VOb2RlVGV4dCA9IHByZXZDbG9zZU5vZGVUZXh0LnNsaWNlKDAsIGNsb3NlVGFnU3RhcnRJbmRleCkgKyBwcmV2Q2xvc2VOb2RlVGV4dC5zbGljZShjbG9zZVRhZ0VuZEluZGV4ICsgMSk7XG4gICAgY2xvc2VOb2RlLnNldFRleHRDb250ZW50KGNsb3NlTm9kZVRleHQpO1xuICAgIGNvbnN0IG9wZW5Ob2RlVGV4dCA9IG9wZW5Ob2RlID09PSBjbG9zZU5vZGUgPyBjbG9zZU5vZGVUZXh0IDogcHJldk9wZW5Ob2RlVGV4dDtcbiAgICBvcGVuTm9kZS5zZXRUZXh0Q29udGVudChvcGVuTm9kZVRleHQuc2xpY2UoMCwgb3BlblRhZ1N0YXJ0SW5kZXgpICsgb3Blbk5vZGVUZXh0LnNsaWNlKG9wZW5UYWdTdGFydEluZGV4ICsgdGFnTGVuZ3RoKSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IG5leHRTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICAkc2V0U2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pO1xuICAgIC8vIEFkanVzdCBvZmZzZXQgYmFzZWQgb24gZGVsZXRlZCBjaGFyc1xuICAgIGNvbnN0IG5ld09mZnNldCA9IGNsb3NlVGFnRW5kSW5kZXggLSB0YWdMZW5ndGggKiAob3Blbk5vZGUgPT09IGNsb3NlTm9kZSA/IDIgOiAxKSArIDE7XG4gICAgbmV4dFNlbGVjdGlvbi5hbmNob3Iuc2V0KG9wZW5Ob2RlLl9fa2V5LCBvcGVuVGFnU3RhcnRJbmRleCwgJ3RleHQnKTtcbiAgICBuZXh0U2VsZWN0aW9uLmZvY3VzLnNldChjbG9zZU5vZGUuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcblxuICAgIC8vIEFwcGx5IGZvcm1hdHRpbmcgdG8gc2VsZWN0ZWQgdGV4dFxuICAgIGZvciAoY29uc3QgZm9ybWF0IG9mIG1hdGNoZXIuZm9ybWF0KSB7XG4gICAgICBpZiAoIW5leHRTZWxlY3Rpb24uaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgbmV4dFNlbGVjdGlvbi5mb3JtYXRUZXh0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29sbGFwc2Ugc2VsZWN0aW9uIHVwIHRvIHRoZSBmb2N1cyBwb2ludFxuICAgIG5leHRTZWxlY3Rpb24uYW5jaG9yLnNldChuZXh0U2VsZWN0aW9uLmZvY3VzLmtleSwgbmV4dFNlbGVjdGlvbi5mb2N1cy5vZmZzZXQsIG5leHRTZWxlY3Rpb24uZm9jdXMudHlwZSk7XG5cbiAgICAvLyBSZW1vdmUgZm9ybWF0dGluZyBmcm9tIGNvbGxhcHNlZCBzZWxlY3Rpb25cbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBtYXRjaGVyLmZvcm1hdCkge1xuICAgICAgaWYgKG5leHRTZWxlY3Rpb24uaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgbmV4dFNlbGVjdGlvbi50b2dnbGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIG5leHRTZWxlY3Rpb24uZm9ybWF0ID0gc2VsZWN0aW9uLmZvcm1hdDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0T3BlblRhZ1N0YXJ0SW5kZXgoc3RyaW5nLCBtYXhJbmRleCwgdGFnKSB7XG4gIGNvbnN0IHRhZ0xlbmd0aCA9IHRhZy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBtYXhJbmRleDsgaSA+PSB0YWdMZW5ndGg7IGktLSkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpIC0gdGFnTGVuZ3RoO1xuICAgIGlmIChpc0VxdWFsU3ViU3RyaW5nKHN0cmluZywgc3RhcnRJbmRleCwgdGFnLCAwLCB0YWdMZW5ndGgpICYmXG4gICAgLy8gU3BhY2UgYWZ0ZXIgb3BlbmluZyB0YWcgY2FuY2VscyB0cmFuc2Zvcm1hdGlvblxuICAgIHN0cmluZ1tzdGFydEluZGV4ICsgdGFnTGVuZ3RoXSAhPT0gJyAnKSB7XG4gICAgICByZXR1cm4gc3RhcnRJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gaXNFcXVhbFN1YlN0cmluZyhzdHJpbmdBLCBhU3RhcnQsIHN0cmluZ0IsIGJTdGFydCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nQVthU3RhcnQgKyBpXSAhPT0gc3RyaW5nQltiU3RhcnQgKyBpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTWFya2Rvd25TaG9ydGN1dHMoZWRpdG9yLCB0cmFuc2Zvcm1lcnMgPSBUUkFOU0ZPUk1FUlMpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7XG4gIGNvbnN0IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCA9IGluZGV4QnkoYnlUeXBlLnRleHRGb3JtYXQsICh7XG4gICAgdGFnXG4gIH0pID0+IHRhZ1t0YWcubGVuZ3RoIC0gMV0pO1xuICBjb25zdCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnNJbmRleCA9IGluZGV4QnkoYnlUeXBlLnRleHRNYXRjaCwgKHtcbiAgICB0cmlnZ2VyXG4gIH0pID0+IHRyaWdnZXIpO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IHR5cGUgPSB0cmFuc2Zvcm1lci50eXBlO1xuICAgIGlmICh0eXBlID09PSAnZWxlbWVudCcgfHwgdHlwZSA9PT0gJ3RleHQtbWF0Y2gnKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSB0cmFuc2Zvcm1lci5kZXBlbmRlbmNpZXM7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmICghZWRpdG9yLmhhc05vZGUobm9kZSkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTWFya2Rvd25TaG9ydGN1dHM6IG1pc3NpbmcgZGVwZW5kZW5jeSAke25vZGUuZ2V0VHlwZSgpfSBmb3IgdHJhbnNmb3JtZXIuIEVuc3VyZSBub2RlIGRlcGVuZGVuY3kgaXMgaW5jbHVkZWQgaW4gZWRpdG9yIGluaXRpYWwgY29uZmlnLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCAkdHJhbnNmb3JtID0gKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgPT4ge1xuICAgIGlmIChydW5FbGVtZW50VHJhbnNmb3JtZXJzKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgYnlUeXBlLmVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChydW5UZXh0TWF0Y2hUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnNJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgJHJ1blRleHRGb3JtYXRUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICB0YWdzLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZVxuICB9KSA9PiB7XG4gICAgLy8gSWdub3JlIHVwZGF0ZXMgZnJvbSBjb2xsYWJvcmF0aW9uIGFuZCB1bmRvL3JlZG8gKGFzIGNoYW5nZXMgYWxyZWFkeSBjYWxjdWxhdGVkKVxuICAgIGlmICh0YWdzLmhhcygnY29sbGFib3JhdGlvbicpIHx8IHRhZ3MuaGFzKCdoaXN0b3JpYycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZWRpdG9yIGlzIHN0aWxsIGNvbXBvc2luZyAoaS5lLiBiYWNrdGlja3MpIHdlIG11c3Qgd2FpdCBiZWZvcmUgdGhlIHVzZXIgY29uZmlybXMgdGhlIGtleVxuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5yZWFkKCRnZXRTZWxlY3Rpb24pO1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUucmVhZCgkZ2V0U2VsZWN0aW9uKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pIHx8ICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JLZXkgPSBzZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gZWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGFuY2hvcktleSk7XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSB8fCAhZGlydHlMZWF2ZXMuaGFzKGFuY2hvcktleSkgfHwgYW5jaG9yT2Zmc2V0ICE9PSAxICYmIGFuY2hvck9mZnNldCA+IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCArIDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAvLyBNYXJrZG93biBpcyBub3QgYXZhaWxhYmxlIGluc2lkZSBjb2RlXG4gICAgICBpZiAoYW5jaG9yTm9kZS5oYXNGb3JtYXQoJ2NvZGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsIHx8ICRpc0NvZGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgICR0cmFuc2Zvcm0ocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBjcmVhdGVCbG9ja05vZGUgPSBjcmVhdGVOb2RlID0+IHtcbiAgcmV0dXJuIChwYXJlbnROb2RlLCBjaGlsZHJlbiwgbWF0Y2gpID0+IHtcbiAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZShtYXRjaCk7XG4gICAgbm9kZS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgIHBhcmVudE5vZGUucmVwbGFjZShub2RlKTtcbiAgICBub2RlLnNlbGVjdCgwLCAwKTtcbiAgfTtcbn07XG5cbi8vIEFtb3VudCBvZiBzcGFjZXMgdGhhdCBkZWZpbmUgaW5kZW50YXRpb24gbGV2ZWxcbi8vIFRPRE86IHNob3VsZCBiZSBhbiBvcHRpb25cbmNvbnN0IExJU1RfSU5ERU5UX1NJWkUgPSA0O1xuZnVuY3Rpb24gZ2V0SW5kZW50KHdoaXRlc3BhY2VzKSB7XG4gIGNvbnN0IHRhYnMgPSB3aGl0ZXNwYWNlcy5tYXRjaCgvXFx0L2cpO1xuICBjb25zdCBzcGFjZXMgPSB3aGl0ZXNwYWNlcy5tYXRjaCgvIC9nKTtcbiAgbGV0IGluZGVudCA9IDA7XG4gIGlmICh0YWJzKSB7XG4gICAgaW5kZW50ICs9IHRhYnMubGVuZ3RoO1xuICB9XG4gIGlmIChzcGFjZXMpIHtcbiAgICBpbmRlbnQgKz0gTWF0aC5mbG9vcihzcGFjZXMubGVuZ3RoIC8gTElTVF9JTkRFTlRfU0laRSk7XG4gIH1cbiAgcmV0dXJuIGluZGVudDtcbn1cbmNvbnN0IGxpc3RSZXBsYWNlID0gbGlzdFR5cGUgPT4ge1xuICByZXR1cm4gKHBhcmVudE5vZGUsIGNoaWxkcmVuLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dE5vZGUgPSBwYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGxpc3RUeXBlID09PSAnY2hlY2snID8gbWF0Y2hbM10gPT09ICd4JyA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5nZXRMaXN0VHlwZSgpID09PSBsaXN0VHlwZSkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IG5leHROb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBsZXQncyBoYW5kbGUgZ3JhY2VmdWxseSwganVzdCBpbiBjYXNlLlxuICAgICAgICBuZXh0Tm9kZS5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRpc0xpc3ROb2RlKHByZXZpb3VzTm9kZSkgJiYgcHJldmlvdXNOb2RlLmdldExpc3RUeXBlKCkgPT09IGxpc3RUeXBlKSB7XG4gICAgICBwcmV2aW91c05vZGUuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgIHBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUsIGxpc3RUeXBlID09PSAnbnVtYmVyJyA/IE51bWJlcihtYXRjaFsyXSkgOiB1bmRlZmluZWQpO1xuICAgICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgIH1cbiAgICBsaXN0SXRlbS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgIGxpc3RJdGVtLnNlbGVjdCgwLCAwKTtcbiAgICBjb25zdCBpbmRlbnQgPSBnZXRJbmRlbnQobWF0Y2hbMV0pO1xuICAgIGlmIChpbmRlbnQpIHtcbiAgICAgIGxpc3RJdGVtLnNldEluZGVudChpbmRlbnQpO1xuICAgIH1cbiAgfTtcbn07XG5jb25zdCBsaXN0RXhwb3J0ID0gKGxpc3ROb2RlLCBleHBvcnRDaGlsZHJlbiwgZGVwdGgpID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGNoaWxkcmVuID0gbGlzdE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgY2hpbGRyZW4pIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICAgIGlmIChsaXN0SXRlbU5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKGxpc3RFeHBvcnQoZmlyc3RDaGlsZCwgZXhwb3J0Q2hpbGRyZW4sIGRlcHRoICsgMSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRlbnQgPSAnICcucmVwZWF0KGRlcHRoICogTElTVF9JTkRFTlRfU0laRSk7XG4gICAgICBjb25zdCBsaXN0VHlwZSA9IGxpc3ROb2RlLmdldExpc3RUeXBlKCk7XG4gICAgICBjb25zdCBwcmVmaXggPSBsaXN0VHlwZSA9PT0gJ251bWJlcicgPyBgJHtsaXN0Tm9kZS5nZXRTdGFydCgpICsgaW5kZXh9LiBgIDogbGlzdFR5cGUgPT09ICdjaGVjaycgPyBgLSBbJHtsaXN0SXRlbU5vZGUuZ2V0Q2hlY2tlZCgpID8gJ3gnIDogJyAnfV0gYCA6ICctICc7XG4gICAgICBvdXRwdXQucHVzaChpbmRlbnQgKyBwcmVmaXggKyBleHBvcnRDaGlsZHJlbihsaXN0SXRlbU5vZGUpKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignXFxuJyk7XG59O1xuY29uc3QgSEVBRElORyA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbSGVhZGluZ05vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIGlmICghJGlzSGVhZGluZ05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IE51bWJlcihub2RlLmdldFRhZygpLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gJyMnLnJlcGVhdChsZXZlbCkgKyAnICcgKyBleHBvcnRDaGlsZHJlbihub2RlKTtcbiAgfSxcbiAgcmVnRXhwOiAvXigjezEsNn0pXFxzLyxcbiAgcmVwbGFjZTogY3JlYXRlQmxvY2tOb2RlKG1hdGNoID0+IHtcbiAgICBjb25zdCB0YWcgPSAnaCcgKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgcmV0dXJuICRjcmVhdGVIZWFkaW5nTm9kZSh0YWcpO1xuICB9KSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgUVVPVEUgPSB7XG4gIGRlcGVuZGVuY2llczogW1F1b3RlTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgaWYgKCEkaXNRdW90ZU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IGV4cG9ydENoaWxkcmVuKG5vZGUpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIG91dHB1dC5wdXNoKCc+ICcgKyBsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbiAgfSxcbiAgcmVnRXhwOiAvXj5cXHMvLFxuICByZXBsYWNlOiAocGFyZW50Tm9kZSwgY2hpbGRyZW4sIF9tYXRjaCwgaXNJbXBvcnQpID0+IHtcbiAgICBpZiAoaXNJbXBvcnQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzUXVvdGVOb2RlKHByZXZpb3VzTm9kZSkpIHtcbiAgICAgICAgcHJldmlvdXNOb2RlLnNwbGljZShwcmV2aW91c05vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIFskY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5jaGlsZHJlbl0pO1xuICAgICAgICBwcmV2aW91c05vZGUuc2VsZWN0KDAsIDApO1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG4gICAgbm9kZS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgIHBhcmVudE5vZGUucmVwbGFjZShub2RlKTtcbiAgICBub2RlLnNlbGVjdCgwLCAwKTtcbiAgfSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgQ09ERSA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbQ29kZU5vZGVdLFxuICBleHBvcnQ6IG5vZGUgPT4ge1xuICAgIGlmICghJGlzQ29kZU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICByZXR1cm4gJ2BgYCcgKyAobm9kZS5nZXRMYW5ndWFnZSgpIHx8ICcnKSArICh0ZXh0Q29udGVudCA/ICdcXG4nICsgdGV4dENvbnRlbnQgOiAnJykgKyAnXFxuJyArICdgYGAnO1xuICB9LFxuICByZWdFeHA6IC9eWyBcXHRdKmBgYChcXHd7MSwxMH0pP1xccy8sXG4gIHJlcGxhY2U6IGNyZWF0ZUJsb2NrTm9kZShtYXRjaCA9PiB7XG4gICAgcmV0dXJuICRjcmVhdGVDb2RlTm9kZShtYXRjaCA/IG1hdGNoWzFdIDogdW5kZWZpbmVkKTtcbiAgfSksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IFVOT1JERVJFRF9MSVNUID0ge1xuICBkZXBlbmRlbmNpZXM6IFtMaXN0Tm9kZSwgTGlzdEl0ZW1Ob2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4gJGlzTGlzdE5vZGUobm9kZSkgPyBsaXN0RXhwb3J0KG5vZGUsIGV4cG9ydENoaWxkcmVuLCAwKSA6IG51bGw7XG4gIH0sXG4gIHJlZ0V4cDogL14oXFxzKilbLSorXVxccy8sXG4gIHJlcGxhY2U6IGxpc3RSZXBsYWNlKCdidWxsZXQnKSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgQ0hFQ0tfTElTVCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbTGlzdE5vZGUsIExpc3RJdGVtTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuICRpc0xpc3ROb2RlKG5vZGUpID8gbGlzdEV4cG9ydChub2RlLCBleHBvcnRDaGlsZHJlbiwgMCkgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IC9eKFxccyopKD86LVxccyk/XFxzPyhcXFsoXFxzfHgpP1xcXSlcXHMvaSxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ2NoZWNrJyksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IE9SREVSRURfTElTVCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbTGlzdE5vZGUsIExpc3RJdGVtTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuICRpc0xpc3ROb2RlKG5vZGUpID8gbGlzdEV4cG9ydChub2RlLCBleHBvcnRDaGlsZHJlbiwgMCkgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IC9eKFxccyopKFxcZHsxLH0pXFwuXFxzLyxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ251bWJlcicpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBJTkxJTkVfQ09ERSA9IHtcbiAgZm9ybWF0OiBbJ2NvZGUnXSxcbiAgdGFnOiAnYCcsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBISUdITElHSFQgPSB7XG4gIGZvcm1hdDogWydoaWdobGlnaHQnXSxcbiAgdGFnOiAnPT0nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9JVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnLCAnaXRhbGljJ10sXG4gIHRhZzogJyoqKicsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCcsICdpdGFsaWMnXSxcbiAgaW50cmF3b3JkOiBmYWxzZSxcbiAgdGFnOiAnX19fJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEJPTERfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnXSxcbiAgdGFnOiAnKionLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCddLFxuICBpbnRyYXdvcmQ6IGZhbHNlLFxuICB0YWc6ICdfXycsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBTVFJJS0VUSFJPVUdIID0ge1xuICBmb3JtYXQ6IFsnc3RyaWtldGhyb3VnaCddLFxuICB0YWc6ICd+ficsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBJVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2l0YWxpYyddLFxuICB0YWc6ICcqJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IElUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnaXRhbGljJ10sXG4gIGludHJhd29yZDogZmFsc2UsXG4gIHRhZzogJ18nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuXG4vLyBPcmRlciBvZiB0ZXh0IHRyYW5zZm9ybWVycyBtYXR0ZXJzOlxuLy9cbi8vIC0gY29kZSBzaG91bGQgZ28gZmlyc3QgYXMgaXQgcHJldmVudHMgYW55IHRyYW5zZm9ybWF0aW9ucyBpbnNpZGVcbi8vIC0gdGhlbiBsb25nZXIgdGFncyBtYXRjaCAoZS5nLiAqKiBvciBfXyBzaG91bGQgZ28gYmVmb3JlICogb3IgXylcbmNvbnN0IExJTksgPSB7XG4gIGRlcGVuZGVuY2llczogW0xpbmtOb2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIGV4cG9ydEZvcm1hdCkgPT4ge1xuICAgIGlmICghJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZSA9IG5vZGUuZ2V0VGl0bGUoKTtcbiAgICBjb25zdCBsaW5rQ29udGVudCA9IHRpdGxlID8gYFske25vZGUuZ2V0VGV4dENvbnRlbnQoKX1dKCR7bm9kZS5nZXRVUkwoKX0gXCIke3RpdGxlfVwiKWAgOiBgWyR7bm9kZS5nZXRUZXh0Q29udGVudCgpfV0oJHtub2RlLmdldFVSTCgpfSlgO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAvLyBBZGQgdGV4dCBzdHlsZXMgb25seSBpZiBsaW5rIGhhcyBzaW5nbGUgdGV4dCBub2RlIGluc2lkZS4gSWYgaXQncyBtb3JlXG4gICAgLy8gdGhlbiBvbmUgd2UgaWdub3JlIGl0IGFzIG1hcmtkb3duIGRvZXMgbm90IHN1cHBvcnQgbmVzdGVkIHN0eWxlcyBmb3IgbGlua3NcbiAgICBpZiAobm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSAmJiAkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgcmV0dXJuIGV4cG9ydEZvcm1hdChmaXJzdENoaWxkLCBsaW5rQ29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaW5rQ29udGVudDtcbiAgICB9XG4gIH0sXG4gIGltcG9ydFJlZ0V4cDogLyg/OlxcWyhbXltdKylcXF0pKD86XFwoKD86KFteKClcXHNdKykoPzpcXHNcIigoPzpbXlwiXSpcXFxcXCIpKlteXCJdKilcIlxccyopPylcXCkpLyxcbiAgcmVnRXhwOiAvKD86XFxbKFteW10rKVxcXSkoPzpcXCgoPzooW14oKVxcc10rKSg/Olxcc1wiKCg/OlteXCJdKlxcXFxcIikqW15cIl0qKVwiXFxzKik/KVxcKSkkLyxcbiAgcmVwbGFjZTogKHRleHROb2RlLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IFssIGxpbmtUZXh0LCBsaW5rVXJsLCBsaW5rVGl0bGVdID0gbWF0Y2g7XG4gICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUobGlua1VybCwge1xuICAgICAgdGl0bGU6IGxpbmtUaXRsZVxuICAgIH0pO1xuICAgIGNvbnN0IGxpbmtUZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsaW5rVGV4dCk7XG4gICAgbGlua1RleHROb2RlLnNldEZvcm1hdCh0ZXh0Tm9kZS5nZXRGb3JtYXQoKSk7XG4gICAgbGlua05vZGUuYXBwZW5kKGxpbmtUZXh0Tm9kZSk7XG4gICAgdGV4dE5vZGUucmVwbGFjZShsaW5rTm9kZSk7XG4gIH0sXG4gIHRyaWdnZXI6ICcpJyxcbiAgdHlwZTogJ3RleHQtbWF0Y2gnXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IEVMRU1FTlRfVFJBTlNGT1JNRVJTID0gW0hFQURJTkcsIFFVT1RFLCBDT0RFLCBVTk9SREVSRURfTElTVCwgT1JERVJFRF9MSVNUXTtcblxuLy8gT3JkZXIgb2YgdGV4dCBmb3JtYXQgdHJhbnNmb3JtZXJzIG1hdHRlcnM6XG4vL1xuLy8gLSBjb2RlIHNob3VsZCBnbyBmaXJzdCBhcyBpdCBwcmV2ZW50cyBhbnkgdHJhbnNmb3JtYXRpb25zIGluc2lkZVxuLy8gLSB0aGVuIGxvbmdlciB0YWdzIG1hdGNoIChlLmcuICoqIG9yIF9fIHNob3VsZCBnbyBiZWZvcmUgKiBvciBfKVxuY29uc3QgVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTID0gW0lOTElORV9DT0RFLCBCT0xEX0lUQUxJQ19TVEFSLCBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFLCBCT0xEX1NUQVIsIEJPTERfVU5ERVJTQ09SRSwgSElHSExJR0hULCBJVEFMSUNfU1RBUiwgSVRBTElDX1VOREVSU0NPUkUsIFNUUklLRVRIUk9VR0hdO1xuY29uc3QgVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlMgPSBbTElOS107XG5jb25zdCBUUkFOU0ZPUk1FUlMgPSBbLi4uRUxFTUVOVF9UUkFOU0ZPUk1FUlMsIC4uLlRFWFRfRk9STUFUX1RSQU5TRk9STUVSUywgLi4uVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlNdO1xuZnVuY3Rpb24gJGNvbnZlcnRGcm9tTWFya2Rvd25TdHJpbmcobWFya2Rvd24sIHRyYW5zZm9ybWVycyA9IFRSQU5TRk9STUVSUywgbm9kZSwgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyA9IGZhbHNlKSB7XG4gIGNvbnN0IGltcG9ydE1hcmtkb3duID0gY3JlYXRlTWFya2Rvd25JbXBvcnQodHJhbnNmb3JtZXJzLCBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzKTtcbiAgcmV0dXJuIGltcG9ydE1hcmtkb3duKG1hcmtkb3duLCBub2RlKTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0VG9NYXJrZG93blN0cmluZyh0cmFuc2Zvcm1lcnMgPSBUUkFOU0ZPUk1FUlMsIG5vZGUsIHNob3VsZFByZXNlcnZlTmV3TGluZXMgPSBmYWxzZSkge1xuICBjb25zdCBleHBvcnRNYXJrZG93biA9IGNyZWF0ZU1hcmtkb3duRXhwb3J0KHRyYW5zZm9ybWVycywgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyk7XG4gIHJldHVybiBleHBvcnRNYXJrZG93bihub2RlKTtcbn1cblxuZXhwb3J0IHsgJGNvbnZlcnRGcm9tTWFya2Rvd25TdHJpbmcsICRjb252ZXJ0VG9NYXJrZG93blN0cmluZywgQk9MRF9JVEFMSUNfU1RBUiwgQk9MRF9JVEFMSUNfVU5ERVJTQ09SRSwgQk9MRF9TVEFSLCBCT0xEX1VOREVSU0NPUkUsIENIRUNLX0xJU1QsIENPREUsIEVMRU1FTlRfVFJBTlNGT1JNRVJTLCBIRUFESU5HLCBISUdITElHSFQsIElOTElORV9DT0RFLCBJVEFMSUNfU1RBUiwgSVRBTElDX1VOREVSU0NPUkUsIExJTkssIE9SREVSRURfTElTVCwgUVVPVEUsIFNUUklLRVRIUk9VR0gsIFRFWFRfRk9STUFUX1RSQU5TRk9STUVSUywgVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlMsIFRSQU5TRk9STUVSUywgVU5PUkRFUkVEX0xJU1QsIHJlZ2lzdGVyTWFya2Rvd25TaG9ydGN1dHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCheckListPlugin.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCheckListPlugin.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckListPlugin: () => (/* binding */ CheckListPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction CheckListPlugin() {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.mergeRegister)(editor.registerCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_3__.INSERT_CHECK_LIST_COMMAND, () => {\n      (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.insertList)(editor, 'check');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_4__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.KEY_ARROW_DOWN_COMMAND, event => {\n      return handleArrownUpOrDown(event, editor, false);\n    }, lexical__WEBPACK_IMPORTED_MODULE_4__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.KEY_ARROW_UP_COMMAND, event => {\n      return handleArrownUpOrDown(event, editor, true);\n    }, lexical__WEBPACK_IMPORTED_MODULE_4__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.KEY_ESCAPE_COMMAND, event => {\n      const activeItem = getActiveCheckListItem();\n      if (activeItem != null) {\n        const rootElement = editor.getRootElement();\n        if (rootElement != null) {\n          rootElement.focus();\n        }\n        return true;\n      }\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_4__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.KEY_SPACE_COMMAND, event => {\n      const activeItem = getActiveCheckListItem();\n      if (activeItem != null && editor.isEditable()) {\n        editor.update(() => {\n          const listItemNode = (0,lexical__WEBPACK_IMPORTED_MODULE_4__.$getNearestNodeFromDOMNode)(activeItem);\n          if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(listItemNode)) {\n            event.preventDefault();\n            listItemNode.toggleChecked();\n          }\n        });\n        return true;\n      }\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_4__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.KEY_ARROW_LEFT_COMMAND, event => {\n      return editor.getEditorState().read(() => {\n        const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_4__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_4__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n          const {\n            anchor\n          } = selection;\n          const isElement = anchor.type === 'element';\n          if (isElement || anchor.offset === 0) {\n            const anchorNode = anchor.getNode();\n            const elementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.$findMatchingParent)(anchorNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_4__.$isElementNode)(node) && !node.isInline());\n            if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(elementNode)) {\n              const parent = elementNode.getParent();\n              if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n                const domNode = editor.getElementByKey(elementNode.__key);\n                if (domNode != null && document.activeElement !== domNode) {\n                  domNode.focus();\n                  event.preventDefault();\n                  return true;\n                }\n              }\n            }\n          }\n        }\n        return false;\n      });\n    }, lexical__WEBPACK_IMPORTED_MODULE_4__.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n      if (rootElement !== null) {\n        rootElement.addEventListener('click', handleClick);\n        rootElement.addEventListener('pointerdown', handlePointerDown);\n      }\n      if (prevElement !== null) {\n        prevElement.removeEventListener('click', handleClick);\n        prevElement.removeEventListener('pointerdown', handlePointerDown);\n      }\n    }));\n  });\n  return null;\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (target === null || !(0,lexical__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if (firstChild != null && (0,lexical__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const pageX = event.pageX / (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.calculateZoomLevel)(target);\n  if (target.dir === 'rtl' ? pageX < rect.right && pageX > rect.right - 20 : pageX > rect.left && pageX < rect.left + 20) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    const domNode = event.target;\n    const editor = findEditor(domNode);\n    if (editor != null && editor.isEditable()) {\n      editor.update(() => {\n        if (event.target) {\n          const node = (0,lexical__WEBPACK_IMPORTED_MODULE_4__.$getNearestNodeFromDOMNode)(domNode);\n          if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        }\n      });\n    }\n  });\n  event.stopPropagation(); // Prevents potential parent-editor listeners from firing, causing the checkbox toggle to be undone\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n  event.stopPropagation();\n}\nfunction findEditor(target) {\n  let node = target;\n  while (node) {\n    // @ts-ignore internal field\n    if (node.__lexicalEditor) {\n      // @ts-ignore internal field\n      return node.__lexicalEditor;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return activeElement != null && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!(0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrownUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = (0,lexical__WEBPACK_IMPORTED_MODULE_4__.$getNearestNodeFromDOMNode)(activeItem);\n      if (!(0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENoZWNrTGlzdFBsdWdpbi5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRztBQUNsQjtBQUNxQjtBQUNtSTtBQUN4TTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0dBQXlCO0FBQzVDLEVBQUUsZ0RBQVM7QUFDWCxXQUFXLDZEQUFhLHdCQUF3QixvRUFBeUI7QUFDekUsTUFBTSx5REFBVTtBQUNoQjtBQUNBLEtBQUssRUFBRSx5REFBb0IsMEJBQTBCLDJEQUFzQjtBQUMzRTtBQUNBLEtBQUssRUFBRSx5REFBb0IsMEJBQTBCLHlEQUFvQjtBQUN6RTtBQUNBLEtBQUssRUFBRSx5REFBb0IsMEJBQTBCLHVEQUFrQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUseURBQW9CLDBCQUEwQixzREFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1FQUEwQjtBQUN6RCxjQUFjLDhEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUseURBQW9CLDBCQUEwQiwyREFBc0I7QUFDM0U7QUFDQSwwQkFBMEIsc0RBQWE7QUFDdkMsWUFBWSwwREFBaUI7QUFDN0I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUVBQW1CLHFCQUFxQix1REFBYztBQUN0RixnQkFBZ0IsOERBQWU7QUFDL0I7QUFDQSxrQkFBa0IsMERBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLEVBQUUseURBQW9CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFhO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixzREFBYTtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrRUFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtRUFBMEI7QUFDakQsY0FBYyw4REFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhEQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsOERBQWU7QUFDeEI7QUFDQSxTQUFTLDBEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1FQUEwQjtBQUNqRCxXQUFXLDhEQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENoZWNrTGlzdFBsdWdpbi5kZXYubWpzPzU0YzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5ELCBpbnNlcnRMaXN0LCAkaXNMaXN0SXRlbU5vZGUsICRpc0xpc3ROb2RlIH0gZnJvbSAnQGxleGljYWwvbGlzdCc7XG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyBtZXJnZVJlZ2lzdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCBpc0hUTUxFbGVtZW50LCBjYWxjdWxhdGVab29tTGV2ZWwgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBDT01NQU5EX1BSSU9SSVRZX0xPVywgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgS0VZX1NQQUNFX0NPTU1BTkQsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzRWxlbWVudE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBDaGVja0xpc3RQbHVnaW4oKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICAgaW5zZXJ0TGlzdChlZGl0b3IsICdjaGVjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIHJldHVybiBoYW5kbGVBcnJvd25VcE9yRG93bihldmVudCwgZWRpdG9yLCBmYWxzZSk7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICByZXR1cm4gaGFuZGxlQXJyb3duVXBPckRvd24oZXZlbnQsIGVkaXRvciwgdHJ1ZSk7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FU0NBUEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcbiAgICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHJvb3RFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByb290RWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfU1BBQ0VfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcbiAgICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwgJiYgZWRpdG9yLmlzRWRpdGFibGUoKSkge1xuICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhY3RpdmVJdGVtKTtcbiAgICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsaXN0SXRlbU5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICByZXR1cm4gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhbmNob3JcbiAgICAgICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgIGNvbnN0IGlzRWxlbWVudCA9IGFuY2hvci50eXBlID09PSAnZWxlbWVudCc7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudCB8fCBhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICAgICAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShlbGVtZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snICYmIChpc0VsZW1lbnQgfHwgZWxlbWVudE5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCkgPT09IGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9tTm9kZSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWxlbWVudE5vZGUuX19rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlICE9IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcigocm9vdEVsZW1lbnQsIHByZXZFbGVtZW50KSA9PiB7XG4gICAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHByZXZFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgICBwcmV2RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNoZWNrSXRlbUV2ZW50KGV2ZW50LCBjYWxsYmFjaykge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICh0YXJnZXQgPT09IG51bGwgfHwgIWlzSFRNTEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElnbm9yZSBjbGlja3Mgb24gTEkgdGhhdCBoYXZlIG5lc3RlZCBsaXN0c1xuICBjb25zdCBmaXJzdENoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gIGlmIChmaXJzdENoaWxkICE9IG51bGwgJiYgaXNIVE1MRWxlbWVudChmaXJzdENoaWxkKSAmJiAoZmlyc3RDaGlsZC50YWdOYW1lID09PSAnVUwnIHx8IGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ09MJykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZSA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgZmllbGRcbiAgaWYgKCFwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUuX19sZXhpY2FsTGlzdFR5cGUgIT09ICdjaGVjaycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgcGFnZVggPSBldmVudC5wYWdlWCAvIGNhbGN1bGF0ZVpvb21MZXZlbCh0YXJnZXQpO1xuICBpZiAodGFyZ2V0LmRpciA9PT0gJ3J0bCcgPyBwYWdlWCA8IHJlY3QucmlnaHQgJiYgcGFnZVggPiByZWN0LnJpZ2h0IC0gMjAgOiBwYWdlWCA+IHJlY3QubGVmdCAmJiBwYWdlWCA8IHJlY3QubGVmdCArIDIwKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsICgpID0+IHtcbiAgICBjb25zdCBkb21Ob2RlID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGVkaXRvciA9IGZpbmRFZGl0b3IoZG9tTm9kZSk7XG4gICAgaWYgKGVkaXRvciAhPSBudWxsICYmIGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbU5vZGUpO1xuICAgICAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIG5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFByZXZlbnRzIHBvdGVudGlhbCBwYXJlbnQtZWRpdG9yIGxpc3RlbmVycyBmcm9tIGZpcmluZywgY2F1c2luZyB0aGUgY2hlY2tib3ggdG9nZ2xlIHRvIGJlIHVuZG9uZVxufVxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsICgpID0+IHtcbiAgICAvLyBQcmV2ZW50cyBjYXJldCBtb3Zpbmcgd2hlbiBjbGlja2luZyBvbiBjaGVjayBtYXJrXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gZmluZEVkaXRvcih0YXJnZXQpIHtcbiAgbGV0IG5vZGUgPSB0YXJnZXQ7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBmaWVsZFxuICAgIGlmIChub2RlLl9fbGV4aWNhbEVkaXRvcikge1xuICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBmaWVsZFxuICAgICAgcmV0dXJuIG5vZGUuX19sZXhpY2FsRWRpdG9yO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHJldHVybiBhY3RpdmVFbGVtZW50ICE9IG51bGwgJiYgYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnTEknICYmIGFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSAhPSBudWxsICYmXG4gIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgZmllbGRcbiAgYWN0aXZlRWxlbWVudC5wYXJlbnROb2RlLl9fbGV4aWNhbExpc3RUeXBlID09PSAnY2hlY2snID8gYWN0aXZlRWxlbWVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ2hlY2tMaXN0SXRlbVNpYmxpbmcobm9kZSwgYmFja3dhcmQpIHtcbiAgbGV0IHNpYmxpbmcgPSBiYWNrd2FyZCA/IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuXG4gIC8vIEdvaW5nIHVwIGluIGEgdHJlZSB0byBnZXQgbm9uLW51bGwgc2libGluZ1xuICB3aGlsZSAoc2libGluZyA9PSBudWxsICYmICRpc0xpc3RJdGVtTm9kZShwYXJlbnQpKSB7XG4gICAgLy8gR2V0IGxpIC0+IHBhcmVudCB1bC9vbCAtPiBwYXJlbnQgbGlcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpIDogcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR29pbmcgZG93biBpbiBhIHRyZWUgdG8gZ2V0IGZpcnN0IG5vbi1uZXN0ZWQgbGlzdCBpdGVtXG4gIHdoaWxlICgkaXNMaXN0SXRlbU5vZGUoc2libGluZykpIHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gYmFja3dhcmQgPyBzaWJsaW5nLmdldExhc3RDaGlsZCgpIDogc2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgfVxuICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IGZpcnN0Q2hpbGQuZ2V0TGFzdENoaWxkKCkgOiBmaXJzdENoaWxkLmdldEZpcnN0Q2hpbGQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFycm93blVwT3JEb3duKGV2ZW50LCBlZGl0b3IsIGJhY2t3YXJkKSB7XG4gIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG4gIGlmIChhY3RpdmVJdGVtICE9IG51bGwpIHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoYWN0aXZlSXRlbSk7XG4gICAgICBpZiAoISRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dExpc3RJdGVtID0gZmluZENoZWNrTGlzdEl0ZW1TaWJsaW5nKGxpc3RJdGVtLCBiYWNrd2FyZCk7XG4gICAgICBpZiAobmV4dExpc3RJdGVtICE9IG51bGwpIHtcbiAgICAgICAgbmV4dExpc3RJdGVtLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobmV4dExpc3RJdGVtLl9fa2V5KTtcbiAgICAgICAgaWYgKGRvbSAhPSBudWxsKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRvbS5mb2N1cygpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBDaGVja0xpc3RQbHVnaW4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCheckListPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalClickableLinkPlugin.dev.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalClickableLinkPlugin.dev.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClickableLinkPlugin: () => (/* binding */ ClickableLinkPlugin),\n/* harmony export */   \"default\": () => (/* binding */ ClickableLinkPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findMatchingDOM(startNode, predicate) {\n  let node = startNode;\n  while (node != null) {\n    if (predicate(node)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction ClickableLinkPlugin({\n  newTab = true,\n  disabled = false\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const onClick = event => {\n      const target = event.target;\n      if (!(target instanceof Node)) {\n        return;\n      }\n      const nearestEditor = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.getNearestEditorFromDOMNode)(target);\n      if (nearestEditor === null) {\n        return;\n      }\n      let url = null;\n      let urlTarget = null;\n      nearestEditor.update(() => {\n        const clickedNode = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$getNearestNodeFromDOMNode)(target);\n        if (clickedNode !== null) {\n          const maybeLinkNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.$findMatchingParent)(clickedNode, lexical__WEBPACK_IMPORTED_MODULE_2__.$isElementNode);\n          if (!disabled) {\n            if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_4__.$isLinkNode)(maybeLinkNode)) {\n              url = maybeLinkNode.sanitizeUrl(maybeLinkNode.getURL());\n              urlTarget = maybeLinkNode.getTarget();\n            } else {\n              const a = findMatchingDOM(target, lexical__WEBPACK_IMPORTED_MODULE_2__.isHTMLAnchorElement);\n              if (a !== null) {\n                url = a.href;\n                urlTarget = a.target;\n              }\n            }\n          }\n        }\n      });\n      if (url === null || url === '') {\n        return;\n      }\n\n      // Allow user to select link text without follwing url\n      const selection = editor.getEditorState().read(lexical__WEBPACK_IMPORTED_MODULE_2__.$getSelection);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_2__.$isRangeSelection)(selection) && !selection.isCollapsed()) {\n        event.preventDefault();\n        return;\n      }\n      const isMiddle = event.type === 'auxclick' && event.button === 1;\n      window.open(url, newTab || isMiddle || event.metaKey || event.ctrlKey || urlTarget === '_blank' ? '_blank' : '_self');\n      event.preventDefault();\n    };\n    const onMouseUp = event => {\n      if (event.button === 1) {\n        onClick(event);\n      }\n    };\n    return editor.registerRootListener((rootElement, prevRootElement) => {\n      if (prevRootElement !== null) {\n        prevRootElement.removeEventListener('click', onClick);\n        prevRootElement.removeEventListener('mouseup', onMouseUp);\n      }\n      if (rootElement !== null) {\n        rootElement.addEventListener('click', onClick);\n        rootElement.addEventListener('mouseup', onMouseUp);\n      }\n    });\n  }, [editor, newTab, disabled]);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENsaWNrYWJsZUxpbmtQbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRDO0FBQ3NDO0FBQ1I7QUFDMEQ7QUFDbEc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixnR0FBeUI7QUFDNUMsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBMEI7QUFDdEQ7QUFDQSxnQ0FBZ0MsbUVBQW1CLGNBQWMsbURBQWM7QUFDL0U7QUFDQSxnQkFBZ0IsMERBQVc7QUFDM0I7QUFDQTtBQUNBLGNBQWM7QUFDZCxnREFBZ0Qsd0RBQW1CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxrREFBYTtBQUNsRSxVQUFVLDBEQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ2xpY2thYmxlTGlua1BsdWdpbi5kZXYubWpzPzUxMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkaXNMaW5rTm9kZSB9IGZyb20gJ0BsZXhpY2FsL2xpbmsnO1xuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgJGZpbmRNYXRjaGluZ1BhcmVudCwgaXNIVE1MQW5jaG9yRWxlbWVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZSwgJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUsICRpc0VsZW1lbnROb2RlLCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ0RPTShzdGFydE5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gQ2xpY2thYmxlTGlua1BsdWdpbih7XG4gIG5ld1RhYiA9IHRydWUsXG4gIGRpc2FibGVkID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb25DbGljayA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lYXJlc3RFZGl0b3IgPSBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUodGFyZ2V0KTtcbiAgICAgIGlmIChuZWFyZXN0RWRpdG9yID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB1cmwgPSBudWxsO1xuICAgICAgbGV0IHVybFRhcmdldCA9IG51bGw7XG4gICAgICBuZWFyZXN0RWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsaWNrZWROb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKGNsaWNrZWROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgbWF5YmVMaW5rTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoY2xpY2tlZE5vZGUsICRpc0VsZW1lbnROb2RlKTtcbiAgICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAoJGlzTGlua05vZGUobWF5YmVMaW5rTm9kZSkpIHtcbiAgICAgICAgICAgICAgdXJsID0gbWF5YmVMaW5rTm9kZS5zYW5pdGl6ZVVybChtYXliZUxpbmtOb2RlLmdldFVSTCgpKTtcbiAgICAgICAgICAgICAgdXJsVGFyZ2V0ID0gbWF5YmVMaW5rTm9kZS5nZXRUYXJnZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBmaW5kTWF0Y2hpbmdET00odGFyZ2V0LCBpc0hUTUxBbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgaWYgKGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBhLmhyZWY7XG4gICAgICAgICAgICAgICAgdXJsVGFyZ2V0ID0gYS50YXJnZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHVybCA9PT0gbnVsbCB8fCB1cmwgPT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgdXNlciB0byBzZWxlY3QgbGluayB0ZXh0IHdpdGhvdXQgZm9sbHdpbmcgdXJsXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCRnZXRTZWxlY3Rpb24pO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTWlkZGxlID0gZXZlbnQudHlwZSA9PT0gJ2F1eGNsaWNrJyAmJiBldmVudC5idXR0b24gPT09IDE7XG4gICAgICB3aW5kb3cub3Blbih1cmwsIG5ld1RhYiB8fCBpc01pZGRsZSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgdXJsVGFyZ2V0ID09PSAnX2JsYW5rJyA/ICdfYmxhbmsnIDogJ19zZWxmJyk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZVVwID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSkge1xuICAgICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJSb290TGlzdGVuZXIoKHJvb3RFbGVtZW50LCBwcmV2Um9vdEVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChwcmV2Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcHJldlJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljayk7XG4gICAgICAgIHByZXZSb290RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2spO1xuICAgICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2VkaXRvciwgbmV3VGFiLCBkaXNhYmxlZF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgQ2xpY2thYmxlTGlua1BsdWdpbiwgQ2xpY2thYmxlTGlua1BsdWdpbiBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalClickableLinkPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposer: () => (/* binding */ LexicalComposer)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.createLexicalComposerContext)(null, theme);\n    let editor = initialEditor || null;\n    if (editor === null) {\n      const newEditor = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.createEditor)({\n        editable: initialConfig.editable,\n        html,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n      if (root.isEmpty()) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$createParagraphNode)();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkc7QUFDdkI7QUFDMUI7QUFDcEI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWUsR0FBRyw0Q0FBUzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixtR0FBNEI7QUFDaEQ7QUFDQTtBQUNBLHdCQUF3QixxREFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0Isc0RBQUcsQ0FBQyx5RkFBc0I7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1CQUFtQixpREFBUTtBQUMzQjtBQUNBLDBCQUEwQiw2REFBb0I7QUFDOUM7QUFDQTtBQUNBLFlBQVksc0RBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXIuZGV2Lm1qcz8yZDNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dCwgTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgY3JlYXRlRWRpdG9yLCAkZ2V0Um9vdCwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRnZXRTZWxlY3Rpb24gfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBISVNUT1JZX01FUkdFX09QVElPTlMgPSB7XG4gIHRhZzogJ2hpc3RvcnktbWVyZ2UnXG59O1xuZnVuY3Rpb24gTGV4aWNhbENvbXBvc2VyKHtcbiAgaW5pdGlhbENvbmZpZyxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgY29tcG9zZXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdGhlbWUsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBlZGl0b3JfX0RFUFJFQ0FURUQ6IGluaXRpYWxFZGl0b3IsXG4gICAgICBub2RlcyxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBlZGl0b3JTdGF0ZTogaW5pdGlhbEVkaXRvclN0YXRlLFxuICAgICAgaHRtbFxuICAgIH0gPSBpbml0aWFsQ29uZmlnO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0KG51bGwsIHRoZW1lKTtcbiAgICBsZXQgZWRpdG9yID0gaW5pdGlhbEVkaXRvciB8fCBudWxsO1xuICAgIGlmIChlZGl0b3IgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5ld0VkaXRvciA9IGNyZWF0ZUVkaXRvcih7XG4gICAgICAgIGVkaXRhYmxlOiBpbml0aWFsQ29uZmlnLmVkaXRhYmxlLFxuICAgICAgICBodG1sLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIG5vZGVzLFxuICAgICAgICBvbkVycm9yOiBlcnJvciA9PiBvbkVycm9yKGVycm9yLCBuZXdFZGl0b3IpLFxuICAgICAgICB0aGVtZVxuICAgICAgfSk7XG4gICAgICBpbml0aWFsaXplRWRpdG9yKG5ld0VkaXRvciwgaW5pdGlhbEVkaXRvclN0YXRlKTtcbiAgICAgIGVkaXRvciA9IG5ld0VkaXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIFtlZGl0b3IsIGNvbnRleHRdO1xuICB9LFxuICAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbXSk7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIGNvbnN0IGlzRWRpdGFibGUgPSBpbml0aWFsQ29uZmlnLmVkaXRhYmxlO1xuICAgIGNvbnN0IFtlZGl0b3JdID0gY29tcG9zZXJDb250ZXh0O1xuICAgIGVkaXRvci5zZXRFZGl0YWJsZShpc0VkaXRhYmxlICE9PSB1bmRlZmluZWQgPyBpc0VkaXRhYmxlIDogdHJ1ZSk7XG5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goTGV4aWNhbENvbXBvc2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb21wb3NlckNvbnRleHQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZUVkaXRvcihlZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSkge1xuICBpZiAoaW5pdGlhbEVkaXRvclN0YXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgIGlmIChyb290LmlzRW1wdHkoKSkge1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICByb290LmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gQ0FOX1VTRV9ET00gPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbDtcbiAgICAgICAgaWYgKCRnZXRTZWxlY3Rpb24oKSAhPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBudWxsICYmIGFjdGl2ZUVsZW1lbnQgPT09IGVkaXRvci5nZXRSb290RWxlbWVudCgpKSB7XG4gICAgICAgICAgcGFyYWdyYXBoLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgfSBlbHNlIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbml0aWFsRWRpdG9yU3RhdGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRFZGl0b3JTdGF0ZSA9IGVkaXRvci5wYXJzZUVkaXRvclN0YXRlKGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKHBhcnNlZEVkaXRvclN0YXRlLCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB7XG4gICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKGluaXRpYWxFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgICAgIGlmIChyb290LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICBpbml0aWFsRWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IExleGljYWxDb21wb3NlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposerContext: () => (/* binding */ LexicalComposerContext),\n/* harmony export */   createLexicalComposerContext: () => (/* binding */ createLexicalComposerContext),\n/* harmony export */   useLexicalComposerContext: () => (/* binding */ useLexicalComposerContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LexicalComposerContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LexicalComposerContext);\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n  return composerContext;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxvREFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQuZGV2Lm1qcz85MTUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0KHBhcmVudCwgdGhlbWUpIHtcbiAgbGV0IHBhcmVudENvbnRleHQgPSBudWxsO1xuICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICBwYXJlbnRDb250ZXh0ID0gcGFyZW50WzFdO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRoZW1lKCkge1xuICAgIGlmICh0aGVtZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhlbWU7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDb250ZXh0ICE9IG51bGwgPyBwYXJlbnRDb250ZXh0LmdldFRoZW1lKCkgOiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0VGhlbWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IHVzZUNvbnRleHQoTGV4aWNhbENvbXBvc2VyQ29udGV4dCk7XG4gIGlmIChjb21wb3NlckNvbnRleHQgPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQ6IGNhbm5vdCBmaW5kIGEgTGV4aWNhbENvbXBvc2VyQ29udGV4dGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9zZXJDb250ZXh0O1xufVxuXG5leHBvcnQgeyBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LCBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0LCB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentEditable: () => (/* binding */ ContentEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ContentEditable({\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaExpanded,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(rootElement => {\n    // defaultView is required for a root element.\n    // In multi-window setups, the defaultView may not exist at certain points.\n    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {\n      editor.setRootElement(rootElement);\n    }\n  }, [editor]);\n  useLayoutEffectImpl(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    ...rest,\n    \"aria-activedescendant\": !isEditable ? undefined : ariaActiveDescendant,\n    \"aria-autocomplete\": !isEditable ? 'none' : ariaAutoComplete,\n    \"aria-controls\": !isEditable ? undefined : ariaControls,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-expanded\": !isEditable ? undefined : role === 'combobox' ? !!ariaExpanded : undefined,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": !isEditable ? undefined : ariaOwns,\n    \"aria-readonly\": !isEditable ? true : undefined,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: ref,\n    role: role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Y7QUFDUjtBQUNsQzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixnR0FBeUI7QUFDNUMsb0NBQW9DLCtDQUFRO0FBQzVDLGNBQWMsa0RBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsc0JBQXNCLHNEQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYubWpzPzAwYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBDb250ZW50RWRpdGFibGUoe1xuICBhcmlhQWN0aXZlRGVzY2VuZGFudCxcbiAgYXJpYUF1dG9Db21wbGV0ZSxcbiAgYXJpYUNvbnRyb2xzLFxuICBhcmlhRGVzY3JpYmVkQnksXG4gIGFyaWFFeHBhbmRlZCxcbiAgYXJpYUxhYmVsLFxuICBhcmlhTGFiZWxsZWRCeSxcbiAgYXJpYU11bHRpbGluZSxcbiAgYXJpYU93bnMsXG4gIGFyaWFSZXF1aXJlZCxcbiAgYXV0b0NhcGl0YWxpemUsXG4gIGNsYXNzTmFtZSxcbiAgaWQsXG4gIHJvbGUgPSAndGV4dGJveCcsXG4gIHNwZWxsQ2hlY2sgPSB0cnVlLFxuICBzdHlsZSxcbiAgdGFiSW5kZXgsXG4gICdkYXRhLXRlc3RpZCc6IHRlc3RpZCxcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW2lzRWRpdGFibGUsIHNldEVkaXRhYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgcmVmID0gdXNlQ2FsbGJhY2socm9vdEVsZW1lbnQgPT4ge1xuICAgIC8vIGRlZmF1bHRWaWV3IGlzIHJlcXVpcmVkIGZvciBhIHJvb3QgZWxlbWVudC5cbiAgICAvLyBJbiBtdWx0aS13aW5kb3cgc2V0dXBzLCB0aGUgZGVmYXVsdFZpZXcgbWF5IG5vdCBleGlzdCBhdCBjZXJ0YWluIHBvaW50cy5cbiAgICBpZiAocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudCAmJiByb290RWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XG4gICAgICBlZGl0b3Iuc2V0Um9vdEVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgIH1cbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBzZXRFZGl0YWJsZShlZGl0b3IuaXNFZGl0YWJsZSgpKTtcbiAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcihjdXJyZW50SXNFZGl0YWJsZSA9PiB7XG4gICAgICBzZXRFZGl0YWJsZShjdXJyZW50SXNFZGl0YWJsZSk7XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIC4uLnJlc3QsXG4gICAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogIWlzRWRpdGFibGUgPyB1bmRlZmluZWQgOiBhcmlhQWN0aXZlRGVzY2VuZGFudCxcbiAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6ICFpc0VkaXRhYmxlID8gJ25vbmUnIDogYXJpYUF1dG9Db21wbGV0ZSxcbiAgICBcImFyaWEtY29udHJvbHNcIjogIWlzRWRpdGFibGUgPyB1bmRlZmluZWQgOiBhcmlhQ29udHJvbHMsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRCeSxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogIWlzRWRpdGFibGUgPyB1bmRlZmluZWQgOiByb2xlID09PSAnY29tYm9ib3gnID8gISFhcmlhRXhwYW5kZWQgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSxcbiAgICBcImFyaWEtbXVsdGlsaW5lXCI6IGFyaWFNdWx0aWxpbmUsXG4gICAgXCJhcmlhLW93bnNcIjogIWlzRWRpdGFibGUgPyB1bmRlZmluZWQgOiBhcmlhT3ducyxcbiAgICBcImFyaWEtcmVhZG9ubHlcIjogIWlzRWRpdGFibGUgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBhcmlhUmVxdWlyZWQsXG4gICAgYXV0b0NhcGl0YWxpemU6IGF1dG9DYXBpdGFsaXplLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogaXNFZGl0YWJsZSxcbiAgICBcImRhdGEtdGVzdGlkXCI6IHRlc3RpZCxcbiAgICBpZDogaWQsXG4gICAgcmVmOiByZWYsXG4gICAgcm9sZTogcm9sZSxcbiAgICBzcGVsbENoZWNrOiBzcGVsbENoZWNrLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICB0YWJJbmRleDogdGFiSW5kZXhcbiAgfSk7XG59XG5cbmV4cG9ydCB7IENvbnRlbnRFZGl0YWJsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $isDecoratorBlockNode: () => (/* binding */ $isDecoratorBlockNode),\n/* harmony export */   DecoratorBlockNode: () => (/* binding */ DecoratorBlockNode)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass DecoratorBlockNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.DecoratorNode {\n  constructor(format, key) {\n    super(key);\n    this.__format = format || '';\n  }\n  exportJSON() {\n    return {\n      format: this.__format || '',\n      type: 'decorator-block',\n      version: 1\n    };\n  }\n  canIndent() {\n    return false;\n  }\n  createDOM() {\n    return document.createElement('div');\n  }\n  updateDOM() {\n    return false;\n  }\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = format;\n  }\n  isInline() {\n    return false;\n  }\n}\nfunction $isDecoratorBlockNode(node) {\n  return node instanceof DecoratorBlockNode;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5kZXYubWpzPzVlZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBEZWNvcmF0b3JOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY2xhc3MgRGVjb3JhdG9yQmxvY2tOb2RlIGV4dGVuZHMgRGVjb3JhdG9yTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGZvcm1hdCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogdGhpcy5fX2Zvcm1hdCB8fCAnJyxcbiAgICAgIHR5cGU6ICdkZWNvcmF0b3ItYmxvY2snLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB9XG4gIHVwZGF0ZURPTSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2V0Rm9ybWF0KGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IGZvcm1hdDtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc0RlY29yYXRvckJsb2NrTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRGVjb3JhdG9yQmxvY2tOb2RlO1xufVxuXG5leHBvcnQgeyAkaXNEZWNvcmF0b3JCbG9ja05vZGUsIERlY29yYXRvckJsb2NrTm9kZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalErrorBoundary: () => (/* binding */ LexicalErrorBoundary),\n/* harmony export */   \"default\": () => (/* binding */ LexicalErrorBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ErrorBoundary, {\n    fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      },\n      children: \"An error was thrown.\"\n    }),\n    onError: onError,\n    children: children\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQ1M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlEQUFvQjtBQUM1QztBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsZ0RBQW1CO0FBQy9DLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMsQ0FBQyw0Q0FBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQixzREFBRztBQUN6QiwyQkFBMkIsc0RBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFaUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxFcnJvckJvdW5kYXJ5LmRldi5tanM/ZGYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbnZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgYSA9IFtdO1xuICB9XG5cbiAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgIGIgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhLmxlbmd0aCAhPT0gYi5sZW5ndGggfHwgYS5zb21lKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiAhT2JqZWN0LmlzKGl0ZW0sIGJbaW5kZXhdKTtcbiAgfSk7XG59O1xuXG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBlcnJvcjogbnVsbFxufTtcblxudmFyIEVycm9yQm91bmRhcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBfYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblxuICAgIF90aGlzLnJlc2V0RXJyb3JCb3VuZGFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucHJvcHMub25SZXNldCA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMpLm9uUmVzZXQuYXBwbHkoX3RoaXMkcHJvcHMsIGFyZ3MpO1xuXG4gICAgICBfdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBFcnJvckJvdW5kYXJ5LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMkb25FcnJvciwgX3RoaXMkcHJvcHMyO1xuXG4gICAgKF90aGlzJHByb3BzJG9uRXJyb3IgPSAoX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcykub25FcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uRXJyb3IuY2FsbChfdGhpcyRwcm9wczIsIGVycm9yLCBpbmZvKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAvLyBoYXBwZW5zIHRvICphbHNvKiBiZSBpbiB0aGUgcmVzZXRLZXlzIGFycmF5LCB3ZSdkIGVuZCB1cCByZXNldHRpbmdcbiAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgaW1tZWRpYXRlbHkuIFRoaXMgd291bGQgbGlrZWx5IHRyaWdnZXIgYSBzZWNvbmRcbiAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgLy8gU28gd2UgbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgY2hlY2sgdGhlIHJlc2V0S2V5cyBvbiB0aGUgZmlyc3QgY2FsbFxuICAgIC8vIG9mIGNEVSBhZnRlciB0aGUgZXJyb3IgaXMgc2V0XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMkb25SZXNldEtlLCBfdGhpcyRwcm9wczM7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvblJlc2V0S2UgPSAoX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcykub25SZXNldEtleXNDaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvblJlc2V0S2UuY2FsbChfdGhpcyRwcm9wczMsIHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cyk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgIEZhbGxiYWNrQ29tcG9uZW50ID0gX3RoaXMkcHJvcHM0LkZhbGxiYWNrQ29tcG9uZW50LFxuICAgICAgICBmYWxsYmFjayA9IF90aGlzJHByb3BzNC5mYWxsYmFjaztcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICB9O1xuXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmFsbGJhY2tSZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICB9IGVsc2UgaWYgKEZhbGxiYWNrQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY3QtZXJyb3ItYm91bmRhcnkgcmVxdWlyZXMgZWl0aGVyIGEgZmFsbGJhY2ssIGZhbGxiYWNrUmVuZGVyLCBvciBGYWxsYmFja0NvbXBvbmVudCBwcm9wJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH07XG5cbiAgcmV0dXJuIEVycm9yQm91bmRhcnk7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gTGV4aWNhbEVycm9yQm91bmRhcnkoe1xuICBjaGlsZHJlbixcbiAgb25FcnJvclxufSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNmMDAnLFxuICAgICAgICBjb2xvcjogJyNmMDAnLFxuICAgICAgICBwYWRkaW5nOiAnOHB4J1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBcIkFuIGVycm9yIHdhcyB0aHJvd24uXCJcbiAgICB9KSxcbiAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cblxuZXhwb3J0IHsgTGV4aWNhbEVycm9yQm91bmRhcnksIExleGljYWxFcnJvckJvdW5kYXJ5IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryPlugin: () => (/* binding */ HistoryPlugin),\n/* harmony export */   createEmptyHistoryState: () => (/* reexport safe */ _lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/history */ \"(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => externalHistoryState || (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)(), [externalHistoryState]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.registerHistory)(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  externalHistoryState\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  useHistory(editor, externalHistoryState);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNOO0FBQ2pCO0FBQ2hCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw4Q0FBTywrQkFBK0IseUVBQXVCO0FBQ3BGLEVBQUUsZ0RBQVM7QUFDWCxXQUFXLGlFQUFlO0FBQzFCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixnR0FBeUI7QUFDNUM7QUFDQTtBQUNBOztBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2Lm1qcz8wNzJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUsIHJlZ2lzdGVySGlzdG9yeSB9IGZyb20gJ0BsZXhpY2FsL2hpc3RvcnknO1xuZXhwb3J0IHsgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUgfSBmcm9tICdAbGV4aWNhbC9oaXN0b3J5JztcbmltcG9ydCB7IHVzZU1lbW8sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiB1c2VIaXN0b3J5KGVkaXRvciwgZXh0ZXJuYWxIaXN0b3J5U3RhdGUsIGRlbGF5ID0gMTAwMCkge1xuICBjb25zdCBoaXN0b3J5U3RhdGUgPSB1c2VNZW1vKCgpID0+IGV4dGVybmFsSGlzdG9yeVN0YXRlIHx8IGNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlKCksIFtleHRlcm5hbEhpc3RvcnlTdGF0ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiByZWdpc3Rlckhpc3RvcnkoZWRpdG9yLCBoaXN0b3J5U3RhdGUsIGRlbGF5KTtcbiAgfSwgW2RlbGF5LCBlZGl0b3IsIGhpc3RvcnlTdGF0ZV0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIEhpc3RvcnlQbHVnaW4oe1xuICBleHRlcm5hbEhpc3RvcnlTdGF0ZVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnlQbHVnaW4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createHorizontalRuleNode: () => (/* binding */ $createHorizontalRuleNode),\n/* harmony export */   $isHorizontalRuleNode: () => (/* binding */ $isHorizontalRuleNode),\n/* harmony export */   HorizontalRuleNode: () => (/* binding */ HorizontalRuleNode),\n/* harmony export */   INSERT_HORIZONTAL_RULE_COMMAND: () => (/* binding */ INSERT_HORIZONTAL_RULE_COMMAND)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_react_useLexicalNodeSelection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/useLexicalNodeSelection */ \"(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_HORIZONTAL_RULE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.createCommand)('INSERT_HORIZONTAL_RULE_COMMAND');\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext)();\n  const [isSelected, setSelected, clearSelection] = (0,_lexical_react_useLexicalNodeSelection__WEBPACK_IMPORTED_MODULE_4__.useLexicalNodeSelection)(nodeKey);\n  const $onDelete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(event => {\n    if (isSelected && (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$isNodeSelection)((0,lexical__WEBPACK_IMPORTED_MODULE_2__.$getSelection)())) {\n      event.preventDefault();\n      const node = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$getNodeByKey)(nodeKey);\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n        return true;\n      }\n    }\n    return false;\n  }, [isSelected, nodeKey]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_5__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_2__.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n        setSelected(!isSelected);\n        return true;\n      }\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_2__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_2__.KEY_DELETE_COMMAND, $onDelete, lexical__WEBPACK_IMPORTED_MODULE_2__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_2__.KEY_BACKSPACE_COMMAND, $onDelete, lexical__WEBPACK_IMPORTED_MODULE_2__.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, $onDelete, setSelected]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n    const isSelectedClassName = 'selected';\n    if (hrElem !== null) {\n      if (isSelected) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_5__.addClassNamesToElement)(hrElem, isSelectedClassName);\n      } else {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_5__.removeClassNamesFromElement)(hrElem, isSelectedClassName);\n      }\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\nclass HorizontalRuleNode extends lexical__WEBPACK_IMPORTED_MODULE_2__.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('hr');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_5__.addClassNamesToElement)(element, config.theme.hr);\n    return element;\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  isInline() {\n    return false;\n  }\n  updateDOM() {\n    return false;\n  }\n  decorate() {\n    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n}\nfunction $convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\nfunction $createHorizontalRuleNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$applyNodeReplacement)(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Y7QUFDRDtBQUNtQjtBQUMwRztBQUMvSjtBQUNQOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsc0RBQWE7QUFDcEQ7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDLG9EQUFvRCwrRkFBdUI7QUFDM0Usb0JBQW9CLGtEQUFXO0FBQy9CLHNCQUFzQix5REFBZ0IsQ0FBQyxzREFBYTtBQUNwRDtBQUNBLG1CQUFtQixzREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYLFdBQVcsNkRBQWEsd0JBQXdCLGtEQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSx5REFBb0IsMEJBQTBCLHVEQUFrQixhQUFhLHlEQUFvQiwwQkFBMEIsMERBQXFCLGFBQWEseURBQW9CO0FBQ3hMLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFzQjtBQUM5QixRQUFRO0FBQ1IsUUFBUSwyRUFBMkI7QUFDbkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUNBQWlDLGtEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFHO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIb3Jpem9udGFsUnVsZU5vZGUuZGV2Lm1qcz9jZWIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsTm9kZVNlbGVjdGlvbic7XG5pbXBvcnQgeyBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCBtZXJnZVJlZ2lzdGVyLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVDb21tYW5kLCBEZWNvcmF0b3JOb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsICRpc05vZGVTZWxlY3Rpb24sICRnZXRTZWxlY3Rpb24sICRnZXROb2RlQnlLZXksIENMSUNLX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfTE9XLCBLRVlfREVMRVRFX0NPTU1BTkQsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBJTlNFUlRfSE9SSVpPTlRBTF9SVUxFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfSE9SSVpPTlRBTF9SVUxFX0NPTU1BTkQnKTtcbmZ1bmN0aW9uIEhvcml6b250YWxSdWxlQ29tcG9uZW50KHtcbiAgbm9kZUtleVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBjbGVhclNlbGVjdGlvbl0gPSB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbihub2RlS2V5KTtcbiAgY29uc3QgJG9uRGVsZXRlID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChpc1NlbGVjdGVkICYmICRpc05vZGVTZWxlY3Rpb24oJGdldFNlbGVjdGlvbigpKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuICAgICAgaWYgKCRpc0hvcml6b250YWxSdWxlTm9kZShub2RlKSkge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBbaXNTZWxlY3RlZCwgbm9kZUtleV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xJQ0tfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgaHJFbGVtID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGhyRWxlbSkge1xuICAgICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3RlZCghaXNTZWxlY3RlZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfREVMRVRFX0NPTU1BTkQsICRvbkRlbGV0ZSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgJG9uRGVsZXRlLCBDT01NQU5EX1BSSU9SSVRZX0xPVykpO1xuICB9LCBbY2xlYXJTZWxlY3Rpb24sIGVkaXRvciwgaXNTZWxlY3RlZCwgbm9kZUtleSwgJG9uRGVsZXRlLCBzZXRTZWxlY3RlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhyRWxlbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZUtleSk7XG4gICAgY29uc3QgaXNTZWxlY3RlZENsYXNzTmFtZSA9ICdzZWxlY3RlZCc7XG4gICAgaWYgKGhyRWxlbSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChockVsZW0sIGlzU2VsZWN0ZWRDbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGhyRWxlbSwgaXNTZWxlY3RlZENsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZWRpdG9yLCBpc1NlbGVjdGVkLCBub2RlS2V5XSk7XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgSG9yaXpvbnRhbFJ1bGVOb2RlIGV4dGVuZHMgRGVjb3JhdG9yTm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnaG9yaXpvbnRhbHJ1bGUnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBIb3Jpem9udGFsUnVsZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZSgpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhyOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhvcml6b250YWxSdWxlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaG9yaXpvbnRhbHJ1bGUnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdocicpXG4gICAgfTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hyJyk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUuaHIpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnXFxuJztcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWNvcmF0ZSgpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChIb3Jpem9udGFsUnVsZUNvbXBvbmVudCwge1xuICAgICAgbm9kZUtleTogdGhpcy5fX2tleVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydEhvcml6b250YWxSdWxlRWxlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlKClcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVIb3Jpem9udGFsUnVsZU5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEhvcml6b250YWxSdWxlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc0hvcml6b250YWxSdWxlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgSG9yaXpvbnRhbFJ1bGVOb2RlO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlLCAkaXNIb3Jpem9udGFsUnVsZU5vZGUsIEhvcml6b250YWxSdWxlTm9kZSwgSU5TRVJUX0hPUklaT05UQUxfUlVMRV9DT01NQU5EIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.dev.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListPlugin: () => (/* binding */ ListPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useList(editor) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_2__.INSERT_ORDERED_LIST_COMMAND, () => {\n      (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.insertList)(editor, 'number');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_2__.INSERT_UNORDERED_LIST_COMMAND, () => {\n      (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.insertList)(editor, 'bullet');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_2__.REMOVE_LIST_COMMAND, () => {\n      (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.removeList)(editor);\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.INSERT_PARAGRAPH_COMMAND, () => {\n      const hasHandledInsertParagraph = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_2__.$handleListInsertParagraph)();\n      if (hasHandledInsertParagraph) {\n        return true;\n      }\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_LOW));\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ListPlugin() {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__.useLexicalComposerContext)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!editor.hasNodes([_lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_2__.ListItemNode])) {\n      throw new Error('ListPlugin: ListNode and/or ListItemNode not registered on editor');\n    }\n  }, [editor]);\n  useList(editor);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEw7QUFDMUc7QUFDaEQ7QUFDYTtBQUMwQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLGdEQUFTO0FBQ1gsV0FBVyw2REFBYSx3QkFBd0Isc0VBQTJCO0FBQzNFLE1BQU0seURBQVU7QUFDaEI7QUFDQSxLQUFLLEVBQUUseURBQW9CLDBCQUEwQix3RUFBNkI7QUFDbEYsTUFBTSx5REFBVTtBQUNoQjtBQUNBLEtBQUssRUFBRSx5REFBb0IsMEJBQTBCLDhEQUFtQjtBQUN4RSxNQUFNLHlEQUFVO0FBQ2hCO0FBQ0EsS0FBSyxFQUFFLHlEQUFvQiwwQkFBMEIsNkRBQXdCO0FBQzdFLHdDQUF3Qyx5RUFBMEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUseURBQW9CO0FBQzNCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnR0FBeUI7QUFDNUMsRUFBRSxnREFBUztBQUNYLDBCQUEwQixtREFBUSxFQUFFLHVEQUFZO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uZGV2Lm1qcz8yYjU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5ELCBpbnNlcnRMaXN0LCBJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCwgUkVNT1ZFX0xJU1RfQ09NTUFORCwgcmVtb3ZlTGlzdCwgJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgsIExpc3ROb2RlLCBMaXN0SXRlbU5vZGUgfSBmcm9tICdAbGV4aWNhbC9saXN0JztcbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBDT01NQU5EX1BSSU9SSVRZX0xPVywgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5EIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdXNlTGlzdChlZGl0b3IpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICAgaW5zZXJ0TGlzdChlZGl0b3IsICdudW1iZXInKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICAgaW5zZXJ0TGlzdChlZGl0b3IsICdidWxsZXQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRU1PVkVfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICByZW1vdmVMaXN0KGVkaXRvcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBjb25zdCBoYXNIYW5kbGVkSW5zZXJ0UGFyYWdyYXBoID0gJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgIGlmIChoYXNIYW5kbGVkSW5zZXJ0UGFyYWdyYXBoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSk7XG4gIH0sIFtlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBMaXN0UGx1Z2luKCkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5oYXNOb2RlcyhbTGlzdE5vZGUsIExpc3RJdGVtTm9kZV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RQbHVnaW46IExpc3ROb2RlIGFuZC9vciBMaXN0SXRlbU5vZGUgbm90IHJlZ2lzdGVyZWQgb24gZWRpdG9yJyk7XG4gICAgfVxuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUxpc3QoZWRpdG9yKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IExpc3RQbHVnaW4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TRANSFORMERS: () => (/* binding */ DEFAULT_TRANSFORMERS),\n/* harmony export */   MarkdownShortcutPlugin: () => (/* binding */ MarkdownShortcutPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_markdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/markdown */ \"(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalHorizontalRuleNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalHorizontalRuleNode */ \"(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HR = {\n  dependencies: [_lexical_react_LexicalHorizontalRuleNode__WEBPACK_IMPORTED_MODULE_1__.HorizontalRuleNode],\n  export: node => {\n    return (0,_lexical_react_LexicalHorizontalRuleNode__WEBPACK_IMPORTED_MODULE_1__.$isHorizontalRuleNode)(node) ? '***' : null;\n  },\n  regExp: /^(---|\\*\\*\\*|___)\\s?$/,\n  replace: (parentNode, _1, _2, isImport) => {\n    const line = (0,_lexical_react_LexicalHorizontalRuleNode__WEBPACK_IMPORTED_MODULE_1__.$createHorizontalRuleNode)();\n\n    // TODO: Get rid of isImport flag\n    if (isImport || parentNode.getNextSibling() != null) {\n      parentNode.replace(line);\n    } else {\n      parentNode.insertBefore(line);\n    }\n    line.selectNext();\n  },\n  type: 'element'\n};\nconst DEFAULT_TRANSFORMERS = [HR, ..._lexical_markdown__WEBPACK_IMPORTED_MODULE_2__.TRANSFORMERS];\nfunction MarkdownShortcutPlugin({\n  transformers = DEFAULT_TRANSFORMERS\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return (0,_lexical_markdown__WEBPACK_IMPORTED_MODULE_2__.registerMarkdownShortcuts)(editor, transformers);\n  }, [editor, transformers]);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7QUFDTTtBQUM4QztBQUM5Rjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsd0ZBQWtCO0FBQ25DO0FBQ0EsV0FBVywrRkFBcUI7QUFDaEMsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsbUdBQXlCOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUMsMkRBQVk7QUFDakQ7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDLEVBQUUsZ0RBQVM7QUFDWCxXQUFXLDRFQUF5QjtBQUNwQyxHQUFHO0FBQ0g7QUFDQTs7QUFFd0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luLmRldi5tanM/NGJmMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IFRSQU5TRk9STUVSUywgcmVnaXN0ZXJNYXJrZG93blNob3J0Y3V0cyB9IGZyb20gJ0BsZXhpY2FsL21hcmtkb3duJztcbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IEhvcml6b250YWxSdWxlTm9kZSwgJGlzSG9yaXpvbnRhbFJ1bGVOb2RlLCAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlIH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZSc7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSFIgPSB7XG4gIGRlcGVuZGVuY2llczogW0hvcml6b250YWxSdWxlTm9kZV0sXG4gIGV4cG9ydDogbm9kZSA9PiB7XG4gICAgcmV0dXJuICRpc0hvcml6b250YWxSdWxlTm9kZShub2RlKSA/ICcqKionIDogbnVsbDtcbiAgfSxcbiAgcmVnRXhwOiAvXigtLS18XFwqXFwqXFwqfF9fXylcXHM/JC8sXG4gIHJlcGxhY2U6IChwYXJlbnROb2RlLCBfMSwgXzIsIGlzSW1wb3J0KSA9PiB7XG4gICAgY29uc3QgbGluZSA9ICRjcmVhdGVIb3Jpem9udGFsUnVsZU5vZGUoKTtcblxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgaXNJbXBvcnQgZmxhZ1xuICAgIGlmIChpc0ltcG9ydCB8fCBwYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgIT0gbnVsbCkge1xuICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlKGxpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShsaW5lKTtcbiAgICB9XG4gICAgbGluZS5zZWxlY3ROZXh0KCk7XG4gIH0sXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IERFRkFVTFRfVFJBTlNGT1JNRVJTID0gW0hSLCAuLi5UUkFOU0ZPUk1FUlNdO1xuZnVuY3Rpb24gTWFya2Rvd25TaG9ydGN1dFBsdWdpbih7XG4gIHRyYW5zZm9ybWVycyA9IERFRkFVTFRfVFJBTlNGT1JNRVJTXG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiByZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzKGVkaXRvciwgdHJhbnNmb3JtZXJzKTtcbiAgfSwgW2VkaXRvciwgdHJhbnNmb3JtZXJzXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBERUZBVUxUX1RSQU5TRk9STUVSUywgTWFya2Rvd25TaG9ydGN1dFBsdWdpbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.dev.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnChangePlugin: () => (/* binding */ OnChangePlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction OnChangePlugin({\n  ignoreHistoryMergeTagChange = true,\n  ignoreSelectionChange = false,\n  onChange\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  useLayoutEffectImpl(() => {\n    if (onChange) {\n      return editor.registerUpdateListener(({\n        editorState,\n        dirtyElements,\n        dirtyLeaves,\n        prevEditorState,\n        tags\n      }) => {\n        if (ignoreSelectionChange && dirtyElements.size === 0 && dirtyLeaves.size === 0 || ignoreHistoryMergeTagChange && tags.has('history-merge') || prevEditorState.isEmpty()) {\n          return;\n        }\n        onChange(editorState, editor, tags);\n      });\n    }\n  }, [editor, ignoreHistoryMergeTagChange, ignoreSelectionChange, onChange]);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGO0FBQy9COztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFlLEdBQUcsNENBQVM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixnR0FBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmRldi5tanM/ODQwOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBPbkNoYW5nZVBsdWdpbih7XG4gIGlnbm9yZUhpc3RvcnlNZXJnZVRhZ0NoYW5nZSA9IHRydWUsXG4gIGlnbm9yZVNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlLFxuICBvbkNoYW5nZVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICAgICAgZWRpdG9yU3RhdGUsXG4gICAgICAgIGRpcnR5RWxlbWVudHMsXG4gICAgICAgIGRpcnR5TGVhdmVzLFxuICAgICAgICBwcmV2RWRpdG9yU3RhdGUsXG4gICAgICAgIHRhZ3NcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZVNlbGVjdGlvbkNoYW5nZSAmJiBkaXJ0eUVsZW1lbnRzLnNpemUgPT09IDAgJiYgZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMCB8fCBpZ25vcmVIaXN0b3J5TWVyZ2VUYWdDaGFuZ2UgJiYgdGFncy5oYXMoJ2hpc3RvcnktbWVyZ2UnKSB8fCBwcmV2RWRpdG9yU3RhdGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKGVkaXRvclN0YXRlLCBlZGl0b3IsIHRhZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBpZ25vcmVIaXN0b3J5TWVyZ2VUYWdDaGFuZ2UsIGlnbm9yZVNlbGVjdGlvbkNoYW5nZSwgb25DaGFuZ2VdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IE9uQ2hhbmdlUGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RichTextPlugin: () => (/* binding */ RichTextPlugin)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _lexical_dragon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/dragon */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_3__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffectImpl(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ErrorBoundary, {\n        onError: e => editor._onError(e),\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n          fallback: null,\n          children: decorators[nodeKey]\n        })\n      });\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useRichTextSetup(editor) {\n  useLayoutEffectImpl(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)((0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__.registerRichText)(editor), (0,_lexical_dragon__WEBPACK_IMPORTED_MODULE_6__.registerDragonSupport)(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [contentEditable, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Placeholder, {\n      content: placeholder\n    }), decorators]\n  });\n}\nfunction Placeholder({\n  content\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = (0,_lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__.useLexicalEditable)();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNYO0FBQ2Q7QUFDVjtBQUNpQztBQUM1QjtBQUNJO0FBQ0E7QUFDRjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSx1RUFBd0I7QUFDekY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtDQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQWE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsK0NBQVE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVM7QUFDZjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxTQUFTLDhDQUFPO0FBQ2hCO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsMENBQTBDLHNEQUFHO0FBQzdDO0FBQ0EsK0JBQStCLHNEQUFHLENBQUMsMkNBQVE7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRDQUE0Qyx1REFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkRBQWEsQ0FBQyxvRUFBZ0IsVUFBVSxzRUFBcUI7O0FBRXhFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBO0FBQ0Esc0JBQXNCLHVEQUFJLENBQUMsdURBQVE7QUFDbkMsNkNBQTZDLHNEQUFHO0FBQ2hEO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBLG1CQUFtQixxRkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsUmljaFRleHRQbHVnaW4uZGV2Lm1qcz9lNzU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgdXNlTGV4aWNhbEVkaXRhYmxlIH0gZnJvbSAnQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlJztcbmltcG9ydCB7ICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeSB9IGZyb20gJ0BsZXhpY2FsL3RleHQnO1xuaW1wb3J0IHsgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlTWVtbywgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmbHVzaFN5bmMsIGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgcmVnaXN0ZXJEcmFnb25TdXBwb3J0IH0gZnJvbSAnQGxleGljYWwvZHJhZ29uJztcbmltcG9ydCB7IHJlZ2lzdGVyUmljaFRleHQgfSBmcm9tICdAbGV4aWNhbC9yaWNoLXRleHQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikge1xuICBjb25zdCBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkoZWRpdG9yLmlzQ29tcG9zaW5nKCkpKTtcbiAgcmV0dXJuIGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXI7XG59XG5mdW5jdGlvbiB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKSB7XG4gIGNvbnN0IFtjYW5TaG93UGxhY2Vob2xkZXIsIHNldENhblNob3dQbGFjZWhvbGRlcl0gPSB1c2VTdGF0ZSgoKSA9PiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikpO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBmdW5jdGlvbiByZXNldENhblNob3dQbGFjZWhvbGRlcigpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICBzZXRDYW5TaG93UGxhY2Vob2xkZXIoY3VycmVudENhblNob3dQbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSwgZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIH0pKTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gY2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHVzZURlY29yYXRvcnMoZWRpdG9yLCBFcnJvckJvdW5kYXJ5KSB7XG4gIGNvbnN0IFtkZWNvcmF0b3JzLCBzZXREZWNvcmF0b3JzXSA9IHVzZVN0YXRlKCgpID0+IGVkaXRvci5nZXREZWNvcmF0b3JzKCkpO1xuXG4gIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzXG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcihuZXh0RGVjb3JhdG9ycyA9PiB7XG4gICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICBzZXREZWNvcmF0b3JzKG5leHREZWNvcmF0b3JzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGNvbnRlbnQgZWRpdGFibGUgbW91bnRzIGJlZm9yZSB0aGUgc3Vic2NyaXB0aW9uIGlzIGFkZGVkLCB0aGVuXG4gICAgLy8gbm90aGluZyB3aWxsIGJlIHJlbmRlcmVkIG9uIGluaXRpYWwgcGFzcy4gV2UgY2FuIGdldCBhcm91bmQgdGhhdCBieVxuICAgIC8vIGVuc3VyaW5nIHRoYXQgd2Ugc2V0IHRoZSB2YWx1ZS5cbiAgICBzZXREZWNvcmF0b3JzKGVkaXRvci5nZXREZWNvcmF0b3JzKCkpO1xuICB9LCBbZWRpdG9yXSk7XG5cbiAgLy8gUmV0dXJuIGRlY29yYXRvcnMgZGVmaW5lZCBhcyBSZWFjdCBQb3J0YWxzXG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBkZWNvcmF0ZWRQb3J0YWxzID0gW107XG4gICAgY29uc3QgZGVjb3JhdG9yS2V5cyA9IE9iamVjdC5rZXlzKGRlY29yYXRvcnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb3JhdG9yS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IGRlY29yYXRvcktleXNbaV07XG4gICAgICBjb25zdCByZWFjdERlY29yYXRvciA9IC8qI19fUFVSRV9fKi9qc3goRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBvbkVycm9yOiBlID0+IGVkaXRvci5fb25FcnJvcihlKSxcbiAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goU3VzcGVuc2UsIHtcbiAgICAgICAgICBmYWxsYmFjazogbnVsbCxcbiAgICAgICAgICBjaGlsZHJlbjogZGVjb3JhdG9yc1tub2RlS2V5XVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcbiAgICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGRlY29yYXRlZFBvcnRhbHMucHVzaCggLyojX19QVVJFX18qL2NyZWF0ZVBvcnRhbChyZWFjdERlY29yYXRvciwgZWxlbWVudCwgbm9kZUtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb3JhdGVkUG9ydGFscztcbiAgfSwgW0Vycm9yQm91bmRhcnksIGRlY29yYXRvcnMsIGVkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHVzZVJpY2hUZXh0U2V0dXAoZWRpdG9yKSB7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKHJlZ2lzdGVyUmljaFRleHQoZWRpdG9yKSwgcmVnaXN0ZXJEcmFnb25TdXBwb3J0KGVkaXRvcikpO1xuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbZWRpdG9yXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gUmljaFRleHRQbHVnaW4oe1xuICBjb250ZW50RWRpdGFibGUsXG4gIHBsYWNlaG9sZGVyLFxuICBFcnJvckJvdW5kYXJ5XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBkZWNvcmF0b3JzID0gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpO1xuICB1c2VSaWNoVGV4dFNldHVwKGVkaXRvcik7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbY29udGVudEVkaXRhYmxlLCAvKiNfX1BVUkVfXyovanN4KFBsYWNlaG9sZGVyLCB7XG4gICAgICBjb250ZW50OiBwbGFjZWhvbGRlclxuICAgIH0pLCBkZWNvcmF0b3JzXVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHtcbiAgY29udGVudFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3Qgc2hvd1BsYWNlaG9sZGVyID0gdXNlQ2FuU2hvd1BsYWNlaG9sZGVyKGVkaXRvcik7XG4gIGNvbnN0IGVkaXRhYmxlID0gdXNlTGV4aWNhbEVkaXRhYmxlKCk7XG4gIGlmICghc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQoZWRpdGFibGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG59XG5cbmV4cG9ydCB7IFJpY2hUZXh0UGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TabIndentationPlugin: () => (/* binding */ TabIndentationPlugin),\n/* harmony export */   registerTabIndentation: () => (/* binding */ registerTabIndentation)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $indentOverTab(selection) {\n  // const handled = new Set();\n  const nodes = selection.getNodes();\n  const canIndentBlockNodes = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$filter)(nodes, node => {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_2__.$isBlockElementNode)(node) && node.canIndent()) {\n      return node;\n    }\n    return null;\n  });\n  // 1. If selection spans across canIndent block nodes: indent\n  if (canIndentBlockNodes.length > 0) {\n    return true;\n  }\n  // 2. If first (anchor/focus) is at block start: indent\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const first = focus.isBefore(anchor) ? focus : anchor;\n  const firstNode = first.getNode();\n  const firstBlock = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestBlockElementAncestorOrThrow)(firstNode);\n  if (firstBlock.canIndent()) {\n    const firstBlockKey = firstBlock.getKey();\n    let selectionAtStart = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$createRangeSelection)();\n    selectionAtStart.anchor.set(firstBlockKey, 0, 'element');\n    selectionAtStart.focus.set(firstBlockKey, 0, 'element');\n    selectionAtStart = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$normalizeSelection__EXPERIMENTAL)(selectionAtStart);\n    if (selectionAtStart.anchor.is(first)) {\n      return true;\n    }\n  }\n  // 3. Else: tab\n  return false;\n}\nfunction registerTabIndentation(editor) {\n  return editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_2__.KEY_TAB_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_2__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const command = $indentOverTab(selection) ? event.shiftKey ? lexical__WEBPACK_IMPORTED_MODULE_2__.OUTDENT_CONTENT_COMMAND : lexical__WEBPACK_IMPORTED_MODULE_2__.INDENT_CONTENT_COMMAND : lexical__WEBPACK_IMPORTED_MODULE_2__.INSERT_TAB_COMMAND;\n    return editor.dispatchCommand(command, undefined);\n  }, lexical__WEBPACK_IMPORTED_MODULE_2__.COMMAND_PRIORITY_EDITOR);\n}\n\n/**\n * This plugin adds the ability to indent content using the tab key. Generally, we don't\n * recommend using this plugin as it could negatively affect acessibility for keyboard\n * users, causing focus to become trapped within the editor.\n */\nfunction TabIndentationPlugin() {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext)();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return registerTabIndentation(editor);\n  });\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYkluZGVudGF0aW9uUGx1Z2luLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGO0FBQ0Q7QUFDd0s7QUFDdk47O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBTztBQUNyQyxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNGQUFzQztBQUMzRDtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFxQjtBQUNoRDtBQUNBO0FBQ0EsdUJBQXVCLDBFQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9EQUFlO0FBQy9DLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNERBQXVCLEdBQUcsMkRBQXNCLEdBQUcsdURBQWtCO0FBQ3RJO0FBQ0EsR0FBRyxFQUFFLDREQUF1QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0dBQXlCO0FBQzVDLEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUV3RCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYkluZGVudGF0aW9uUGx1Z2luLmRldi5tanM/OGFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7ICRmaWx0ZXIsICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93IH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgS0VZX1RBQl9DT01NQU5ELCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIElOREVOVF9DT05URU5UX0NPTU1BTkQsIElOU0VSVF9UQUJfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9FRElUT1IsICRpc0Jsb2NrRWxlbWVudE5vZGUsICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGluZGVudE92ZXJUYWIoc2VsZWN0aW9uKSB7XG4gIC8vIGNvbnN0IGhhbmRsZWQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGNhbkluZGVudEJsb2NrTm9kZXMgPSAkZmlsdGVyKG5vZGVzLCBub2RlID0+IHtcbiAgICBpZiAoJGlzQmxvY2tFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmNhbkluZGVudCgpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuICAvLyAxLiBJZiBzZWxlY3Rpb24gc3BhbnMgYWNyb3NzIGNhbkluZGVudCBibG9jayBub2RlczogaW5kZW50XG4gIGlmIChjYW5JbmRlbnRCbG9ja05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyAyLiBJZiBmaXJzdCAoYW5jaG9yL2ZvY3VzKSBpcyBhdCBibG9jayBzdGFydDogaW5kZW50XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBmaXJzdCA9IGZvY3VzLmlzQmVmb3JlKGFuY2hvcikgPyBmb2N1cyA6IGFuY2hvcjtcbiAgY29uc3QgZmlyc3ROb2RlID0gZmlyc3QuZ2V0Tm9kZSgpO1xuICBjb25zdCBmaXJzdEJsb2NrID0gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coZmlyc3ROb2RlKTtcbiAgaWYgKGZpcnN0QmxvY2suY2FuSW5kZW50KCkpIHtcbiAgICBjb25zdCBmaXJzdEJsb2NrS2V5ID0gZmlyc3RCbG9jay5nZXRLZXkoKTtcbiAgICBsZXQgc2VsZWN0aW9uQXRTdGFydCA9ICRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICAgIHNlbGVjdGlvbkF0U3RhcnQuYW5jaG9yLnNldChmaXJzdEJsb2NrS2V5LCAwLCAnZWxlbWVudCcpO1xuICAgIHNlbGVjdGlvbkF0U3RhcnQuZm9jdXMuc2V0KGZpcnN0QmxvY2tLZXksIDAsICdlbGVtZW50Jyk7XG4gICAgc2VsZWN0aW9uQXRTdGFydCA9ICRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTChzZWxlY3Rpb25BdFN0YXJ0KTtcbiAgICBpZiAoc2VsZWN0aW9uQXRTdGFydC5hbmNob3IuaXMoZmlyc3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gMy4gRWxzZTogdGFiXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFiSW5kZW50YXRpb24oZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9UQUJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBjb21tYW5kID0gJGluZGVudE92ZXJUYWIoc2VsZWN0aW9uKSA/IGV2ZW50LnNoaWZ0S2V5ID8gT1VUREVOVF9DT05URU5UX0NPTU1BTkQgOiBJTkRFTlRfQ09OVEVOVF9DT01NQU5EIDogSU5TRVJUX1RBQl9DT01NQU5EO1xuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGNvbW1hbmQsIHVuZGVmaW5lZCk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKTtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBhZGRzIHRoZSBhYmlsaXR5IHRvIGluZGVudCBjb250ZW50IHVzaW5nIHRoZSB0YWIga2V5LiBHZW5lcmFsbHksIHdlIGRvbid0XG4gKiByZWNvbW1lbmQgdXNpbmcgdGhpcyBwbHVnaW4gYXMgaXQgY291bGQgbmVnYXRpdmVseSBhZmZlY3QgYWNlc3NpYmlsaXR5IGZvciBrZXlib2FyZFxuICogdXNlcnMsIGNhdXNpbmcgZm9jdXMgdG8gYmVjb21lIHRyYXBwZWQgd2l0aGluIHRoZSBlZGl0b3IuXG4gKi9cbmZ1bmN0aW9uIFRhYkluZGVudGF0aW9uUGx1Z2luKCkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0ZXJUYWJJbmRlbnRhdGlvbihlZGl0b3IpO1xuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IFRhYkluZGVudGF0aW9uUGx1Z2luLCByZWdpc3RlclRhYkluZGVudGF0aW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTreeView.dev.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeView: () => (/* binding */ TreeView)\n/* harmony export */ });\n/* harmony import */ var _lexical_devtools_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/devtools-core */ \"(ssr)/./node_modules/@lexical/react/node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction TreeView({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editor,\n  customPrintNode\n}) {\n  const treeElementRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n  const [editorCurrentState, setEditorCurrentState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editor.getEditorState());\n  const commandsLog = (0,_lexical_devtools_core__WEBPACK_IMPORTED_MODULE_2__.useLexicalCommandsLog)(editor);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.mergeRegister)(editor.registerUpdateListener(({\n      editorState\n    }) => {\n      setEditorCurrentState(editorState);\n    }), editor.registerEditableListener(() => {\n      setEditorCurrentState(editor.getEditorState());\n    }));\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const element = treeElementRef.current;\n    if (element !== null) {\n      // @ts-ignore Internal field\n      element.__lexicalEditor = editor;\n      return () => {\n        // @ts-ignore Internal field\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor, treeElementRef]);\n  const handleEditorReadOnly = isReadonly => {\n    const rootElement = editor.getRootElement();\n    if (rootElement == null) {\n      return;\n    }\n    rootElement.contentEditable = isReadonly ? 'false' : 'true';\n  };\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_lexical_devtools_core__WEBPACK_IMPORTED_MODULE_2__.TreeView, {\n    treeTypeButtonClassName: treeTypeButtonClassName,\n    timeTravelButtonClassName: timeTravelButtonClassName,\n    timeTravelPanelSliderClassName: timeTravelPanelSliderClassName,\n    timeTravelPanelButtonClassName: timeTravelPanelButtonClassName,\n    viewClassName: viewClassName,\n    timeTravelPanelClassName: timeTravelPanelClassName,\n    setEditorReadOnly: handleEditorReadOnly,\n    editorState: editorCurrentState,\n    setEditorState: state => editor.setEditorState(state),\n    generateContent: async function (exportDOM) {\n      return (0,_lexical_devtools_core__WEBPACK_IMPORTED_MODULE_2__.generateContent)(editor, commandsLog, exportDOM, customPrintNode);\n    },\n    ref: treeElementRef\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRyZWVWaWV3LmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0c7QUFDekQ7QUFDaEI7QUFDYTtBQUNKOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0NBQXNDLDRDQUFlO0FBQ3JELHNEQUFzRCwrQ0FBUTtBQUM5RCxzQkFBc0IsNkVBQXFCO0FBQzNDLEVBQUUsZ0RBQVM7QUFDWCxXQUFXLDZEQUFhO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFHLENBQUMsNERBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVFQUFlO0FBQzVCLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUcmVlVmlldy5kZXYubWpzP2QzY2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tbWFuZHNMb2csIFRyZWVWaWV3IGFzIFRyZWVWaWV3JDEsIGdlbmVyYXRlQ29udGVudCB9IGZyb20gJ0BsZXhpY2FsL2RldnRvb2xzLWNvcmUnO1xuaW1wb3J0IHsgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gVHJlZVZpZXcoe1xuICB0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZSxcbiAgdGltZVRyYXZlbEJ1dHRvbkNsYXNzTmFtZSxcbiAgdGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsUGFuZWxCdXR0b25DbGFzc05hbWUsXG4gIHZpZXdDbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxQYW5lbENsYXNzTmFtZSxcbiAgZWRpdG9yLFxuICBjdXN0b21QcmludE5vZGVcbn0pIHtcbiAgY29uc3QgdHJlZUVsZW1lbnRSZWYgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gIGNvbnN0IFtlZGl0b3JDdXJyZW50U3RhdGUsIHNldEVkaXRvckN1cnJlbnRTdGF0ZV0gPSB1c2VTdGF0ZShlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKSk7XG4gIGNvbnN0IGNvbW1hbmRzTG9nID0gdXNlTGV4aWNhbENvbW1hbmRzTG9nKGVkaXRvcik7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICAgIGVkaXRvclN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgc2V0RWRpdG9yQ3VycmVudFN0YXRlKGVkaXRvclN0YXRlKTtcbiAgICB9KSwgZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICBzZXRFZGl0b3JDdXJyZW50U3RhdGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICAgIH0pKTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0cmVlRWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBAdHMtaWdub3JlIEludGVybmFsIGZpZWxkXG4gICAgICBlbGVtZW50Ll9fbGV4aWNhbEVkaXRvciA9IGVkaXRvcjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgSW50ZXJuYWwgZmllbGRcbiAgICAgICAgZWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlZGl0b3IsIHRyZWVFbGVtZW50UmVmXSk7XG4gIGNvbnN0IGhhbmRsZUVkaXRvclJlYWRPbmx5ID0gaXNSZWFkb25seSA9PiB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBpZiAocm9vdEVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByb290RWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBpc1JlYWRvbmx5ID8gJ2ZhbHNlJyA6ICd0cnVlJztcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goVHJlZVZpZXckMSwge1xuICAgIHRyZWVUeXBlQnV0dG9uQ2xhc3NOYW1lOiB0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZSxcbiAgICB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lOiB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgIHRpbWVUcmF2ZWxQYW5lbFNsaWRlckNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lLFxuICAgIHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgIHZpZXdDbGFzc05hbWU6IHZpZXdDbGFzc05hbWUsXG4gICAgdGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWUsXG4gICAgc2V0RWRpdG9yUmVhZE9ubHk6IGhhbmRsZUVkaXRvclJlYWRPbmx5LFxuICAgIGVkaXRvclN0YXRlOiBlZGl0b3JDdXJyZW50U3RhdGUsXG4gICAgc2V0RWRpdG9yU3RhdGU6IHN0YXRlID0+IGVkaXRvci5zZXRFZGl0b3JTdGF0ZShzdGF0ZSksXG4gICAgZ2VuZXJhdGVDb250ZW50OiBhc3luYyBmdW5jdGlvbiAoZXhwb3J0RE9NKSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVDb250ZW50KGVkaXRvciwgY29tbWFuZHNMb2csIGV4cG9ydERPTSwgY3VzdG9tUHJpbnROb2RlKTtcbiAgICB9LFxuICAgIHJlZjogdHJlZUVsZW1lbnRSZWZcbiAgfSk7XG59XG5cbmV4cG9ydCB7IFRyZWVWaWV3IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@lexical/react/node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeView: () => (/* binding */ TreeView),\n/* harmony export */   generateContent: () => (/* binding */ generateContent),\n/* harmony export */   registerLexicalCommandLogger: () => (/* binding */ registerLexicalCommandLogger),\n/* harmony export */   useLexicalCommandsLog: () => (/* binding */ useLexicalCommandsLog)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.dev.mjs\");\n/* harmony import */ var _lexical_mark__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/mark */ \"(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.mjs\");\n/* harmony import */ var _lexical_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/table */ \"(ssr)/./node_modules/@lexical/table/LexicalTable.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '',\n  isLastChild: '',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst FORMAT_PREDICATES_PARAGRAPH = [node => node.hasTextFormat('bold') && 'Bold', node => node.hasTextFormat('code') && 'Code', node => node.hasTextFormat('italic') && 'Italic', node => node.hasTextFormat('strikethrough') && 'Strikethrough', node => node.hasTextFormat('subscript') && 'Subscript', node => node.hasTextFormat('superscript') && 'Superscript', node => node.hasTextFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction generateContent(editor, commandsLog, exportDOM, customPrintNode, obfuscateText = false) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML((0,_lexical_html__WEBPACK_IMPORTED_MODULE_2__.$generateHtmlFromNodes)(editor));\n    });\n    return htmlString;\n  }\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n    visitTree((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}\\n`;\n      res += $printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection) ? printRangeSelection(selection) : (0,_lexical_table__WEBPACK_IMPORTED_MODULE_4__.$isTableSelection)(selection) ? printTableSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n  if (commandsLog.length) {\n    for (const {\n      index,\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n   ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n   None dispatched.';\n  }\n  res += '\\n\\n editor:';\n  res += `\\n   namespace ${editorConfig.namespace}`;\n  if (compositionKey !== null) {\n    res += `\\n   compositionKey ${compositionKey}`;\n  }\n  res += `\\n   editable ${String(editable)}`;\n  return res;\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n   anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n   focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printNodeSelection(selection) {\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isNodeSelection)(selection)) {\n    return '';\n  }\n  return `: node\\n   [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printTableSelection(selection) {\n  return `: table\\n   { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isElementNode)(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text, obfuscateText = false) {\n  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n  if (obfuscateText) {\n    return textToPrint.replace(/[^\\s]/g, '*');\n  }\n  return textToPrint;\n}\nfunction printNode(node, customPrintNode, obfuscateText = false) {\n  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : undefined;\n  if (customPrint !== undefined && customPrint.length > 0) {\n    return customPrint;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isTextNode)(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text, obfuscateText)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$isLinkNode)(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link, obfuscateText)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ((0,_lexical_mark__WEBPACK_IMPORTED_MODULE_6__.$isMarkNode)(node)) {\n    return `ids: [ ${node.getIDs().join(', ')} ]`;\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isParagraphNode)(node)) {\n    const formatText = printTextFormatProperties(node);\n    return formatText !== '' ? `{ ${formatText} }` : '';\n  } else {\n    return '';\n  }\n}\nfunction printTextFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES_PARAGRAPH.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printTitleProperties(node) {\n  let str = node.getTitle();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n  return str;\n}\nfunction $printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isTextNode)(node) || !(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection) || !isSelected || (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isElementNode)(node)) {\n    return '';\n  }\n\n  // No selected characters.\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n  return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isNodeSelection)(selection) || anchorAndFocus === null) {\n    return [-1, -1];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1;\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LARGE_EDITOR_STATE_SIZE = 1000;\nconst TreeView = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function TreeViewWrapped({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editorState,\n  setEditorState,\n  setEditorReadOnly,\n  generateContent\n}, ref) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [content, setContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [showExportDOM, setShowExportDOM] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const playingIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [isLimited, setIsLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [showLimited, setShowLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const lastEditorStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const lastGenerationID = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  const generateTree = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(exportDOM => {\n    const myID = ++lastGenerationID.current;\n    generateContent(exportDOM).then(treeText => {\n      if (myID === lastGenerationID.current) {\n        setContent(treeText);\n      }\n    }).catch(err => {\n      if (myID === lastGenerationID.current) {\n        setContent(`Error rendering tree: ${err.message}\\n\\nStack:\\n${err.stack}`);\n      }\n    });\n  }, [generateContent]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {\n      setIsLimited(true);\n      if (!showLimited) {\n        return;\n      }\n    }\n\n    // Prevent re-rendering if the editor state hasn't changed\n    if (lastEditorStateRef.current !== editorState) {\n      lastEditorStateRef.current = editorState;\n      generateTree(showExportDOM);\n      if (!timeTravelEnabled) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    }\n  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);\n  const handleExportModeToggleClick = () => {\n    generateTree(!showExportDOM);\n    setShowExportDOM(!showExportDOM);\n  };\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n    className: viewClassName,\n    children: [!showLimited && isLimited ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n      style: {\n        padding: 20\n      },\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n        style: {\n          marginRight: 20\n        },\n        children: \"Detected large EditorState, this can impact debugging performance.\"\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        onClick: () => {\n          setShowLimited(true);\n        },\n        style: {\n          background: 'transparent',\n          border: '1px solid white',\n          color: 'white',\n          cursor: 'pointer',\n          padding: 5\n        },\n        children: \"Show full tree\"\n      })]\n    }) : null, !showLimited ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n      onClick: () => handleExportModeToggleClick(),\n      className: treeTypeButtonClassName,\n      type: \"button\",\n      children: showExportDOM ? 'Tree' : 'Export DOM'\n    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n      onClick: () => {\n        setEditorReadOnly(true);\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      },\n      className: timeTravelButtonClassName,\n      type: \"button\",\n      children: \"Time Travel\"\n    }), (showLimited || !isLimited) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"pre\", {\n      ref: ref,\n      children: content\n    }), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n      className: timeTravelPanelClassName,\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          if (playingIndexRef.current === totalEditorStates - 1) {\n            playingIndexRef.current = 1;\n          }\n          setIsPlaying(!isPlaying);\n        },\n        type: \"button\",\n        children: isPlaying ? 'Pause' : 'Play'\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"input\", {\n        className: timeTravelPanelSliderClassName,\n        ref: inputRef,\n        onChange: event => {\n          const editorStateIndex = Number(event.target.value);\n          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n          if (timeStampedEditorState) {\n            playingIndexRef.current = editorStateIndex;\n            setEditorState(timeStampedEditorState[1]);\n          }\n        },\n        type: \"range\",\n        min: \"1\",\n        max: totalEditorStates - 1\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          setEditorReadOnly(false);\n          const index = timeStampedEditorStates.length - 1;\n          const timeStampedEditorState = timeStampedEditorStates[index];\n          setEditorState(timeStampedEditorState[1]);\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setTimeTravelEnabled(false);\n          setIsPlaying(false);\n        },\n        type: \"button\",\n        children: \"Exit\"\n      })]\n    })]\n  });\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerLexicalCommandLogger(editor, setLoggedCommands) {\n  const unregisterCommandListeners = new Set();\n  let i = 0;\n  for (const [command] of editor._commands) {\n    unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n      setLoggedCommands(state => {\n        i += 1;\n        const newState = [...state];\n        newState.push({\n          index: i,\n          payload,\n          type: command.type ? command.type : 'UNKNOWN'\n        });\n        if (newState.length > 10) {\n          newState.shift();\n        }\n        return newState;\n      });\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_CRITICAL));\n  }\n  return () => unregisterCommandListeners.forEach(unregister => unregister());\n}\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return registerLexicalCommandLogger(editor, setLoggedCommands);\n  }, [editor]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => loggedCommands, [loggedCommands]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3Qvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2RldnRvb2xzLWNvcmUvTGV4aWNhbERldnRvb2xzQ29yZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVEO0FBQ1g7QUFDQTtBQUNPO0FBQzhHO0FBQzNFO0FBQ3hDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUVBQXNCO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQyxjQUFjLGlEQUFRO0FBQ3RCO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUMsRUFBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsZ0RBQWdEO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCwyQ0FBMkMsMERBQWlCLCtDQUErQyxpRUFBaUI7QUFDNUgsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixNQUFNLElBQUksUUFBUSxLQUFLLGFBQWEsZ0VBQWdFO0FBQzFIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9C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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdCQUFnQixzREFBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxFQUFFLDhEQUF5QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQ0FBUTtBQUN0RCxFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0gsU0FBUyw4Q0FBTztBQUNoQjs7QUFFMEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L25vZGVfbW9kdWxlcy9AbGV4aWNhbC9kZXZ0b29scy1jb3JlL0xleGljYWxEZXZ0b29sc0NvcmUuZGV2Lm1qcz8xYTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyB9IGZyb20gJ0BsZXhpY2FsL2h0bWwnO1xuaW1wb3J0IHsgJGlzTGlua05vZGUgfSBmcm9tICdAbGV4aWNhbC9saW5rJztcbmltcG9ydCB7ICRpc01hcmtOb2RlIH0gZnJvbSAnQGxleGljYWwvbWFyayc7XG5pbXBvcnQgeyAkaXNUYWJsZVNlbGVjdGlvbiB9IGZyb20gJ0BsZXhpY2FsL3RhYmxlJztcbmltcG9ydCB7ICRnZXRTZWxlY3Rpb24sICRnZXRSb290LCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzTm9kZVNlbGVjdGlvbiwgJGlzRWxlbWVudE5vZGUsICRpc1RleHROb2RlLCAkaXNQYXJhZ3JhcGhOb2RlLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4cywganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQgPSBPYmplY3QuZnJlZXplKHtcbiAgJ1xcdCc6ICdcXFxcdCcsXG4gICdcXG4nOiAnXFxcXG4nXG59KTtcbmNvbnN0IE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVggPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQpLmpvaW4oJ3wnKSwgJ2cnKTtcbmNvbnN0IFNZTUJPTFMgPSBPYmplY3QuZnJlZXplKHtcbiAgYW5jZXN0b3JIYXNOZXh0U2libGluZzogJ3wnLFxuICBhbmNlc3RvcklzTGFzdENoaWxkOiAnICcsXG4gIGhhc05leHRTaWJsaW5nOiAn4pScJyxcbiAgaXNMYXN0Q2hpbGQ6ICfilJQnLFxuICBzZWxlY3RlZENoYXI6ICdeJyxcbiAgc2VsZWN0ZWRMaW5lOiAnPidcbn0pO1xuY29uc3QgRk9STUFUX1BSRURJQ0FURVMgPSBbbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnYm9sZCcpICYmICdCb2xkJywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnY29kZScpICYmICdDb2RlJywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnaXRhbGljJykgJiYgJ0l0YWxpYycsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSAmJiAnU3RyaWtldGhyb3VnaCcsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ3N1YnNjcmlwdCcpICYmICdTdWJzY3JpcHQnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdzdXBlcnNjcmlwdCcpICYmICdTdXBlcnNjcmlwdCcsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ3VuZGVybGluZScpICYmICdVbmRlcmxpbmUnXTtcbmNvbnN0IEZPUk1BVF9QUkVESUNBVEVTX1BBUkFHUkFQSCA9IFtub2RlID0+IG5vZGUuaGFzVGV4dEZvcm1hdCgnYm9sZCcpICYmICdCb2xkJywgbm9kZSA9PiBub2RlLmhhc1RleHRGb3JtYXQoJ2NvZGUnKSAmJiAnQ29kZScsIG5vZGUgPT4gbm9kZS5oYXNUZXh0Rm9ybWF0KCdpdGFsaWMnKSAmJiAnSXRhbGljJywgbm9kZSA9PiBub2RlLmhhc1RleHRGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSAmJiAnU3RyaWtldGhyb3VnaCcsIG5vZGUgPT4gbm9kZS5oYXNUZXh0Rm9ybWF0KCdzdWJzY3JpcHQnKSAmJiAnU3Vic2NyaXB0Jywgbm9kZSA9PiBub2RlLmhhc1RleHRGb3JtYXQoJ3N1cGVyc2NyaXB0JykgJiYgJ1N1cGVyc2NyaXB0Jywgbm9kZSA9PiBub2RlLmhhc1RleHRGb3JtYXQoJ3VuZGVybGluZScpICYmICdVbmRlcmxpbmUnXTtcbmNvbnN0IERFVEFJTF9QUkVESUNBVEVTID0gW25vZGUgPT4gbm9kZS5pc0RpcmVjdGlvbmxlc3MoKSAmJiAnRGlyZWN0aW9ubGVzcycsIG5vZGUgPT4gbm9kZS5pc1VubWVyZ2VhYmxlKCkgJiYgJ1VubWVyZ2VhYmxlJ107XG5jb25zdCBNT0RFX1BSRURJQ0FURVMgPSBbbm9kZSA9PiBub2RlLmlzVG9rZW4oKSAmJiAnVG9rZW4nLCBub2RlID0+IG5vZGUuaXNTZWdtZW50ZWQoKSAmJiAnU2VnbWVudGVkJ107XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yLCBjb21tYW5kc0xvZywgZXhwb3J0RE9NLCBjdXN0b21QcmludE5vZGUsIG9iZnVzY2F0ZVRleHQgPSBmYWxzZSkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBlZGl0b3JDb25maWcgPSBlZGl0b3IuX2NvbmZpZztcbiAgY29uc3QgY29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICBjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5fZWRpdGFibGU7XG4gIGlmIChleHBvcnRET00pIHtcbiAgICBsZXQgaHRtbFN0cmluZyA9ICcnO1xuICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgaHRtbFN0cmluZyA9IHByaW50UHJldHR5SFRNTCgkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvcikpO1xuICAgIH0pO1xuICAgIHJldHVybiBodG1sU3RyaW5nO1xuICB9XG4gIGxldCByZXMgPSAnIHJvb3RcXG4nO1xuICBjb25zdCBzZWxlY3Rpb25TdHJpbmcgPSBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmlzaXRUcmVlKCRnZXRSb290KCksIChub2RlLCBpbmRlbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBub2RlLmdldEtleSgpO1xuICAgICAgY29uc3Qgbm9kZUtleURpc3BsYXkgPSBgKCR7bm9kZUtleX0pYDtcbiAgICAgIGNvbnN0IHR5cGVEaXNwbGF5ID0gbm9kZS5nZXRUeXBlKCkgfHwgJyc7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gbm9kZS5pc1NlbGVjdGVkKCk7XG4gICAgICByZXMgKz0gYCR7aXNTZWxlY3RlZCA/IFNZTUJPTFMuc2VsZWN0ZWRMaW5lIDogJyAnfSAke2luZGVudC5qb2luKCcgJyl9ICR7bm9kZUtleURpc3BsYXl9ICR7dHlwZURpc3BsYXl9ICR7cHJpbnROb2RlKG5vZGUsIGN1c3RvbVByaW50Tm9kZSwgb2JmdXNjYXRlVGV4dCl9XFxuYDtcbiAgICAgIHJlcyArPSAkcHJpbnRTZWxlY3RlZENoYXJzTGluZSh7XG4gICAgICAgIGluZGVudCxcbiAgICAgICAgaXNTZWxlY3RlZCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZUtleURpc3BsYXksXG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgdHlwZURpc3BsYXlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3Rpb24gPT09IG51bGwgPyAnOiBudWxsJyA6ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgPyBwcmludFJhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgOiAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pID8gcHJpbnRUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIDogcHJpbnROb2RlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH0pO1xuICByZXMgKz0gJ1xcbiBzZWxlY3Rpb24nICsgc2VsZWN0aW9uU3RyaW5nO1xuICByZXMgKz0gJ1xcblxcbiBjb21tYW5kczonO1xuICBpZiAoY29tbWFuZHNMb2cubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBpbmRleCxcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkXG4gICAgfSBvZiBjb21tYW5kc0xvZykge1xuICAgICAgcmVzICs9IGBcXG4gIOKUlCAke2luZGV4fS4geyB0eXBlOiAke3R5cGV9LCBwYXlsb2FkOiAke3BheWxvYWQgaW5zdGFuY2VvZiBFdmVudCA/IHBheWxvYWQuY29uc3RydWN0b3IubmFtZSA6IHBheWxvYWR9IH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMgKz0gJ1xcbiAg4pSUIE5vbmUgZGlzcGF0Y2hlZC4nO1xuICB9XG4gIHJlcyArPSAnXFxuXFxuIGVkaXRvcjonO1xuICByZXMgKz0gYFxcbiAg4pSUIG5hbWVzcGFjZSAke2VkaXRvckNvbmZpZy5uYW1lc3BhY2V9YDtcbiAgaWYgKGNvbXBvc2l0aW9uS2V5ICE9PSBudWxsKSB7XG4gICAgcmVzICs9IGBcXG4gIOKUlCBjb21wb3NpdGlvbktleSAke2NvbXBvc2l0aW9uS2V5fWA7XG4gIH1cbiAgcmVzICs9IGBcXG4gIOKUlCBlZGl0YWJsZSAke1N0cmluZyhlZGl0YWJsZSl9YDtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHByaW50UmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIGxldCByZXMgPSAnJztcbiAgY29uc3QgZm9ybWF0VGV4dCA9IHByaW50Rm9ybWF0UHJvcGVydGllcyhzZWxlY3Rpb24pO1xuICByZXMgKz0gYDogcmFuZ2UgJHtmb3JtYXRUZXh0ICE9PSAnJyA/IGB7ICR7Zm9ybWF0VGV4dH0gfWAgOiAnJ30gJHtzZWxlY3Rpb24uc3R5bGUgIT09ICcnID8gYHsgc3R5bGU6ICR7c2VsZWN0aW9uLnN0eWxlfSB9IGAgOiAnJ31gO1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIHJlcyArPSBgXFxuICDilJwgYW5jaG9yIHsga2V5OiAke2FuY2hvci5rZXl9LCBvZmZzZXQ6ICR7YW5jaG9yT2Zmc2V0ID09PSBudWxsID8gJ251bGwnIDogYW5jaG9yT2Zmc2V0fSwgdHlwZTogJHthbmNob3IudHlwZX0gfWA7XG4gIHJlcyArPSBgXFxuICDilJQgZm9jdXMgeyBrZXk6ICR7Zm9jdXMua2V5fSwgb2Zmc2V0OiAke2ZvY3VzT2Zmc2V0ID09PSBudWxsID8gJ251bGwnIDogZm9jdXNPZmZzZXR9LCB0eXBlOiAke2ZvY3VzLnR5cGV9IH1gO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcHJpbnROb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBpZiAoISRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gYDogbm9kZVxcbiAg4pSUIFske0FycmF5LmZyb20oc2VsZWN0aW9uLl9ub2Rlcykuam9pbignLCAnKX1dYDtcbn1cbmZ1bmN0aW9uIHByaW50VGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHJldHVybiBgOiB0YWJsZVxcbiAg4pSUIHsgdGFibGU6ICR7c2VsZWN0aW9uLnRhYmxlS2V5fSwgYW5jaG9yQ2VsbDogJHtzZWxlY3Rpb24uYW5jaG9yLmtleX0sIGZvY3VzQ2VsbDogJHtzZWxlY3Rpb24uZm9jdXMua2V5fSB9YDtcbn1cbmZ1bmN0aW9uIHZpc2l0VHJlZShjdXJyZW50Tm9kZSwgdmlzaXRvciwgaW5kZW50ID0gW10pIHtcbiAgY29uc3QgY2hpbGROb2RlcyA9IGN1cnJlbnROb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUsIGkpID0+IHtcbiAgICB2aXNpdG9yKGNoaWxkTm9kZSwgaW5kZW50LmNvbmNhdChpID09PSBjaGlsZE5vZGVzTGVuZ3RoIC0gMSA/IFNZTUJPTFMuaXNMYXN0Q2hpbGQgOiBTWU1CT0xTLmhhc05leHRTaWJsaW5nKSk7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkTm9kZSkpIHtcbiAgICAgIHZpc2l0VHJlZShjaGlsZE5vZGUsIHZpc2l0b3IsIGluZGVudC5jb25jYXQoaSA9PT0gY2hpbGROb2Rlc0xlbmd0aCAtIDEgPyBTWU1CT0xTLmFuY2VzdG9ySXNMYXN0Q2hpbGQgOiBTWU1CT0xTLmFuY2VzdG9ySGFzTmV4dFNpYmxpbmcpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHRleHQsIG9iZnVzY2F0ZVRleHQgPSBmYWxzZSkge1xuICBjb25zdCB0ZXh0VG9QcmludCA9IE9iamVjdC5lbnRyaWVzKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IGFjYy5yZXBsYWNlKG5ldyBSZWdFeHAoa2V5LCAnZycpLCBTdHJpbmcodmFsdWUpKSwgdGV4dCk7XG4gIGlmIChvYmZ1c2NhdGVUZXh0KSB7XG4gICAgcmV0dXJuIHRleHRUb1ByaW50LnJlcGxhY2UoL1teXFxzXS9nLCAnKicpO1xuICB9XG4gIHJldHVybiB0ZXh0VG9QcmludDtcbn1cbmZ1bmN0aW9uIHByaW50Tm9kZShub2RlLCBjdXN0b21QcmludE5vZGUsIG9iZnVzY2F0ZVRleHQgPSBmYWxzZSkge1xuICBjb25zdCBjdXN0b21QcmludCA9IGN1c3RvbVByaW50Tm9kZSA/IGN1c3RvbVByaW50Tm9kZShub2RlLCBvYmZ1c2NhdGVUZXh0KSA6IHVuZGVmaW5lZDtcbiAgaWYgKGN1c3RvbVByaW50ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tUHJpbnQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjdXN0b21QcmludDtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IHRpdGxlID0gdGV4dC5sZW5ndGggPT09IDAgPyAnKGVtcHR5KScgOiBgXCIke25vcm1hbGl6ZSh0ZXh0LCBvYmZ1c2NhdGVUZXh0KX1cImA7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHByaW50QWxsVGV4dE5vZGVQcm9wZXJ0aWVzKG5vZGUpO1xuICAgIHJldHVybiBbdGl0bGUsIHByb3BlcnRpZXMubGVuZ3RoICE9PSAwID8gYHsgJHtwcm9wZXJ0aWVzfSB9YCA6IG51bGxdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJykudHJpbSgpO1xuICB9IGVsc2UgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgbGluayA9IG5vZGUuZ2V0VVJMKCk7XG4gICAgY29uc3QgdGl0bGUgPSBsaW5rLmxlbmd0aCA9PT0gMCA/ICcoZW1wdHkpJyA6IGBcIiR7bm9ybWFsaXplKGxpbmssIG9iZnVzY2F0ZVRleHQpfVwiYDtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcHJpbnRBbGxMaW5rTm9kZVByb3BlcnRpZXMobm9kZSk7XG4gICAgcmV0dXJuIFt0aXRsZSwgcHJvcGVydGllcy5sZW5ndGggIT09IDAgPyBgeyAke3Byb3BlcnRpZXN9IH1gIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKS50cmltKCk7XG4gIH0gZWxzZSBpZiAoJGlzTWFya05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gYGlkczogWyAke25vZGUuZ2V0SURzKCkuam9pbignLCAnKX0gXWA7XG4gIH0gZWxzZSBpZiAoJGlzUGFyYWdyYXBoTm9kZShub2RlKSkge1xuICAgIGNvbnN0IGZvcm1hdFRleHQgPSBwcmludFRleHRGb3JtYXRQcm9wZXJ0aWVzKG5vZGUpO1xuICAgIHJldHVybiBmb3JtYXRUZXh0ICE9PSAnJyA/IGB7ICR7Zm9ybWF0VGV4dH0gfWAgOiAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbmZ1bmN0aW9uIHByaW50VGV4dEZvcm1hdFByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBGT1JNQVRfUFJFRElDQVRFU19QQVJBR1JBUEgubWFwKHByZWRpY2F0ZSA9PiBwcmVkaWNhdGUobm9kZU9yU2VsZWN0aW9uKSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnZm9ybWF0OiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwcmludEFsbFRleHROb2RlUHJvcGVydGllcyhub2RlKSB7XG4gIHJldHVybiBbcHJpbnRGb3JtYXRQcm9wZXJ0aWVzKG5vZGUpLCBwcmludERldGFpbFByb3BlcnRpZXMobm9kZSksIHByaW50TW9kZVByb3BlcnRpZXMobm9kZSldLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpO1xufVxuZnVuY3Rpb24gcHJpbnRBbGxMaW5rTm9kZVByb3BlcnRpZXMobm9kZSkge1xuICByZXR1cm4gW3ByaW50VGFyZ2V0UHJvcGVydGllcyhub2RlKSwgcHJpbnRSZWxQcm9wZXJ0aWVzKG5vZGUpLCBwcmludFRpdGxlUHJvcGVydGllcyhub2RlKV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG59XG5mdW5jdGlvbiBwcmludERldGFpbFByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBERVRBSUxfUFJFRElDQVRFUy5tYXAocHJlZGljYXRlID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICBpZiAoc3RyICE9PSAnJykge1xuICAgIHN0ciA9ICdkZXRhaWw6ICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHByaW50TW9kZVByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBNT0RFX1BSRURJQ0FURVMubWFwKHByZWRpY2F0ZSA9PiBwcmVkaWNhdGUobm9kZU9yU2VsZWN0aW9uKSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnbW9kZTogJyArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gcHJpbnRGb3JtYXRQcm9wZXJ0aWVzKG5vZGVPclNlbGVjdGlvbikge1xuICBsZXQgc3RyID0gRk9STUFUX1BSRURJQ0FURVMubWFwKHByZWRpY2F0ZSA9PiBwcmVkaWNhdGUobm9kZU9yU2VsZWN0aW9uKSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnZm9ybWF0OiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwcmludFRhcmdldFByb3BlcnRpZXMobm9kZSkge1xuICBsZXQgc3RyID0gbm9kZS5nZXRUYXJnZXQoKTtcbiAgLy8gVE9ETyBGaXggbnVsbGlzaCBvbiBMaW5rTm9kZVxuICBpZiAoc3RyICE9IG51bGwpIHtcbiAgICBzdHIgPSAndGFyZ2V0OiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwcmludFJlbFByb3BlcnRpZXMobm9kZSkge1xuICBsZXQgc3RyID0gbm9kZS5nZXRSZWwoKTtcbiAgLy8gVE9ETyBGaXggbnVsbGlzaCBvbiBMaW5rTm9kZVxuICBpZiAoc3RyICE9IG51bGwpIHtcbiAgICBzdHIgPSAncmVsOiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwcmludFRpdGxlUHJvcGVydGllcyhub2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFRpdGxlKCk7XG4gIC8vIFRPRE8gRml4IG51bGxpc2ggb24gTGlua05vZGVcbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gJ3RpdGxlOiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiAkcHJpbnRTZWxlY3RlZENoYXJzTGluZSh7XG4gIGluZGVudCxcbiAgaXNTZWxlY3RlZCxcbiAgbm9kZSxcbiAgbm9kZUtleURpc3BsYXksXG4gIHNlbGVjdGlvbixcbiAgdHlwZURpc3BsYXlcbn0pIHtcbiAgLy8gTm8gc2VsZWN0aW9uIG9yIG5vZGUgaXMgbm90IHNlbGVjdGVkLlxuICBpZiAoISRpc1RleHROb2RlKG5vZGUpIHx8ICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFpc1NlbGVjdGVkIHx8ICRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gTm8gc2VsZWN0ZWQgY2hhcmFjdGVycy5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGlmIChub2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnIHx8IGFuY2hvci5nZXROb2RlKCkgPT09IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkgJiYgYW5jaG9yLm9mZnNldCA9PT0gZm9jdXMub2Zmc2V0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IFtzdGFydCwgZW5kXSA9ICRnZXRTZWxlY3Rpb25TdGFydEVuZChub2RlLCBzZWxlY3Rpb24pO1xuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBzZWxlY3Rpb25MYXN0SW5kZW50ID0gaW5kZW50W2luZGVudC5sZW5ndGggLSAxXSA9PT0gU1lNQk9MUy5oYXNOZXh0U2libGluZyA/IFNZTUJPTFMuYW5jZXN0b3JIYXNOZXh0U2libGluZyA6IFNZTUJPTFMuYW5jZXN0b3JJc0xhc3RDaGlsZDtcbiAgY29uc3QgaW5kZW50aW9uQ2hhcnMgPSBbLi4uaW5kZW50LnNsaWNlKDAsIGluZGVudC5sZW5ndGggLSAxKSwgc2VsZWN0aW9uTGFzdEluZGVudF07XG4gIGNvbnN0IHVuc2VsZWN0ZWRDaGFycyA9IEFycmF5KHN0YXJ0ICsgMSkuZmlsbCgnICcpO1xuICBjb25zdCBzZWxlY3RlZENoYXJzID0gQXJyYXkoZW5kIC0gc3RhcnQpLmZpbGwoU1lNQk9MUy5zZWxlY3RlZENoYXIpO1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gdHlwZURpc3BsYXkubGVuZ3RoICsgMzsgLy8gMiBmb3IgdGhlIHNwYWNlcyBhcm91bmQgKyAxIGZvciB0aGUgZG91YmxlIHF1b3RlLlxuXG4gIGNvbnN0IG5vZGVQcmludFNwYWNlcyA9IEFycmF5KG5vZGVLZXlEaXNwbGF5Lmxlbmd0aCArIHBhZGRpbmdMZW5ndGgpLmZpbGwoJyAnKTtcbiAgcmV0dXJuIFtTWU1CT0xTLnNlbGVjdGVkTGluZSwgaW5kZW50aW9uQ2hhcnMuam9pbignICcpLCBbLi4ubm9kZVByaW50U3BhY2VzLCAuLi51bnNlbGVjdGVkQ2hhcnMsIC4uLnNlbGVjdGVkQ2hhcnNdLmpvaW4oJycpXS5qb2luKCcgJykgKyAnXFxuJztcbn1cbmZ1bmN0aW9uIHByaW50UHJldHR5SFRNTChzdHIpIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBzdHIudHJpbSgpO1xuICByZXR1cm4gcHJldHRpZnlIVE1MKGRpdiwgMCkuaW5uZXJIVE1MO1xufVxuZnVuY3Rpb24gcHJldHRpZnlIVE1MKG5vZGUsIGxldmVsKSB7XG4gIGNvbnN0IGluZGVudEJlZm9yZSA9IG5ldyBBcnJheShsZXZlbCsrICsgMSkuam9pbignICAnKTtcbiAgY29uc3QgaW5kZW50QWZ0ZXIgPSBuZXcgQXJyYXkobGV2ZWwgLSAxKS5qb2luKCcgICcpO1xuICBsZXQgdGV4dE5vZGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcbicgKyBpbmRlbnRCZWZvcmUpO1xuICAgIG5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2RlLmNoaWxkcmVuW2ldKTtcbiAgICBwcmV0dGlmeUhUTUwobm9kZS5jaGlsZHJlbltpXSwgbGV2ZWwpO1xuICAgIGlmIChub2RlLmxhc3RFbGVtZW50Q2hpbGQgPT09IG5vZGUuY2hpbGRyZW5baV0pIHtcbiAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcbicgKyBpbmRlbnRBZnRlcik7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uU3RhcnRFbmQobm9kZSwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gWy0xLCAtMV07XG4gIH1cbiAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuXG4gIC8vIE9ubHkgb25lIG5vZGUgaXMgYmVpbmcgc2VsZWN0ZWQuXG4gIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIG5vZGUgPT09IGFuY2hvck5vZGUgJiYgYW5jaG9yLm9mZnNldCAhPT0gZm9jdXMub2Zmc2V0KSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBhbmNob3Iub2Zmc2V0IDwgZm9jdXMub2Zmc2V0ID8gW2FuY2hvci5vZmZzZXQsIGZvY3VzLm9mZnNldF0gOiBbZm9jdXMub2Zmc2V0LCBhbmNob3Iub2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUpIHtcbiAgICAgIFtzdGFydCwgZW5kXSA9IGFuY2hvck5vZGUuaXNCZWZvcmUoZm9jdXNOb2RlKSA/IFthbmNob3Iub2Zmc2V0LCB0ZXh0TGVuZ3RoXSA6IFswLCBhbmNob3Iub2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSkge1xuICAgICAgW3N0YXJ0LCBlbmRdID0gZm9jdXNOb2RlLmlzQmVmb3JlKGFuY2hvck5vZGUpID8gW2ZvY3VzLm9mZnNldCwgdGV4dExlbmd0aF0gOiBbMCwgZm9jdXMub2Zmc2V0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZSBpcyB3aXRoaW4gc2VsZWN0aW9uIGJ1dCBub3QgdGhlIGFuY2hvciBub3IgZm9jdXMuXG4gICAgICBbc3RhcnQsIGVuZF0gPSBbMCwgdGV4dExlbmd0aF07XG4gICAgfVxuICB9XG5cbiAgLy8gQWNjb3VudCBmb3Igbm9uLXNpbmdsZSB3aWR0aCBjaGFyYWN0ZXJzLlxuICBjb25zdCBudW1Ob25TaW5nbGVXaWR0aENoYXJCZWZvcmVTZWxlY3Rpb24gPSAodGV4dENvbnRlbnQuc2xpY2UoMCwgc3RhcnQpLm1hdGNoKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVgpIHx8IFtdKS5sZW5ndGg7XG4gIGNvbnN0IG51bU5vblNpbmdsZVdpZHRoQ2hhckluU2VsZWN0aW9uID0gKHRleHRDb250ZW50LnNsaWNlKHN0YXJ0LCBlbmQpLm1hdGNoKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVgpIHx8IFtdKS5sZW5ndGg7XG4gIHJldHVybiBbc3RhcnQgKyBudW1Ob25TaW5nbGVXaWR0aENoYXJCZWZvcmVTZWxlY3Rpb24sIGVuZCArIG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiArIG51bU5vblNpbmdsZVdpZHRoQ2hhckluU2VsZWN0aW9uXTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBMQVJHRV9FRElUT1JfU1RBVEVfU0laRSA9IDEwMDA7XG5jb25zdCBUcmVlVmlldyA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKGZ1bmN0aW9uIFRyZWVWaWV3V3JhcHBlZCh7XG4gIHRyZWVUeXBlQnV0dG9uQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZSxcbiAgdmlld0NsYXNzTmFtZSxcbiAgdGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lLFxuICBlZGl0b3JTdGF0ZSxcbiAgc2V0RWRpdG9yU3RhdGUsXG4gIHNldEVkaXRvclJlYWRPbmx5LFxuICBnZW5lcmF0ZUNvbnRlbnRcbn0sIHJlZikge1xuICBjb25zdCBbdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXMsIHNldFRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2NvbnRlbnQsIHNldENvbnRlbnRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbdGltZVRyYXZlbEVuYWJsZWQsIHNldFRpbWVUcmF2ZWxFbmFibGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dFeHBvcnRET00sIHNldFNob3dFeHBvcnRET01dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBwbGF5aW5nSW5kZXhSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbaXNQbGF5aW5nLCBzZXRJc1BsYXlpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMaW1pdGVkLCBzZXRJc0xpbWl0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0xpbWl0ZWQsIHNldFNob3dMaW1pdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgbGFzdEVkaXRvclN0YXRlUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGxhc3RHZW5lcmF0aW9uSUQgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGdlbmVyYXRlVHJlZSA9IHVzZUNhbGxiYWNrKGV4cG9ydERPTSA9PiB7XG4gICAgY29uc3QgbXlJRCA9ICsrbGFzdEdlbmVyYXRpb25JRC5jdXJyZW50O1xuICAgIGdlbmVyYXRlQ29udGVudChleHBvcnRET00pLnRoZW4odHJlZVRleHQgPT4ge1xuICAgICAgaWYgKG15SUQgPT09IGxhc3RHZW5lcmF0aW9uSUQuY3VycmVudCkge1xuICAgICAgICBzZXRDb250ZW50KHRyZWVUZXh0KTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKG15SUQgPT09IGxhc3RHZW5lcmF0aW9uSUQuY3VycmVudCkge1xuICAgICAgICBzZXRDb250ZW50KGBFcnJvciByZW5kZXJpbmcgdHJlZTogJHtlcnIubWVzc2FnZX1cXG5cXG5TdGFjazpcXG4ke2Vyci5zdGFja31gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2dlbmVyYXRlQ29udGVudF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2hvd0xpbWl0ZWQgJiYgZWRpdG9yU3RhdGUuX25vZGVNYXAuc2l6ZSA+IExBUkdFX0VESVRPUl9TVEFURV9TSVpFKSB7XG4gICAgICBzZXRJc0xpbWl0ZWQodHJ1ZSk7XG4gICAgICBpZiAoIXNob3dMaW1pdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHJlLXJlbmRlcmluZyBpZiB0aGUgZWRpdG9yIHN0YXRlIGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGxhc3RFZGl0b3JTdGF0ZVJlZi5jdXJyZW50ICE9PSBlZGl0b3JTdGF0ZSkge1xuICAgICAgbGFzdEVkaXRvclN0YXRlUmVmLmN1cnJlbnQgPSBlZGl0b3JTdGF0ZTtcbiAgICAgIGdlbmVyYXRlVHJlZShzaG93RXhwb3J0RE9NKTtcbiAgICAgIGlmICghdGltZVRyYXZlbEVuYWJsZWQpIHtcbiAgICAgICAgc2V0VGltZVN0YW1wZWRFZGl0b3JTdGF0ZXMoY3VycmVudEVkaXRvclN0YXRlcyA9PiBbLi4uY3VycmVudEVkaXRvclN0YXRlcywgW0RhdGUubm93KCksIGVkaXRvclN0YXRlXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VkaXRvclN0YXRlLCBnZW5lcmF0ZVRyZWUsIHNob3dFeHBvcnRET00sIHNob3dMaW1pdGVkLCB0aW1lVHJhdmVsRW5hYmxlZF0pO1xuICBjb25zdCB0b3RhbEVkaXRvclN0YXRlcyA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzLmxlbmd0aDtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNQbGF5aW5nKSB7XG4gICAgICBsZXQgdGltZW91dElkO1xuICAgICAgY29uc3QgcGxheSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gcGxheWluZ0luZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHRvdGFsRWRpdG9yU3RhdGVzIC0gMSkge1xuICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbY3VycmVudEluZGV4XVswXTtcbiAgICAgICAgY29uc3QgbmV4dFRpbWUgPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tjdXJyZW50SW5kZXggKyAxXVswXTtcbiAgICAgICAgY29uc3QgdGltZURpZmYgPSBuZXh0VGltZSAtIGN1cnJlbnRUaW1lO1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwbGF5aW5nSW5kZXhSZWYuY3VycmVudCsrO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGxheWluZ0luZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFJlZi5jdXJyZW50O1xuICAgICAgICAgIGlmIChpbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRFZGl0b3JTdGF0ZSh0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tpbmRleF1bMV0pO1xuICAgICAgICAgIHBsYXkoKTtcbiAgICAgICAgfSwgdGltZURpZmYpO1xuICAgICAgfTtcbiAgICAgIHBsYXkoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt0aW1lU3RhbXBlZEVkaXRvclN0YXRlcywgaXNQbGF5aW5nLCB0b3RhbEVkaXRvclN0YXRlcywgc2V0RWRpdG9yU3RhdGVdKTtcbiAgY29uc3QgaGFuZGxlRXhwb3J0TW9kZVRvZ2dsZUNsaWNrID0gKCkgPT4ge1xuICAgIGdlbmVyYXRlVHJlZSghc2hvd0V4cG9ydERPTSk7XG4gICAgc2V0U2hvd0V4cG9ydERPTSghc2hvd0V4cG9ydERPTSk7XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lLFxuICAgIGNoaWxkcmVuOiBbIXNob3dMaW1pdGVkICYmIGlzTGltaXRlZCA/IC8qI19fUFVSRV9fKi9qc3hzKFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBhZGRpbmc6IDIwXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgbWFyZ2luUmlnaHQ6IDIwXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBcIkRldGVjdGVkIGxhcmdlIEVkaXRvclN0YXRlLCB0aGlzIGNhbiBpbXBhY3QgZGVidWdnaW5nIHBlcmZvcm1hbmNlLlwiXG4gICAgICB9KSwgLyojX19QVVJFX18qL2pzeChcImJ1dHRvblwiLCB7XG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICBzZXRTaG93TGltaXRlZCh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCB3aGl0ZScsXG4gICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgcGFkZGluZzogNVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogXCJTaG93IGZ1bGwgdHJlZVwiXG4gICAgICB9KV1cbiAgICB9KSA6IG51bGwsICFzaG93TGltaXRlZCA/IC8qI19fUFVSRV9fKi9qc3goXCJidXR0b25cIiwge1xuICAgICAgb25DbGljazogKCkgPT4gaGFuZGxlRXhwb3J0TW9kZVRvZ2dsZUNsaWNrKCksXG4gICAgICBjbGFzc05hbWU6IHRyZWVUeXBlQnV0dG9uQ2xhc3NOYW1lLFxuICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgIGNoaWxkcmVuOiBzaG93RXhwb3J0RE9NID8gJ1RyZWUnIDogJ0V4cG9ydCBET00nXG4gICAgfSkgOiBudWxsLCAhdGltZVRyYXZlbEVuYWJsZWQgJiYgKHNob3dMaW1pdGVkIHx8ICFpc0xpbWl0ZWQpICYmIHRvdGFsRWRpdG9yU3RhdGVzID4gMiAmJiAvKiNfX1BVUkVfXyovanN4KFwiYnV0dG9uXCIsIHtcbiAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgc2V0RWRpdG9yUmVhZE9ubHkodHJ1ZSk7XG4gICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50ID0gdG90YWxFZGl0b3JTdGF0ZXMgLSAxO1xuICAgICAgICBzZXRUaW1lVHJhdmVsRW5hYmxlZCh0cnVlKTtcbiAgICAgIH0sXG4gICAgICBjbGFzc05hbWU6IHRpbWVUcmF2ZWxCdXR0b25DbGFzc05hbWUsXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgY2hpbGRyZW46IFwiVGltZSBUcmF2ZWxcIlxuICAgIH0pLCAoc2hvd0xpbWl0ZWQgfHwgIWlzTGltaXRlZCkgJiYgLyojX19QVVJFX18qL2pzeChcInByZVwiLCB7XG4gICAgICByZWY6IHJlZixcbiAgICAgIGNoaWxkcmVuOiBjb250ZW50XG4gICAgfSksIHRpbWVUcmF2ZWxFbmFibGVkICYmIChzaG93TGltaXRlZCB8fCAhaXNMaW1pdGVkKSAmJiAvKiNfX1BVUkVfXyovanN4cyhcImRpdlwiLCB7XG4gICAgICBjbGFzc05hbWU6IHRpbWVUcmF2ZWxQYW5lbENsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuOiBbLyojX19QVVJFX18qL2pzeChcImJ1dHRvblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlpbmdJbmRleFJlZi5jdXJyZW50ID09PSB0b3RhbEVkaXRvclN0YXRlcyAtIDEpIHtcbiAgICAgICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0SXNQbGF5aW5nKCFpc1BsYXlpbmcpO1xuICAgICAgICB9LFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICBjaGlsZHJlbjogaXNQbGF5aW5nID8gJ1BhdXNlJyA6ICdQbGF5J1xuICAgICAgfSksIC8qI19fUFVSRV9fKi9qc3goXCJpbnB1dFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lLFxuICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICBvbkNoYW5nZTogZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGVkaXRvclN0YXRlSW5kZXggPSBOdW1iZXIoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICBjb25zdCB0aW1lU3RhbXBlZEVkaXRvclN0YXRlID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbZWRpdG9yU3RhdGVJbmRleF07XG4gICAgICAgICAgaWYgKHRpbWVTdGFtcGVkRWRpdG9yU3RhdGUpIHtcbiAgICAgICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50ID0gZWRpdG9yU3RhdGVJbmRleDtcbiAgICAgICAgICAgIHNldEVkaXRvclN0YXRlKHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICBtaW46IFwiMVwiLFxuICAgICAgICBtYXg6IHRvdGFsRWRpdG9yU3RhdGVzIC0gMVxuICAgICAgfSksIC8qI19fUFVSRV9fKi9qc3goXCJidXR0b25cIiwge1xuICAgICAgICBjbGFzc05hbWU6IHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZSxcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIHNldEVkaXRvclJlYWRPbmx5KGZhbHNlKTtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgY29uc3QgdGltZVN0YW1wZWRFZGl0b3JTdGF0ZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2luZGV4XTtcbiAgICAgICAgICBzZXRFZGl0b3JTdGF0ZSh0aW1lU3RhbXBlZEVkaXRvclN0YXRlWzFdKTtcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgaWYgKGlucHV0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFRpbWVUcmF2ZWxFbmFibGVkKGZhbHNlKTtcbiAgICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJFeGl0XCJcbiAgICAgIH0pXVxuICAgIH0pXVxuICB9KTtcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTGV4aWNhbENvbW1hbmRMb2dnZXIoZWRpdG9yLCBzZXRMb2dnZWRDb21tYW5kcykge1xuICBjb25zdCB1bnJlZ2lzdGVyQ29tbWFuZExpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGNvbnN0IFtjb21tYW5kXSBvZiBlZGl0b3IuX2NvbW1hbmRzKSB7XG4gICAgdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lcnMuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgcGF5bG9hZCA9PiB7XG4gICAgICBzZXRMb2dnZWRDb21tYW5kcyhzdGF0ZSA9PiB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBbLi4uc3RhdGVdO1xuICAgICAgICBuZXdTdGF0ZS5wdXNoKHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgIHR5cGU6IGNvbW1hbmQudHlwZSA/IGNvbW1hbmQudHlwZSA6ICdVTktOT1dOJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld1N0YXRlLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgbmV3U3RhdGUuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXJzLmZvckVhY2godW5yZWdpc3RlciA9PiB1bnJlZ2lzdGVyKCkpO1xufVxuZnVuY3Rpb24gdXNlTGV4aWNhbENvbW1hbmRzTG9nKGVkaXRvcikge1xuICBjb25zdCBbbG9nZ2VkQ29tbWFuZHMsIHNldExvZ2dlZENvbW1hbmRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gcmVnaXN0ZXJMZXhpY2FsQ29tbWFuZExvZ2dlcihlZGl0b3IsIHNldExvZ2dlZENvbW1hbmRzKTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBsb2dnZWRDb21tYW5kcywgW2xvZ2dlZENvbW1hbmRzXSk7XG59XG5cbmV4cG9ydCB7IFRyZWVWaWV3LCBnZW5lcmF0ZUNvbnRlbnQsIHJlZ2lzdGVyTGV4aWNhbENvbW1hbmRMb2dnZXIsIHVzZUxleGljYWxDb21tYW5kc0xvZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useLexicalEditable),\n/* harmony export */   useLexicalEditable: () => (/* binding */ useLexicalEditable)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n * @param subscription - The function to create the {@link LexicalSubscription}. This function's identity must be stable (e.g. defined at module scope or with useCallback).\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  const initializedSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => subscription(editor), [editor, subscription]);\n  const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initializedSubscription.initialValueFn());\n  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(valueRef.current);\n  useLayoutEffectImpl(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\n/**\n * Get the current value for {@link LexicalEditor.isEditable}\n * using {@link useLexicalSubscription}.\n * You should prefer this over manually observing the value with\n * {@link LexicalEditor.registerEditableListener},\n * which is a bit tricky to do correctly, particularly when using\n * React StrictMode (the default for development) or concurrency.\n */\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNKOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFlLEdBQUcsNENBQVM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQSxtQkFBbUIsZ0dBQXlCO0FBQzVDLGtDQUFrQyw4Q0FBTztBQUN6QyxtQkFBbUIsNkNBQU07QUFDekIsNEJBQTRCLCtDQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QixVQUFVLDZCQUE2QjtBQUN2QztBQUNBLElBQUksNkNBQTZDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxFZGl0YWJsZS5kZXYubWpzPzA2NWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBTaG9ydGN1dCB0byBMZXhpY2FsIHN1YnNjcmlwdGlvbnMgd2hlbiB2YWx1ZXMgYXJlIHVzZWQgZm9yIHJlbmRlci5cbiAqIEBwYXJhbSBzdWJzY3JpcHRpb24gLSBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSB7QGxpbmsgTGV4aWNhbFN1YnNjcmlwdGlvbn0uIFRoaXMgZnVuY3Rpb24ncyBpZGVudGl0eSBtdXN0IGJlIHN0YWJsZSAoZS5nLiBkZWZpbmVkIGF0IG1vZHVsZSBzY29wZSBvciB3aXRoIHVzZUNhbGxiYWNrKS5cbiAqL1xuZnVuY3Rpb24gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IGluaXRpYWxpemVkU3Vic2NyaXB0aW9uID0gdXNlTWVtbygoKSA9PiBzdWJzY3JpcHRpb24oZWRpdG9yKSwgW2VkaXRvciwgc3Vic2NyaXB0aW9uXSk7XG4gIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmKGluaXRpYWxpemVkU3Vic2NyaXB0aW9uLmluaXRpYWxWYWx1ZUZuKCkpO1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVN0YXRlKHZhbHVlUmVmLmN1cnJlbnQpO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpbml0aWFsVmFsdWVGbixcbiAgICAgIHN1YnNjcmliZVxuICAgIH0gPSBpbml0aWFsaXplZFN1YnNjcmlwdGlvbjtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWVGbigpO1xuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzZXRWYWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2NyaWJlKG5ld1ZhbHVlID0+IHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9KTtcbiAgfSwgW2luaXRpYWxpemVkU3Vic2NyaXB0aW9uLCBzdWJzY3JpcHRpb25dKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHN1YnNjcmlwdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICBpbml0aWFsVmFsdWVGbjogKCkgPT4gZWRpdG9yLmlzRWRpdGFibGUoKSxcbiAgICBzdWJzY3JpYmU6IGNhbGxiYWNrID0+IHtcbiAgICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZvciB7QGxpbmsgTGV4aWNhbEVkaXRvci5pc0VkaXRhYmxlfVxuICogdXNpbmcge0BsaW5rIHVzZUxleGljYWxTdWJzY3JpcHRpb259LlxuICogWW91IHNob3VsZCBwcmVmZXIgdGhpcyBvdmVyIG1hbnVhbGx5IG9ic2VydmluZyB0aGUgdmFsdWUgd2l0aFxuICoge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyfSxcbiAqIHdoaWNoIGlzIGEgYml0IHRyaWNreSB0byBkbyBjb3JyZWN0bHksIHBhcnRpY3VsYXJseSB3aGVuIHVzaW5nXG4gKiBSZWFjdCBTdHJpY3RNb2RlICh0aGUgZGVmYXVsdCBmb3IgZGV2ZWxvcG1lbnQpIG9yIGNvbmN1cnJlbmN5LlxuICovXG5mdW5jdGlvbiB1c2VMZXhpY2FsRWRpdGFibGUoKSB7XG4gIHJldHVybiB1c2VMZXhpY2FsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG59XG5cbmV4cG9ydCB7IHVzZUxleGljYWxFZGl0YWJsZSBhcyBkZWZhdWx0LCB1c2VMZXhpY2FsRWRpdGFibGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalNodeSelection.dev.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLexicalNodeSelection: () => (/* binding */ useLexicalNodeSelection)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getNodeByKey)(key);\n    if (node === null) {\n      return false;\n    }\n    return node.isSelected();\n  });\n}\nfunction useLexicalNodeSelection(key) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  const [isSelected, setIsSelected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => isNodeSelected(editor, key));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false;\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(selected => {\n    editor.update(() => {\n      let selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isNodeSelection)(selection)) {\n        selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createNodeSelection)();\n        (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$setSelection)(selection);\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isNodeSelection)(selection)) {\n        if (selected) {\n          selection.add(key);\n        } else {\n          selection.delete(key);\n        }\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isNodeSelection)(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGO0FBQzRCO0FBQ3JEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsZ0dBQXlCO0FBQzVDLHNDQUFzQywrQ0FBUTtBQUM5QyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkMsV0FBVyx5REFBZ0I7QUFDM0Isb0JBQW9CLDZEQUFvQjtBQUN4QyxRQUFRLHNEQUFhO0FBQ3JCO0FBQ0EsVUFBVSx5REFBZ0I7QUFDMUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILHdCQUF3QixrREFBVztBQUNuQztBQUNBLHdCQUF3QixzREFBYTtBQUNyQyxVQUFVLHlEQUFnQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uZGV2Lm1qcz8zYWQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzTm9kZVNlbGVjdGlvbiwgJGNyZWF0ZU5vZGVTZWxlY3Rpb24sICRzZXRTZWxlY3Rpb24sICRnZXROb2RlQnlLZXkgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGlzTm9kZVNlbGVjdGVkKGVkaXRvciwga2V5KSB7XG4gIHJldHVybiBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmlzU2VsZWN0ZWQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbihrZXkpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtpc1NlbGVjdGVkLCBzZXRJc1NlbGVjdGVkXSA9IHVzZVN0YXRlKCgpID0+IGlzTm9kZVNlbGVjdGVkKGVkaXRvciwga2V5KSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgY29uc3QgdW5yZWdpc3RlciA9IGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgc2V0SXNTZWxlY3RlZChpc05vZGVTZWxlY3RlZChlZGl0b3IsIGtleSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICB9O1xuICB9LCBbZWRpdG9yLCBrZXldKTtcbiAgY29uc3Qgc2V0U2VsZWN0ZWQgPSB1c2VDYWxsYmFjayhzZWxlY3RlZCA9PiB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBsZXQgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uYWRkKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtlZGl0b3IsIGtleV0pO1xuICBjb25zdCBjbGVhclNlbGVjdGVkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBzZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBjbGVhclNlbGVjdGVkXTtcbn1cblxuZXhwb3J0IHsgdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createHeadingNode: () => (/* binding */ $createHeadingNode),\n/* harmony export */   $createQuoteNode: () => (/* binding */ $createQuoteNode),\n/* harmony export */   $isHeadingNode: () => (/* binding */ $isHeadingNode),\n/* harmony export */   $isQuoteNode: () => (/* binding */ $isQuoteNode),\n/* harmony export */   DRAG_DROP_PASTE: () => (/* binding */ DRAG_DROP_PASTE),\n/* harmony export */   HeadingNode: () => (/* binding */ HeadingNode),\n/* harmony export */   QuoteNode: () => (/* binding */ QuoteNode),\n/* harmony export */   eventFiles: () => (/* binding */ eventFiles),\n/* harmony export */   registerRichText: () => (/* binding */ registerRichText)\n/* harmony export */ });\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet === this.getTextContentSize() || !selection ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const clipboardData = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, InputEvent) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      selection.removeText();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(target);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(dataTransfer, selection, editor);\n      } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REMOVE_TEXT_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_TAB_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$insertNodes)([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, true);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, false);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, false)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode)) {\n      const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestBlockElementAncestorOrThrow)(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ENTER_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n        if (node !== null) {\n          const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(selection);\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(eventRange.node);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECT_ALL_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll)();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, event => {\n    (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionCapturedInDecoratorInput)(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUY7QUFDUztBQUN3RTtBQUN5MkI7O0FBRS9nQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQWE7QUFDckM7QUFDQSx3QkFBd0IsZ0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixzREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsNkRBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFXO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzRUFBc0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLHNEQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDZEQUFvQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2REFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDZEQUFvQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkMsMEJBQTBCLGlFQUFpQix1QkFBdUIsaUVBQWlCO0FBQ25GO0FBQ0EsTUFBTSxrRkFBOEI7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVEsbUVBQWUsU0FBUyxpRUFBaUI7QUFDakQ7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkMsUUFBUSwwREFBaUI7QUFDekI7QUFDQSxNQUFNLFNBQVMseURBQWdCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUVBQWlCO0FBQ3ZCO0FBQ0EsSUFBSSxTQUFTLGlFQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDLE9BQU8sMERBQWlCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFtQixxQkFBcUIsdURBQWM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtRUFBMEI7QUFDekMsU0FBUyx5REFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlEQUFRO0FBQzFEO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQWEsd0JBQXdCLGtEQUFhO0FBQzNFLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNkJBQTZCLDZEQUF3QjtBQUN4RCxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix3REFBbUI7QUFDekUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsd0RBQW1CO0FBQ3pFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHNFQUFpQztBQUN2RixzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0ZBQThCO0FBQ3RDLFFBQVEsU0FBUywwREFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHdEQUFtQjtBQUN6RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix3REFBbUI7QUFDekUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMkRBQXNCO0FBQzVFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQixnQkFBZ0IseURBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFtQixxQkFBcUIsdURBQWM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDhEQUF5QjtBQUMvRSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiw2REFBd0I7QUFDOUUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsdURBQWtCO0FBQ3hFLElBQUkscURBQVksRUFBRSx1REFBYztBQUNoQztBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDJEQUFzQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsNERBQXVCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIseURBQW9CO0FBQzFFLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUywwREFBaUI7QUFDaEMsMkJBQTJCLHlEQUFnQjtBQUMzQyw2QkFBNkIseURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDJEQUFzQjtBQUM1RSxzQkFBc0Isc0RBQWE7QUFDbkMsUUFBUSx5REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsMERBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlEQUFnQjtBQUMzQyw2QkFBNkIseURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDJEQUFzQjtBQUM1RSxzQkFBc0Isc0RBQWE7QUFDbkMsUUFBUSx5REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBLFFBQVEsNEZBQXdDO0FBQ2hEO0FBQ0E7QUFDQSxNQUFNLGtFQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDREQUF1QjtBQUM3RSxzQkFBc0Isc0RBQWE7QUFDbkMsUUFBUSx5REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RkFBd0M7QUFDaEQ7QUFDQSxNQUFNLGtFQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDBEQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJEQUEyRCxvREFBVztBQUN0RSxzQkFBc0Isc0ZBQXNDO0FBQzVEO0FBQ0Esc0NBQXNDLDREQUF1QjtBQUM3RDtBQUNBO0FBQ0Esa0NBQWtDLDZEQUF3QjtBQUMxRCxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix1REFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBd0I7QUFDMUQsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsc0RBQWlCO0FBQ3ZFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOERBQXlCO0FBQy9EO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQXdCO0FBQzFELEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHVEQUFrQjtBQUN4RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixpREFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YscUJBQXFCLG1FQUEwQjtBQUMvQztBQUNBLDRCQUE0Qiw4REFBcUI7QUFDakQsY0FBYyxvREFBVztBQUN6QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMEVBQWlDO0FBQ3ZFLFVBQVUsc0RBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHNEQUFpQjtBQUN2RTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQywyQkFBMkIsMERBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHFEQUFnQjtBQUN0RTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQywyQkFBMkIsMERBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBMEI7QUFDN0MsVUFBVSx5REFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsdURBQWtCO0FBQ3hFLElBQUksbURBQVU7QUFDZDtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGlEQUFZO0FBQ2xFLElBQUksbUVBQWUsU0FBUyxpRUFBaUI7QUFDN0M7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixnREFBVztBQUNqRTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsa0RBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNEVBQW1DO0FBQzNDO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUI7QUFDNUI7QUFDQTs7QUFFcUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JpY2gtdGV4dC9MZXhpY2FsUmljaFRleHQuZGV2Lm1qcz8xNzRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0LCBjb3B5VG9DbGlwYm9hcmQgfSBmcm9tICdAbGV4aWNhbC9jbGlwYm9hcmQnO1xuaW1wb3J0IHsgJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbiwgJG1vdmVDaGFyYWN0ZXIgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgb2JqZWN0S2xhc3NFcXVhbHMsIG1lcmdlUmVnaXN0ZXIsICRmaW5kTWF0Y2hpbmdQYXJlbnQsICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93IH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ29tbWFuZCwgRWxlbWVudE5vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsIENMSUNLX0NPTU1BTkQsICRnZXRTZWxlY3Rpb24sICRpc05vZGVTZWxlY3Rpb24sIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgJGlzUmFuZ2VTZWxlY3Rpb24sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIFJFTU9WRV9URVhUX0NPTU1BTkQsIEZPUk1BVF9URVhUX0NPTU1BTkQsIEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsICRpc0VsZW1lbnROb2RlLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIElOU0VSVF9UQUJfQ09NTUFORCwgJGluc2VydE5vZGVzLCAkY3JlYXRlVGFiTm9kZSwgSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIEtFWV9BUlJPV19VUF9DT01NQU5ELCAkZ2V0QWRqYWNlbnROb2RlLCAkaXNEZWNvcmF0b3JOb2RlLCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCAkaXNSb290Tm9kZSwgS0VZX0RFTEVURV9DT01NQU5ELCBLRVlfRU5URVJfQ09NTUFORCwgS0VZX0VTQ0FQRV9DT01NQU5ELCBEUk9QX0NPTU1BTkQsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24sICRpc1RleHROb2RlLCAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwsICRzZXRTZWxlY3Rpb24sIERSQUdTVEFSVF9DT01NQU5ELCBEUkFHT1ZFUl9DT01NQU5ELCBTRUxFQ1RfQUxMX0NPTU1BTkQsICRzZWxlY3RBbGwsIENPUFlfQ09NTUFORCwgQ1VUX0NPTU1BTkQsIFBBU1RFX0NPTU1BTkQsIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0LCAkZ2V0Um9vdCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KHgsIHkpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICBvZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBAdHMtaWdub3JlIEZGIC0gbm8gdHlwZXNcbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IHJhbmdlLm9mZnNldE5vZGUsXG4gICAgICBvZmZzZXQ6IHJhbmdlLm9mZnNldFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgSUVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBEUkFHX0RST1BfUEFTVEUgPSBjcmVhdGVDb21tYW5kKCdEUkFHX0RST1BfUEFTVEVfRklMRScpO1xuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFF1b3RlTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdxdW90ZSc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFF1b3RlTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnF1b3RlKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja3F1b3RlOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0QmxvY2txdW90ZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGVsZW1lbnQgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3F1b3RlJ1xuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdGlvblxuXG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBuZXdCbG9jayA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdCbG9jay5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0Jsb2NrLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3QmxvY2s7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgdGhpcy5yZXBsYWNlKHBhcmFncmFwaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVRdW90ZU5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFF1b3RlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1F1b3RlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUXVvdGVOb2RlO1xufVxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIEhlYWRpbmdOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdoZWFkaW5nJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUobm9kZS5fX3RhZywgbm9kZS5fX2tleSk7XG4gIH1cbiAgY29uc3RydWN0b3IodGFnLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190YWcgPSB0YWc7XG4gIH1cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGFnO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLl9fdGFnO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHRoZW1lLmhlYWRpbmc7XG4gICAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1t0YWddO1xuICAgICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoMTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoMjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoMzogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBwOiBub2RlID0+IHtcbiAgICAgICAgLy8gZG9tTm9kZSBpcyBhIDxwPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gICAgICAgIGNvbnN0IHBhcmFncmFwaCA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJhZ3JhcGguZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwgJiYgaXNHb29nbGVEb2NzVGl0bGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogKCkgPT4gKHtcbiAgICAgICAgICAgICAgbm9kZTogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgc3Bhbjogbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc0dvb2dsZURvY3NUaXRsZShub2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBkb21Ob2RlID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub2RlOiAkY3JlYXRlSGVhZGluZ05vZGUoJ2gxJylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoZWxlbWVudCAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtYXRUeXBlID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgICBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9IGZvcm1hdFR5cGU7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVIZWFkaW5nTm9kZShzZXJpYWxpemVkTm9kZS50YWcpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKSxcbiAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgLy8gTXV0YXRpb25cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGFuY2hvck9mZmV0ID0gc2VsZWN0aW9uID8gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgOiAwO1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBhbmNob3JPZmZldCA9PT0gdGhpcy5nZXRUZXh0Q29udGVudFNpemUoKSB8fCAhc2VsZWN0aW9uID8gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSA6ICRjcmVhdGVIZWFkaW5nTm9kZSh0aGlzLmdldFRhZygpKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIG5ld0VsZW1lbnQuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICBpZiAoYW5jaG9yT2ZmZXQgPT09IDAgJiYgIXRoaXMuaXNFbXB0eSgpICYmIHNlbGVjdGlvbikge1xuICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgIHRoaXMucmVwbGFjZShwYXJhZ3JhcGgsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICF0aGlzLmlzRW1wdHkoKSA/ICRjcmVhdGVIZWFkaW5nTm9kZSh0aGlzLmdldFRhZygpKSA6ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBuZXdFbGVtZW50LmFwcGVuZChjaGlsZCkpO1xuICAgIHRoaXMucmVwbGFjZShuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBpc0dvb2dsZURvY3NUaXRsZShkb21Ob2RlKSB7XG4gIGlmIChkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzcGFuJykge1xuICAgIHJldHVybiBkb21Ob2RlLnN0eWxlLmZvbnRTaXplID09PSAnMjZwdCc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRIZWFkaW5nRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbm9kZSA9IG51bGw7XG4gIGlmIChub2RlTmFtZSA9PT0gJ2gxJyB8fCBub2RlTmFtZSA9PT0gJ2gyJyB8fCBub2RlTmFtZSA9PT0gJ2gzJyB8fCBub2RlTmFtZSA9PT0gJ2g0JyB8fCBub2RlTmFtZSA9PT0gJ2g1JyB8fCBub2RlTmFtZSA9PT0gJ2g2Jykge1xuICAgIG5vZGUgPSAkY3JlYXRlSGVhZGluZ05vZGUobm9kZU5hbWUpO1xuICAgIGlmIChlbGVtZW50LnN0eWxlICE9PSBudWxsKSB7XG4gICAgICBub2RlLnNldEZvcm1hdChlbGVtZW50LnN0eWxlLnRleHRBbGlnbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRCbG9ja3F1b3RlRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG4gIGlmIChlbGVtZW50LnN0eWxlICE9PSBudWxsKSB7XG4gICAgbm9kZS5zZXRGb3JtYXQoZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUhlYWRpbmdOb2RlKGhlYWRpbmdUYWcpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgSGVhZGluZ05vZGUoaGVhZGluZ1RhZykpO1xufVxuZnVuY3Rpb24gJGlzSGVhZGluZ05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhlYWRpbmdOb2RlO1xufVxuZnVuY3Rpb24gb25QYXN0ZUZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBvYmplY3RLbGFzc0VxdWFscyhldmVudCwgSW5wdXRFdmVudCkgfHwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIEtleWJvYXJkRXZlbnQpID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGNsaXBib2FyZERhdGEgIT0gbnVsbCAmJiBzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChjbGlwYm9hcmREYXRhLCBzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAgdGFnOiAncGFzdGUnXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gb25DdXRGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGF3YWl0IGNvcHlUb0NsaXBib2FyZChlZGl0b3IsIG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkgPyBldmVudCA6IG51bGwpO1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5nZXROb2RlcygpLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBDbGlwYm9hcmQgbWF5IGNvbnRhaW4gZmlsZXMgdGhhdCB3ZSBhcmVuJ3QgYWxsb3dlZCB0byByZWFkLiBXaGlsZSB0aGUgZXZlbnQgaXMgYXJndWFibHkgdXNlbGVzcyxcbi8vIGluIGNlcnRhaW4gb2NjYXNpb25zLCB3ZSB3YW50IHRvIGtub3cgd2hldGhlciBpdCB3YXMgYSBmaWxlIHRyYW5zZmVyLCBhcyBvcHBvc2VkIHRvIHRleHQuIFdlXG4vLyBjb250cm9sIHRoaXMgd2l0aCB0aGUgZmlyc3QgYm9vbGVhbiBmbGFnLlxuZnVuY3Rpb24gZXZlbnRGaWxlcyhldmVudCkge1xuICBsZXQgZGF0YVRyYW5zZmVyID0gbnVsbDtcbiAgaWYgKG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBEcmFnRXZlbnQpKSB7XG4gICAgZGF0YVRyYW5zZmVyID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICB9IGVsc2UgaWYgKG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICBkYXRhVHJhbnNmZXIgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICB9XG4gIGlmIChkYXRhVHJhbnNmZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCBbXSwgZmFsc2VdO1xuICB9XG4gIGNvbnN0IHR5cGVzID0gZGF0YVRyYW5zZmVyLnR5cGVzO1xuICBjb25zdCBoYXNGaWxlcyA9IHR5cGVzLmluY2x1ZGVzKCdGaWxlcycpO1xuICBjb25zdCBoYXNDb250ZW50ID0gdHlwZXMuaW5jbHVkZXMoJ3RleHQvaHRtbCcpIHx8IHR5cGVzLmluY2x1ZGVzKCd0ZXh0L3BsYWluJyk7XG4gIHJldHVybiBbaGFzRmlsZXMsIEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSwgaGFzQ29udGVudF07XG59XG5mdW5jdGlvbiAkaGFuZGxlSW5kZW50QW5kT3V0ZGVudChpbmRlbnRPck91dGRlbnQpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxyZWFkeUhhbmRsZWQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgY29uc3Qga2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICBpZiAoYWxyZWFkeUhhbmRsZWQuaGFzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRCbG9jayA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50Tm9kZSA9PiAkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSAmJiAhcGFyZW50Tm9kZS5pc0lubGluZSgpKTtcbiAgICBpZiAocGFyZW50QmxvY2sgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnRCbG9jay5nZXRLZXkoKTtcbiAgICBpZiAocGFyZW50QmxvY2suY2FuSW5kZW50KCkgJiYgIWFscmVhZHlIYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICBhbHJlYWR5SGFuZGxlZC5hZGQocGFyZW50S2V5KTtcbiAgICAgIGluZGVudE9yT3V0ZGVudChwYXJlbnRCbG9jayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbHJlYWR5SGFuZGxlZC5zaXplID4gMDtcbn1cbmZ1bmN0aW9uICRpc1RhcmdldFdpdGhpbkRlY29yYXRvcih0YXJnZXQpIHtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKHRhcmdldCk7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uQXRFbmRPZlJvb3Qoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICByZXR1cm4gZm9jdXMua2V5ID09PSAncm9vdCcgJiYgZm9jdXMub2Zmc2V0ID09PSAkZ2V0Um9vdCgpLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJSaWNoVGV4dChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xJQ0tfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgMCksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVDaGFyYWN0ZXIoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChERUxFVEVfV09SRF9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVXb3JkKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoREVMRVRFX0xJTkVfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZGVsZXRlTGluZShpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnRPclRleHQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAodHlwZW9mIGV2ZW50T3JUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChldmVudE9yVGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YVRyYW5zZmVyID0gZXZlbnRPclRleHQuZGF0YVRyYW5zZmVyO1xuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAhPSBudWxsKSB7XG4gICAgICAgICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnRPclRleHQuZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRU1PVkVfVEVYVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9STUFUX1RFWFRfQ09NTUFORCwgZm9ybWF0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5mb3JtYXRUZXh0KGZvcm1hdCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBmb3JtYXQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgISRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgY29uc3QgZWxlbWVudCA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50Tm9kZSA9PiAkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSAmJiAhcGFyZW50Tm9kZS5pc0lubGluZSgpKTtcbiAgICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgc2VsZWN0U3RhcnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmluc2VydExpbmVCcmVhayhzZWxlY3RTdGFydCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9UQUJfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnROb2RlcyhbJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgKCkgPT4ge1xuICAgIHJldHVybiAkaGFuZGxlSW5kZW50QW5kT3V0ZGVudChibG9jayA9PiB7XG4gICAgICBjb25zdCBpbmRlbnQgPSBibG9jay5nZXRJbmRlbnQoKTtcbiAgICAgIGJsb2NrLnNldEluZGVudChpbmRlbnQgKyAxKTtcbiAgICB9KTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKE9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgcmV0dXJuICRoYW5kbGVJbmRlbnRBbmRPdXRkZW50KGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGluZGVudCA9IGJsb2NrLmdldEluZGVudCgpO1xuICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgYmxvY2suc2V0SW5kZW50KGluZGVudCAtIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSAkZ2V0QWRqYWNlbnROb2RlKHNlbGVjdGlvbi5mb2N1cywgdHJ1ZSk7XG4gICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmICRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzU2VsZWN0aW9uQXRFbmRPZlJvb3Qoc2VsZWN0aW9uKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBmYWxzZSk7XG4gICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmICRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBub2Rlc1swXS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc0hvbGRpbmdTaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmICgkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgZmFsc2UpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGlmICgkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgYW5jaG9yLm9mZnNldCA9PT0gMCAmJiAhJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyhhbmNob3JOb2RlKTtcbiAgICAgIGlmIChlbGVtZW50LmdldEluZGVudCgpID4gMCkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGlmICgkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGJlZm9yZWlucHV0LCB0aGVuIHdlIGNhbiBhdm9pZCBibG9ja2luZ1xuICAgICAgLy8gdGhlIGRlZmF1bHQgYmVoYXZpb3IuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBpT1MgY2FuXG4gICAgICAvLyBpbnRlcmNlcHQgdGhhdCB3ZSdyZSBhY3R1YWxseSBpbnNlcnRpbmcgYSBwYXJhZ3JhcGgsXG4gICAgICAvLyBhbmQgYXV0b2NvbXBsZXRlLCBhdXRvY2FwaXRhbGl6ZSBldGMgd29yayBhcyBpbnRlbmRlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGFsc28gY2F1c2UgYSBzdHJhbmdlIHBlcmZvcm1hbmNlIGlzc3VlIGluXG4gICAgICAvLyBTYWZhcmksIHdoZXJlIHRoZXJlIGlzIGEgbm90aWNlYWJsZSBwYXVzZSBkdWUgdG9cbiAgICAgIC8vIHByZXZlbnRpbmcgdGhlIGtleSBkb3duIG9mIGVudGVyLlxuICAgICAgaWYgKChJU19JT1MgfHwgSVNfU0FGQVJJIHx8IElTX0FQUExFX1dFQktJVCkgJiYgQ0FOX1VTRV9CRUZPUkVfSU5QVVQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FU0NBUEVfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWRpdG9yLmJsdXIoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERST1BfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFssIGZpbGVzXSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgY29uc3QgZXZlbnRSYW5nZSA9IGNhcmV0RnJvbVBvaW50KHgsIHkpO1xuICAgICAgaWYgKGV2ZW50UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9mZnNldDogZG9tT2Zmc2V0LFxuICAgICAgICAgIG5vZGU6IGRvbU5vZGVcbiAgICAgICAgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShkb21Ob2RlKTtcbiAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KG5vZGUuZ2V0S2V5KCksIGRvbU9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQobm9kZS5nZXRLZXkoKSwgZG9tT2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKS5nZXRLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChwYXJlbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQocGFyZW50S2V5LCBvZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwoc2VsZWN0aW9uKTtcbiAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5vcm1hbGl6ZWRTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERSQUdTVEFSVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgW2lzRmlsZVRyYW5zZmVyXSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoaXNGaWxlVHJhbnNmZXIgJiYgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChEUkFHT1ZFUl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgW2lzRmlsZVRyYW5zZmVyXSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoaXNGaWxlVHJhbnNmZXIgJiYgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgY29uc3QgZXZlbnRSYW5nZSA9IGNhcmV0RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChldmVudFJhbmdlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZXZlbnRSYW5nZS5ub2RlKTtcbiAgICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgICAgIC8vIFNob3cgYnJvd3NlciBjYXJldCBhcyB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgbWVkaWEgYWNyb3NzIHRoZSBzY3JlZW4uIFdvbid0IHdvcmtcbiAgICAgICAgLy8gZm9yIERlY29yYXRvck5vZGUgbm9yIGl0J3MgcmVsZXZhbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUX0FMTF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJHNlbGVjdEFsbCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ09QWV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIENsaXBib2FyZEV2ZW50KSA/IGV2ZW50IDogbnVsbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIG9uQ3V0Rm9yUmljaFRleHQoZXZlbnQsIGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChQQVNURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgWywgZmlsZXMsIGhhc1RleHRDb250ZW50XSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGlmIChmaWxlcy5sZW5ndGggPiAwICYmICFoYXNUZXh0Q29udGVudCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChEUkFHX0RST1BfUEFTVEUsIGZpbGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGlucHV0cyB0aGVuIHBhc3RlIHdpdGhpbiB0aGUgaW5wdXQgaWdub3JlIGNyZWF0aW5nIGEgbmV3IG5vZGUgb24gcGFzdGUgZXZlbnRcbiAgICBpZiAoaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgb25QYXN0ZUZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpKTtcbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlSGVhZGluZ05vZGUsICRjcmVhdGVRdW90ZU5vZGUsICRpc0hlYWRpbmdOb2RlLCAkaXNRdW90ZU5vZGUsIERSQUdfRFJPUF9QQVNURSwgSGVhZGluZ05vZGUsIFF1b3RlTm9kZSwgZXZlbnRGaWxlcywgcmVnaXN0ZXJSaWNoVGV4dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* binding */ $cloneWithProperties),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* binding */ $selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\nfunction $updateParagraphNodeProperties(target, source) {\n  target.__textFormat = source.__textFormat;\n  return target;\n}\n\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor;\n  // @ts-expect-error\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(clone)) {\n    return $updateParagraphNodeProperties(clone, node);\n  }\n  return clone;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value instanceof Function) {\n      styles[key] = value(prevStyles[key]);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }. Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected, split it\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, isBackward);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode)) {\n    firstType = 'text';\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n    return false;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9UOztBQUVwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsbURB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O0FBQ2pCO0FBQ0EsSUFBSSxVQUFVLHVEQUFjO0FBQzVCO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJLFVBQVUsdURBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seURBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPLHVEQUFjLFVBQVUsNERBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBZ0IsZ0JBQWdCLG9EQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsa0NBQWtDO0FBQzlEOztBQUVvWiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcz80MDA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGlzVGV4dE5vZGUsICRpc0VsZW1lbnROb2RlLCAkaXNQYXJhZ3JhcGhOb2RlLCAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cywgJGlzUm9vdE5vZGUsICRnZXROb2RlQnlLZXksICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGNyZWF0ZVRleHROb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGdldFJvb3QsICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRoYXNBbmNlc3RvciwgJGlzTGVhZk5vZGUsICRzZXRTZWxlY3Rpb24sICRnZXRBZGphY2VudE5vZGUsICRpc0RlY29yYXRvck5vZGUsICRpc0xpbmVCcmVha05vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ1NTX1RPX1NUWUxFUyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBnZXRET01UZXh0Tm9kZShlbGVtZW50KSB7XG4gIGxldCBub2RlID0gZWxlbWVudDtcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRET01JbmRleFdpdGhpblBhcmVudChub2RlKSB7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgaGFwcGVuJyk7XG4gIH1cbiAgcmV0dXJuIFtwYXJlbnQsIEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpLmluZGV4T2Yobm9kZSldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZWxlY3Rpb24gcmFuZ2UgZm9yIHRoZSBET00uXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGFuY2hvck5vZGUgLSBUaGUgYW5jaG9yIG5vZGUgb2YgYSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0gX2FuY2hvck9mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGFuY2hvciB0byB0aGUgZm9jdXMuXG4gKiBAcGFyYW0gZm9jdXNOb2RlIC0gVGhlIGN1cnJlbnQgZm9jdXMuXG4gKiBAcGFyYW0gX2ZvY3VzT2Zmc2V0IC0gVGhlIGFtb3VudCBvZiBzcGFjZSBvZmZzZXQgZnJvbSB0aGUgZm9jdXMgdG8gdGhlIGFuY2hvci5cbiAqIEByZXR1cm5zIFRoZSByYW5nZSBvZiBzZWxlY3Rpb24gZm9yIHRoZSBET00gdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NUmFuZ2UoZWRpdG9yLCBhbmNob3JOb2RlLCBfYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIF9mb2N1c09mZnNldCkge1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3JOb2RlLmdldEtleSgpO1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBsZXQgYW5jaG9yRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpO1xuICBsZXQgZm9jdXNET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGZvY3VzS2V5KTtcbiAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gIGxldCBmb2N1c09mZnNldCA9IF9mb2N1c09mZnNldDtcbiAgaWYgKCRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgYW5jaG9yRE9NID0gZ2V0RE9NVGV4dE5vZGUoYW5jaG9yRE9NKTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUoZm9jdXNOb2RlKSkge1xuICAgIGZvY3VzRE9NID0gZ2V0RE9NVGV4dE5vZGUoZm9jdXNET00pO1xuICB9XG4gIGlmIChhbmNob3JOb2RlID09PSB1bmRlZmluZWQgfHwgZm9jdXNOb2RlID09PSB1bmRlZmluZWQgfHwgYW5jaG9yRE9NID09PSBudWxsIHx8IGZvY3VzRE9NID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGFuY2hvckRPTS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgIFthbmNob3JET00sIGFuY2hvck9mZnNldF0gPSBnZXRET01JbmRleFdpdGhpblBhcmVudChhbmNob3JET00pO1xuICB9XG4gIGlmIChmb2N1c0RPTS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgIFtmb2N1c0RPTSwgZm9jdXNPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoZm9jdXNET00pO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBhbmNob3JET00uZmlyc3RDaGlsZDtcbiAgaWYgKGFuY2hvckRPTSA9PT0gZm9jdXNET00gJiYgZmlyc3RDaGlsZCAhPSBudWxsICYmIGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09ICdCUicgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGZvY3VzT2Zmc2V0ID09PSAwKSB7XG4gICAgZm9jdXNPZmZzZXQgPSAxO1xuICB9XG4gIHRyeSB7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChmb2N1c0RPTSwgZm9jdXNPZmZzZXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHJhbmdlLmNvbGxhcHNlZCAmJiAoYW5jaG9yT2Zmc2V0ICE9PSBmb2N1c09mZnNldCB8fCBhbmNob3JLZXkgIT09IGZvY3VzS2V5KSkge1xuICAgIC8vIFJhbmdlIGlzIGJhY2t3YXJkcywgd2UgbmVlZCB0byByZXZlcnNlIGl0XG4gICAgcmFuZ2Uuc2V0U3RhcnQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpO1xuICB9XG4gIHJldHVybiByYW5nZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIERPTVJlY3RzLCBnZW5lcmFsbHkgdXNlZCB0byBoZWxwIHRoZSBlZGl0b3IgZmluZCBhIHNwZWNpZmljIGxvY2F0aW9uIG9uIHRoZSBzY3JlZW4uXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gcmFuZ2UgLSBBIGZyYWdtZW50IG9mIGEgZG9jdW1lbnQgdGhhdCBjYW4gY29udGFpbiBub2RlcyBhbmQgcGFydHMgb2YgdGV4dCBub2Rlcy5cbiAqIEByZXR1cm5zIFRoZSBzZWxlY3Rpb25SZWN0cyBhcyBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgcm9vdFJlY3QgPSByb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocm9vdEVsZW1lbnQpO1xuICBjb25zdCByb290UGFkZGluZyA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgY29uc3Qgc2VsZWN0aW9uUmVjdHMgPSBBcnJheS5mcm9tKHJhbmdlLmdldENsaWVudFJlY3RzKCkpO1xuICBsZXQgc2VsZWN0aW9uUmVjdHNMZW5ndGggPSBzZWxlY3Rpb25SZWN0cy5sZW5ndGg7XG4gIC8vc29ydCByZWN0cyBmcm9tIHRvcCBsZWZ0IHRvIGJvdHRvbSByaWdodC5cbiAgc2VsZWN0aW9uUmVjdHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHRvcCA9IGEudG9wIC0gYi50b3A7XG4gICAgLy8gU29tZSByZWN0cyBtYXRjaCBwb3NpdGlvbiBjbG9zZWx5LCBidXQgbm90IHBlcmZlY3RseSxcbiAgICAvLyBzbyB3ZSBnaXZlIGEgM3B4IHRvbGVyYW5jZS5cbiAgICBpZiAoTWF0aC5hYnModG9wKSA8PSAzKSB7XG4gICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gdG9wO1xuICB9KTtcbiAgbGV0IHByZXZSZWN0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvblJlY3RzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWxlY3Rpb25SZWN0ID0gc2VsZWN0aW9uUmVjdHNbaV07XG4gICAgLy8gRXhjbHVkZSByZWN0cyB0aGF0IG92ZXJsYXAgcHJlY2VkaW5nIFJlY3RzIGluIHRoZSBzb3J0ZWQgbGlzdC5cbiAgICBjb25zdCBpc092ZXJsYXBwaW5nUmVjdCA9IHByZXZSZWN0ICYmIHByZXZSZWN0LnRvcCA8PSBzZWxlY3Rpb25SZWN0LnRvcCAmJiBwcmV2UmVjdC50b3AgKyBwcmV2UmVjdC5oZWlnaHQgPiBzZWxlY3Rpb25SZWN0LnRvcCAmJiBwcmV2UmVjdC5sZWZ0ICsgcHJldlJlY3Qud2lkdGggPiBzZWxlY3Rpb25SZWN0LmxlZnQ7XG4gICAgLy8gRXhjbHVkZSBzZWxlY3Rpb25zIHRoYXQgc3BhbiB0aGUgZW50aXJlIGVsZW1lbnRcbiAgICBjb25zdCBzZWxlY3Rpb25TcGFuc0VsZW1lbnQgPSBzZWxlY3Rpb25SZWN0LndpZHRoICsgcm9vdFBhZGRpbmcgPT09IHJvb3RSZWN0LndpZHRoO1xuICAgIGlmIChpc092ZXJsYXBwaW5nUmVjdCB8fCBzZWxlY3Rpb25TcGFuc0VsZW1lbnQpIHtcbiAgICAgIHNlbGVjdGlvblJlY3RzLnNwbGljZShpLS0sIDEpO1xuICAgICAgc2VsZWN0aW9uUmVjdHNMZW5ndGgtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwcmV2UmVjdCA9IHNlbGVjdGlvblJlY3Q7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGlvblJlY3RzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcyBwcm92aWRlZCBpbiB0aGUgQ1NTIHN0cmluZy5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHN0cmluZyBvZiBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqIEByZXR1cm5zIFRoZSBzdHlsZU9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpIHtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSB7fTtcbiAgY29uc3Qgc3R5bGVzID0gY3NzLnNwbGl0KCc7Jyk7XG4gIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gc3R5bGUuc3BsaXQoLzooW15dKykvKTsgLy8gc3BsaXQgb24gZmlyc3QgY29sb25cbiAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgc3R5bGVPYmplY3Rba2V5LnRyaW0oKV0gPSB2YWx1ZS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZU9iamVjdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIENTUyBzdHJpbmcsIHJldHVybnMgYW4gb2JqZWN0IGZyb20gdGhlIHN0eWxlIGNhY2hlLlxuICogQHBhcmFtIGNzcyAtIFRoZSBDU1MgcHJvcGVydHkgYXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIENTUyBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcykge1xuICBsZXQgdmFsdWUgPSBDU1NfVE9fU1RZTEVTLmdldChjc3MpO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKGNzcyk7XG4gICAgQ1NTX1RPX1NUWUxFUy5zZXQoY3NzLCB2YWx1ZSk7XG4gIH1cbiAge1xuICAgIC8vIEZyZWV6ZSB0aGUgdmFsdWUgaW4gREVWIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbnNcbiAgICBPYmplY3QuZnJlZXplKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgQ1NTIHN0eWxlcyBmcm9tIHRoZSBzdHlsZSBvYmplY3QuXG4gKiBAcGFyYW0gc3R5bGVzIC0gVGhlIHN0eWxlIG9iamVjdCBjb250YWluaW5nIHRoZSBzdHlsZXMgdG8gZ2V0LlxuICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgQ1NTIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRDU1NGcm9tU3R5bGVPYmplY3Qoc3R5bGVzKSB7XG4gIGxldCBjc3MgPSAnJztcbiAgZm9yIChjb25zdCBzdHlsZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGNzcyArPSBgJHtzdHlsZX06ICR7c3R5bGVzW3N0eWxlXX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNzcztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gJHVwZGF0ZUVsZW1lbnROb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX19maXJzdCA9IHNvdXJjZS5fX2ZpcnN0O1xuICB0YXJnZXQuX19sYXN0ID0gc291cmNlLl9fbGFzdDtcbiAgdGFyZ2V0Ll9fc2l6ZSA9IHNvdXJjZS5fX3NpemU7XG4gIHRhcmdldC5fX2Zvcm1hdCA9IHNvdXJjZS5fX2Zvcm1hdDtcbiAgdGFyZ2V0Ll9faW5kZW50ID0gc291cmNlLl9faW5kZW50O1xuICB0YXJnZXQuX19kaXIgPSBzb3VyY2UuX19kaXI7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiAkdXBkYXRlVGV4dE5vZGVQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlKSB7XG4gIHRhcmdldC5fX2Zvcm1hdCA9IHNvdXJjZS5fX2Zvcm1hdDtcbiAgdGFyZ2V0Ll9fc3R5bGUgPSBzb3VyY2UuX19zdHlsZTtcbiAgdGFyZ2V0Ll9fbW9kZSA9IHNvdXJjZS5fX21vZGU7XG4gIHRhcmdldC5fX2RldGFpbCA9IHNvdXJjZS5fX2RldGFpbDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uICR1cGRhdGVQYXJhZ3JhcGhOb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX190ZXh0Rm9ybWF0ID0gc291cmNlLl9fdGV4dEZvcm1hdDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgY29weSBvZiBhIG5vZGUsIGJ1dCBnZW5lcmF0ZXMgYSBuZXcga2V5IGZvciB0aGUgY29weS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgVGhlIGNsb25lIG9mIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiAkY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gbm9kZS5jb25zdHJ1Y3RvcjtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBjb25zdCBjbG9uZSA9IGNvbnN0cnVjdG9yLmNsb25lKG5vZGUpO1xuICBjbG9uZS5fX3BhcmVudCA9IG5vZGUuX19wYXJlbnQ7XG4gIGNsb25lLl9fbmV4dCA9IG5vZGUuX19uZXh0O1xuICBjbG9uZS5fX3ByZXYgPSBub2RlLl9fcHJldjtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmICRpc0VsZW1lbnROb2RlKGNsb25lKSkge1xuICAgIHJldHVybiAkdXBkYXRlRWxlbWVudE5vZGVQcm9wZXJ0aWVzKGNsb25lLCBub2RlKTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkgJiYgJGlzVGV4dE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVUZXh0Tm9kZVByb3BlcnRpZXMoY2xvbmUsIG5vZGUpO1xuICB9XG4gIGlmICgkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpICYmICRpc1BhcmFncmFwaE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVQYXJhZ3JhcGhOb2RlUHJvcGVydGllcyhjbG9uZSwgbm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEdlbmVyYWxseSB1c2VkIHRvIGFwcGVuZCB0ZXh0IGNvbnRlbnQgdG8gSFRNTCBhbmQgSlNPTi4gR3JhYnMgdGhlIHRleHQgY29udGVudCBhbmQgXCJzbGljZXNcIlxuICogaXQgdG8gYmUgZ2VuZXJhdGVkIGludG8gdGhlIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIGNvbnRhaW5pbmcgdGhlIG5vZGUgd2hvc2UgVGV4dE5vZGUgaXMgdG8gYmUgZWRpdGVkLlxuICogQHBhcmFtIHRleHROb2RlIC0gVGhlIFRleHROb2RlIHRvIGJlIGVkaXRlZC5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIFRleHROb2RlLlxuICovXG5mdW5jdGlvbiAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24sIHRleHROb2RlKSB7XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGlmICh0ZXh0Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgJiYgIXRleHROb2RlLmlzU2VnbWVudGVkKCkgJiYgIXRleHROb2RlLmlzVG9rZW4oKSAmJiBhbmNob3JBbmRGb2N1cyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IGFuY2hvckFuZEZvY3VzO1xuICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBpc0FuY2hvciA9IHRleHROb2RlLmlzKGFuY2hvck5vZGUpO1xuICAgIGNvbnN0IGlzRm9jdXMgPSB0ZXh0Tm9kZS5pcyhmb2N1c05vZGUpO1xuICAgIGlmIChpc0FuY2hvciB8fCBpc0ZvY3VzKSB7XG4gICAgICBjb25zdCBbYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldF0gPSAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cyhzZWxlY3Rpb24pO1xuICAgICAgY29uc3QgaXNTYW1lID0gYW5jaG9yTm9kZS5pcyhmb2N1c05vZGUpO1xuICAgICAgY29uc3QgaXNGaXJzdCA9IHRleHROb2RlLmlzKGlzQmFja3dhcmQgPyBmb2N1c05vZGUgOiBhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IHRleHROb2RlLmlzKGlzQmFja3dhcmQgPyBhbmNob3JOb2RlIDogZm9jdXNOb2RlKTtcbiAgICAgIGxldCBzdGFydE9mZnNldCA9IDA7XG4gICAgICBsZXQgZW5kT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGlzU2FtZSkge1xuICAgICAgICBzdGFydE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBzdGFydE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZW5kT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIGVuZE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHRleHROb2RlLl9fdGV4dCA9IHRleHROb2RlLl9fdGV4dC5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHROb2RlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgb2YgdGhlIHNlbGVjdGlvbiB0byB0ZXN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcG9pbnQgb2Zmc2V0IGlzIGluIHRoZSBsYXN0IHBvc3NpYmxlIHBvc2l0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0F0Tm9kZUVuZChwb2ludCkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gcG9pbnQuZ2V0Tm9kZSgpLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICB9XG4gIGNvbnN0IG5vZGUgPSBwb2ludC5nZXROb2RlKCk7XG4gIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgaXNBdE5vZGVFbmQ6IG5vZGUgbXVzdCBiZSBhIFRleHROb2RlIG9yIEVsZW1lbnROb2RlYCk7XG4gIH1cbiAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gbm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbn1cblxuLyoqXG4gKiBUcmltcyB0ZXh0IGZyb20gYSBub2RlIGluIG9yZGVyIHRvIHNob3J0ZW4gaXQsIGVnLiB0byBlbmZvcmNlIGEgdGV4dCdzIG1heCBsZW5ndGguIElmIGl0IGRlbGV0ZXMgdGV4dFxuICogdGhhdCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgYW5jaG9yIHRoZW4gaXQgd2lsbCBsZWF2ZSAyIGluZGVudHMsIG90aGVyd2lzZSwgaWYgbm8gdGV4dCBjb250ZW50IGV4aXN0cywgaXQgZGVsZXRlc1xuICogdGhlIFRleHROb2RlLiBJdCB3aWxsIG1vdmUgdGhlIGZvY3VzIHRvIGVpdGhlciB0aGUgZW5kIG9mIGFueSBsZWZ0IG92ZXIgdGV4dCBvciBiZWdpbm5pbmcgb2YgYSBuZXcgVGV4dE5vZGUuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGFuY2hvciAtIFRoZSBhbmNob3Igb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCB3aGVyZSB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBwb2ludGluZy5cbiAqIEBwYXJhbSBkZWxDb3VudCAtIFRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0byBkZWxldGUuIFVzZWZ1bCBhcyBhIGR5bmFtaWMgdmFyaWFibGUgZWcuIHRleHRDb250ZW50U2l6ZSAtIG1heExlbmd0aDtcbiAqL1xuZnVuY3Rpb24gJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IoZWRpdG9yLCBhbmNob3IsIGRlbENvdW50KSB7XG4gIC8vIFdvcmsgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5jaG9yIHBvaW50XG4gIGxldCBjdXJyZW50Tm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGxldCByZW1haW5pbmcgPSBkZWxDb3VudDtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGRlc2NlbmRhbnROb2RlID0gY3VycmVudE5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYW5jaG9yLm9mZnNldCk7XG4gICAgaWYgKGRlc2NlbmRhbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAocmVtYWluaW5nID4gMCAmJiBjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGxhc3REZXNjZW5kYW50ID0gY3VycmVudE5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgIGlmIChsYXN0RGVzY2VuZGFudCAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGxhc3REZXNjZW5kYW50O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBsZXQgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlID0gMDtcbiAgICBpZiAobmV4dE5vZGUgPT09IG51bGwpIHtcbiAgICAgIGxldCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBsZXQgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIHdoaWxlIChwYXJlbnRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5leHROb2RlID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2UgPSBwYXJlbnQuaXNJbmxpbmUoKSA/IDAgOiAyO1xuICAgICAgICBuZXh0Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0ZXh0ID0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAvLyBJZiB0aGUgdGV4dCBpcyBlbXB0eSwgd2UgbmVlZCB0byBjb25zaWRlciBhZGRpbmcgaW4gdHdvIGxpbmUgYnJlYWtzIHRvIG1hdGNoXG4gICAgLy8gdGhlIGNvbnRlbnQgaWYgd2Ugd2VyZSB0byBnZXQgaXQgZnJvbSBpdHMgcGFyZW50LlxuICAgIGlmICh0ZXh0ID09PSAnJyAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGhhbmRsZWQgaW4gY29yZT9cbiAgICAgIHRleHQgPSAnXFxuXFxuJztcbiAgICB9XG4gICAgY29uc3QgY3VycmVudE5vZGVTaXplID0gdGV4dC5sZW5ndGg7XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShjdXJyZW50Tm9kZSkgfHwgcmVtYWluaW5nID49IGN1cnJlbnROb2RlU2l6ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBjdXJyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDAgJiYgISRpc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nIC09IGN1cnJlbnROb2RlU2l6ZSArIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZTtcbiAgICAgIGN1cnJlbnROb2RlID0gbmV4dE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IGN1cnJlbnROb2RlLmdldEtleSgpO1xuICAgICAgLy8gU2VlIGlmIHdlIGNhbiBqdXN0IHJldmVydCBpdCB0byB3aGF0IHdhcyBpbiB0aGUgbGFzdCBlZGl0b3Igc3RhdGVcbiAgICAgIGNvbnN0IHByZXZUZXh0Q29udGVudCA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2Tm9kZSA9ICRnZXROb2RlQnlLZXkoa2V5KTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKHByZXZOb2RlKSAmJiBwcmV2Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIHJldHVybiBwcmV2Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjdXJyZW50Tm9kZVNpemUgLSByZW1haW5pbmc7XG4gICAgICBjb25zdCBzbGljZWRUZXh0ID0gdGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuICAgICAgaWYgKHByZXZUZXh0Q29udGVudCAhPT0gbnVsbCAmJiBwcmV2VGV4dENvbnRlbnQgIT09IHRleHQpIHtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gICAgICAgIGlmICghY3VycmVudE5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShwcmV2VGV4dENvbnRlbnQpO1xuICAgICAgICAgIGN1cnJlbnROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICAgIHRhcmdldCA9IHRleHROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldFRleHRDb250ZW50KHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZPZmZzZXQgPSBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0LnNlbGVjdChwcmV2T2Zmc2V0LCBwcmV2T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAvLyBTcGxpdCB0ZXh0XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBhbmNob3Iua2V5ID09PSBrZXk7XG4gICAgICAgIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAvLyBNb3ZlIG9mZnNldCB0byBlbmQgaWYgaXQncyBsZXNzIHRoYW4gdGhlIHJlbWFpbmluZyBudW1iZXIsIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSdsbCBoYXZlIGEgbmVnYXRpdmUgc3BsaXRTdGFydC5cbiAgICAgICAgaWYgKGFuY2hvck9mZnNldCA8IHJlbWFpbmluZykge1xuICAgICAgICAgIGFuY2hvck9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpdFN0YXJ0ID0gaXNTZWxlY3RlZCA/IGFuY2hvck9mZnNldCAtIHJlbWFpbmluZyA6IDA7XG4gICAgICAgIGNvbnN0IHNwbGl0RW5kID0gaXNTZWxlY3RlZCA/IGFuY2hvck9mZnNldCA6IG9mZnNldDtcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQgJiYgc3BsaXRTdGFydCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IFtleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBbLCBleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoc2xpY2VkVGV4dCk7XG4gICAgICAgIGN1cnJlbnROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBUZXh0Tm9kZSdzIHN0eWxlIG9iamVjdCBhbmQgYWRkcyB0aGUgc3R5bGVzIHRvIHRoZSBDU1MuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBUZXh0Tm9kZSB0byBhZGQgc3R5bGVzIHRvLlxuICovXG5mdW5jdGlvbiAkYWRkTm9kZVN0eWxlKG5vZGUpIHtcbiAgY29uc3QgQ1NTVGV4dCA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKENTU1RleHQpO1xuICBDU1NfVE9fU1RZTEVTLnNldChDU1NUZXh0LCBzdHlsZXMpO1xufVxuZnVuY3Rpb24gJHBhdGNoU3R5bGUodGFyZ2V0LCBwYXRjaCkge1xuICBjb25zdCBwcmV2U3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKCdnZXRTdHlsZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LmdldFN0eWxlKCkgOiB0YXJnZXQuc3R5bGUpO1xuICBjb25zdCBuZXdTdHlsZXMgPSBPYmplY3QuZW50cmllcyhwYXRjaCkucmVkdWNlKChzdHlsZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlKHByZXZTdHlsZXNba2V5XSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LCB7XG4gICAgLi4ucHJldlN0eWxlc1xuICB9IHx8IHt9KTtcbiAgY29uc3QgbmV3Q1NTVGV4dCA9IGdldENTU0Zyb21TdHlsZU9iamVjdChuZXdTdHlsZXMpO1xuICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KG5ld0NTU1RleHQsIG5ld1N0eWxlcyk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqIFdpbGwgdXBkYXRlIHBhcnRpYWxseSBzZWxlY3RlZCBUZXh0Tm9kZXMgYnkgc3BsaXR0aW5nIHRoZSBUZXh0Tm9kZSBhbmQgYXBwbHlpbmdcbiAqIHRoZSBzdHlsZXMgdG8gdGhlIGFwcHJvcHJpYXRlIG9uZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgbm9kZShzKSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4geyBDU1NQcm9wZXJ0eTogdmFsdWUgfS4gQ2FuIGFsc28gYWNjZXB0IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uICRwYXRjaFN0eWxlVGV4dChzZWxlY3Rpb24sIHBhdGNoKSB7XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAoYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICBsZXQgZmlyc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1swXTtcbiAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdO1xuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICRwYXRjaFN0eWxlKHNlbGVjdGlvbiwgcGF0Y2gpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmaXJzdE5vZGVUZXh0ID0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gIGxldCBzdGFydE9mZnNldCA9IGlzQmVmb3JlID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gIGxldCBlbmRPZmZzZXQgPSBpc0JlZm9yZSA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICBjb25zdCBzdGFydFR5cGUgPSBpc0JlZm9yZSA/IGFuY2hvci50eXBlIDogZm9jdXMudHlwZTtcbiAgY29uc3QgZW5kVHlwZSA9IGlzQmVmb3JlID8gZm9jdXMudHlwZSA6IGFuY2hvci50eXBlO1xuICBjb25zdCBlbmRLZXkgPSBpc0JlZm9yZSA/IGZvY3VzLmtleSA6IGFuY2hvci5rZXk7XG5cbiAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB0aGUgdXNlciBvbmx5IHNlbGVjdGVkIHRoZSB2ZXJ5IGVuZCBvZiB0aGVcbiAgLy8gZmlyc3Qgbm9kZSBzbyB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgaXQgaW4gdGhlIGZvcm1hdHRpbmcgY2hhbmdlLlxuICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgLy8gd2UgYmFzaWNhbGx5IG1ha2UgdGhlIHNlY29uZCBub2RlIHRoZSBmaXJzdE5vZGUsIGNoYW5naW5nIG9mZnNldHMgYWNjb3JkaW5nbHlcbiAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICBmaXJzdE5vZGUgPSBuZXh0U2libGluZztcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHdlIG9ubHkgc2VsZWN0ZWQgYSBzaW5nbGUgbm9kZVxuICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUuY2FuSGF2ZUZvcm1hdCgpKSB7XG4gICAgICBzdGFydE9mZnNldCA9IHN0YXJ0VHlwZSA9PT0gJ2VsZW1lbnQnID8gMCA6IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICBlbmRPZmZzZXQgPSBlbmRUeXBlID09PSAnZWxlbWVudCcgPyBmaXJzdE5vZGVUZXh0TGVuZ3RoIDogYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcblxuICAgICAgLy8gTm8gYWN0dWFsIHRleHQgaXMgc2VsZWN0ZWQsIHNvIGRvIG5vdGhpbmcuXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IGVuZE9mZnNldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBlbnRpcmUgbm9kZSBpcyBzZWxlY3RlZCwgc28ganVzdCBmb3JtYXQgaXRcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoZmlyc3ROb2RlLCBwYXRjaCk7XG4gICAgICAgIGZpcnN0Tm9kZS5zZWxlY3Qoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG5vZGVzXG4gICAgICAgIC8vIGFuZCBzdHlsZSB0aGUgc2VsZWN0ZWQgb25lLlxuICAgICAgICBjb25zdCBzcGxpdE5vZGVzID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICAkcGF0Y2hTdHlsZShyZXBsYWNlbWVudCwgcGF0Y2gpO1xuICAgICAgICByZXBsYWNlbWVudC5zZWxlY3QoMCwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0gLy8gbXVsdGlwbGUgbm9kZXMgc2VsZWN0ZWQuXG4gIH0gZWxzZSB7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgc3RhcnRPZmZzZXQgPCBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgJiYgZmlyc3ROb2RlLmNhbkhhdmVGb3JtYXQoKSkge1xuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBlbnRpcmUgZmlyc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCwgc28gc3BsaXQgaXRcbiAgICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldClbMV07XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGlzQmVmb3JlKSB7XG4gICAgICAgICAgYW5jaG9yLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvY3VzLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkcGF0Y2hTdHlsZShmaXJzdE5vZGUsIHBhdGNoKTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSAmJiBsYXN0Tm9kZS5jYW5IYXZlRm9ybWF0KCkpIHtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHRMZW5ndGggPSBsYXN0Tm9kZVRleHQubGVuZ3RoO1xuXG4gICAgICAvLyBUaGUgbGFzdCBub2RlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSB0aGUgZW5kIG5vZGVcbiAgICAgIC8vXG4gICAgICAvLyBJZiBub3QsIGFzc3VtZSB0aGUgbGFzdCBub2RlIGlzIGZ1bGx5LXNlbGVjdGVkIHVubGVzcyB0aGUgZW5kIG9mZnNldCBpc1xuICAgICAgLy8gemVyby5cbiAgICAgIGlmIChsYXN0Tm9kZS5fX2tleSAhPT0gZW5kS2V5ICYmIGVuZE9mZnNldCAhPT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgPSBsYXN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBlbnRpcmUgbGFzdCBub2RlIGlzbid0IHNlbGVjdGVkLCBzcGxpdCBpdFxuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gbGFzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IDAgfHwgZW5kVHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAgICRwYXRjaFN0eWxlKGxhc3ROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3R5bGUgYWxsIHRoZSB0ZXh0IG5vZGVzIGluIGJldHdlZW5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2ldO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlS2V5ID0gc2VsZWN0ZWROb2RlLmdldEtleSgpO1xuICAgICAgaWYgKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkgJiYgc2VsZWN0ZWROb2RlLmNhbkhhdmVGb3JtYXQoKSAmJiBzZWxlY3RlZE5vZGVLZXkgIT09IGZpcnN0Tm9kZS5nZXRLZXkoKSAmJiBzZWxlY3RlZE5vZGVLZXkgIT09IGxhc3ROb2RlLmdldEtleSgpICYmICFzZWxlY3RlZE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgICRwYXRjaFN0eWxlKHNlbGVjdGVkTm9kZSwgcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiB0aGF0IGFyZSBvZiBvbmUgYmxvY2sgdHlwZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCBibG9ja3MgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnQgLSBUaGUgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBub2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzZXRCbG9ja3NUeXBlKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCkge1xuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGFuY2hvciA9IGFuY2hvckFuZEZvY3VzID8gYW5jaG9yQW5kRm9jdXNbMF0gOiBudWxsO1xuICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHJvb3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICBmaXJzdENoaWxkLnJlcGxhY2UoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgZmlyc3RTZWxlY3RlZEJsb2NrID0gYW5jaG9yICE9PSBudWxsID8gJGdldEFuY2VzdG9yKGFuY2hvci5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKSA6IGZhbHNlO1xuICBpZiAoZmlyc3RTZWxlY3RlZEJsb2NrICYmIG5vZGVzLmluZGV4T2YoZmlyc3RTZWxlY3RlZEJsb2NrKSA9PT0gLTEpIHtcbiAgICBub2Rlcy5wdXNoKGZpcnN0U2VsZWN0ZWRCbG9jayk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoIUlOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGJsb2NrIG5vZGUgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgbm9kZS5yZXBsYWNlKHRhcmdldEVsZW1lbnQsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlUGFyZW50RW1wdHlFbGVtZW50cyhzdGFydGluZ05vZGUpIHtcbiAgbGV0IG5vZGUgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICEkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAobGF0ZXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogV3JhcHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gaW50byBhbm90aGVyIG5vZGUgb2YgdGhlIHR5cGUgcmV0dXJuZWQgYnkgY3JlYXRlRWxlbWVudC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBhbmQgaXRzIGNoaWxkcmVuIHRvLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBjb25zdCBhbmNob3IgPSBhbmNob3JBbmRGb2N1cyA/IGFuY2hvckFuZEZvY3VzWzBdIDogbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgKG5vZGVzTGVuZ3RoID09PSAwIHx8IG5vZGVzTGVuZ3RoID09PSAxICYmIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgZWxlbWVudC5zZXRGb3JtYXQodGFyZ2V0LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgZWxlbWVudC5zZXRJbmRlbnQodGFyZ2V0LmdldEluZGVudCgpKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGVsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldC5yZXBsYWNlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdG9wTGV2ZWxOb2RlID0gbnVsbDtcbiAgbGV0IGRlc2NlbmRhbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3cmFwcGluZyBoYXMgdG8gYmUgYnJva2VuIGRvd24gaW50byBtdWx0aXBsZSBjaHVua3MuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGVcbiAgICAvLyB1c2VyIHNlbGVjdGVkIG11bHRpcGxlIFJvb3QtbGlrZSBub2RlcyB0aGF0IGhhdmUgdG8gYmUgdHJlYXRlZCBzZXBhcmF0ZWx5IGFzIGlmIHRoZXkgYXJlXG4gICAgLy8gdGhlaXIgb3duIGJyYW5jaC4gSS5lLiB5b3UgZG9uJ3Qgd2FudCB0byB3cmFwIGEgd2hvbGUgdGFibGUsIGJ1dCByYXRoZXIgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAvLyBvZiBlYWNoIG9mIHRoZSBjZWxsIG5vZGVzLlxuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgdG9wTGV2ZWxOb2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsTm9kZSA9PT0gbnVsbCB8fCB0b3BMZXZlbE5vZGUgIT09IG51bGwgJiYgJGhhc0FuY2VzdG9yKG5vZGUsIHRvcExldmVsTm9kZSkpIHtcbiAgICAgIGRlc2NlbmRhbnRzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW25vZGVdO1xuICAgIH1cbiAgfVxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG5cbi8qKlxuICogV3JhcHMgZWFjaCBub2RlIGludG8gYSBuZXcgRWxlbWVudE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byB3cmFwLlxuICogQHBhcmFtIG5vZGVzIC0gQW4gYXJyYXkgb2Ygbm9kZXMsIGdlbmVyYWxseSB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBub2Rlc0xlbmd0aCAtIFRoZSBsZW5ndGggb2Ygbm9kZXMuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gd3JhcCBhbGwgdGhlIG5vZGVzIGludG8uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICBjb25zdCBlbGVtZW50TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgLy8gVGhlIGJlbG93IGxvZ2ljIGlzIHRvIGZpbmQgdGhlIHJpZ2h0IHRhcmdldCBmb3IgdXMgdG9cbiAgLy8gZWl0aGVyIGluc2VydEFmdGVyL2luc2VydEJlZm9yZS9hcHBlbmQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgLy8gZWxlbWVudHMgdG8uIFRoaXMgaXMgbWFkZSBtb3JlIGNvbXBsaWNhdGVkIGR1ZSB0byBuZXN0ZWRcbiAgLy8gc3RydWN0dXJlcy5cbiAgbGV0IHRhcmdldCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBpZiAodGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIGxldCB0YXJnZXRJc1ByZXZTaWJsaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nO1xuICAgICAgdGFyZ2V0SXNQcmV2U2libGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZW1wdHlFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuICAvLyBGaW5kIGFueSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBlbXB0eUVsZW1lbnRzLmFkZChub2RlLmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbW92ZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAvLyBNb3ZlIG91dCBhbGwgbGVhZiBub2RlcyBpbnRvIG91ciBlbGVtZW50cyBhcnJheS5cbiAgLy8gSWYgd2UgZmluZCBhIHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50LCBhbHNvIG1vdmUgbWFrZVxuICAvLyBhbiBlbGVtZW50IGZvciB0aGF0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmICRpc0xlYWZOb2RlKG5vZGUpICYmICFtb3ZlZE5vZGVzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHBhcmVudC5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICBtb3ZlZE5vZGVzLmFkZChjaGlsZC5nZXRLZXkoKSk7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSBpbiBlbXB0eUVsZW1lbnRzIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgICBlbGVtZW50cy5wdXNoKHRhcmdldEVsZW1lbnQpO1xuICAgICAgbm9kZS5yZW1vdmUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICB3cmFwcGluZ0VsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBsZXQgbGFzdEVsZW1lbnQgPSBudWxsO1xuXG4gIC8vIElmIG91ciB0YXJnZXQgaXMgUm9vdC1saWtlLCBsZXQncyBzZWUgaWYgd2UgY2FuIHJlLWFkanVzdFxuICAvLyBzbyB0aGF0IHRoZSB0YXJnZXQgaXMgdGhlIGZpcnN0IGNoaWxkIGluc3RlYWQuXG4gIGlmICgkaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICBpZiAodGFyZ2V0SXNQcmV2U2libGluZykge1xuICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IHRhcmdldC5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gZmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXQuYXBwZW5kKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZSh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQpO1xuICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmFuY2hvcikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uZm9jdXMpKSB7XG4gICAgJHNldFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uLmNsb25lKCkpO1xuICB9IGVsc2UgaWYgKGxhc3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbGFzdEVsZW1lbnQuc2VsZWN0RW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBzaG91bGQgYmUgb3ZlcnJpZGRlbi4gVXNlZCB3aXRoIERlY29yYXRvck5vZGVzXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBkZWZhdWx0IGNoYXJhY3RlciBzZWxlY3Rpb24gbWF5IG5lZWQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZHMgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKiBAcmV0dXJucyB0cnVlIGlmIGl0IHNob3VsZCBiZSBvdmVycmlkZGVuLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBpc0JhY2t3YXJkKTtcbiAgcmV0dXJuICRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSB8fCAkaXNFbGVtZW50Tm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJbmxpbmUoKSAmJiAhcG9zc2libGVOb2RlLmNhbkJlRW1wdHkoKTtcbn1cblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCB0ZXh0IG9yIG5vZGVzLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gc2VsZWN0ZWQgYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHBhcmFtIGdyYW51bGFyaXR5IC0gVGhlIGRpc3RhbmNlIHRvIGFkanVzdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgc2VsZWN0aW9uLm1vZGlmeShpc0hvbGRpbmdTaGlmdCA/ICdleHRlbmQnIDogJ21vdmUnLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSk7XG59XG5cbi8qKlxuICogVGVzdHMgYSBwYXJlbnQgZWxlbWVudCBmb3IgcmlnaHQgdG8gbGVmdCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBwYXJlbnQgaXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9ucycgcGFyZW50IGVsZW1lbnQgaGFzIGEgZGlyZWN0aW9uIG9mICdydGwnIChyaWdodCB0byBsZWZ0KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHBhcmVudCA9ICRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpID8gYW5jaG9yTm9kZSA6IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICByZXR1cm4gcGFyZW50LmdldERpcmVjdGlvbigpID09PSAncnRsJztcbn1cblxuLyoqXG4gKiBNb3ZlcyBzZWxlY3Rpb24gYnkgY2hhcmFjdGVyIGFjY29yZGluZyB0byBhcmd1bWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiB0aGUgY2hhcmFjdGVycyB0byBtb3ZlLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gYmFja3dhcmQgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNSVEwgPSAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbik7XG4gICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCA/ICFpc1JUTCA6IGlzUlRMLCAnY2hhcmFjdGVyJyk7XG59XG5cbi8qKlxuICogRXhwYW5kcyB0aGUgY3VycmVudCBTZWxlY3Rpb24gdG8gY292ZXIgYWxsIG9mIHRoZSBjb250ZW50IGluIHRoZSBlZGl0b3IuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICovXG5mdW5jdGlvbiAkc2VsZWN0QWxsKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHRvcFBhcmVudCA9IGFuY2hvck5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpO1xuICBjb25zdCByb290ID0gdG9wUGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgbGV0IGZpcnN0Tm9kZSA9IHJvb3QuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGxldCBsYXN0Tm9kZSA9IHJvb3QuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgbGV0IGZpcnN0VHlwZSA9ICdlbGVtZW50JztcbiAgbGV0IGxhc3RUeXBlID0gJ2VsZW1lbnQnO1xuICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgZmlyc3RUeXBlID0gJ3RleHQnO1xuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZSAhPT0gbnVsbCkge1xuICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgIGxhc3RUeXBlID0gJ3RleHQnO1xuICAgIGxhc3RPZmZzZXQgPSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpICYmIGxhc3ROb2RlICE9PSBudWxsKSB7XG4gICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgaWYgKGZpcnN0Tm9kZSAmJiBsYXN0Tm9kZSkge1xuICAgIGFuY2hvci5zZXQoZmlyc3ROb2RlLmdldEtleSgpLCAwLCBmaXJzdFR5cGUpO1xuICAgIGZvY3VzLnNldChsYXN0Tm9kZS5nZXRLZXkoKSwgbGFzdE9mZnNldCwgbGFzdFR5cGUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgTm9kZXMsIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB3aG9zZSBzdHlsZSB2YWx1ZSB0byBnZXQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZm9yIG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCBjc3MgPSBub2RlLmdldFN0eWxlKCk7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG4gIGlmIChzdHlsZU9iamVjdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzdHlsZU9iamVjdFtzdHlsZVByb3BlcnR5XSB8fCBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGZvciBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgaWYgc2V0LiBJZiBub3Qgc2V0LCBpdCByZXR1cm5zIHRoZSBkZWZhdWx0VmFsdWUuXG4gKiBJZiBhbGwgVGV4dE5vZGVzIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHZhbHVlLCBpdCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIFRleHROb2RlcyB3aG9zZSB2YWx1ZSB0byBmaW5kLlxuICogQHBhcmFtIHN0eWxlUHJvcGVydHkgLSBUaGUgQ1NTIHN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHksIGRlZmF1bHRzIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZm9yIHRoZSBzZWxlY3RlZCBUZXh0Tm9kZXMuXG4gKi9cbmZ1bmN0aW9uICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHkoc2VsZWN0aW9uLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUgPSAnJykge1xuICBsZXQgc3R5bGVWYWx1ZSA9IG51bGw7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzLm9mZnNldCA6IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGVuZE5vZGUgPSBpc0JhY2t3YXJkID8gZm9jdXMuZ2V0Tm9kZSgpIDogYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLnN0eWxlICE9PSAnJykge1xuICAgIGNvbnN0IGNzcyA9IHNlbGVjdGlvbi5zdHlsZTtcbiAgICBjb25zdCBzdHlsZU9iamVjdCA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpO1xuICAgIGlmIChzdHlsZU9iamVjdCAhPT0gbnVsbCAmJiBzdHlsZVByb3BlcnR5IGluIHN0eWxlT2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAvLyBpZiBubyBhY3R1YWwgY2hhcmFjdGVycyBpbiB0aGUgZW5kIG5vZGUgYXJlIHNlbGVjdGVkLCB3ZSBkb24ndFxuICAgIC8vIGluY2x1ZGUgaXQgaW4gdGhlIHNlbGVjdGlvbiBmb3IgcHVycG9zZXMgb2YgZGV0ZXJtaW5pbmcgc3R5bGVcbiAgICAvLyB2YWx1ZVxuICAgIGlmIChpICE9PSAwICYmIGVuZE9mZnNldCA9PT0gMCAmJiBub2RlLmlzKGVuZE5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBub2RlU3R5bGVWYWx1ZSA9ICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICBpZiAoc3R5bGVWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBzdHlsZVZhbHVlID0gbm9kZVN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlVmFsdWUgIT09IG5vZGVTdHlsZVZhbHVlKSB7XG4gICAgICAgIC8vIG11bHRpcGxlIHRleHQgbm9kZXMgYXJlIGluIHRoZSBzZWxlY3Rpb24gYW5kIHRoZXkgZG9uJ3QgYWxsXG4gICAgICAgIC8vIGhhdmUgdGhlIHNhbWUgc3R5bGUuXG4gICAgICAgIHN0eWxlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZVZhbHVlID09PSBudWxsID8gZGVmYXVsdFZhbHVlIDogc3R5bGVWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb2YgdGhlIGxpYnJhcnkuXG4gKiBQbGVhc2UgZG8gbm90IHVzZSBpdCBhcyBpdCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmZ1bmN0aW9uIElOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpIHtcbiAgaWYgKCRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCAkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgY29uc3QgaXNMZWFmRWxlbWVudCA9IGZpcnN0Q2hpbGQgPT09IG51bGwgfHwgJGlzTGluZUJyZWFrTm9kZShmaXJzdENoaWxkKSB8fCAkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSB8fCBmaXJzdENoaWxkLmlzSW5saW5lKCk7XG4gIHJldHVybiAhbm9kZS5pc0lubGluZSgpICYmIG5vZGUuY2FuQmVFbXB0eSgpICE9PSBmYWxzZSAmJiBpc0xlYWZFbGVtZW50O1xufVxuZnVuY3Rpb24gJGdldEFuY2VzdG9yKG5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZ2V0UGFyZW50KCkgIT09IG51bGwgJiYgIXByZWRpY2F0ZShwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcHJlZGljYXRlKHBhcmVudCkgPyBwYXJlbnQgOiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcn0gYnkgQGxleGljYWwvZXNsaW50LXBsdWdpbiBydWxlcy1vZi1sZXhpY2FsICovXG5jb25zdCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yID0gJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3I7XG5cbmV4cG9ydCB7ICRhZGROb2RlU3R5bGUsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5LCAkaXNBdE5vZGVFbmQsICRpc1BhcmVudEVsZW1lbnRSVEwsICRtb3ZlQ2FyZXRTZWxlY3Rpb24sICRtb3ZlQ2hhcmFjdGVyLCAkcGF0Y2hTdHlsZVRleHQsICRzZWxlY3RBbGwsICRzZXRCbG9ja3NUeXBlLCAkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uLCAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCwgJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IsICR3cmFwTm9kZXMsIGNyZWF0ZURPTVJhbmdlLCBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZSwgZ2V0U3R5bGVPYmplY3RGcm9tQ1NTLCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/table/LexicalTable.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.dev.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $computeTableMap: () => (/* binding */ $computeTableMap),\n/* harmony export */   $computeTableMapSkipCellCheck: () => (/* binding */ $computeTableMapSkipCellCheck),\n/* harmony export */   $createTableCellNode: () => (/* binding */ $createTableCellNode),\n/* harmony export */   $createTableNode: () => (/* binding */ $createTableNode),\n/* harmony export */   $createTableNodeWithDimensions: () => (/* binding */ $createTableNodeWithDimensions),\n/* harmony export */   $createTableRowNode: () => (/* binding */ $createTableRowNode),\n/* harmony export */   $createTableSelection: () => (/* binding */ $createTableSelection),\n/* harmony export */   $deleteTableColumn: () => (/* binding */ $deleteTableColumn),\n/* harmony export */   $deleteTableColumn__EXPERIMENTAL: () => (/* binding */ $deleteTableColumn__EXPERIMENTAL),\n/* harmony export */   $deleteTableRow__EXPERIMENTAL: () => (/* binding */ $deleteTableRow__EXPERIMENTAL),\n/* harmony export */   $getElementForTableNode: () => (/* binding */ $getElementForTableNode),\n/* harmony export */   $getNodeTriplet: () => (/* binding */ $getNodeTriplet),\n/* harmony export */   $getTableCellNodeFromLexicalNode: () => (/* binding */ $getTableCellNodeFromLexicalNode),\n/* harmony export */   $getTableCellNodeRect: () => (/* binding */ $getTableCellNodeRect),\n/* harmony export */   $getTableColumnIndexFromTableCellNode: () => (/* binding */ $getTableColumnIndexFromTableCellNode),\n/* harmony export */   $getTableNodeFromLexicalNodeOrThrow: () => (/* binding */ $getTableNodeFromLexicalNodeOrThrow),\n/* harmony export */   $getTableRowIndexFromTableCellNode: () => (/* binding */ $getTableRowIndexFromTableCellNode),\n/* harmony export */   $getTableRowNodeFromTableCellNodeOrThrow: () => (/* binding */ $getTableRowNodeFromTableCellNodeOrThrow),\n/* harmony export */   $insertTableColumn: () => (/* binding */ $insertTableColumn),\n/* harmony export */   $insertTableColumn__EXPERIMENTAL: () => (/* binding */ $insertTableColumn__EXPERIMENTAL),\n/* harmony export */   $insertTableRow: () => (/* binding */ $insertTableRow),\n/* harmony export */   $insertTableRow__EXPERIMENTAL: () => (/* binding */ $insertTableRow__EXPERIMENTAL),\n/* harmony export */   $isTableCellNode: () => (/* binding */ $isTableCellNode),\n/* harmony export */   $isTableNode: () => (/* binding */ $isTableNode),\n/* harmony export */   $isTableRowNode: () => (/* binding */ $isTableRowNode),\n/* harmony export */   $isTableSelection: () => (/* binding */ $isTableSelection),\n/* harmony export */   $removeTableRowAtIndex: () => (/* binding */ $removeTableRowAtIndex),\n/* harmony export */   $unmergeCell: () => (/* binding */ $unmergeCell),\n/* harmony export */   INSERT_TABLE_COMMAND: () => (/* binding */ INSERT_TABLE_COMMAND),\n/* harmony export */   TableCellHeaderStates: () => (/* binding */ TableCellHeaderStates),\n/* harmony export */   TableCellNode: () => (/* binding */ TableCellNode),\n/* harmony export */   TableNode: () => (/* binding */ TableNode),\n/* harmony export */   TableObserver: () => (/* binding */ TableObserver),\n/* harmony export */   TableRowNode: () => (/* binding */ TableRowNode),\n/* harmony export */   applyTableHandlers: () => (/* binding */ applyTableHandlers),\n/* harmony export */   getDOMCellFromTarget: () => (/* binding */ getDOMCellFromTarget),\n/* harmony export */   getTableObserverFromTableElement: () => (/* binding */ getTableObserverFromTableElement)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.__colSpan;\n  }\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = style.textDecoration.split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lexicalNode)) {\n        const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraphNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusRowMap[focusStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    const [map, cellMap] = $computeTableMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(grid, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n    if (cellA !== null && cellA.is(cell)) {\n      cellAValue = value;\n    }\n    if (cellB !== null && cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n  const gridChildren = grid.getChildren();\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected GridNode children to be TableRowNode`);\n    }\n    const rowChildren = row.getChildren();\n    let j = 0;\n    for (const cell of rowChildren) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      }\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent GridNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n    const nodes = [tableNode];\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isCurrentlyReadOnlyMode)()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  const focus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(this.tableSelection);\n          editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection);\n      this.editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(cellNode)) {\n          const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {\n      onMouseMove: onMouseMove,\n      onMouseUp: onMouseUp\n    };\n  };\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableObserver.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n));\n      const topLevelCellElementNode = nearestElementNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(nearestElementNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && $isTableCellNode(n.getParent()));\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topLevelCellElementNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  });\n  const $deleteCellHandler = event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      event.preventDefault();\n      event.stopPropagation();\n      tableObserver.clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, event => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    let newAnchorCellKey;\n    let newFocusCellKey;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        if (r === fromY && c === fromX) {\n          newAnchorCellKey = currentGridCellNode.getKey();\n        } else if (r === toY && c === toX) {\n          newFocusCellKey = currentGridCellNode.getKey();\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    if (newAnchorCellKey && newFocusCellKey) {\n      const newTableSelection = $createTableSelection();\n      newTableSelection.set(nodes[0].getKey(), newAnchorCellKey, newFocusCellKey);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newTableSelection);\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          newSelection.focus.set(tableNode.getParentOrThrow().getKey(), tableNode.getIndexWithinParent(), 'element');\n        } else {\n          newSelection.anchor.set(tableNode.getParentOrThrow().getKey(), isBackward ? tableNode.getIndexWithinParent() + 1 : tableNode.getIndexWithinParent(), 'element');\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelectionFromDom)(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if (direction === 'backward' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n      const anchorType = selection.anchor.type;\n      const anchorOffset = selection.anchor.offset;\n      if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n      if (!parentNode) {\n        return false;\n      }\n      const siblingNode = parentNode.getPreviousSibling();\n      if (!siblingNode || !$isTableNode(siblingNode)) {\n        return false;\n      }\n      stopEvent(event);\n      siblingNode.selectEnd();\n      return true;\n    }\n    return false;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  static getType() {\n    return 'table';\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n  constructor(key) {\n    super(key);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, config.theme.table);\n    return tableElement;\n  }\n  updateDOM() {\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(tableElement)) {\n            tBody.append(...tableElement.children);\n          }\n          const firstRow = this.getFirstChildOrThrow();\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n          const colCount = firstRow.getChildrenSize();\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const cell = row[x];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction $convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlIO0FBQ3l4Qjs7QUFFbDVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBVztBQUN2Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRWk0QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5tanM/N2YzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsICRmaW5kTWF0Y2hpbmdQYXJlbnQsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IEVsZW1lbnROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc0xpbmVCcmVha05vZGUsICRpc1RleHROb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsIGNyZWF0ZUNvbW1hbmQsICRjcmVhdGVUZXh0Tm9kZSwgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRjcmVhdGVQb2ludCwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkZ2V0Tm9kZUJ5S2V5LCBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSwgJHNldFNlbGVjdGlvbiwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkZ2V0Um9vdCwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9ISUdILCBLRVlfQVJST1dfVVBfQ09NTUFORCwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgREVMRVRFX1dPUkRfQ09NTUFORCwgREVMRVRFX0xJTkVfQ09NTUFORCwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMLCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORCwgRk9STUFUX1RFWFRfQ09NTUFORCwgRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBLRVlfVEFCX0NPTU1BTkQsIEZPQ1VTX0NPTU1BTkQsIFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbSwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAkaXNEZWNvcmF0b3JOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgUElYRUxfVkFMVUVfUkVHX0VYUCA9IC9eKFxcZCsoPzpcXC5cXGQrKT8pcHgkLztcblxuLy8gLlBsYXlncm91bmRFZGl0b3JUaGVtZV9fdGFibGVDZWxsIHdpZHRoIHZhbHVlIGZyb21cbi8vIHBhY2thZ2VzL2xleGljYWwtcGxheWdyb3VuZC9zcmMvdGhlbWVzL1BsYXlncm91bmRFZGl0b3JUaGVtZS5jc3NcbmNvbnN0IENPTFVNTl9XSURUSCA9IDc1O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFRhYmxlQ2VsbEhlYWRlclN0YXRlcyA9IHtcbiAgQk9USDogMyxcbiAgQ09MVU1OOiAyLFxuICBOT19TVEFUVVM6IDAsXG4gIFJPVzogMVxufTtcbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZUNlbGxOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGVjZWxsJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIGNvbnN0IGNlbGxOb2RlID0gbmV3IFRhYmxlQ2VsbE5vZGUobm9kZS5fX2hlYWRlclN0YXRlLCBub2RlLl9fY29sU3Bhbiwgbm9kZS5fX3dpZHRoLCBub2RlLl9fa2V5KTtcbiAgICBjZWxsTm9kZS5fX3Jvd1NwYW4gPSBub2RlLl9fcm93U3BhbjtcbiAgICBjZWxsTm9kZS5fX2JhY2tncm91bmRDb2xvciA9IG5vZGUuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgcmV0dXJuIGNlbGxOb2RlO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRkOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHRoOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBjb2xTcGFuID0gc2VyaWFsaXplZE5vZGUuY29sU3BhbiB8fCAxO1xuICAgIGNvbnN0IHJvd1NwYW4gPSBzZXJpYWxpemVkTm9kZS5yb3dTcGFuIHx8IDE7XG4gICAgY29uc3QgY2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShzZXJpYWxpemVkTm9kZS5oZWFkZXJTdGF0ZSwgY29sU3Bhbiwgc2VyaWFsaXplZE5vZGUud2lkdGggfHwgdW5kZWZpbmVkKTtcbiAgICBjZWxsTm9kZS5fX3Jvd1NwYW4gPSByb3dTcGFuO1xuICAgIGNlbGxOb2RlLl9fYmFja2dyb3VuZENvbG9yID0gc2VyaWFsaXplZE5vZGUuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgcmV0dXJuIGNlbGxOb2RlO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICB0aGlzLl9fcm93U3BhbiA9IDE7XG4gICAgdGhpcy5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgdGhpcy5fX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG51bGw7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuZ2V0VGFnKCkpO1xuICAgIGlmICh0aGlzLl9fd2lkdGgpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9fd2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5yb3dTcGFuID0gdGhpcy5fX3Jvd1NwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLl9fYmFja2dyb3VuZENvbG9yICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbCwgdGhpcy5oYXNIZWFkZXIoKSAmJiBjb25maWcudGhlbWUudGFibGVDZWxsSGVhZGVyKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3QgZWxlbWVudF8gPSBlbGVtZW50O1xuICAgICAgZWxlbWVudF8uc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBibGFjayc7XG4gICAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnRfLmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fcm93U3BhbiA+IDEpIHtcbiAgICAgICAgZWxlbWVudF8ucm93U3BhbiA9IHRoaXMuX19yb3dTcGFuO1xuICAgICAgfVxuICAgICAgZWxlbWVudF8uc3R5bGUud2lkdGggPSBgJHt0aGlzLmdldFdpZHRoKCkgfHwgQ09MVU1OX1dJRFRIfXB4YDtcbiAgICAgIGVsZW1lbnRfLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAndG9wJztcbiAgICAgIGVsZW1lbnRfLnN0eWxlLnRleHRBbGlnbiA9ICdzdGFydCc7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpO1xuICAgICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50Xy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzSGVhZGVyKCkpIHtcbiAgICAgICAgZWxlbWVudF8uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmMmYzZjUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpLFxuICAgICAgY29sU3BhbjogdGhpcy5fX2NvbFNwYW4sXG4gICAgICBoZWFkZXJTdGF0ZTogdGhpcy5fX2hlYWRlclN0YXRlLFxuICAgICAgcm93U3BhbjogdGhpcy5fX3Jvd1NwYW4sXG4gICAgICB0eXBlOiAndGFibGVjZWxsJyxcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKClcbiAgICB9O1xuICB9XG4gIGdldENvbFNwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jb2xTcGFuO1xuICB9XG4gIHNldENvbFNwYW4oY29sU3Bhbikge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKS5fX2NvbFNwYW4gPSBjb2xTcGFuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFJvd1NwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19yb3dTcGFuO1xuICB9XG4gIHNldFJvd1NwYW4ocm93U3Bhbikge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKS5fX3Jvd1NwYW4gPSByb3dTcGFuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNIZWFkZXIoKSA/ICd0aCcgOiAndGQnO1xuICB9XG4gIHNldEhlYWRlclN0eWxlcyhoZWFkZXJTdGF0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgcmV0dXJuIHRoaXMuX19oZWFkZXJTdGF0ZTtcbiAgfVxuICBnZXRIZWFkZXJTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWFkZXJTdGF0ZTtcbiAgfVxuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3dpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHRoaXMuX193aWR0aDtcbiAgfVxuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3dpZHRoO1xuICB9XG4gIGdldEJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2JhY2tncm91bmRDb2xvcjtcbiAgfVxuICBzZXRCYWNrZ3JvdW5kQ29sb3IobmV3QmFja2dyb3VuZENvbG9yKSB7XG4gICAgdGhpcy5nZXRXcml0YWJsZSgpLl9fYmFja2dyb3VuZENvbG9yID0gbmV3QmFja2dyb3VuZENvbG9yO1xuICB9XG4gIHRvZ2dsZUhlYWRlclN0eWxlKGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGlmICgoc2VsZi5fX2hlYWRlclN0YXRlICYgaGVhZGVyU3RhdGVUb1RvZ2dsZSkgPT09IGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSAtPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9faGVhZGVyU3RhdGUgKz0gaGVhZGVyU3RhdGVUb1RvZ2dsZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaGFzSGVhZGVyU3RhdGUoaGVhZGVyU3RhdGUpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0SGVhZGVyU3R5bGVzKCkgJiBoZWFkZXJTdGF0ZSkgPT09IGhlYWRlclN0YXRlO1xuICB9XG4gIGhhc0hlYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlYWRlclN0YXRlICE9PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlYWRlclN0YXRlICE9PSB0aGlzLl9faGVhZGVyU3RhdGUgfHwgcHJldk5vZGUuX193aWR0aCAhPT0gdGhpcy5fX3dpZHRoIHx8IHByZXZOb2RlLl9fY29sU3BhbiAhPT0gdGhpcy5fX2NvbFNwYW4gfHwgcHJldk5vZGUuX19yb3dTcGFuICE9PSB0aGlzLl9fcm93U3BhbiB8fCBwcmV2Tm9kZS5fX2JhY2tncm91bmRDb2xvciAhPT0gdGhpcy5fX2JhY2tncm91bmRDb2xvcjtcbiAgfVxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBkb21Ob2RlXyA9IGRvbU5vZGU7XG4gIGNvbnN0IG5vZGVOYW1lID0gZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgd2lkdGggPSB1bmRlZmluZWQ7XG4gIGlmIChQSVhFTF9WQUxVRV9SRUdfRVhQLnRlc3QoZG9tTm9kZV8uc3R5bGUud2lkdGgpKSB7XG4gICAgd2lkdGggPSBwYXJzZUZsb2F0KGRvbU5vZGVfLnN0eWxlLndpZHRoKTtcbiAgfVxuICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUobm9kZU5hbWUgPT09ICd0aCcgPyBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XIDogVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgZG9tTm9kZV8uY29sU3Bhbiwgd2lkdGgpO1xuICB0YWJsZUNlbGxOb2RlLl9fcm93U3BhbiA9IGRvbU5vZGVfLnJvd1NwYW47XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGRvbU5vZGVfLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gJycpIHtcbiAgICB0YWJsZUNlbGxOb2RlLl9fYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gZG9tTm9kZV8uc3R5bGU7XG4gIGNvbnN0IHRleHREZWNvcmF0aW9uID0gc3R5bGUudGV4dERlY29yYXRpb24uc3BsaXQoJyAnKTtcbiAgY29uc3QgaGFzQm9sZEZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0ID09PSAnNzAwJyB8fCBzdHlsZS5mb250V2VpZ2h0ID09PSAnYm9sZCc7XG4gIGNvbnN0IGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygnbGluZS10aHJvdWdoJyk7XG4gIGNvbnN0IGhhc0l0YWxpY0ZvbnRTdHlsZSA9IHN0eWxlLmZvbnRTdHlsZSA9PT0gJ2l0YWxpYyc7XG4gIGNvbnN0IGhhc1VuZGVybGluZVRleHREZWNvcmF0aW9uID0gdGV4dERlY29yYXRpb24uaW5jbHVkZXMoJ3VuZGVybGluZScpO1xuICByZXR1cm4ge1xuICAgIGFmdGVyOiBjaGlsZExleGljYWxOb2RlcyA9PiB7XG4gICAgICBpZiAoY2hpbGRMZXhpY2FsTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNoaWxkTGV4aWNhbE5vZGVzLnB1c2goJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hpbGRMZXhpY2FsTm9kZXM7XG4gICAgfSxcbiAgICBmb3JDaGlsZDogKGxleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSkgPT4ge1xuICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUocGFyZW50TGV4aWNhbE5vZGUpICYmICEkaXNFbGVtZW50Tm9kZShsZXhpY2FsTm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGxleGljYWxOb2RlKSAmJiBsZXhpY2FsTm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnXFxuJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShsZXhpY2FsTm9kZSkpIHtcbiAgICAgICAgICBpZiAoaGFzQm9sZEZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnYm9sZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdHJpa2V0aHJvdWdoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNJdGFsaWNGb250U3R5bGUpIHtcbiAgICAgICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnaXRhbGljJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCd1bmRlcmxpbmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQobGV4aWNhbE5vZGUpO1xuICAgICAgICByZXR1cm4gcGFyYWdyYXBoTm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgICB9LFxuICAgIG5vZGU6IHRhYmxlQ2VsbE5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlLCBjb2xTcGFuID0gMSwgd2lkdGgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSwgY29sU3Bhbiwgd2lkdGgpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlQ2VsbE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSU5TRVJUX1RBQkxFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfVEFCTEVfQ09NTUFORCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZVJvd05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlcm93JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVSb3dOb2RlKG5vZGUuX19oZWlnaHQsIG5vZGUuX19rZXkpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVSb3dFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZVJvd05vZGUoc2VyaWFsaXplZE5vZGUuaGVpZ2h0KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihoZWlnaHQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2hlaWdodCA9IGhlaWdodDtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICAuLi4odGhpcy5nZXRIZWlnaHQoKSAmJiB7XG4gICAgICAgIGhlaWdodDogdGhpcy5nZXRIZWlnaHQoKVxuICAgICAgfSksXG4gICAgICB0eXBlOiAndGFibGVyb3cnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgIGlmICh0aGlzLl9faGVpZ2h0KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3RoaXMuX19oZWlnaHR9cHhgO1xuICAgIH1cbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZVJvdyk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuX19oZWlnaHQ7XG4gIH1cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVpZ2h0O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlaWdodCAhPT0gdGhpcy5fX2hlaWdodDtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlUm93RWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgbGV0IGhlaWdodCA9IHVuZGVmaW5lZDtcbiAgaWYgKFBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpKSB7XG4gICAgaGVpZ2h0ID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZVRhYmxlUm93Tm9kZShoZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVSb3dOb2RlKGhlaWdodCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZVJvd05vZGUoaGVpZ2h0KSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZVJvd05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlUm93Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKHJvd0NvdW50LCBjb2x1bW5Db3VudCwgaW5jbHVkZUhlYWRlcnMgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgZm9yIChsZXQgaVJvdyA9IDA7IGlSb3cgPCByb3dDb3VudDsgaVJvdysrKSB7XG4gICAgY29uc3QgdGFibGVSb3dOb2RlID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuICAgIGZvciAobGV0IGlDb2x1bW4gPSAwOyBpQ29sdW1uIDwgY29sdW1uQ291bnQ7IGlDb2x1bW4rKykge1xuICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgIGlmICh0eXBlb2YgaW5jbHVkZUhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLnJvd3MpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpQ29sdW1uID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLmNvbHVtbnMpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSk7XG4gICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKCRjcmVhdGVUZXh0Tm9kZSgpKTtcbiAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgdGFibGVSb3dOb2RlLmFwcGVuZCh0YWJsZUNlbGxOb2RlKTtcbiAgICB9XG4gICAgdGFibGVOb2RlLmFwcGVuZCh0YWJsZVJvd05vZGUpO1xuICB9XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZShzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyhzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlUm93Tm9kZShuKSk7XG4gIGlmICgkaXNUYWJsZVJvd05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlIHJvdy4nKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBub2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcbiAgaWYgKCRpc1RhYmxlTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVSb3dOb2RlKTtcbiAgcmV0dXJuIHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVSb3dOb2RlKSk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuIHRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVDZWxsTm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZSk7XG4gIHJldHVybiB7XG4gICAgYWJvdmU6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5IC0gMSwgdGFibGUpLFxuICAgIGJlbG93OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSArIDEsIHRhYmxlKSxcbiAgICBsZWZ0OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCAtIDEsIHksIHRhYmxlKSxcbiAgICByaWdodDogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHggKyAxLCB5LCB0YWJsZSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVUYWJsZVJvd0F0SW5kZXgodGFibGVOb2RlLCBpbmRleFRvRGVsZXRlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBpZiAoaW5kZXhUb0RlbGV0ZSA+PSB0YWJsZVJvd3MubGVuZ3RoIHx8IGluZGV4VG9EZWxldGUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1tpbmRleFRvRGVsZXRlXTtcbiAgdGFyZ2V0Um93Tm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvdyh0YWJsZU5vZGUsIHRhcmdldEluZGV4LCBzaG91bGRJbnNlcnRBZnRlciA9IHRydWUsIHJvd0NvdW50LCB0YWJsZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93cy5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSByb3cgdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNvbnN0IHRhcmdldFJvd05vZGUgPSB0YWJsZVJvd3NbdGFyZ2V0SW5kZXhdO1xuICBpZiAoJGlzVGFibGVSb3dOb2RlKHRhcmdldFJvd05vZGUpKSB7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NlbGxzID0gdGFyZ2V0Um93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3QgdGFibGVDb2x1bW5Db3VudCA9IHRhYmxlUm93Q2VsbHMubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3VGFibGVSb3dOb2RlID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0YWJsZUNvbHVtbkNvdW50OyBjKyspIHtcbiAgICAgICAgY29uc3QgdGFibGVDZWxsRnJvbVRhcmdldFJvdyA9IHRhYmxlUm93Q2VsbHNbY107XG4gICAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93KSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgIGJlbG93XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93LCB0YWJsZSk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWJvdmUgJiYgYWJvdmUuZ2V0V2lkdGgoKSB8fCBiZWxvdyAmJiBiZWxvdy5nZXRXaWR0aCgpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFib3ZlICYmIGFib3ZlLmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pIHx8IGJlbG93ICYmIGJlbG93Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIDEsIHdpZHRoKTtcbiAgICAgICAgdGFibGVDZWxsTm9kZS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIG5ld1RhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRBZnRlcihuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRCZWZvcmUobmV3VGFibGVSb3dOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3cgYmVmb3JlIGluc2VydGlvbiBpbmRleCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuY29uc3QgZ2V0SGVhZGVyU3RhdGUgPSAoY3VycmVudFN0YXRlLCBwb3NzaWJsZVN0YXRlKSA9PiB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5CT1RIIHx8IGN1cnJlbnRTdGF0ZSA9PT0gcG9zc2libGVTdGF0ZSkge1xuICAgIHJldHVybiBwb3NzaWJsZVN0YXRlO1xuICB9XG4gIHJldHVybiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xufTtcbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvd19fRVhQRVJJTUVOVEFMKGluc2VydEFmdGVyID0gdHJ1ZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBHcmlkU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBbZm9jdXNDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgZm9jdXNDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3dcbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgaWYgKGluc2VydEFmdGVyKSB7XG4gICAgY29uc3QgZm9jdXNFbmRSb3cgPSBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiAtIDE7XG4gICAgY29uc3QgZm9jdXNFbmRSb3dNYXAgPSBncmlkTWFwW2ZvY3VzRW5kUm93XTtcbiAgICBjb25zdCBuZXdSb3cgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93XG4gICAgICB9ID0gZm9jdXNFbmRSb3dNYXBbaV07XG4gICAgICBpZiAoc3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPD0gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBmb2N1c0VuZFJvd01hcFtpXS5jZWxsO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEhlYWRlclN0YXRlID0gY3VycmVudENlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKTtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmb2N1c0VuZFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c0VuZFJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoZm9jdXNFbmRSb3dOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYGZvY3VzRW5kUm93IGlzIG5vdCBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBmb2N1c0VuZFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3Um93KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmb2N1c1N0YXJ0Um93TWFwID0gZ3JpZE1hcFtmb2N1c1N0YXJ0Um93XTtcbiAgICBjb25zdCBuZXdSb3cgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93XG4gICAgICB9ID0gZm9jdXNTdGFydFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyA9PT0gZm9jdXNTdGFydFJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGZvY3VzU3RhcnRSb3dNYXBbaV0uY2VsbDtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGxIZWFkZXJTdGF0ZSA9IGN1cnJlbnRDZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgICAgIGNvbnN0IGhlYWRlclN0YXRlID0gZ2V0SGVhZGVyU3RhdGUoY3VycmVudENlbGxIZWFkZXJTdGF0ZSwgVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTik7XG4gICAgICAgIG5ld1Jvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZm9jdXNTdGFydFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c1N0YXJ0Um93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShmb2N1c1N0YXJ0Um93Tm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBmb2N1c0VuZFJvdyBpcyBub3QgYSBUYWJsZVJvd05vZGVgKTtcbiAgICB9XG4gICAgZm9jdXNTdGFydFJvd05vZGUuaW5zZXJ0QmVmb3JlKG5ld1Jvdyk7XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZUNvbHVtbih0YWJsZU5vZGUsIHRhcmdldEluZGV4LCBzaG91bGRJbnNlcnRBZnRlciA9IHRydWUsIGNvbHVtbkNvdW50LCB0YWJsZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgdGFibGVDZWxsc1RvQmVJbnNlcnRlZCA9IFtdO1xuICBmb3IgKGxldCByID0gMDsgciA8IHRhYmxlUm93cy5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IGN1cnJlbnRUYWJsZVJvd05vZGUgPSB0YWJsZVJvd3Nbcl07XG4gICAgaWYgKCRpc1RhYmxlUm93Tm9kZShjdXJyZW50VGFibGVSb3dOb2RlKSkge1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb2x1bW5Db3VudDsgYysrKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlUm93Q2hpbGRyZW4gPSBjdXJyZW50VGFibGVSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSB0YWJsZVJvd0NoaWxkcmVuLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0Q2VsbCA9IHRhYmxlUm93Q2hpbGRyZW5bdGFyZ2V0SW5kZXhdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFyZ2V0Q2VsbCkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGFibGUgY2VsbGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHJpZ2h0XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YXJnZXRDZWxsLCB0YWJsZSk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGlmIChsZWZ0ICYmIGxlZnQuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVykgfHwgcmlnaHQgJiYgcmlnaHQuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVykpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1RhYmxlQ2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKTtcbiAgICAgICAgbmV3VGFibGVDZWxsLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICAgICAgdGFibGVDZWxsc1RvQmVJbnNlcnRlZC5wdXNoKHtcbiAgICAgICAgICBuZXdUYWJsZUNlbGwsXG4gICAgICAgICAgdGFyZ2V0Q2VsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGFibGVDZWxsc1RvQmVJbnNlcnRlZC5mb3JFYWNoKCh7XG4gICAgbmV3VGFibGVDZWxsLFxuICAgIHRhcmdldENlbGxcbiAgfSkgPT4ge1xuICAgIGlmIChzaG91bGRJbnNlcnRBZnRlcikge1xuICAgICAgdGFyZ2V0Q2VsbC5pbnNlcnRBZnRlcihuZXdUYWJsZUNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRDZWxsLmluc2VydEJlZm9yZShuZXdUYWJsZUNlbGwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTChpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgR3JpZFNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgZm9jdXNDZWxsTWFwLCBhbmNob3JDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgZm9jdXNDZWxsLCBhbmNob3JDZWxsKTtcbiAgY29uc3Qgcm93Q291bnQgPSBncmlkTWFwLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnRDb2x1bW4gPSBpbnNlcnRBZnRlciA/IE1hdGgubWF4KGZvY3VzQ2VsbE1hcC5zdGFydENvbHVtbiwgYW5jaG9yQ2VsbE1hcC5zdGFydENvbHVtbikgOiBNYXRoLm1pbihmb2N1c0NlbGxNYXAuc3RhcnRDb2x1bW4sIGFuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW4pO1xuICBjb25zdCBpbnNlcnRBZnRlckNvbHVtbiA9IGluc2VydEFmdGVyID8gc3RhcnRDb2x1bW4gKyBmb2N1c0NlbGwuX19jb2xTcGFuIC0gMSA6IHN0YXJ0Q29sdW1uIC0gMTtcbiAgY29uc3QgZ3JpZEZpcnN0Q2hpbGQgPSBncmlkLmdldEZpcnN0Q2hpbGQoKTtcbiAgaWYgKCEkaXNUYWJsZVJvd05vZGUoZ3JpZEZpcnN0Q2hpbGQpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGZpcnN0VGFibGUgY2hpbGQgdG8gYmUgYSByb3dgKTtcbiAgfVxuICBsZXQgZmlyc3RJbnNlcnRlZENlbGwgPSBudWxsO1xuICBmdW5jdGlvbiAkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUykge1xuICAgIGNvbnN0IGNlbGwgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgIGlmIChmaXJzdEluc2VydGVkQ2VsbCA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RJbnNlcnRlZENlbGwgPSBjZWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuICBsZXQgbG9vcFJvdyA9IGdyaWRGaXJzdENoaWxkO1xuICByb3dMb29wOiBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgY29uc3QgY3VycmVudFJvdyA9IGxvb3BSb3cuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRSb3cpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCByb3cgbmV4dFNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxvb3BSb3cgPSBjdXJyZW50Um93O1xuICAgIH1cbiAgICBjb25zdCByb3dNYXAgPSBncmlkTWFwW2ldO1xuICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSByb3dNYXBbaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uXS5jZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwKSB7XG4gICAgICAkaW5zZXJ0Rmlyc3QobG9vcFJvdywgJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNlbGw6IGN1cnJlbnRDZWxsLFxuICAgICAgc3RhcnRDb2x1bW46IGN1cnJlbnRTdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93OiBjdXJyZW50U3RhcnRSb3dcbiAgICB9ID0gcm93TWFwW2luc2VydEFmdGVyQ29sdW1uXTtcbiAgICBpZiAoY3VycmVudFN0YXJ0Q29sdW1uICsgY3VycmVudENlbGwuX19jb2xTcGFuIC0gMSA8PSBpbnNlcnRBZnRlckNvbHVtbikge1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbFJvd1N0YXJ0ID0gY3VycmVudFN0YXJ0Um93O1xuICAgICAgbGV0IHByZXZDZWxsSW5kZXggPSBpbnNlcnRBZnRlckNvbHVtbjtcbiAgICAgIHdoaWxlIChpbnNlcnRBZnRlckNlbGxSb3dTdGFydCAhPT0gaSAmJiBpbnNlcnRBZnRlckNlbGwuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBwcmV2Q2VsbEluZGV4IC09IGN1cnJlbnRDZWxsLl9fY29sU3BhbjtcbiAgICAgICAgaWYgKHByZXZDZWxsSW5kZXggPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNlbGw6IGNlbGxfLFxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93X1xuICAgICAgICAgIH0gPSByb3dNYXBbcHJldkNlbGxJbmRleF07XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY2VsbF87XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBzdGFydFJvd187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9vcFJvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgICAgIGNvbnRpbnVlIHJvd0xvb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDZWxsLnNldENvbFNwYW4oY3VycmVudENlbGwuX19jb2xTcGFuICsgMSk7XG4gICAgfVxuICB9XG4gIGlmIChmaXJzdEluc2VydGVkQ2VsbCAhPT0gbnVsbCkge1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGZpcnN0SW5zZXJ0ZWRDZWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGVSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tpXTtcbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG4gICAgICB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBHcmlkU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBhbmNob3JDZWxsTWFwLCBmb2N1c0NlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGFuY2hvclN0YXJ0Um93XG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3dcbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgY29uc3QgZm9jdXNFbmRSb3cgPSBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiAtIDE7XG4gIGlmIChncmlkTWFwLmxlbmd0aCA9PT0gZm9jdXNFbmRSb3cgLSBhbmNob3JTdGFydFJvdyArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgY29uc3QgbmV4dFJvdyA9IGdyaWRNYXBbZm9jdXNFbmRSb3cgKyAxXTtcbiAgY29uc3QgbmV4dFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c0VuZFJvdyArIDEpO1xuICBmb3IgKGxldCByb3cgPSBmb2N1c0VuZFJvdzsgcm93ID49IGFuY2hvclN0YXJ0Um93OyByb3ctLSkge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IGNvbHVtbkNvdW50IC0gMTsgY29sdW1uID49IDA7IGNvbHVtbi0tKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93OiBjZWxsU3RhcnRSb3csXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjZWxsU3RhcnRDb2x1bW5cbiAgICAgIH0gPSBncmlkTWFwW3Jvd11bY29sdW1uXTtcbiAgICAgIGlmIChjZWxsU3RhcnRDb2x1bW4gIT09IGNvbHVtbikge1xuICAgICAgICAvLyBEb24ndCByZXBlYXQgd29yayBmb3IgdGhlIHNhbWUgQ2VsbFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFJvd3Mgb3ZlcmZsb3dpbmcgdG9wIGhhdmUgdG8gYmUgdHJpbW1lZFxuICAgICAgaWYgKHJvdyA9PT0gYW5jaG9yU3RhcnRSb3cgJiYgY2VsbFN0YXJ0Um93IDwgYW5jaG9yU3RhcnRSb3cpIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuIC0gKGNlbGxTdGFydFJvdyAtIGFuY2hvclN0YXJ0Um93KSk7XG4gICAgICB9XG4gICAgICAvLyBSb3dzIG92ZXJmbG93aW5nIGJvdHRvbSBoYXZlIHRvIGJlIHRyaW1tZWQgYW5kIG1vdmVkIHRvIHRoZSBuZXh0IHJvd1xuICAgICAgaWYgKGNlbGxTdGFydFJvdyA+PSBhbmNob3JTdGFydFJvdyAmJiBjZWxsU3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPiBmb2N1c0VuZFJvdykge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gLSAoZm9jdXNFbmRSb3cgLSBjZWxsU3RhcnRSb3cgKyAxKSk7XG4gICAgICAgIGlmICghKG5leHRSb3dOb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBuZXh0Um93Tm9kZSBub3QgdG8gYmUgbnVsbGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAkaW5zZXJ0Rmlyc3QobmV4dFJvd05vZGUsIGNlbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNlbGw6IHByZXZpb3VzQ2VsbFxuICAgICAgICAgIH0gPSBuZXh0Um93W2NvbHVtbiAtIDFdO1xuICAgICAgICAgIHByZXZpb3VzQ2VsbC5pbnNlcnRBZnRlcihjZWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgocm93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWROb2RlIGNoaWxkQXRJbmRleCgke1N0cmluZyhyb3cpfSkgdG8gYmUgUm93Tm9kZWApO1xuICAgIH1cbiAgICByb3dOb2RlLnJlbW92ZSgpO1xuICB9XG4gIGlmIChuZXh0Um93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBncmlkTWFwW2FuY2hvclN0YXJ0Um93IC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1Jvd1swXTtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIEdyaWRTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBbYW5jaG9yQ2VsbCwsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGxdID0gJGdldE5vZGVUcmlwbGV0KGZvY3VzKTtcbiAgY29uc3QgW2dyaWRNYXAsIGFuY2hvckNlbGxNYXAsIGZvY3VzQ2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGFuY2hvckNlbGwsIGZvY3VzQ2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtbjogYW5jaG9yU3RhcnRDb2x1bW5cbiAgfSA9IGFuY2hvckNlbGxNYXA7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvdyxcbiAgICBzdGFydENvbHVtbjogZm9jdXNTdGFydENvbHVtblxuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBjb25zdCBzdGFydENvbHVtbiA9IE1hdGgubWluKGFuY2hvclN0YXJ0Q29sdW1uLCBmb2N1c1N0YXJ0Q29sdW1uKTtcbiAgY29uc3QgZW5kQ29sdW1uID0gTWF0aC5tYXgoYW5jaG9yU3RhcnRDb2x1bW4gKyBhbmNob3JDZWxsLl9fY29sU3BhbiAtIDEsIGZvY3VzU3RhcnRDb2x1bW4gKyBmb2N1c0NlbGwuX19jb2xTcGFuIC0gMSk7XG4gIGNvbnN0IHNlbGVjdGVkQ29sdW1uQ291bnQgPSBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDE7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gZ3JpZE1hcFswXS5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA9PT0gZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxKSB7XG4gICAgLy8gRW1wdHkgZ3JpZFxuICAgIGdyaWQuc2VsZWN0UHJldmlvdXMoKTtcbiAgICBncmlkLnJlbW92ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByb3dDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dDb3VudDsgcm93KyspIHtcbiAgICBmb3IgKGxldCBjb2x1bW4gPSBzdGFydENvbHVtbjsgY29sdW1uIDw9IGVuZENvbHVtbjsgY29sdW1uKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRDb2x1bW46IGNlbGxTdGFydENvbHVtblxuICAgICAgfSA9IGdyaWRNYXBbcm93XVtjb2x1bW5dO1xuICAgICAgaWYgKGNlbGxTdGFydENvbHVtbiA8IHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgY29uc3Qgb3ZlcmZsb3dMZWZ0ID0gc3RhcnRDb2x1bW4gLSBjZWxsU3RhcnRDb2x1bW47XG4gICAgICAgICAgLy8gT3ZlcmZsb3dpbmcgbGVmdFxuICAgICAgICAgIGNlbGwuc2V0Q29sU3BhbihjZWxsLl9fY29sU3BhbiAtXG4gICAgICAgICAgLy8gUG9zc2libGUgb3ZlcmZsb3cgcmlnaHQgdG9vXG4gICAgICAgICAgTWF0aC5taW4oc2VsZWN0ZWRDb2x1bW5Db3VudCwgY2VsbC5fX2NvbFNwYW4gLSBvdmVyZmxvd0xlZnQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjZWxsU3RhcnRDb2x1bW4gKyBjZWxsLl9fY29sU3BhbiAtIDEgPiBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gZW5kQ29sdW1uKSB7XG4gICAgICAgICAgLy8gT3ZlcmZsb3dpbmcgcmlnaHRcbiAgICAgICAgICBjb25zdCBpblNlbGVjdGVkQXJlYSA9IGVuZENvbHVtbiAtIGNlbGxTdGFydENvbHVtbiArIDE7XG4gICAgICAgICAgY2VsbC5zZXRDb2xTcGFuKGNlbGwuX19jb2xTcGFuIC0gaW5TZWxlY3RlZEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBmb2N1c1Jvd01hcCA9IGdyaWRNYXBbZm9jdXNTdGFydFJvd107XG4gIGNvbnN0IG5leHRDb2x1bW4gPSBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3Bhbl07XG4gIGlmIChuZXh0Q29sdW1uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRDb2x1bW47XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uIC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1JvdztcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCkge1xuICBjb25zdCBmaXJzdERlc2NlbmRhbnQgPSBjZWxsLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICBpZiAoZmlyc3REZXNjZW5kYW50ID09IG51bGwpIHtcbiAgICBjZWxsLnNlbGVjdFN0YXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgZmlyc3REZXNjZW5kYW50LmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3RTdGFydCgpO1xuICB9XG59XG5mdW5jdGlvbiAkaW5zZXJ0Rmlyc3QocGFyZW50LCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmQobm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICR1bm1lcmdlQ2VsbCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgR3JpZFNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBbY2VsbCwgcm93LCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBjb2xTcGFuID0gY2VsbC5fX2NvbFNwYW47XG4gIGNvbnN0IHJvd1NwYW4gPSBjZWxsLl9fcm93U3BhbjtcbiAgaWYgKGNvbFNwYW4gPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb2xTcGFuOyBpKyspIHtcbiAgICAgIGNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUykpO1xuICAgIH1cbiAgICBjZWxsLnNldENvbFNwYW4oMSk7XG4gIH1cbiAgaWYgKHJvd1NwYW4gPiAxKSB7XG4gICAgY29uc3QgW21hcCwgY2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGNlbGwsIGNlbGwpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0Q29sdW1uLFxuICAgICAgc3RhcnRSb3dcbiAgICB9ID0gY2VsbE1hcDtcbiAgICBsZXQgY3VycmVudFJvd05vZGU7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dTcGFuOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBzdGFydFJvdyArIGk7XG4gICAgICBjb25zdCBjdXJyZW50Um93TWFwID0gbWFwW2N1cnJlbnRSb3ddO1xuICAgICAgY3VycmVudFJvd05vZGUgPSAoY3VycmVudFJvd05vZGUgfHwgcm93KS5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvd05vZGUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCByb3cgbmV4dCBzaWJsaW5nIHRvIGJlIGEgcm93YCk7XG4gICAgICB9XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGNvbHVtbiA9IDA7IGNvbHVtbiA8IHN0YXJ0Q29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbE1hcCA9IGN1cnJlbnRSb3dNYXBbY29sdW1uXTtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBjdXJyZW50Q2VsbE1hcC5jZWxsO1xuICAgICAgICBpZiAoY3VycmVudENlbGxNYXAuc3RhcnRSb3cgPT09IGN1cnJlbnRSb3cpIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwgPSBjdXJyZW50Q2VsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENlbGwuX19jb2xTcGFuID4gMSkge1xuICAgICAgICAgIGNvbHVtbiArPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5zZXJ0QWZ0ZXJDZWxsID09PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG4gICAgICAgICAgJGluc2VydEZpcnN0KGN1cnJlbnRSb3dOb2RlLCAkY3JlYXRlVGFibGVDZWxsTm9kZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgY2VsbEEsIGNlbGxCKSB7XG4gIGNvbnN0IFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkLCBjZWxsQSwgY2VsbEIpO1xuICBpZiAoIShjZWxsQVZhbHVlICE9PSBudWxsKSkge1xuICAgIHRocm93IEVycm9yKGBBbmNob3Igbm90IGZvdW5kIGluIEdyaWRgKTtcbiAgfVxuICBpZiAoIShjZWxsQlZhbHVlICE9PSBudWxsKSkge1xuICAgIHRocm93IEVycm9yKGBGb2N1cyBub3QgZm91bmQgaW4gR3JpZGApO1xuICB9XG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2soZ3JpZCwgY2VsbEEsIGNlbGxCKSB7XG4gIGNvbnN0IHRhYmxlTWFwID0gW107XG4gIGxldCBjZWxsQVZhbHVlID0gbnVsbDtcbiAgbGV0IGNlbGxCVmFsdWUgPSBudWxsO1xuICBmdW5jdGlvbiB3cml0ZShzdGFydFJvdywgc3RhcnRDb2x1bW4sIGNlbGwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgIGNlbGwsXG4gICAgICBzdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93XG4gICAgfTtcbiAgICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW47XG4gICAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICBpZiAodGFibGVNYXBbc3RhcnRSb3cgKyBpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhYmxlTWFwW3N0YXJ0Um93ICsgaV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG4gICAgICAgIHRhYmxlTWFwW3N0YXJ0Um93ICsgaV1bc3RhcnRDb2x1bW4gKyBqXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2VsbEEgIT09IG51bGwgJiYgY2VsbEEuaXMoY2VsbCkpIHtcbiAgICAgIGNlbGxBVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNlbGxCICE9PSBudWxsICYmIGNlbGxCLmlzKGNlbGwpKSB7XG4gICAgICBjZWxsQlZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzRW1wdHkocm93LCBjb2x1bW4pIHtcbiAgICByZXR1cm4gdGFibGVNYXBbcm93XSA9PT0gdW5kZWZpbmVkIHx8IHRhYmxlTWFwW3Jvd11bY29sdW1uXSA9PT0gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGdyaWRDaGlsZHJlbiA9IGdyaWQuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBncmlkQ2hpbGRyZW5baV07XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93KSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWROb2RlIGNoaWxkcmVuIHRvIGJlIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCByb3dDaGlsZHJlbiA9IHJvdy5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBqID0gMDtcbiAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVSb3dOb2RlIGNoaWxkcmVuIHRvIGJlIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghaXNFbXB0eShpLCBqKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICB3cml0ZShpLCBqLCBjZWxsKTtcbiAgICAgIGogKz0gY2VsbC5fX2NvbFNwYW47XG4gICAgfVxuICB9XG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gJGdldE5vZGVUcmlwbGV0KHNvdXJjZSkge1xuICBsZXQgY2VsbDtcbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGUpIHtcbiAgICBjZWxsID0gc291cmNlO1xuICB9IGVsc2UgaWYgKCdfX3R5cGUnIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY2VsbCA9IGNlbGxfO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbF8pKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdG8gZmluZCBhIHBhcmVudCBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNlbGwgPSBjZWxsXztcbiAgfVxuICBjb25zdCByb3cgPSBjZWxsLmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3cpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlQ2VsbE5vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZVJvd05vZGVgKTtcbiAgfVxuICBjb25zdCBncmlkID0gcm93LmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlTm9kZShncmlkKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZVJvd05vZGUgdG8gaGF2ZSBhIHBhcmVudCBHcmlkTm9kZWApO1xuICB9XG4gIHJldHVybiBbY2VsbCwgcm93LCBncmlkXTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxOb2RlUmVjdCh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IFtjZWxsTm9kZSwsIGdyaWROb2RlXSA9ICRnZXROb2RlVHJpcGxldCh0YWJsZUNlbGxOb2RlKTtcbiAgY29uc3Qgcm93cyA9IGdyaWROb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IHJvd0NvdW50ID0gcm93cy5sZW5ndGg7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gcm93c1swXS5nZXRDaGlsZHJlbigpLmxlbmd0aDtcblxuICAvLyBDcmVhdGUgYSBtYXRyaXggb2YgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgdGFibGUgdG8gdHJhY2sgdGhlIHBvc2l0aW9uIG9mIGVhY2ggY2VsbFxuICBjb25zdCBjZWxsTWF0cml4ID0gbmV3IEFycmF5KHJvd0NvdW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgY2VsbE1hdHJpeFtpXSA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XG4gIH1cbiAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHJvd0NvdW50OyByb3dJbmRleCsrKSB7XG4gICAgY29uc3Qgcm93ID0gcm93c1tyb3dJbmRleF07XG4gICAgY29uc3QgY2VsbHMgPSByb3cuZ2V0Q2hpbGRyZW4oKTtcbiAgICBsZXQgY29sdW1uSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGNlbGxJbmRleCA9IDA7IGNlbGxJbmRleCA8IGNlbGxzLmxlbmd0aDsgY2VsbEluZGV4KyspIHtcbiAgICAgIC8vIEZpbmQgdGhlIG5leHQgYXZhaWxhYmxlIHBvc2l0aW9uIGluIHRoZSBtYXRyaXgsIHNraXAgdGhlIHBvc2l0aW9uIG9mIG1lcmdlZCBjZWxsc1xuICAgICAgd2hpbGUgKGNlbGxNYXRyaXhbcm93SW5kZXhdW2NvbHVtbkluZGV4XSkge1xuICAgICAgICBjb2x1bW5JbmRleCsrO1xuICAgICAgfVxuICAgICAgY29uc3QgY2VsbCA9IGNlbGxzW2NlbGxJbmRleF07XG4gICAgICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW4gfHwgMTtcbiAgICAgIGNvbnN0IGNvbFNwYW4gPSBjZWxsLl9fY29sU3BhbiB8fCAxO1xuXG4gICAgICAvLyBQdXQgdGhlIGNlbGwgaW50byB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbiBpbiB0aGUgbWF0cml4XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd1NwYW47IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbFNwYW47IGorKykge1xuICAgICAgICAgIGNlbGxNYXRyaXhbcm93SW5kZXggKyBpXVtjb2x1bW5JbmRleCArIGpdID0gY2VsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdG8gdGhlIG9yaWdpbmFsIGluZGV4LCByb3cgc3BhbiBhbmQgY29sdW1uIHNwYW4gb2YgdGhlIGNlbGwuXG4gICAgICBpZiAoY2VsbE5vZGUgPT09IGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xTcGFuLFxuICAgICAgICAgIGNvbHVtbkluZGV4LFxuICAgICAgICAgIHJvd0luZGV4LFxuICAgICAgICAgIHJvd1NwYW5cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbHVtbkluZGV4ICs9IGNvbFNwYW47XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNsYXNzIFRhYmxlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IodGFibGVLZXksIGFuY2hvciwgZm9jdXMpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gICAgYW5jaG9yLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIGZvY3VzLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy50YWJsZUtleSA9IHRhYmxlS2V5O1xuICB9XG4gIGdldFN0YXJ0RW5kUG9pbnRzKCkge1xuICAgIHJldHVybiBbdGhpcy5hbmNob3IsIHRoaXMuZm9jdXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgU2VsZWN0aW9uIGlzIFwiYmFja3dhcmRzXCIsIG1lYW5pbmcgdGhlIGZvY3VzXG4gICAqIGxvZ2ljYWxseSBwcmVjZWRlcyB0aGUgYW5jaG9yIGluIHRoZSBFZGl0b3JTdGF0ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgU2VsZWN0aW9uIGlzIGJhY2t3YXJkcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1cy5pc0JlZm9yZSh0aGlzLmFuY2hvcik7XG4gIH1cbiAgZ2V0Q2FjaGVkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE5vZGVzO1xuICB9XG4gIHNldENhY2hlZE5vZGVzKG5vZGVzKSB7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgfVxuICBpcyhzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFibGVLZXkgPT09IHNlbGVjdGlvbi50YWJsZUtleSAmJiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cyk7XG4gIH1cbiAgc2V0KHRhYmxlS2V5LCBhbmNob3JDZWxsS2V5LCBmb2N1c0NlbGxLZXkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnRhYmxlS2V5ID0gdGFibGVLZXk7XG4gICAgdGhpcy5hbmNob3Iua2V5ID0gYW5jaG9yQ2VsbEtleTtcbiAgICB0aGlzLmZvY3VzLmtleSA9IGZvY3VzQ2VsbEtleTtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbih0aGlzLnRhYmxlS2V5LCB0aGlzLmFuY2hvciwgdGhpcy5mb2N1cyk7XG4gIH1cbiAgaXNDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4dHJhY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXMoKTtcbiAgfVxuICBpbnNlcnRSYXdUZXh0KHRleHQpIHtcbiAgICAvLyBEbyBub3RoaW5nP1xuICB9XG4gIGluc2VydFRleHQoKSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuICBpbnNlcnROb2Rlcyhub2Rlcykge1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHRoaXMuZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlU2VsZWN0aW9uIGZvY3VzIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTChmb2N1c05vZGUuc2VsZWN0KDAsIGZvY3VzTm9kZS5nZXRDaGlsZHJlblNpemUoKSkpO1xuICAgIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICAvLyBUT0RPIERlcHJlY2F0ZSB0aGlzIG1ldGhvZC4gSXQncyBjb25mdXNpbmcgd2hlbiB1c2VkIHdpdGggY29sc3Bhbnxyb3dzcGFuXG4gIGdldFNoYXBlKCkge1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLmFuY2hvci5rZXkpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiBhbmNob3IgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGVSZWN0ID0gJGdldFRhYmxlQ2VsbE5vZGVSZWN0KGFuY2hvckNlbGxOb2RlKTtcbiAgICBpZiAoIShhbmNob3JDZWxsTm9kZVJlY3QgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgQW5jaG9yTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLmZvY3VzLmtleSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZVJlY3QgPSAkZ2V0VGFibGVDZWxsTm9kZVJlY3QoZm9jdXNDZWxsTm9kZSk7XG4gICAgaWYgKCEoZm9jdXNDZWxsTm9kZVJlY3QgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgZm9jdXNDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgsIGZvY3VzQ2VsbE5vZGVSZWN0LmNvbHVtbkluZGV4KTtcbiAgICBjb25zdCBzdG9wWCA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCwgZm9jdXNDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGgubWluKGFuY2hvckNlbGxOb2RlUmVjdC5yb3dJbmRleCwgZm9jdXNDZWxsTm9kZVJlY3Qucm93SW5kZXgpO1xuICAgIGNvbnN0IHN0b3BZID0gTWF0aC5tYXgoYW5jaG9yQ2VsbE5vZGVSZWN0LnJvd0luZGV4LCBmb2N1c0NlbGxOb2RlUmVjdC5yb3dJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21YOiBNYXRoLm1pbihzdGFydFgsIHN0b3BYKSxcbiAgICAgIGZyb21ZOiBNYXRoLm1pbihzdGFydFksIHN0b3BZKSxcbiAgICAgIHRvWDogTWF0aC5tYXgoc3RhcnRYLCBzdG9wWCksXG4gICAgICB0b1k6IE1hdGgubWF4KHN0YXJ0WSwgc3RvcFkpXG4gICAgfTtcbiAgfVxuICBnZXROb2RlcygpIHtcbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuICAgIGlmIChjYWNoZWROb2RlcyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZE5vZGVzO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gdGhpcy5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHRoaXMuZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGFuY2hvckNlbGwgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIC8vIHRvZG8gcmVwbGFjZSB3aXRoIHRyaXBsZXRcbiAgICBjb25zdCBmb2N1c0NlbGwgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gYW5jaG9yIHRvIGJlIChvciBhIGNoaWxkIG9mKSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yUm93ID0gYW5jaG9yQ2VsbC5nZXRQYXJlbnQoKTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShhbmNob3JSb3cpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYW5jaG9yQ2VsbCB0byBoYXZlIGEgcGFyZW50IFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZU5vZGUgPSBhbmNob3JSb3cuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRhYmxlTm9kZSB0byBoYXZlIGEgcGFyZW50IFRhYmxlTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c0NlbGxHcmlkID0gZm9jdXNDZWxsLmdldFBhcmVudHMoKVsxXTtcbiAgICBpZiAoZm9jdXNDZWxsR3JpZCAhPT0gdGFibGVOb2RlKSB7XG4gICAgICBpZiAoIXRhYmxlTm9kZS5pc1BhcmVudE9mKGZvY3VzQ2VsbCkpIHtcbiAgICAgICAgLy8gZm9jdXMgaXMgb24gaGlnaGVyIEdyaWQgbGV2ZWwgdGhhbiBhbmNob3JcbiAgICAgICAgY29uc3QgZ3JpZFBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEoZ3JpZFBhcmVudCAhPSBudWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBncmlkUGFyZW50IHRvIGhhdmUgYSBwYXJlbnRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCh0aGlzLnRhYmxlS2V5LCBncmlkUGFyZW50LmdldEtleSgpLCBmb2N1c0NlbGwuZ2V0S2V5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYW5jaG9yIGlzIG9uIGhpZ2hlciBHcmlkIGxldmVsIHRoYW4gZm9jdXNcbiAgICAgICAgY29uc3QgZm9jdXNDZWxsUGFyZW50ID0gZm9jdXNDZWxsR3JpZC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEoZm9jdXNDZWxsUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGZvY3VzQ2VsbFBhcmVudCB0byBoYXZlIGEgcGFyZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQodGhpcy50YWJsZUtleSwgZm9jdXNDZWxsLmdldEtleSgpLCBmb2N1c0NlbGxQYXJlbnQuZ2V0S2V5KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIE1hcHBpbmcgdGhlIHdob2xlIEdyaWQgZXZlcnkgdGltZSBub3QgZWZmaWNpZW50LiBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGVudGlyZSBzdGF0ZSBvbmx5XG4gICAgLy8gb25jZSAob24gbG9hZCkgYW5kIGl0ZXJhdGUgb24gaXQgYXMgdXBkYXRlcyBvY2N1ci4gSG93ZXZlciwgdG8gZG8gdGhpcyB3ZSBuZWVkIHRvIGhhdmUgdGhlXG4gICAgLy8gYWJpbGl0eSB0byBzdG9yZSBhIHN0YXRlLiBLaWxsaW5nIFRhYmxlU2VsZWN0aW9uIGFuZCBtb3ZpbmcgdGhlIGxvZ2ljIHRvIHRoZSBwbHVnaW4gd291bGQgbWFrZVxuICAgIC8vIHRoaXMgcG9zc2libGUuXG4gICAgY29uc3QgW21hcCwgY2VsbEFNYXAsIGNlbGxCTWFwXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICAgIGxldCBtaW5Db2x1bW4gPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydENvbHVtbiwgY2VsbEJNYXAuc3RhcnRDb2x1bW4pO1xuICAgIGxldCBtaW5Sb3cgPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydFJvdywgY2VsbEJNYXAuc3RhcnRSb3cpO1xuICAgIGxldCBtYXhDb2x1bW4gPSBNYXRoLm1heChjZWxsQU1hcC5zdGFydENvbHVtbiArIGNlbGxBTWFwLmNlbGwuX19jb2xTcGFuIC0gMSwgY2VsbEJNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQk1hcC5jZWxsLl9fY29sU3BhbiAtIDEpO1xuICAgIGxldCBtYXhSb3cgPSBNYXRoLm1heChjZWxsQU1hcC5zdGFydFJvdyArIGNlbGxBTWFwLmNlbGwuX19yb3dTcGFuIC0gMSwgY2VsbEJNYXAuc3RhcnRSb3cgKyBjZWxsQk1hcC5jZWxsLl9fcm93U3BhbiAtIDEpO1xuICAgIGxldCBleHBsb3JlZE1pbkNvbHVtbiA9IG1pbkNvbHVtbjtcbiAgICBsZXQgZXhwbG9yZWRNaW5Sb3cgPSBtaW5Sb3c7XG4gICAgbGV0IGV4cGxvcmVkTWF4Q29sdW1uID0gbWluQ29sdW1uO1xuICAgIGxldCBleHBsb3JlZE1heFJvdyA9IG1pblJvdztcbiAgICBmdW5jdGlvbiBleHBhbmRCb3VuZGFyeShtYXBWYWx1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uLFxuICAgICAgICBzdGFydFJvdzogY2VsbFN0YXJ0Um93XG4gICAgICB9ID0gbWFwVmFsdWU7XG4gICAgICBtaW5Db2x1bW4gPSBNYXRoLm1pbihtaW5Db2x1bW4sIGNlbGxTdGFydENvbHVtbik7XG4gICAgICBtaW5Sb3cgPSBNYXRoLm1pbihtaW5Sb3csIGNlbGxTdGFydFJvdyk7XG4gICAgICBtYXhDb2x1bW4gPSBNYXRoLm1heChtYXhDb2x1bW4sIGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSk7XG4gICAgICBtYXhSb3cgPSBNYXRoLm1heChtYXhSb3csIGNlbGxTdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSk7XG4gICAgfVxuICAgIHdoaWxlIChtaW5Db2x1bW4gPCBleHBsb3JlZE1pbkNvbHVtbiB8fCBtaW5Sb3cgPCBleHBsb3JlZE1pblJvdyB8fCBtYXhDb2x1bW4gPiBleHBsb3JlZE1heENvbHVtbiB8fCBtYXhSb3cgPiBleHBsb3JlZE1heFJvdykge1xuICAgICAgaWYgKG1pbkNvbHVtbiA8IGV4cGxvcmVkTWluQ29sdW1uKSB7XG4gICAgICAgIC8vIEV4cGFuZCBvbiB0aGUgbGVmdFxuICAgICAgICBjb25zdCByb3dEaWZmID0gZXhwbG9yZWRNYXhSb3cgLSBleHBsb3JlZE1pblJvdztcbiAgICAgICAgY29uc3QgcHJldmlvdXNDb2x1bW4gPSBleHBsb3JlZE1pbkNvbHVtbiAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvd0RpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtleHBsb3JlZE1pblJvdyArIGldW3ByZXZpb3VzQ29sdW1uXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwbG9yZWRNaW5Db2x1bW4gPSBwcmV2aW91c0NvbHVtbjtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5Sb3cgPCBleHBsb3JlZE1pblJvdykge1xuICAgICAgICAvLyBFeHBhbmQgb24gdG9wXG4gICAgICAgIGNvbnN0IGNvbHVtbkRpZmYgPSBleHBsb3JlZE1heENvbHVtbiAtIGV4cGxvcmVkTWluQ29sdW1uO1xuICAgICAgICBjb25zdCBwcmV2aW91c1JvdyA9IGV4cGxvcmVkTWluUm93IC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gY29sdW1uRGlmZjsgaSsrKSB7XG4gICAgICAgICAgZXhwYW5kQm91bmRhcnkobWFwW3ByZXZpb3VzUm93XVtleHBsb3JlZE1pbkNvbHVtbiArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBleHBsb3JlZE1pblJvdyA9IHByZXZpb3VzUm93O1xuICAgICAgfVxuICAgICAgaWYgKG1heENvbHVtbiA+IGV4cGxvcmVkTWF4Q29sdW1uKSB7XG4gICAgICAgIC8vIEV4cGFuZCBvbiB0aGUgcmlnaHRcbiAgICAgICAgY29uc3Qgcm93RGlmZiA9IGV4cGxvcmVkTWF4Um93IC0gZXhwbG9yZWRNaW5Sb3c7XG4gICAgICAgIGNvbnN0IG5leHRDb2x1bW4gPSBleHBsb3JlZE1heENvbHVtbiArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvd0RpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtleHBsb3JlZE1pblJvdyArIGldW25leHRDb2x1bW5dKTtcbiAgICAgICAgfVxuICAgICAgICBleHBsb3JlZE1heENvbHVtbiA9IG5leHRDb2x1bW47XG4gICAgICB9XG4gICAgICBpZiAobWF4Um93ID4gZXhwbG9yZWRNYXhSb3cpIHtcbiAgICAgICAgLy8gRXhwYW5kIG9uIHRoZSBib3R0b21cbiAgICAgICAgY29uc3QgY29sdW1uRGlmZiA9IGV4cGxvcmVkTWF4Q29sdW1uIC0gZXhwbG9yZWRNaW5Db2x1bW47XG4gICAgICAgIGNvbnN0IG5leHRSb3cgPSBleHBsb3JlZE1heFJvdyArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHVtbkRpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtuZXh0Um93XVtleHBsb3JlZE1pbkNvbHVtbiArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBleHBsb3JlZE1heFJvdyA9IG5leHRSb3c7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gW3RhYmxlTm9kZV07XG4gICAgbGV0IGxhc3RSb3cgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSBtaW5Sb3c7IGkgPD0gbWF4Um93OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBtaW5Db2x1bW47IGogPD0gbWF4Q29sdW1uOyBqKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNlbGxcbiAgICAgICAgfSA9IG1hcFtpXVtqXTtcbiAgICAgICAgY29uc3QgY3VycmVudFJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRSb3cpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlQ2VsbE5vZGUgcGFyZW50IHRvIGJlIGEgVGFibGVSb3dOb2RlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IGxhc3RSb3cpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGN1cnJlbnRSb3cpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVzLnB1c2goY2VsbCwgLi4uJGdldENoaWxkcmVuUmVjdXJzaXZlbHkoY2VsbCkpO1xuICAgICAgICBsYXN0Um93ID0gY3VycmVudFJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZXNbaV0uZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xuICB9XG59XG5mdW5jdGlvbiAkaXNUYWJsZVNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgVGFibGVTZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGFuY2hvciA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIGNvbnN0IGZvY3VzID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbigncm9vdCcsIGFuY2hvciwgZm9jdXMpO1xufVxuZnVuY3Rpb24gJGdldENoaWxkcmVuUmVjdXJzaXZlbHkobm9kZSkge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtub2RlXTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmICghKGN1cnJlbnROb2RlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgU3RhY2subGVuZ3RoID4gMDsgY2FuJ3QgYmUgdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHN0YWNrLnVuc2hpZnQoLi4uY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgbm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jbGFzcyBUYWJsZU9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoZWRpdG9yLCB0YWJsZU5vZGVLZXkpIHtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy5saXN0ZW5lcnNUb1JlbW92ZSA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnRhYmxlTm9kZUtleSA9IHRhYmxlTm9kZUtleTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLnRhYmxlID0ge1xuICAgICAgY29sdW1uczogMCxcbiAgICAgIGRvbVJvd3M6IFtdLFxuICAgICAgcm93czogMFxuICAgIH07XG4gICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsID0gbnVsbDtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gICAgdGhpcy50cmFja1RhYmxlKCk7XG4gICAgdGhpcy5pc1NlbGVjdGluZyA9IGZhbHNlO1xuICB9XG4gIGdldFRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzVG9SZW1vdmUpLmZvckVhY2gocmVtb3ZlTGlzdGVuZXIgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG4gIH1cbiAgdHJhY2tUYWJsZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlY29yZHMgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgbGV0IGdyaWROZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XG4gICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnVEFCTEUnIHx8IG5vZGVOYW1lID09PSAnVEJPRFknIHx8IG5vZGVOYW1lID09PSAnVEhFQUQnIHx8IG5vZGVOYW1lID09PSAnVFInKSB7XG4gICAgICAgICAgICBncmlkTmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JpZE5lZWRzUmVkcmF3KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhYmxlID0gZ2V0VGFibGUodGFibGVFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSB0aGlzLmVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFibGUgPSBnZXRUYWJsZSh0YWJsZUVsZW1lbnQpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YWJsZUVsZW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjbGVhckhpZ2hsaWdodCgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsID0gbnVsbDtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVGFibGVOb2RlLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JpZCA9IGdldFRhYmxlKHRhYmxlRWxlbWVudCk7XG4gICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgZ3JpZCwgbnVsbCk7XG4gICAgICAkc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH1cbiAgZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG4gICAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgICB0YWJsZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZS1zZWxlY3Rpb24nKTtcbiAgICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KHRhYmxlRWxlbWVudCwgZWRpdG9yLl9jb25maWcudGhlbWUudGFibGVTZWxlY3Rpb24pO1xuICAgICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGhpcy50YWJsZU5vZGVLZXkpIHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICB0aGlzLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWJsZU5vZGVLZXkgPSBzZWxlY3Rpb24udGFibGVLZXk7XG4gICAgICB0aGlzLnVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIGlnbm9yZVN0YXJ0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXROb2RlQnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFRhYmxlTm9kZS4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbGxYID0gY2VsbC54O1xuICAgICAgY29uc3QgY2VsbFkgPSBjZWxsLnk7XG4gICAgICB0aGlzLmZvY3VzQ2VsbCA9IGNlbGw7XG4gICAgICBpZiAodGhpcy5hbmNob3JDZWxsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgICAgIC8vIENvbGxhcHNlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbikge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KHRoaXMuYW5jaG9yQ2VsbC5lbGVtLCAwLCB0aGlzLmZvY3VzQ2VsbC5lbGVtLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgJiYgKHRoaXMuYW5jaG9yWCAhPT0gY2VsbFggfHwgdGhpcy5hbmNob3JZICE9PSBjZWxsWSB8fCBpZ25vcmVTdGFydCkpIHtcbiAgICAgICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2VsbFggPT09IHRoaXMuZm9jdXNYICYmIGNlbGxZID09PSB0aGlzLmZvY3VzWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZvY3VzWCA9IGNlbGxYO1xuICAgICAgdGhpcy5mb2N1c1kgPSBjZWxsWTtcbiAgICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpIHtcbiAgICAgICAgY29uc3QgZm9jdXNUYWJsZUNlbGxOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICAgICAgaWYgKHRoaXMudGFibGVTZWxlY3Rpb24gIT0gbnVsbCAmJiB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ICE9IG51bGwgJiYgJGlzVGFibGVDZWxsTm9kZShmb2N1c1RhYmxlQ2VsbE5vZGUpICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c1RhYmxlQ2VsbE5vZGUpKSkge1xuICAgICAgICAgIGNvbnN0IGZvY3VzTm9kZUtleSA9IGZvY3VzVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gdGhpcy50YWJsZVNlbGVjdGlvbi5jbG9uZSgpIHx8ICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpO1xuICAgICAgICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IGZvY3VzTm9kZUtleTtcbiAgICAgICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uLnNldCh0aGlzLnRhYmxlTm9kZUtleSwgdGhpcy5hbmNob3JDZWxsTm9kZUtleSwgdGhpcy5mb2N1c0NlbGxOb2RlS2V5KTtcbiAgICAgICAgICAkc2V0U2VsZWN0aW9uKHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLnRhYmxlLCB0aGlzLnRhYmxlU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IGNlbGw7XG4gICAgdGhpcy5hbmNob3JYID0gY2VsbC54O1xuICAgIHRoaXMuYW5jaG9yWSA9IGNlbGwueTtcbiAgICB0aGlzLmVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgYW5jaG9yVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShhbmNob3JUYWJsZUNlbGxOb2RlKSkge1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlS2V5ID0gYW5jaG9yVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IHRoaXMudGFibGVTZWxlY3Rpb24gIT0gbnVsbCA/IHRoaXMudGFibGVTZWxlY3Rpb24uY2xvbmUoKSA6ICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gYW5jaG9yTm9kZUtleTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmb3JtYXRDZWxscyh0eXBlKSB7XG4gICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdyaWQgc2VsZWN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1hdFNlbGVjdGlvbiA9ICRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICAgICAgY29uc3QgYW5jaG9yID0gZm9ybWF0U2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gZm9ybWF0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgc2VsZWN0aW9uLmdldE5vZGVzKCkuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSAmJiBjZWxsTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGFuY2hvci5zZXQoY2VsbE5vZGUuZ2V0S2V5KCksIDAsICdlbGVtZW50Jyk7XG4gICAgICAgICAgZm9jdXMuc2V0KGNlbGxOb2RlLmdldEtleSgpLCBjZWxsTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICBmb3JtYXRTZWxlY3Rpb24uZm9ybWF0VGV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICB0aGlzLmVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9XG4gIGNsZWFyVGV4dCgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXROb2RlQnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFRhYmxlTm9kZS4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdyaWQgc2VsZWN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5maWx0ZXIoJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPT09IHRoaXMudGFibGUuY29sdW1ucyAqIHRoaXMudGFibGUucm93cykge1xuICAgICAgICB0YWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgLy8gRGVsZXRlIGVudGlyZSB0YWJsZVxuICAgICAgICB0YWJsZU5vZGUucmVtb3ZlKCk7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gJGdldFJvb3QoKTtcbiAgICAgICAgcm9vdE5vZGUuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGNlbGxOb2RlID0+IHtcbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNlbGxOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKCk7XG4gICAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQodGV4dE5vZGUpO1xuICAgICAgICAgIGNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgICAgICBjZWxsTm9kZS5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBwYXJhZ3JhcGhOb2RlKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLnRhYmxlLCBudWxsKTtcbiAgICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IExFWElDQUxfRUxFTUVOVF9LRVkgPSAnX19sZXhpY2FsVGFibGVTZWxlY3Rpb24nO1xuY29uc3QgZ2V0RE9NU2VsZWN0aW9uID0gdGFyZ2V0V2luZG93ID0+IENBTl9VU0VfRE9NID8gKHRhcmdldFdpbmRvdyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpIDogbnVsbDtcbmNvbnN0IGlzTW91c2VEb3duT25FdmVudCA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIChldmVudC5idXR0b25zICYgMSkgPT09IDE7XG59O1xuZnVuY3Rpb24gYXBwbHlUYWJsZUhhbmRsZXJzKHRhYmxlTm9kZSwgdGFibGVFbGVtZW50LCBlZGl0b3IsIGhhc1RhYkhhbmRsZXIpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyByb290IGVsZW1lbnQuJyk7XG4gIH1cbiAgY29uc3QgdGFibGVPYnNlcnZlciA9IG5ldyBUYWJsZU9ic2VydmVyKGVkaXRvciwgdGFibGVOb2RlLmdldEtleSgpKTtcbiAgY29uc3QgZWRpdG9yV2luZG93ID0gZWRpdG9yLl93aW5kb3cgfHwgd2luZG93O1xuICBhdHRhY2hUYWJsZU9ic2VydmVyVG9UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCB0YWJsZU9ic2VydmVyKTtcbiAgY29uc3QgY3JlYXRlTW91c2VIYW5kbGVycyA9ICgpID0+IHtcbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb3VzZU1vdmUgPSBtb3ZlRXZlbnQgPT4ge1xuICAgICAgLy8gZGVsYXlpbmcgbW91c2Vtb3ZlIGhhbmRsZXIgdG8gYWxsb3cgc2VsZWN0aW9uY2hhbmdlIGhhbmRsZXIgZnJvbSBMZXhpY2FsRXZlbnRzLnRzIHRvIGJlIGV4ZWN1dGVkIGZpcnN0XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc01vdXNlRG93bk9uRXZlbnQobW92ZUV2ZW50KSAmJiB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nKSB7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgICAgICBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb2N1c0NlbGwgPSBnZXRET01DZWxsRnJvbVRhcmdldChtb3ZlRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKGZvY3VzQ2VsbCAhPT0gbnVsbCAmJiAodGFibGVPYnNlcnZlci5hbmNob3JYICE9PSBmb2N1c0NlbGwueCB8fCB0YWJsZU9ic2VydmVyLmFuY2hvclkgIT09IGZvY3VzQ2VsbC55KSkge1xuICAgICAgICAgIG1vdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGZvY3VzQ2VsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZSxcbiAgICAgIG9uTW91c2VVcDogb25Nb3VzZVVwXG4gICAgfTtcbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGV2ZW50ID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3JXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5jaG9yQ2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICBpZiAoYW5jaG9yQ2VsbCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yQ2VsbCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uTW91c2VVcCxcbiAgICAgICAgb25Nb3VzZU1vdmVcbiAgICAgIH0gPSBjcmVhdGVNb3VzZUhhbmRsZXJzKCk7XG4gICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfSwgMCk7XG4gIH0pO1xuXG4gIC8vIENsZWFyIHNlbGVjdGlvbiB3aGVuIGNsaWNraW5nIG91dHNpZGUgb2YgZG9tLlxuICBjb25zdCBtb3VzZURvd25DYWxsYmFjayA9IGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSAmJiByb290RWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkNhbGxiYWNrKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4gZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkNhbGxiYWNrKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsICdkb3duJywgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCAndXAnLCB0YWJsZU5vZGUsIHRhYmxlT2JzZXJ2ZXIpLCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgJ2JhY2t3YXJkJywgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCAnZm9yd2FyZCcsIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlciksIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FU0NBUEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBmb2N1c0NlbGxOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgY29uc3QgZGVsZXRlVGV4dEhhbmRsZXIgPSBjb21tYW5kID0+ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVPYnNlcnZlci5jbGVhclRleHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2YoYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbnRhaW5zUGFydGlhbFRhYmxlID0gaXNBbmNob3JJbnNpZGUgJiYgIWlzRm9jdXNJbnNpZGUgfHwgaXNGb2N1c0luc2lkZSAmJiAhaXNBbmNob3JJbnNpZGU7XG4gICAgICBpZiAoc2VsZWN0aW9uQ29udGFpbnNQYXJ0aWFsVGFibGUpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5jbGVhclRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWFyZXN0RWxlbWVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pKTtcbiAgICAgIGNvbnN0IHRvcExldmVsQ2VsbEVsZW1lbnROb2RlID0gbmVhcmVzdEVsZW1lbnROb2RlICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQobmVhcmVzdEVsZW1lbnROb2RlLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pICYmICRpc1RhYmxlQ2VsbE5vZGUobi5nZXRQYXJlbnQoKSkpO1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZSh0b3BMZXZlbENlbGxFbGVtZW50Tm9kZSkgfHwgISRpc0VsZW1lbnROb2RlKG5lYXJlc3RFbGVtZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1hbmQgPT09IERFTEVURV9MSU5FX0NPTU1BTkQgJiYgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogRml4IERlbGV0ZSBMaW5lIGluIFRhYmxlIENlbGxzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBbREVMRVRFX1dPUkRfQ09NTUFORCwgREVMRVRFX0xJTkVfQ09NTUFORCwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EXS5mb3JFYWNoKGNvbW1hbmQgPT4ge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgZGVsZXRlVGV4dEhhbmRsZXIoY29tbWFuZCksIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfSk7XG4gIGNvbnN0ICRkZWxldGVDZWxsSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGFibGVPYnNlcnZlci5jbGVhclRleHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCAkZGVsZXRlQ2VsbEhhbmRsZXIsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfREVMRVRFX0NPTU1BTkQsICRkZWxldGVDZWxsSGFuZGxlciwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLmZvcm1hdENlbGxzKHBheWxvYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIGZvcm1hdFR5cGUgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c05vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZU1hcCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JOb2RlLCBmb2N1c05vZGUpO1xuICAgIGNvbnN0IG1heFJvdyA9IE1hdGgubWF4KGFuY2hvckNlbGwuc3RhcnRSb3csIGZvY3VzQ2VsbC5zdGFydFJvdyk7XG4gICAgY29uc3QgbWF4Q29sdW1uID0gTWF0aC5tYXgoYW5jaG9yQ2VsbC5zdGFydENvbHVtbiwgZm9jdXNDZWxsLnN0YXJ0Q29sdW1uKTtcbiAgICBjb25zdCBtaW5Sb3cgPSBNYXRoLm1pbihhbmNob3JDZWxsLnN0YXJ0Um93LCBmb2N1c0NlbGwuc3RhcnRSb3cpO1xuICAgIGNvbnN0IG1pbkNvbHVtbiA9IE1hdGgubWluKGFuY2hvckNlbGwuc3RhcnRDb2x1bW4sIGZvY3VzQ2VsbC5zdGFydENvbHVtbik7XG4gICAgZm9yIChsZXQgaSA9IG1pblJvdzsgaSA8PSBtYXhSb3c7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IG1pbkNvbHVtbjsgaiA8PSBtYXhDb2x1bW47IGorKykge1xuICAgICAgICBjb25zdCBjZWxsID0gdGFibGVNYXBbaV1bal0uY2VsbDtcbiAgICAgICAgY2VsbC5zZXRGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICAgIGNvbnN0IGNlbGxDaGlsZHJlbiA9IGNlbGwuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjZWxsQ2hpbGRyZW4ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNlbGxDaGlsZHJlbltrXTtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpICYmICFjaGlsZC5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVPYnNlcnZlci5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSk7XG4gICAgICAgIGlmIChlZGdlUG9zaXRpb24pIHtcbiAgICAgICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIFskY3JlYXRlVGV4dE5vZGUocGF5bG9hZCldKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgaWYgKGhhc1RhYkhhbmRsZXIpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9UQUJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgIHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCAhZXZlbnQuc2hpZnRLZXkgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPQ1VTX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIHJldHVybiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJDZWxsRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgICBjb25zdCBjdXJyZW50Q29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgcmV0dXJuIHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICB9XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgc2VsZWN0aW9uUGF5bG9hZCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZXMsXG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gc2VsZWN0aW9uUGF5bG9hZDtcbiAgICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICAgIGNvbnN0IGlzVGFibGVTZWxlY3Rpb24gPSAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IGlzUmFuZ2VTZWxlY3Rpb24gPSAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IGlzU2VsZWN0aW9uSW5zaWRlT2ZHcmlkID0gaXNSYW5nZVNlbGVjdGlvbiAmJiAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpICE9PSBudWxsICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKSAhPT0gbnVsbCB8fCBpc1RhYmxlU2VsZWN0aW9uO1xuICAgIGlmIChub2Rlcy5sZW5ndGggIT09IDEgfHwgISRpc1RhYmxlTm9kZShub2Rlc1swXSkgfHwgIWlzU2VsZWN0aW9uSW5zaWRlT2ZHcmlkIHx8IGFuY2hvckFuZEZvY3VzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IFthbmNob3JdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgY29uc3QgbmV3R3JpZCA9IG5vZGVzWzBdO1xuICAgIGNvbnN0IG5ld0dyaWRSb3dzID0gbmV3R3JpZC5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IG5ld0NvbHVtbkNvdW50ID0gbmV3R3JpZC5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IG5ld1Jvd0NvdW50ID0gbmV3R3JpZC5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCBncmlkQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgY29uc3QgZ3JpZFJvd05vZGUgPSBncmlkQ2VsbE5vZGUgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChncmlkQ2VsbE5vZGUsIG4gPT4gJGlzVGFibGVSb3dOb2RlKG4pKTtcbiAgICBjb25zdCBncmlkTm9kZSA9IGdyaWRSb3dOb2RlICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoZ3JpZFJvd05vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoZ3JpZENlbGxOb2RlKSB8fCAhJGlzVGFibGVSb3dOb2RlKGdyaWRSb3dOb2RlKSB8fCAhJGlzVGFibGVOb2RlKGdyaWROb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFkgPSBncmlkUm93Tm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGNvbnN0IHN0b3BZID0gTWF0aC5taW4oZ3JpZE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgLSAxLCBzdGFydFkgKyBuZXdSb3dDb3VudCAtIDEpO1xuICAgIGNvbnN0IHN0YXJ0WCA9IGdyaWRDZWxsTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGNvbnN0IHN0b3BYID0gTWF0aC5taW4oZ3JpZFJvd05vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgLSAxLCBzdGFydFggKyBuZXdDb2x1bW5Db3VudCAtIDEpO1xuICAgIGNvbnN0IGZyb21YID0gTWF0aC5taW4oc3RhcnRYLCBzdG9wWCk7XG4gICAgY29uc3QgZnJvbVkgPSBNYXRoLm1pbihzdGFydFksIHN0b3BZKTtcbiAgICBjb25zdCB0b1ggPSBNYXRoLm1heChzdGFydFgsIHN0b3BYKTtcbiAgICBjb25zdCB0b1kgPSBNYXRoLm1heChzdGFydFksIHN0b3BZKTtcbiAgICBjb25zdCBncmlkUm93Tm9kZXMgPSBncmlkTm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBuZXdSb3dJZHggPSAwO1xuICAgIGxldCBuZXdBbmNob3JDZWxsS2V5O1xuICAgIGxldCBuZXdGb2N1c0NlbGxLZXk7XG4gICAgZm9yIChsZXQgciA9IGZyb21ZOyByIDw9IHRvWTsgcisrKSB7XG4gICAgICBjb25zdCBjdXJyZW50R3JpZFJvd05vZGUgPSBncmlkUm93Tm9kZXNbcl07XG4gICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50R3JpZFJvd05vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0dyaWRSb3dOb2RlID0gbmV3R3JpZFJvd3NbbmV3Um93SWR4XTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKG5ld0dyaWRSb3dOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBncmlkQ2VsbE5vZGVzID0gY3VycmVudEdyaWRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCBuZXdHcmlkQ2VsbE5vZGVzID0gbmV3R3JpZFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGxldCBuZXdDb2x1bW5JZHggPSAwO1xuICAgICAgZm9yIChsZXQgYyA9IGZyb21YOyBjIDw9IHRvWDsgYysrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRHcmlkQ2VsbE5vZGUgPSBncmlkQ2VsbE5vZGVzW2NdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY3VycmVudEdyaWRDZWxsTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3R3JpZENlbGxOb2RlID0gbmV3R3JpZENlbGxOb2Rlc1tuZXdDb2x1bW5JZHhdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobmV3R3JpZENlbGxOb2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PT0gZnJvbVkgJiYgYyA9PT0gZnJvbVgpIHtcbiAgICAgICAgICBuZXdBbmNob3JDZWxsS2V5ID0gY3VycmVudEdyaWRDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyID09PSB0b1kgJiYgYyA9PT0gdG9YKSB7XG4gICAgICAgICAgbmV3Rm9jdXNDZWxsS2V5ID0gY3VycmVudEdyaWRDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbENoaWxkcmVuID0gY3VycmVudEdyaWRDZWxsTm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBuZXdHcmlkQ2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICAgIGN1cnJlbnRHcmlkQ2VsbE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEdyaWRDZWxsTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsQ2hpbGRyZW4uZm9yRWFjaChuID0+IG4ucmVtb3ZlKCkpO1xuICAgICAgICBuZXdDb2x1bW5JZHgrKztcbiAgICAgIH1cbiAgICAgIG5ld1Jvd0lkeCsrO1xuICAgIH1cbiAgICBpZiAobmV3QW5jaG9yQ2VsbEtleSAmJiBuZXdGb2N1c0NlbGxLZXkpIHtcbiAgICAgIGNvbnN0IG5ld1RhYmxlU2VsZWN0aW9uID0gJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCk7XG4gICAgICBuZXdUYWJsZVNlbGVjdGlvbi5zZXQobm9kZXNbMF0uZ2V0S2V5KCksIG5ld0FuY2hvckNlbGxLZXksIG5ld0ZvY3VzQ2VsbEtleSk7XG4gICAgICAkc2V0U2VsZWN0aW9uKG5ld1RhYmxlU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgIC8vIFVzaW5nIGV4cGxpY2l0IGNvbXBhcmlzb24gd2l0aCB0YWJsZSBub2RlIHRvIGVuc3VyZSBpdCdzIG5vdCBhIG5lc3RlZCB0YWJsZVxuICAgICAgLy8gYXMgaW4gdGhhdCBjYXNlIHdlJ2xsIGxlYXZlIHNlbGVjdGlvbiByZXNvbHZpbmcgdG8gdGhhdCB0YWJsZVxuICAgICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gISEoYW5jaG9yQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGxOb2RlKSkpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9ICEhKGZvY3VzQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGZvY3VzQ2VsbE5vZGUpKSk7XG4gICAgICBjb25zdCBpc1BhcnRpYWx5V2l0aGluVGFibGUgPSBpc0FuY2hvckluc2lkZSAhPT0gaXNGb2N1c0luc2lkZTtcbiAgICAgIGNvbnN0IGlzV2l0aGluVGFibGUgPSBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgICBpZiAoaXNQYXJ0aWFseVdpdGhpblRhYmxlKSB7XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICBpZiAoaXNGb2N1c0luc2lkZSkge1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQodGFibGVOb2RlLmdldFBhcmVudE9yVGhyb3coKS5nZXRLZXkoKSwgdGFibGVOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCksICdlbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQodGFibGVOb2RlLmdldFBhcmVudE9yVGhyb3coKS5nZXRLZXkoKSwgaXNCYWNrd2FyZCA/IHRhYmxlTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMSA6IHRhYmxlTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpLCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc1dpdGhpblRhYmxlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gc2VsZWN0aW9uIHNwYW5zIGFjcm9zcyBtdWx0aXBsZSBjZWxscyBidXQgc3RpbGxcbiAgICAgICAgLy8gaGFzIHJhbmdlIHNlbGVjdGlvbiwgdGhlbiB3ZSBjb252ZXJ0IGl0IGludG8gZ3JpZCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKCFhbmNob3JDZWxsTm9kZS5pcyhmb2N1c0NlbGxOb2RlKSkge1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUpKTtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSksIHRydWUpO1xuICAgICAgICAgIGlmICghdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmVcbiAgICAgICAgICAgICAgfSA9IGNyZWF0ZU1vdXNlSGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgICAgICAgICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uICYmICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVOb2RlLmdldEtleSgpKSB7XG4gICAgICAvLyBpZiBzZWxlY3Rpb24gZ29lcyBvdXRzaWRlIG9mIHRoZSB0YWJsZSB3ZSBuZWVkIHRvIGNoYW5nZSBpdCB0byBSYW5nZSBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlICYmIGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpIHtcbiAgICAgICAgY29uc3QgZm9jdXNOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tU2VsZWN0aW9uLmZvY3VzTm9kZSk7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNPdXRzaWRlID0gZm9jdXNOb2RlICYmICF0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoZm9jdXNOb2RlKSk7XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gYW5jaG9yTm9kZSAmJiB0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoYW5jaG9yTm9kZSkpO1xuICAgICAgICBpZiAoaXNGb2N1c091dHNpZGUgJiYgaXNBbmNob3JJbnNpZGUgJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbShkb21TZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQodGFibGVOb2RlLmdldEtleSgpLCBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gdGFibGVOb2RlLmdldENoaWxkcmVuU2l6ZSgpIDogMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSAmJiB0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uICYmICF0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIudXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24obnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YWJsZU9ic2VydmVyLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzICYmICF0YWJsZU5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAkcmVtb3ZlSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcik7XG4gICAgfSBlbHNlIGlmICghdGFibGVPYnNlcnZlci5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyAmJiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlZGdlUG9zaXRpb24gPSAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSk7XG4gICAgaWYgKGVkZ2VQb3NpdGlvbikge1xuICAgICAgJGluc2VydFBhcmFncmFwaEF0VGFibGVFZGdlKGVkZ2VQb3NpdGlvbiwgdGFibGVOb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgcmV0dXJuIHRhYmxlT2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBhdHRhY2hUYWJsZU9ic2VydmVyVG9UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCB0YWJsZU9ic2VydmVyKSB7XG4gIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXSA9IHRhYmxlT2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpIHtcbiAgcmV0dXJuIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXTtcbn1cbmZ1bmN0aW9uIGdldERPTUNlbGxGcm9tVGFyZ2V0KG5vZGUpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IGNlbGwgPSBjdXJyZW50Tm9kZS5fY2VsbDtcbiAgICAgIGlmIChjZWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFibGUodGFibGVFbGVtZW50KSB7XG4gIGNvbnN0IGRvbVJvd3MgPSBbXTtcbiAgY29uc3QgZ3JpZCA9IHtcbiAgICBjb2x1bW5zOiAwLFxuICAgIGRvbVJvd3MsXG4gICAgcm93czogMFxuICB9O1xuICBsZXQgY3VycmVudE5vZGUgPSB0YWJsZUVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGRvbVJvd3MubGVuZ3RoID0gMDtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTWFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTWFtZSA9PT0gJ1REJyB8fCBub2RlTWFtZSA9PT0gJ1RIJykge1xuICAgICAgY29uc3QgZWxlbSA9IGN1cnJlbnROb2RlO1xuICAgICAgY29uc3QgY2VsbCA9IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgaGFzQmFja2dyb3VuZENvbG9yOiBlbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciAhPT0gJycsXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGN1cnJlbnROb2RlLl9jZWxsID0gY2VsbDtcbiAgICAgIGxldCByb3cgPSBkb21Sb3dzW3ldO1xuICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdyA9IGRvbVJvd3NbeV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvd1t4XSA9IGNlbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKHNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgeCsrO1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHkrKztcbiAgICAgIHggPSAwO1xuICAgICAgY3VycmVudE5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICBncmlkLmNvbHVtbnMgPSB4ICsgMTtcbiAgZ3JpZC5yb3dzID0geSArIDE7XG4gIHJldHVybiBncmlkO1xufVxuZnVuY3Rpb24gJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRhYmxlLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsTm9kZXMgPSBuZXcgU2V0KHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXROb2RlcygpIDogW10pO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZSwgKGNlbGwsIGxleGljYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBpZiAoc2VsZWN0ZWRDZWxsTm9kZXMuaGFzKGxleGljYWxOb2RlKSkge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoVGFibGVDZWxsKGdyaWQsIGNiKSB7XG4gIGNvbnN0IHtcbiAgICBkb21Sb3dzXG4gIH0gPSBncmlkO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGRvbVJvd3MubGVuZ3RoOyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmICghcm93KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3cubGVuZ3RoOyB4KyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dbeF07XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY2IoY2VsbCwgbGV4aWNhbE5vZGUsIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVTZWxlY3Rpb24uZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoVGFibGVDZWxsKHRhYmxlU2VsZWN0aW9uLnRhYmxlLCBjZWxsID0+IHtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcikge1xuICB0YWJsZU9ic2VydmVyLmVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoVGFibGVDZWxsKHRhYmxlT2JzZXJ2ZXIudGFibGUsIGNlbGwgPT4ge1xuICAgIGNvbnN0IGVsZW0gPSBjZWxsLmVsZW07XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICRyZW1vdmVIaWdobGlnaHRGcm9tRE9NKGVkaXRvciwgY2VsbCk7XG4gICAgaWYgKCFlbGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgeCwgeSwgZGlyZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVPYnNlcnZlci50YWJsZS5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4ICsgKGlzRm9yd2FyZCA/IDEgOiAtMSksIHksIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCBpc0ZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLnJvd3MgLSAxIDogMCkpIHtcbiAgICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coaXNGb3J3YXJkID8gMCA6IHRhYmxlT2JzZXJ2ZXIudGFibGUuY29sdW1ucyAtIDEsIHkgKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgdGFibGVPYnNlcnZlci50YWJsZSksIGlzRm9yd2FyZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRm9yd2FyZCkge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3VwJzpcbiAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVPYnNlcnZlci50YWJsZSksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnZG93bic6XG4gICAgICBpZiAoeSAhPT0gdGFibGVPYnNlcnZlci50YWJsZS5yb3dzIC0gMSkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSArIDEsIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuY29uc3QgYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24gPSAodGFibGVPYnNlcnZlciwgdGFibGVOb2RlLCB4LCB5LCBkaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgaXNGb3J3YXJkID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCc7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAnYmFja3dhcmQnOlxuICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgaWYgKHggIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLmNvbHVtbnMgLSAxIDogMCkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHggKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgeSwgdGFibGVPYnNlcnZlci50YWJsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAndXAnOlxuICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHgsIHkgLSAxLCB0YWJsZU9ic2VydmVyLnRhYmxlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgaWYgKHkgIT09IHRhYmxlT2JzZXJ2ZXIudGFibGUucm93cyAtIDEpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHgsIHkgKyAxLCB0YWJsZU9ic2VydmVyLnRhYmxlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcbiAgICBjb25zdCBpc0ZvY3VzSW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSk7XG4gICAgcmV0dXJuIGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZUNlbGwsIGZyb21TdGFydCkge1xuICBpZiAoZnJvbVN0YXJ0KSB7XG4gICAgdGFibGVDZWxsLnNlbGVjdFN0YXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGFibGVDZWxsLnNlbGVjdEVuZCgpO1xuICB9XG59XG5jb25zdCBCUk9XU0VSX0JMVUVfUkdCID0gJzE3MiwyMDYsMjQ3JztcbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW1lbnQpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdG8gZmluZCBMZXhpY2FsTm9kZSBmcm9tIFRhYmxlIENlbGwgRE9NTm9kZWApO1xuICB9XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IG5vZGUuZ2V0QmFja2dyb3VuZENvbG9yKCk7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgYHJnYigke0JST1dTRVJfQkxVRV9SR0J9KWApO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtaW1hZ2UnLCBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKCR7QlJPV1NFUl9CTFVFX1JHQn0sMC44NSksIHJnYmEoJHtCUk9XU0VSX0JMVUVfUkdCfSwwLjg1KSlgKTtcbiAgfVxuICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdjYXJldC1jb2xvcicsICd0cmFuc3BhcmVudCcpO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBjZWxsLmVsZW07XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRvIGZpbmQgTGV4aWNhbE5vZGUgZnJvbSBUYWJsZSBDZWxsIERPTU5vZGVgKTtcbiAgfVxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBub2RlLmdldEJhY2tncm91bmRDb2xvcigpO1xuICBpZiAoYmFja2dyb3VuZENvbG9yID09PSBudWxsKSB7XG4gICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICB9XG4gIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2JhY2tncm91bmQtaW1hZ2UnKTtcbiAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY2FyZXQtY29sb3InKTtcbn1cbmZ1bmN0aW9uICRmaW5kQ2VsbE5vZGUobm9kZSkge1xuICBjb25zdCBjZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSA/IGNlbGxOb2RlIDogbnVsbDtcbn1cbmZ1bmN0aW9uICRmaW5kVGFibGVOb2RlKG5vZGUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZU5vZGUpO1xuICByZXR1cm4gJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkgPyB0YWJsZU5vZGUgOiBudWxsO1xufVxuZnVuY3Rpb24gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsIGRpcmVjdGlvbiwgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSB7XG4gIGlmICgoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSAmJiBpc1R5cGVhaGVhZE1lbnVJblZpZXcoZWRpdG9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnYmFja3dhcmQnICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvclR5cGUgPSBzZWxlY3Rpb24uYW5jaG9yLnR5cGU7XG4gICAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgIGlmIChhbmNob3JUeXBlICE9PSAnZWxlbWVudCcgJiYgIShhbmNob3JUeXBlID09PSAndGV4dCcgJiYgYW5jaG9yT2Zmc2V0ID09PSAwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoIWFuY2hvck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSAmJiAhbi5pc0lubGluZSgpKTtcbiAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWJsaW5nTm9kZSA9IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoIXNpYmxpbmdOb2RlIHx8ICEkaXNUYWJsZU5vZGUoc2libGluZ05vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICBzaWJsaW5nTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhYW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yQ2VsbFRhYmxlID0gJGZpbmRUYWJsZU5vZGUoYW5jaG9yQ2VsbE5vZGUpO1xuICAgIGlmIChhbmNob3JDZWxsVGFibGUgIT09IHRhYmxlTm9kZSAmJiBhbmNob3JDZWxsVGFibGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbFRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbFRhYmxlLmdldEtleSgpKTtcbiAgICAgIGlmIChhbmNob3JDZWxsVGFibGVFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci50YWJsZSA9IGdldFRhYmxlKGFuY2hvckNlbGxUYWJsZUVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsIGRpcmVjdGlvbiwgYW5jaG9yQ2VsbFRhYmxlLCB0YWJsZU9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyB8fCBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgY29uc3QgYW5jaG9yVHlwZSA9IGFuY2hvci50eXBlO1xuICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKCFhbmNob3JOb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiAkaXNEZWNvcmF0b3JOb2RlKHNlbGVjdGVkTm9kZXNbMF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0V4aXRpbmdUYWJsZUFuY2hvcihhbmNob3JUeXBlLCBhbmNob3JPZmZzZXQsIGFuY2hvck5vZGUsIGRpcmVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuICRoYW5kbGVUYWJsZUV4aXQoZXZlbnQsIGFuY2hvck5vZGUsIHRhYmxlTm9kZSwgZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yQ2VsbERvbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbE5vZGUuX19rZXkpO1xuICAgIGNvbnN0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yLmtleSk7XG4gICAgaWYgKGFuY2hvckRPTSA9PSBudWxsIHx8IGFuY2hvckNlbGxEb20gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgZWRnZVNlbGVjdGlvblJlY3Q7XG4gICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGVkZ2VTZWxlY3Rpb25SZWN0ID0gYW5jaG9yRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBjb25zdCBlZGdlQ2hpbGQgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBhbmNob3JDZWxsTm9kZS5nZXRGaXJzdENoaWxkKCkgOiBhbmNob3JDZWxsTm9kZS5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAoZWRnZUNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWRnZUNoaWxkRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShlZGdlQ2hpbGQuX19rZXkpO1xuICAgIGlmIChlZGdlQ2hpbGRET00gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlZGdlUmVjdCA9IGVkZ2VDaGlsZERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc0V4aXRpbmcgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBlZGdlUmVjdC50b3AgPiBlZGdlU2VsZWN0aW9uUmVjdC50b3AgLSBlZGdlU2VsZWN0aW9uUmVjdC5oZWlnaHQgOiBlZGdlU2VsZWN0aW9uUmVjdC5ib3R0b20gKyBlZGdlU2VsZWN0aW9uUmVjdC5oZWlnaHQgPiBlZGdlUmVjdC5ib3R0b207XG4gICAgaWYgKGlzRXhpdGluZykge1xuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGNvbnN0IGNvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICBjb25zdCBjZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzLngsIGNvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCk7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgY29yZHMueCwgY29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3IuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1cy5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IFt0YWJsZU5vZGVGcm9tU2VsZWN0aW9uXSA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlRnJvbVNlbGVjdGlvbi5nZXRLZXkoKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVOb2RlKHRhYmxlTm9kZUZyb21TZWxlY3Rpb24pIHx8IHRhYmxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhYmxlT2JzZXJ2ZXIudXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IGdyaWQgPSBnZXRUYWJsZSh0YWJsZUVsZW1lbnQpO1xuICAgIGNvbnN0IGNvcmRzQW5jaG9yID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlLCBncmlkKTtcbiAgICBjb25zdCBhbmNob3JDZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzQW5jaG9yLngsIGNvcmRzQW5jaG9yLnksIGdyaWQpO1xuICAgIHRhYmxlT2JzZXJ2ZXIuc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihhbmNob3JDZWxsKTtcbiAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgY29uc3QgY29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSwgZ3JpZCk7XG4gICAgICByZXR1cm4gYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24odGFibGVPYnNlcnZlciwgdGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgY29yZHMueCwgY29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9jdXNDZWxsTm9kZS5zZWxlY3RFbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZWFoZWFkTWVudUluVmlldyhlZGl0b3IpIHtcbiAgLy8gVGhlcmUgaXMgbm8gaW5idWlsdCB3YXkgdG8gY2hlY2sgaWYgdGhlIGNvbXBvbmVudCBwaWNrZXIgaXMgaW4gdmlld1xuICAvLyBidXQgd2UgY2FuIGNoZWNrIGlmIHRoZSByb290IERPTSBlbGVtZW50IGhhcyB0aGUgYXJpYS1jb250cm9scyBhdHRyaWJ1dGUgXCJ0eXBlYWhlYWQtbWVudVwiLlxuICBjb25zdCByb290ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGlmICghcm9vdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcm9vdC5oYXNBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSAmJiByb290LmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpID09PSAndHlwZWFoZWFkLW1lbnUnO1xufVxuZnVuY3Rpb24gaXNFeGl0aW5nVGFibGVBbmNob3IodHlwZSwgb2Zmc2V0LCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIGlzRXhpdGluZ1RhYmxlRWxlbWVudEFuY2hvcih0eXBlLCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pIHx8ICRpc0V4aXRpbmdUYWJsZVRleHRBbmNob3IodHlwZSwgb2Zmc2V0LCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNFeGl0aW5nVGFibGVFbGVtZW50QW5jaG9yKHR5cGUsIGFuY2hvck5vZGUsIGRpcmVjdGlvbikge1xuICByZXR1cm4gdHlwZSA9PT0gJ2VsZW1lbnQnICYmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBhbmNob3JOb2RlLmdldFByZXZpb3VzU2libGluZygpID09PSBudWxsIDogYW5jaG9yTm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKTtcbn1cbmZ1bmN0aW9uICRpc0V4aXRpbmdUYWJsZVRleHRBbmNob3IodHlwZSwgb2Zmc2V0LCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSAmJiAhbi5pc0lubGluZSgpKTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc1ZhbGlkT2Zmc2V0ID0gZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gb2Zmc2V0ID09PSAwIDogb2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHQnICYmIGhhc1ZhbGlkT2Zmc2V0ICYmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBwYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpID09PSBudWxsIDogcGFyZW50Tm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKTtcbn1cbmZ1bmN0aW9uICRoYW5kbGVUYWJsZUV4aXQoZXZlbnQsIGFuY2hvck5vZGUsIHRhYmxlTm9kZSwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbdGFibGVNYXAsIGNlbGxWYWx1ZV0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbE5vZGUsIGFuY2hvckNlbGxOb2RlKTtcbiAgaWYgKCFpc0V4aXRpbmdDZWxsKHRhYmxlTWFwLCBjZWxsVmFsdWUsIGRpcmVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9Ob2RlID0gJGdldEV4aXRpbmdUb05vZGUoYW5jaG9yTm9kZSwgZGlyZWN0aW9uLCB0YWJsZU5vZGUpO1xuICBpZiAoIXRvTm9kZSB8fCAkaXNUYWJsZU5vZGUodG9Ob2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpO1xuICBpZiAoZGlyZWN0aW9uID09PSAnYmFja3dhcmQnKSB7XG4gICAgdG9Ob2RlLnNlbGVjdEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIHRvTm9kZS5zZWxlY3RTdGFydCgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNFeGl0aW5nQ2VsbCh0YWJsZU1hcCwgY2VsbFZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF07XG4gIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV1bdGFibGVNYXBbMF0ubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtbixcbiAgICBzdGFydFJvd1xuICB9ID0gY2VsbFZhbHVlO1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gc3RhcnRDb2x1bW4gPT09IGZpcnN0Q2VsbC5zdGFydENvbHVtbiAmJiBzdGFydFJvdyA9PT0gZmlyc3RDZWxsLnN0YXJ0Um93IDogc3RhcnRDb2x1bW4gPT09IGxhc3RDZWxsLnN0YXJ0Q29sdW1uICYmIHN0YXJ0Um93ID09PSBsYXN0Q2VsbC5zdGFydFJvdztcbn1cbmZ1bmN0aW9uICRnZXRFeGl0aW5nVG9Ob2RlKGFuY2hvck5vZGUsIGRpcmVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgIW4uaXNJbmxpbmUoKSk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgYW5jaG9yU2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyA/IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBwYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIHJldHVybiBhbmNob3JTaWJsaW5nICYmICRpc1RhYmxlTm9kZShhbmNob3JTaWJsaW5nKSA/IGFuY2hvclNpYmxpbmcgOiBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyB0YWJsZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiB0YWJsZU5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbn1cbmZ1bmN0aW9uICRpbnNlcnRQYXJhZ3JhcGhBdFRhYmxlRWRnZShlZGdlUG9zaXRpb24sIHRhYmxlTm9kZSwgY2hpbGRyZW4pIHtcbiAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIGlmIChlZGdlUG9zaXRpb24gPT09ICdmaXJzdCcpIHtcbiAgICB0YWJsZU5vZGUuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlTm9kZS5pbnNlcnRBZnRlcihwYXJhZ3JhcGhOb2RlKTtcbiAgfVxuICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCguLi4oY2hpbGRyZW4gfHwgW10pKTtcbiAgcGFyYWdyYXBoTm9kZS5zZWxlY3RFbmQoKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKCF0YWJsZU5vZGVQYXJlbnQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlUGFyZW50LmdldEtleSgpKTtcbiAgaWYgKCF0YWJsZU5vZGVQYXJlbnRET00pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIG5lc3RlZCB0YWJsZXNcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBpZiAoIWRvbVNlbGVjdGlvbiB8fCBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSAhPT0gdGFibGVOb2RlUGFyZW50RE9NKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gIGlmICghYW5jaG9yQ2VsbE5vZGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHBhcmVudFRhYmxlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JDZWxsTm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuICBpZiAoISRpc1RhYmxlTm9kZShwYXJlbnRUYWJsZSkgfHwgIXBhcmVudFRhYmxlLmlzKHRhYmxlTm9kZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IFt0YWJsZU1hcCwgY2VsbFZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsTm9kZSwgYW5jaG9yQ2VsbE5vZGUpO1xuICBjb25zdCBmaXJzdENlbGwgPSB0YWJsZU1hcFswXVswXTtcbiAgY29uc3QgbGFzdENlbGwgPSB0YWJsZU1hcFt0YWJsZU1hcC5sZW5ndGggLSAxXVt0YWJsZU1hcFswXS5sZW5ndGggLSAxXTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93LFxuICAgIHN0YXJ0Q29sdW1uXG4gIH0gPSBjZWxsVmFsdWU7XG4gIGNvbnN0IGlzQXRGaXJzdENlbGwgPSBzdGFydFJvdyA9PT0gZmlyc3RDZWxsLnN0YXJ0Um93ICYmIHN0YXJ0Q29sdW1uID09PSBmaXJzdENlbGwuc3RhcnRDb2x1bW47XG4gIGNvbnN0IGlzQXRMYXN0Q2VsbCA9IHN0YXJ0Um93ID09PSBsYXN0Q2VsbC5zdGFydFJvdyAmJiBzdGFydENvbHVtbiA9PT0gbGFzdENlbGwuc3RhcnRDb2x1bW47XG4gIGlmIChpc0F0Rmlyc3RDZWxsKSB7XG4gICAgcmV0dXJuICdmaXJzdCc7XG4gIH0gZWxzZSBpZiAoaXNBdExhc3RDZWxsKSB7XG4gICAgcmV0dXJuICdsYXN0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZSc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZTogX25vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRUYWJsZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oX3NlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnLCBlZGl0b3IpIHtcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCBjb25maWcudGhlbWUudGFibGUpO1xuICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydERPTShlZGl0b3IpLFxuICAgICAgYWZ0ZXI6IHRhYmxlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmICh0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gdGFibGVFbGVtZW50LmNsb25lTm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGNvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnKTtcbiAgICAgICAgICBjb25zdCB0Qm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG4gICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQodGFibGVFbGVtZW50KSkge1xuICAgICAgICAgICAgdEJvZHkuYXBwZW5kKC4uLnRhYmxlRWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGhpcy5nZXRGaXJzdENoaWxkT3JUaHJvdygpO1xuICAgICAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGZpcnN0Um93KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvdyBub2RlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb2xDb3VudCA9IGZpcnN0Um93LmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sJyk7XG4gICAgICAgICAgICBjb2xHcm91cC5hcHBlbmQoY29sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3RWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4oY29sR3JvdXAsIHRCb2R5KTtcbiAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm93cyxcbiAgICAgIGRvbVJvd3NcbiAgICB9ID0gdGFibGU7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzOyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgICBpZiAocm93ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gcm93LmZpbmRJbmRleChjZWxsID0+IHtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlbGVtXG4gICAgICAgIH0gPSBjZWxsO1xuICAgICAgICBjb25zdCBjZWxsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW0pO1xuICAgICAgICByZXR1cm4gY2VsbE5vZGUgPT09IHRhYmxlQ2VsbE5vZGU7XG4gICAgICB9KTtcbiAgICAgIGlmICh4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGluIHRhYmxlLicpO1xuICB9XG4gIGdldERPTUNlbGxGcm9tQ29yZHMoeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkb21Sb3dzXG4gICAgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgaWYgKHJvdyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY2VsbCA9IHJvd1t4XTtcbiAgICBpZiAoY2VsbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRET01DZWxsRnJvbUNvcmRzKHgsIHksIHRhYmxlKTtcbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2VsbCBub3QgZm91bmQgYXQgY29yZHMuJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0RE9NQ2VsbEZyb21Db3Jkcyh4LCB5LCB0YWJsZSk7XG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSwgdGFibGUpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGF0IGNvcmRzIG5vdCBUYWJsZUNlbGxOb2RlLicpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjYW5TZWxlY3RCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gJGdldEVsZW1lbnRGb3JUYWJsZU5vZGUoZWRpdG9yLCB0YWJsZU5vZGUpIHtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBpZiAodGFibGVFbGVtZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIEVsZW1lbnQgTm90IEZvdW5kJyk7XG4gIH1cbiAgcmV0dXJuIGdldFRhYmxlKHRhYmxlRWxlbWVudCk7XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlRWxlbWVudChfZG9tTm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVUYWJsZU5vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZSgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzVGFibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZU5vZGU7XG59XG5cbmV4cG9ydCB7ICRjb21wdXRlVGFibGVNYXAsICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrLCAkY3JlYXRlVGFibGVDZWxsTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zLCAkY3JlYXRlVGFibGVSb3dOb2RlLCAkY3JlYXRlVGFibGVTZWxlY3Rpb24sICRkZWxldGVUYWJsZUNvbHVtbiwgJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwsICRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMLCAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZSwgJGdldE5vZGVUcmlwbGV0LCAkZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZSwgJGdldFRhYmxlQ2VsbE5vZGVSZWN0LCAkZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlLCAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdywgJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSwgJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdywgJGluc2VydFRhYmxlQ29sdW1uLCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCwgJGluc2VydFRhYmxlUm93LCAkaW5zZXJ0VGFibGVSb3dfX0VYUEVSSU1FTlRBTCwgJGlzVGFibGVDZWxsTm9kZSwgJGlzVGFibGVOb2RlLCAkaXNUYWJsZVJvd05vZGUsICRpc1RhYmxlU2VsZWN0aW9uLCAkcmVtb3ZlVGFibGVSb3dBdEluZGV4LCAkdW5tZXJnZUNlbGwsIElOU0VSVF9UQUJMRV9DT01NQU5ELCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMsIFRhYmxlQ2VsbE5vZGUsIFRhYmxlTm9kZSwgVGFibGVPYnNlcnZlciwgVGFibGVSb3dOb2RlLCBhcHBseVRhYmxlSGFuZGxlcnMsIGdldERPTUNlbGxGcm9tVGFyZ2V0LCBnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/table/LexicalTable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $canShowPlaceholder: () => (/* binding */ $canShowPlaceholder),\n/* harmony export */   $canShowPlaceholderCurry: () => (/* binding */ $canShowPlaceholderCurry),\n/* harmony export */   $findTextIntersectionFromCharacters: () => (/* binding */ $findTextIntersectionFromCharacters),\n/* harmony export */   $isRootTextContentEmpty: () => (/* binding */ $isRootTextContentEmpty),\n/* harmony export */   $isRootTextContentEmptyCurry: () => (/* binding */ $isRootTextContentEmptyCurry),\n/* harmony export */   $rootTextContent: () => (/* binding */ $rootTextContent),\n/* harmony export */   registerLexicalTextEntity: () => (/* binding */ registerLexicalTextEntity)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(topBlock)) {\n      return false;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topBlock)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStIOztBQUUvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLFFBQVEseURBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCLFdBQVcseURBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBLGFBQWEsb0RBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9EQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2Q0FBUTtBQUN4RTtBQUNBO0FBQ0E7O0FBRWtNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90ZXh0L0xleGljYWxUZXh0LmRldi5tanM/MDY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRnZXRSb290LCAkaXNEZWNvcmF0b3JOb2RlLCAkaXNFbGVtZW50Tm9kZSwgJGlzUGFyYWdyYXBoTm9kZSwgJGlzVGV4dE5vZGUsIFRleHROb2RlLCAkY3JlYXRlVGV4dE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3QncyB0ZXh0IGNvbnRlbnQuXG4gKiBAcmV0dXJucyBUaGUgcm9vdCdzIHRleHQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gJHJvb3RUZXh0Q29udGVudCgpIHtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIHJldHVybiByb290LmdldFRleHRDb250ZW50KCk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSByb290IGhhcyBhbnkgdGV4dCBjb250ZW50IGFuZCBjYW4gdHJpbSBhbnkgd2hpdGVzcGFjZSBpZiBpdCBkb2VzLlxuICogQHBhcmFtIGlzRWRpdG9yQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEBwYXJhbSB0cmltIC0gU2hvdWxkIHRoZSByb290IHRleHQgaGF2ZSBpdHMgd2hpdGVzcGFjZWQgdHJpbW1lZD8gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGV4dCBjb250ZW50IGlzIGVtcHR5LCBmYWxzZSBpZiB0aGVyZSBpcyB0ZXh0IG9yIGlzRWRpdG9yQ29tcG9zaW5nIGlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltID0gdHJ1ZSkge1xuICBpZiAoaXNFZGl0b3JDb21wb3NpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHRleHQgPSAkcm9vdFRleHRDb250ZW50KCk7XG4gIGlmICh0cmltKSB7XG4gICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICB9XG4gIHJldHVybiB0ZXh0ID09PSAnJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB7QGxpbmsgJGlzUm9vdFRleHRDb250ZW50RW1wdHl9XG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHBhcmFtIHRyaW0gLSBTaG91bGQgdGhlIHJvb3QgdGV4dCBoYXZlIGl0cyB3aGl0ZXNwYWNlZCB0cmltbWVkPyBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5IGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gJGlzUm9vdFRleHRDb250ZW50RW1wdHlDdXJyeShpc0VkaXRvckNvbXBvc2luZywgdHJpbSkge1xuICByZXR1cm4gKCkgPT4gJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgc2hvdWxkIHNob3cgdGhlIHBsYWNlaG9sZGVyLiBJZiBhbnl0aGluZyBpcyBpblxuICogaW4gdGhlIHJvb3QgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBub3QgYmUgc2hvd24uXG4gKiBAcGFyYW0gaXNDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgc2hvdWxkIHNob3cgdGhlIHBsYWNlaG9sZGVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRjYW5TaG93UGxhY2Vob2xkZXIoaXNDb21wb3NpbmcpIHtcbiAgaWYgKCEkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0NvbXBvc2luZywgZmFsc2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wQmxvY2sgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZSh0b3BCbG9jaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKHRvcEJsb2NrKSkge1xuICAgICAgaWYgKCEkaXNQYXJhZ3JhcGhOb2RlKHRvcEJsb2NrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodG9wQmxvY2suX19pbmRlbnQgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wQmxvY2tDaGlsZHJlbiA9IHRvcEJsb2NrLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCB0b3BCbG9ja0NoaWxkcmVuTGVuZ3RoID0gdG9wQmxvY2tDaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRvcEJsb2NrQ2hpbGRyZW5MZW5ndGg7IHMrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRvcEJsb2NrQ2hpbGRyZW5baV07XG4gICAgICAgIGlmICghJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHtAbGluayAkY2FuU2hvd1BsYWNlaG9sZGVyfVxuICogQHBhcmFtIGlzRWRpdG9yQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyAkY2FuU2hvd1BsYWNlaG9sZGVyIHdpdGggYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkoaXNFZGl0b3JDb21wb3NpbmcpIHtcbiAgcmV0dXJuICgpID0+ICRjYW5TaG93UGxhY2Vob2xkZXIoaXNFZGl0b3JDb21wb3NpbmcpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogRmluZHMgYSBUZXh0Tm9kZSB3aXRoIGEgc2l6ZSBsYXJnZXIgdGhhbiB0YXJnZXRDaGFyYWN0ZXJzIGFuZCByZXR1cm5zXG4gKiB0aGUgbm9kZSBhbG9uZyB3aXRoIHRoZSByZW1haW5pbmcgbGVuZ3RoIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHJvb3QgLSBUaGUgUm9vdE5vZGUuXG4gKiBAcGFyYW0gdGFyZ2V0Q2hhcmFjdGVycyAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB3aG9zZSBUZXh0Tm9kZSBtdXN0IGJlIGxhcmdlciB0aGFuLlxuICogQHJldHVybnMgVGhlIFRleHROb2RlIGFuZCB0aGUgaW50ZXJzZWN0aW9ucyBvZmZzZXQsIG9yIG51bGwgaWYgbm8gVGV4dE5vZGUgaXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uICRmaW5kVGV4dEludGVyc2VjdGlvbkZyb21DaGFyYWN0ZXJzKHJvb3QsIHRhcmdldENoYXJhY3RlcnMpIHtcbiAgbGV0IG5vZGUgPSByb290LmdldEZpcnN0Q2hpbGQoKTtcbiAgbGV0IGN1cnJlbnRDaGFyYWN0ZXJzID0gMDtcbiAgbWFpbkxvb3A6IHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hhcmFjdGVycyA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICBpZiAoY3VycmVudENoYXJhY3RlcnMgKyBjaGFyYWN0ZXJzID4gdGFyZ2V0Q2hhcmFjdGVycykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiB0YXJnZXRDaGFyYWN0ZXJzIC0gY3VycmVudENoYXJhY3RlcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDaGFyYWN0ZXJzICs9IGNoYXJhY3RlcnM7XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmIChwYXJlbnRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgdHVwbGUgdGhhdCBjYW4gYmUgcmVzdGVkICguLi4pIGludG8gbWVyZ2VSZWdpc3RlciB0byBjbGVhbiB1cFxuICogbm9kZSB0cmFuc2Zvcm1zIGxpc3RlbmVycyB0aGF0IHRyYW5zZm9ybXMgdGV4dCBpbnRvIGFub3RoZXIgbm9kZSwgZWcuIGEgSGFzaHRhZ05vZGUuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihcbiAgICAgIC4uLnJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkoZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZSwgY3JlYXRlTm9kZSksXG4gICAgKTtcbiAgfSwgW2NyZWF0ZU5vZGUsIGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGVdKTtcbiAqIGBgYFxuICogV2hlcmUgdGFyZ2V0Tm9kZSBpcyB0aGUgdHlwZSBvZiBub2RlIGNvbnRhaW5pbmcgdGhlIHRleHQgeW91IHdhbnQgdG8gdHJhbnNmb3JtIChsaWtlIGEgdGV4dCBpbnB1dCksXG4gKiB0aGVuIGdldE1hdGNoIHVzZXMgYSByZWdleCB0byBmaW5kIGEgbWF0Y2hpbmcgdGV4dCBhbmQgY3JlYXRlcyB0aGUgcHJvcGVyIG5vZGUgdG8gaW5jbHVkZSB0aGUgbWF0Y2hpbmcgdGV4dC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gZ2V0TWF0Y2ggLSBGaW5kcyBhIG1hdGNoaW5nIHN0cmluZyB0aGF0IHNhdGlzZmllcyBhIHJlZ2V4IGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIFRoZSBub2RlIHR5cGUgdGhhdCBjb250YWlucyB0ZXh0IHRvIG1hdGNoIHdpdGguIGVnLiBIYXNodGFnTm9kZVxuICogQHBhcmFtIGNyZWF0ZU5vZGUgLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBub2RlIHRvIGNvbnRhaW4gdGhlIG1hdGNoZWQgdGV4dC4gZWcgY3JlYXRlSGFzaHRhZ05vZGVcbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBsYWluIHRleHQgYW5kIHJldmVyc2Ugbm9kZSB0cmFuc2Zvcm0gbGlzdGVuZXJzLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckxleGljYWxUZXh0RW50aXR5KGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGUsIGNyZWF0ZU5vZGUpIHtcbiAgY29uc3QgaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuICBjb25zdCAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0ID0gbm9kZSA9PiB7XG4gICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUobm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXQoKSk7XG4gICAgbm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgfTtcbiAgY29uc3QgZ2V0TW9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlLmdldExhdGVzdCgpLl9fbW9kZTtcbiAgfTtcbiAgY29uc3QgJHRleHROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgaWYgKCFub2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcmV2U2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgbGV0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNUZXh0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkVGV4dCA9IHByZXZpb3VzVGV4dCArIHRleHQ7XG4gICAgICBjb25zdCBwcmV2TWF0Y2ggPSBnZXRNYXRjaChjb21iaW5lZFRleHQpO1xuICAgICAgaWYgKGlzVGFyZ2V0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgICAgaWYgKHByZXZNYXRjaCA9PT0gbnVsbCB8fCBnZXRNb2RlKHByZXZTaWJsaW5nKSAhPT0gMCkge1xuICAgICAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQocHJldlNpYmxpbmcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gcHJldk1hdGNoLmVuZCAtIHByZXZpb3VzVGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb25jYXRUZXh0ID0gdGV4dC5zbGljZSgwLCBkaWZmKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RleHRDb250ZW50ID0gcHJldmlvdXNUZXh0ICsgY29uY2F0VGV4dDtcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgICAgICAgcHJldlNpYmxpbmcuc2V0VGV4dENvbnRlbnQobmV3VGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdUZXh0ID0gdGV4dC5zbGljZShkaWZmKTtcbiAgICAgICAgICAgICAgbm9kZS5zZXRUZXh0Q29udGVudChyZW1haW5pbmdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldk1hdGNoID09PSBudWxsIHx8IHByZXZNYXRjaC5zdGFydCA8IHByZXZpb3VzVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIG1hdGNoID0gZ2V0TWF0Y2godGV4dCk7XG4gICAgICBsZXQgbmV4dFRleHQgPSBtYXRjaCA9PT0gbnVsbCA/ICcnIDogdGV4dC5zbGljZShtYXRjaC5lbmQpO1xuICAgICAgdGV4dCA9IG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRUZXh0ID09PSAnJykge1xuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IGN1cnJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgICBuZXh0VGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCkgKyBuZXh0U2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGNvbnN0IG5leHRNYXRjaCA9IGdldE1hdGNoKG5leHRUZXh0KTtcbiAgICAgICAgICBpZiAobmV4dE1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNUYXJnZXROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5leHRTaWJsaW5nLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dE1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwICYmICRpc1RleHROb2RlKHByZXZTaWJsaW5nKSAmJiBwcmV2U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgICBwcmV2TWF0Y2hMZW5ndGhUb1NraXAgKz0gbWF0Y2guZW5kO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBub2RlVG9SZXBsYWNlO1xuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIFtub2RlVG9SZXBsYWNlLCBjdXJyZW50Tm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQobWF0Y2guZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFssIG5vZGVUb1JlcGxhY2UsIGN1cnJlbnROb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChtYXRjaC5zdGFydCArIHByZXZNYXRjaExlbmd0aFRvU2tpcCwgbWF0Y2guZW5kICsgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwKTtcbiAgICAgIH1cbiAgICAgIGlmICghKG5vZGVUb1JlcGxhY2UgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7J25vZGVUb1JlcGxhY2UnfSBzaG91bGQgbm90IGJlIHVuZGVmaW5lZC4gWW91IG1heSB3YW50IHRvIGNoZWNrIHNwbGl0T2Zmc2V0cyBwYXNzZWQgdG8gdGhlIHNwbGl0VGV4dC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZVRvUmVwbGFjZSk7XG4gICAgICByZXBsYWNlbWVudE5vZGUuc2V0Rm9ybWF0KG5vZGVUb1JlcGxhY2UuZ2V0Rm9ybWF0KCkpO1xuICAgICAgbm9kZVRvUmVwbGFjZS5yZXBsYWNlKHJlcGxhY2VtZW50Tm9kZSk7XG4gICAgICBpZiAoY3VycmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2TWF0Y2hMZW5ndGhUb1NraXAgPSAwO1xuICAgICAgcHJldlNpYmxpbmcgPSByZXBsYWNlbWVudE5vZGU7XG4gICAgfVxuICB9O1xuICBjb25zdCAkcmV2ZXJzZU5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IG1hdGNoID0gZ2V0TWF0Y2godGV4dCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPiBtYXRjaC5lbmQpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBzcGxpdCBvdXQgdGhlIHJlc3Qgb2YgdGhlIHRleHQgYXMgc2ltcGxlIHRleHRcbiAgICAgIG5vZGUuc3BsaXRUZXh0KG1hdGNoLmVuZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobmV4dFNpYmxpbmcpO1xuXG4gICAgICAvLyBUaGlzIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgaW4gdGhlIHByZXZpb3VzIGJsb2NrXG4gICAgICBpZiAoaXNUYXJnZXROb2RlKG5vZGUpKSB7XG4gICAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVQbGFpblRleHRUcmFuc2Zvcm0gPSBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRleHROb2RlLCAkdGV4dE5vZGVUcmFuc2Zvcm0pO1xuICBjb25zdCByZW1vdmVSZXZlcnNlTm9kZVRyYW5zZm9ybSA9IGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0odGFyZ2V0Tm9kZSwgJHJldmVyc2VOb2RlVHJhbnNmb3JtKTtcbiAgcmV0dXJuIFtyZW1vdmVQbGFpblRleHRUcmFuc2Zvcm0sIHJlbW92ZVJldmVyc2VOb2RlVHJhbnNmb3JtXTtcbn1cblxuZXhwb3J0IHsgJGNhblNob3dQbGFjZWhvbGRlciwgJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5LCAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycywgJGlzUm9vdFRleHRDb250ZW50RW1wdHksICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnksICRyb290VGV4dENvbnRlbnQsIHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/text/LexicalText.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ positionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getLatest();\n  const end = endingNode || ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(start) ? start.getLastDescendant() || start : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$cloneWithProperties)(node);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode)(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n      root.append(node);\n    }\n    const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRjtBQUNzSDtBQUMvRjs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLDJFQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWE7QUFDckMsV0FBVywwREFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzUkFBc1IsNkNBQVE7QUFDOVIsNFFBQTRRLDZDQUFRO0FBQ3BSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBUTtBQUN6Qyw2QkFBNkIsdURBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJpQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanM/NmI4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlLCAkY2xvbmVXaXRoUHJvcGVydGllcyB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgVGV4dE5vZGUsICRnZXRSb290LCAkaXNFbGVtZW50Tm9kZSwgJGlzVGV4dE5vZGUsICRzZXRTZWxlY3Rpb24sICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJHNwbGl0Tm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmV4cG9ydCB7ICRzcGxpdE5vZGUsIGlzQmxvY2tEb21Ob2RlLCBpc0hUTUxBbmNob3JFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0lubGluZURvbU5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSQxICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyQxID0gQ0FOX1VTRV9ET00kMSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FORFJPSURfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIElTX0FORFJPSUQkMSAmJiBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUUkMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBwYXNzZWQgd2hlbiBjYWxsZWQuIEl0IGlzIGdlbmVyYWxseSB1c2VkXG4gKiB0byByZWdpc3RlciBtdWx0aXBsZSBsZXhpY2FsIGxpc3RlbmVycyBhbmQgdGhlbiB0ZWFyIHRoZW0gZG93biB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwsIHN1Y2hcbiAqIGFzIFJlYWN0J3MgdXNlRWZmZWN0IGhvb2suXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMSBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQyIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDMgbG9naWMpXG4gKiAgIClcbiAqIH0sIFtlZGl0b3JdKVxuICogYGBgXG4gKiBJbiB0aGlzIGNhc2UsIHVzZUVmZmVjdCBpcyByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IG1lcmdlUmVnaXN0ZXIgYXMgYSBjbGVhbnVwXG4gKiBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBlaXRoZXIgdGhlIHVzZUVmZmVjdCBydW5zIGFnYWluIChkdWUgdG8gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXNcbiAqIHVwZGF0aW5nKSBvciB0aGUgY29tcG9uZW50IGl0IHJlc2lkZXMgaW4gdW5tb3VudHMuXG4gKiBOb3RlIHRoZSBmdW5jdGlvbnMgZG9uJ3QgbmVjY2VzYXJpbHkgbmVlZCB0byBiZSBpbiBhbiBhcnJheSBhcyBhbGwgYXJndWVtZW50c1xuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIGZ1bmMgYXJndW1lbnQgYW5kIHNwcmVhZCBmcm9tIHRoZXJlLlxuICogQHBhcmFtIGZ1bmMgLSBBbiBhcnJheSBvZiBmdW5jdGlvbnMgbWVhbnQgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMgdGhlIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGFsbCB0aGUgcGFzc2VkIHJlZ2lzdGVyIGNvbW1hbmQgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlZ2lzdGVyKC4uLmZ1bmMpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmdW5jLmZvckVhY2goZiA9PiBmKCkpO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHB4KHZhbHVlKSB7XG4gIHJldHVybiBgJHt2YWx1ZX1weGA7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgbXV0YXRpb25PYnNlcnZlckNvbmZpZyA9IHtcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xuZnVuY3Rpb24gcG9zaXRpb25Ob2RlT25SYW5nZShlZGl0b3IsIHJhbmdlLCBvblJlcG9zaXRpb24pIHtcbiAgbGV0IHJvb3RET01Ob2RlID0gbnVsbDtcbiAgbGV0IHBhcmVudERPTU5vZGUgPSBudWxsO1xuICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuICBsZXQgbGFzdE5vZGVzID0gW107XG4gIGNvbnN0IHdyYXBwZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIGlmICghKHJvb3RET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbnVsbCByb290RE9NTm9kZWApO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnRET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbnVsbCBwYXJlbnRET01Ob2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IHJvb3RMZWZ0LFxuICAgICAgdG9wOiByb290VG9wXG4gICAgfSA9IHJvb3RET01Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBhcmVudERPTU5vZGVfID0gcGFyZW50RE9NTm9kZTtcbiAgICBjb25zdCByZWN0cyA9IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpO1xuICAgIGlmICghd3JhcHBlck5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHBhcmVudERPTU5vZGVfLmFwcGVuZCh3cmFwcGVyTm9kZSk7XG4gICAgfVxuICAgIGxldCBoYXNSZXBvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAvLyBUcnkgdG8gcmV1c2UgdGhlIHByZXZpb3VzbHkgY3JlYXRlZCBOb2RlIHdoZW4gcG9zc2libGUsIG5vIG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZS9jcmVhdGUgb24gdGhlIG1vc3QgY29tbW9uIGNhc2UgcmVwb3NpdGlvbiBjYXNlXG4gICAgICBjb25zdCByZWN0Tm9kZSA9IGxhc3ROb2Rlc1tpXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IHJlY3ROb2RlU3R5bGUgPSByZWN0Tm9kZS5zdHlsZTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVmdCA9IHB4KHJlY3QubGVmdCAtIHJvb3RMZWZ0KTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLmxlZnQgIT09IGxlZnQpIHtcbiAgICAgICAgcmVjdE5vZGVTdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcCA9IHB4KHJlY3QudG9wIC0gcm9vdFRvcCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS50b3AgIT09IHRvcCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS50b3AgPSB0b3A7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB3aWR0aCA9IHB4KHJlY3Qud2lkdGgpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWlnaHQgPSBweChyZWN0LmhlaWdodCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdE5vZGUucGFyZW50Tm9kZSAhPT0gd3JhcHBlck5vZGUpIHtcbiAgICAgICAgd3JhcHBlck5vZGUuYXBwZW5kKHJlY3ROb2RlKTtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3ROb2Rlc1tpXSA9IHJlY3ROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobGFzdE5vZGVzLmxlbmd0aCA+IHJlY3RzLmxlbmd0aCkge1xuICAgICAgbGFzdE5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoaGFzUmVwb3NpdGlvbmVkKSB7XG4gICAgICBvblJlcG9zaXRpb24obGFzdE5vZGVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgICByb290RE9NTm9kZSA9IG51bGw7XG4gICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB3cmFwcGVyTm9kZS5yZW1vdmUoKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbGFzdE5vZGVzKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgICBsYXN0Tm9kZXMgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIGNvbnN0IGN1cnJlbnRSb290RE9NTm9kZSA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50Um9vdERPTU5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXJlbnRET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCEoY3VycmVudFBhcmVudERPTU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIHN0b3AoKTtcbiAgICByb290RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZTtcbiAgICBwYXJlbnRET01Ob2RlID0gY3VycmVudFBhcmVudERPTU5vZGU7XG4gICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgY29uc3QgbmV4dFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBjb25zdCBuZXh0UGFyZW50RE9NTm9kZSA9IG5leHRSb290RE9NTm9kZSAmJiBuZXh0Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChuZXh0Um9vdERPTU5vZGUgIT09IHJvb3RET01Ob2RlIHx8IG5leHRQYXJlbnRET01Ob2RlICE9PSBwYXJlbnRET01Ob2RlKSB7XG4gICAgICAgIHJldHVybiByZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAoIXdyYXBwZXJOb2RlLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAvLyBUT0RPIHRocm90dGxlXG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRQYXJlbnRET01Ob2RlLCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnKTtcbiAgICBwb3NpdGlvbigpO1xuICB9XG4gIGNvbnN0IHJlbW92ZVJvb3RMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcihyZXN0YXJ0KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVSb290TGlzdGVuZXIoKTtcbiAgICBzdG9wKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbWFya1NlbGVjdGlvbihlZGl0b3IsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICBsZXQgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICBmdW5jdGlvbiBjb21wdXRlKGVkaXRvclN0YXRlKSB7XG4gICAgZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNGb2N1c09mZnNldCA9IG51bGw7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZUtleSA9IGN1cnJlbnRBbmNob3JOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZUtleSA9IGN1cnJlbnRGb2N1c05vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEFuY2hvck5vZGVLZXkpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEZvY3VzTm9kZUtleSk7XG4gICAgICBjb25zdCBkaWZmZXJlbnRBbmNob3JET00gPSBwcmV2aW91c0FuY2hvck5vZGUgPT09IG51bGwgfHwgY3VycmVudEFuY2hvck5vZGVET00gPT09IG51bGwgfHwgY3VycmVudEFuY2hvck9mZnNldCAhPT0gcHJldmlvdXNBbmNob3JPZmZzZXQgfHwgY3VycmVudEFuY2hvck5vZGVLZXkgIT09IHByZXZpb3VzQW5jaG9yTm9kZS5nZXRLZXkoKSB8fCBjdXJyZW50QW5jaG9yTm9kZSAhPT0gcHJldmlvdXNBbmNob3JOb2RlICYmICghKHByZXZpb3VzQW5jaG9yTm9kZSBpbnN0YW5jZW9mIFRleHROb2RlKSB8fCBjdXJyZW50QW5jaG9yTm9kZS51cGRhdGVET00ocHJldmlvdXNBbmNob3JOb2RlLCBjdXJyZW50QW5jaG9yTm9kZURPTSwgZWRpdG9yLl9jb25maWcpKTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEZvY3VzRE9NID0gcHJldmlvdXNGb2N1c05vZGUgPT09IG51bGwgfHwgY3VycmVudEZvY3VzTm9kZURPTSA9PT0gbnVsbCB8fCBjdXJyZW50Rm9jdXNPZmZzZXQgIT09IHByZXZpb3VzRm9jdXNPZmZzZXQgfHwgY3VycmVudEZvY3VzTm9kZUtleSAhPT0gcHJldmlvdXNGb2N1c05vZGUuZ2V0S2V5KCkgfHwgY3VycmVudEZvY3VzTm9kZSAhPT0gcHJldmlvdXNGb2N1c05vZGUgJiYgKCEocHJldmlvdXNGb2N1c05vZGUgaW5zdGFuY2VvZiBUZXh0Tm9kZSkgfHwgY3VycmVudEZvY3VzTm9kZS51cGRhdGVET00ocHJldmlvdXNGb2N1c05vZGUsIGN1cnJlbnRGb2N1c05vZGVET00sIGVkaXRvci5fY29uZmlnKSk7XG4gICAgICBpZiAoZGlmZmVyZW50QW5jaG9yRE9NIHx8IGRpZmZlcmVudEZvY3VzRE9NKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvckhUTUxFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3IuZ2V0Tm9kZSgpLmdldEtleSgpKTtcbiAgICAgICAgY29uc3QgZm9jdXNIVE1MRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXMuZ2V0Tm9kZSgpLmdldEtleSgpKTtcbiAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZWN0aW9uIGJleW9uZCB0aGUgY29tbW9uIFRleHROb2RlXG4gICAgICAgIGlmIChhbmNob3JIVE1MRWxlbWVudCAhPT0gbnVsbCAmJiBmb2N1c0hUTUxFbGVtZW50ICE9PSBudWxsICYmIGFuY2hvckhUTUxFbGVtZW50LnRhZ05hbWUgPT09ICdTUEFOJyAmJiBmb2N1c0hUTUxFbGVtZW50LnRhZ05hbWUgPT09ICdTUEFOJykge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBsZXQgZmlyc3RIVE1MRWxlbWVudDtcbiAgICAgICAgICBsZXQgZmlyc3RPZmZzZXQ7XG4gICAgICAgICAgbGV0IGxhc3RIVE1MRWxlbWVudDtcbiAgICAgICAgICBsZXQgbGFzdE9mZnNldDtcbiAgICAgICAgICBpZiAoZm9jdXMuaXNCZWZvcmUoYW5jaG9yKSkge1xuICAgICAgICAgICAgZmlyc3RIVE1MRWxlbWVudCA9IGZvY3VzSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBmaXJzdE9mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICAgICAgICAgIGxhc3RIVE1MRWxlbWVudCA9IGFuY2hvckhUTUxFbGVtZW50O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0SFRNTEVsZW1lbnQgPSBhbmNob3JIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGZpcnN0T2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICAgIGxhc3RIVE1MRWxlbWVudCA9IGZvY3VzSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaXJzdFRleHROb2RlID0gZmlyc3RIVE1MRWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgIGlmICghKGZpcnN0VGV4dE5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGV4dCBub2RlIHRvIGJlIGZpcnN0IGNoaWxkIG9mIHNwYW5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGFzdFRleHROb2RlID0gbGFzdEhUTUxFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgaWYgKCEobGFzdFRleHROb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRleHQgbm9kZSB0byBiZSBmaXJzdCBjaGlsZCBvZiBzcGFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGZpcnN0VGV4dE5vZGUsIGZpcnN0T2Zmc2V0KTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobGFzdFRleHROb2RlLCBsYXN0T2Zmc2V0KTtcbiAgICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9IHBvc2l0aW9uTm9kZU9uUmFuZ2UoZWRpdG9yLCByYW5nZSwgZG9tTm9kZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkb21Ob2RlIG9mIGRvbU5vZGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvbU5vZGVTdHlsZSA9IGRvbU5vZGUuc3R5bGU7XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCAhPT0gJ0hpZ2hsaWdodCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCA9ICdIaWdobGlnaHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuY29sb3IgIT09ICdIaWdobGlnaHRUZXh0Jykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5jb2xvciA9ICdIaWdobGlnaHRUZXh0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnpJbmRleCAhPT0gJy0xJykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS56SW5kZXggPSAnLTEnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucG9pbnRlckV2ZW50cyAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgIT09IHB4KC0xLjUpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLm1hcmdpblRvcCA9IHB4KC0xLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCAhPT0gcHgoNCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCA9IHB4KDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSAhPT0gcHgoMCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSA9IHB4KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZXBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb25SZXBvc2l0aW9uKGRvbU5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gY3VycmVudEFuY2hvck5vZGU7XG4gICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IGN1cnJlbnRBbmNob3JPZmZzZXQ7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IGN1cnJlbnRGb2N1c05vZGU7XG4gICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gY3VycmVudEZvY3VzT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIGVkaXRvclN0YXRlXG4gIH0pID0+IGNvbXB1dGUoZWRpdG9yU3RhdGUpKSwgcmVtb3ZlUmFuZ2VMaXN0ZW5lciwgKCkgPT4ge1xuICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gSG90Zml4IHRvIGV4cG9ydCB0aGVzZSB3aXRoIGlubGluZWQgdHlwZXMgIzU5MThcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMTtcbmNvbnN0IENBTl9VU0VfRE9NID0gQ0FOX1VTRV9ET00kMTtcbmNvbnN0IElTX0FORFJPSUQgPSBJU19BTkRST0lEJDE7XG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IElTX0FORFJPSURfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRSA9IElTX0FQUExFJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBJU19BUFBMRV9XRUJLSVQkMTtcbmNvbnN0IElTX0NIUk9NRSA9IElTX0NIUk9NRSQxO1xuY29uc3QgSVNfRklSRUZPWCA9IElTX0ZJUkVGT1gkMTtcbmNvbnN0IElTX0lPUyA9IElTX0lPUyQxO1xuY29uc3QgSVNfU0FGQVJJID0gSVNfU0FGQVJJJDE7XG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgYWRkcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gYWRkIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIFsnZWxlbWVudC1pbm5lciBhY3RpdmUnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgYWRkIGJvdGggJ2VsZW1lbnQtaW5uZXInIGFuZCAnYWN0aXZlJyBhcyBjbGFzc2VzIHRvIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIGFkZGVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byBhZGQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCByZW1vdmVzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byByZW1vdmUgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBbJ2FjdGl2ZSBzbWFsbCcsIHRydWUsIG51bGxdKVxuICogd2lsbCByZW1vdmUgYm90aCB0aGUgJ2FjdGl2ZScgYW5kICdzbWFsbCcgY2xhc3NlcyBmcm9tIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIHJlbW92ZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIHJlbW92ZSBmcm9tIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIHR5cGUgbWF0Y2hlcyB0aGUgdHlwZXMgcGFzc2VkIHdpdGhpbiB0aGUgYWNjZXB0YWJsZU1pbWVUeXBlcyBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogVGhlIHR5cGVzIHBhc3NlZCBtdXN0IGJlIHN0cmluZ3MgYW5kIGFyZSBDQVNFLVNFTlNJVElWRS5cbiAqIGVnLiBpZiBmaWxlIGlzIG9mIHR5cGUgJ3RleHQnIGFuZCBhY2NlcHRhYmxlTWltZVR5cGVzID0gWydURVhUJywgJ0lNQUdFJ10gdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlLlxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB5b3Ugd2FudCB0byB0eXBlIGNoZWNrLlxuICogQHBhcmFtIGFjY2VwdGFibGVNaW1lVHlwZXMgLSBBbiBhcnJheSBvZiBzdHJpbmdzIG9mIHR5cGVzIHdoaWNoIHRoZSBmaWxlIGlzIGNoZWNrZWQgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgaXMgYW4gYWNjZXB0YWJsZSBtaW1lIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGZvciAoY29uc3QgYWNjZXB0YWJsZVR5cGUgb2YgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aChhY2NlcHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTGV4aWNhbCBGaWxlIFJlYWRlciB3aXRoOlxuICogIDEuIE1JTUUgdHlwZSBzdXBwb3J0XG4gKiAgMi4gYmF0Y2hlZCByZXN1bHRzIChIaXN0b3J5UGx1Z2luIGNvbXBhdGliaWxpdHkpXG4gKiAgMy4gT3JkZXIgYXdhcmUgKHJlc3BlY3RzIHRoZSBvcmRlciB3aGVuIG11bHRpcGxlIEZpbGVzIGFyZSBwYXNzZWQpXG4gKlxuICogY29uc3QgZmlsZXNSZXN1bHQgPSBhd2FpdCBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIFsnaW1hZ2UvJ10pO1xuICogZmlsZXNSZXN1bHQuZm9yRWFjaChmaWxlID0+IGVkaXRvci5kaXNwYXRjaENvbW1hbmQoJ0lOU0VSVF9JTUFHRScsIHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIH0pKTtcbiAqL1xuZnVuY3Rpb24gbWVkaWFGaWxlUmVhZGVyKGZpbGVzLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGNvbnN0IGZpbGVzSXRlcmF0b3IgPSBmaWxlc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG4gICAgY29uc3QgaGFuZGxlTmV4dEZpbGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRvbmUsXG4gICAgICAgIHZhbHVlOiBmaWxlXG4gICAgICB9ID0gZmlsZXNJdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm9jZXNzZWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSkge1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogXCJEZXB0aC1GaXJzdCBTZWFyY2hcIiBzdGFydHMgYXQgdGhlIHJvb3QvdG9wIG5vZGUgb2YgYSB0cmVlIGFuZCBnb2VzIGFzIGZhciBhcyBpdCBjYW4gZG93biBhIGJyYW5jaCBlbmRcbiAqIGJlZm9yZSBiYWNrdHJhY2tpbmcgYW5kIGZpbmRpbmcgYSBuZXcgcGF0aC4gQ29uc2lkZXIgc29sdmluZyBhIG1hemUgYnkgaHVnZ2luZyBlaXRoZXIgd2FsbCwgbW92aW5nIGRvd24gYVxuICogYnJhbmNoIHVudGlsIHlvdSBoaXQgYSBkZWFkLWVuZCAobGVhZikgYW5kIGJhY2t0cmFja2luZyB0byBmaW5kIHRoZSBuZWFyZXN0IGJyYW5jaGluZyBwYXRoIGFuZCByZXBlYXQuXG4gKiBJdCB3aWxsIHRoZW4gcmV0dXJuIGFsbCB0aGUgbm9kZXMgZm91bmQgaW4gdGhlIHNlYXJjaCBpbiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9tbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kaW5nTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbW1pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiBhbGwgdGhlIG5vZGVzIGZvdW5kIGJ5IHRoZSBzZWFyY2gsIGluY2x1ZGluZyB0aGVpciBkZXB0aCBpbnRvIHRoZSB0cmVlLlxuICoge2RlcHRoOiBudW1iZXIsIG5vZGU6IExleGljYWxOb2RlfSBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgZW5kaW5nIG5vZGUpIHNvIGxvbmcgYXMgaXQgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uICRkZnMoc3RhcnRpbmdOb2RlLCBlbmRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGNvbnN0IHN0YXJ0ID0gKHN0YXJ0aW5nTm9kZSB8fCAkZ2V0Um9vdCgpKS5nZXRMYXRlc3QoKTtcbiAgY29uc3QgZW5kID0gZW5kaW5nTm9kZSB8fCAoJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gc3RhcnQuZ2V0TGFzdERlc2NlbmRhbnQoKSB8fCBzdGFydCA6IHN0YXJ0KTtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgbGV0IGRlcHRoID0gJGdldERlcHRoKG5vZGUpO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiAhbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGRlcHRoKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgaW1tZWRpYXRlIHNpYmxpbmcgb3IgbmVhcmVzdCBwYXJlbnQgc2libGluZ1xuICAgICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgICAgd2hpbGUgKHNpYmxpbmcgPT09IG51bGwgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiAkZ2V0RGVwdGgobm9kZSkge1xuICBsZXQgaW5uZXJOb2RlID0gbm9kZTtcbiAgbGV0IGRlcHRoID0gMDtcbiAgd2hpbGUgKChpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpICE9PSBudWxsKSB7XG4gICAgZGVwdGgrKztcbiAgfVxuICByZXR1cm4gZGVwdGg7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSByaWdodC10by1sZWZ0IHByZW9yZGVyIHRyZWUgdHJhdmVyc2FsLlxuICogRnJvbSB0aGUgc3RhcnRpbmcgbm9kZSBpdCBnb2VzIHRvIHRoZSByaWdodG1vc3QgY2hpbGQsIHRoYW4gYmFja3RyYWNrcyB0byBwYXJldCBhbmQgZmluZHMgbmV3IHJpZ2h0bW9zdCBwYXRoLlxuICogSXQgd2lsbCByZXR1cm4gdGhlIG5leHQgbm9kZSBpbiB0cmF2ZXJzYWwgc2VxdWVuY2UgYWZ0ZXIgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIFRoZSB0cmF2ZXJzYWwgaXMgc2ltaWxhciB0byAkZGZzIGZ1bmN0aW9ucyBhYm92ZSwgYnV0IHRoZSBub2RlcyBhcmUgdmlzaXRlZCByaWdodC10by1sZWZ0LCBub3QgbGVmdC10by1yaWdodC5cbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5leHQgbm9kZSBpbiBwcmUtb3JkZXIgcmlnaHQgdG8gbGVmdCB0cmF2ZXJzYWwgc2VxdWVuY2Ugb3IgYG51bGxgLCBpZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgbm9kZSA9IG5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgIHdoaWxlIChzaWJsaW5nID09PSBudWxsICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3N0YXJ0Tm9kZS5fX2tleX0gdG8gaGF2ZSBjbG9zZXN0IGJsb2NrIGVsZW1lbnQgbm9kZS5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrTm9kZTtcbn1cbi8qKlxuICogU3RhcnRzIHdpdGggYSBub2RlIGFuZCBtb3ZlcyB1cCB0aGUgdHJlZSAodG93YXJkIHRoZSByb290IG5vZGUpIHRvIGZpbmQgYSBtYXRjaGluZyBub2RlIGJhc2VkIG9uXG4gKiB0aGUgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhlIGZpbmRGbi4gKENvbnNpZGVyIEphdmFTY3JpcHRzJyAuZmluZCgpIGZ1bmN0aW9uIHdoZXJlIGEgdGVzdGluZyBmdW5jdGlvbiBtdXN0IGJlXG4gKiBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIGVnLiBpZiggKG5vZGUpID0+IG5vZGUuX190eXBlID09PSAnZGl2JykgKSByZXR1cm4gdHJ1ZTsgb3RoZXJ3aXNlIHJldHVybiBmYWxzZVxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLlxuICogQHBhcmFtIGZpbmRGbiAtIEEgdGVzdGluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBub2RlIHNhdGlzZmllcyB0aGUgdGVzdGluZyBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMgQSBwYXJlbnQgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIGZpbmRGbiBwYXJhbWV0ZXJzLCBvciBudWxsIGlmIG9uZSB3YXNuJ3QgZm91bmQuXG4gKi9cbmNvbnN0ICRmaW5kTWF0Y2hpbmdQYXJlbnQgPSAoc3RhcnRpbmdOb2RlLCBmaW5kRm4pID0+IHtcbiAgbGV0IGN1cnIgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChjdXJyICE9PSAkZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBuZXN0ZWQgZWxlbWVudCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGludG8gYSBzaW5nbGUgbm9kZSBvZiB0aGF0IHR5cGUuXG4gKiBJdCBpcyBnZW5lcmFsbHkgdXNlZCBmb3IgbWFya3MvY29tbWVudGluZ1xuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgdGFyZ2V0IGZvciB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYmUgZXh0cmFjdGVkIGZyb20uXG4gKiBAcGFyYW0gY2xvbmVOb2RlIC0gU2VlIHtAbGluayAkY3JlYXRlTWFya05vZGV9XG4gKiBAcGFyYW0gaGFuZGxlT3ZlcmxhcCAtIEhhbmRsZXMgYW55IG92ZXJsYXAgYmV0d2VlbiB0aGUgbm9kZSB0byBleHRyYWN0IGFuZCB0aGUgdGFyZ2V0Tm9kZVxuICogQHJldHVybnMgVGhlIGxleGljYWwgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyKGVkaXRvciwgdGFyZ2V0Tm9kZSwgY2xvbmVOb2RlLCBoYW5kbGVPdmVybGFwKSB7XG4gIGNvbnN0ICRpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG4gIGNvbnN0ICRmaW5kTWF0Y2ggPSBub2RlID0+IHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB3ZSBkb24ndCBoYXZlIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBvZiB0aGUgdGFyZ2V0LFxuICAgIC8vIGFzIHdlIG5lZWQgdG8gaGFuZGxlIHRoZW0gZmlyc3QuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBjaGlsZE5vZGUgPSBub2RlO1xuICAgIHdoaWxlIChwYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjaGlsZE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCBtYXRjaCA9ICRmaW5kTWF0Y2gobm9kZSk7XG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSBtYXRjaDtcblxuICAgICAgLy8gU2ltcGxlIHBhdGgsIHdlIGNhbiBtb3ZlIGNoaWxkIG91dCBhbmQgc2libGluZ3MgaW50byBhIG5ldyBwYXJlbnQuXG5cbiAgICAgIGlmIChjaGlsZC5pcyhub2RlKSkge1xuICAgICAgICBoYW5kbGVPdmVybGFwKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGNoaWxkLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3NMZW5ndGggPSBuZXh0U2libGluZ3MubGVuZ3RoO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgICAgICBpZiAobmV4dFNpYmxpbmdzTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gY2xvbmVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QWZ0ZXIobmV3UGFyZW50KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTaWJsaW5nc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kKG5leHRTaWJsaW5nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKHRhcmdldE5vZGUsICRlbGVtZW50Tm9kZVRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBlZGl0b3IgYW5kIG1hcmtzIGl0IGFzIGRpcnR5IHRvIGJlIHJlY29uY2lsZWQuIElmIHRoZXJlIHdhcyBhIHNlbGVjdGlvbixcbiAqIGl0IHdvdWxkIGJlIHNldCBiYWNrIHRvIGl0cyBwcmV2aW91cyBzdGF0ZSwgb3IgbnVsbCBvdGhlcndpc2UuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gZWRpdG9yU3RhdGUgLSBUaGUgZWRpdG9yJ3Mgc3RhdGVcbiAqL1xuZnVuY3Rpb24gJHJlc3RvcmVFZGl0b3JTdGF0ZShlZGl0b3IsIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IEZVTExfUkVDT05DSUxFID0gMjtcbiAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBlZGl0b3JTdGF0ZS5fbm9kZU1hcCkge1xuICAgIGNvbnN0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMobm9kZSk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNsb25lKSkge1xuICAgICAgaWYgKCEkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSBiZSBhIFRleHROb2RlYCk7XG4gICAgICB9XG4gICAgICBjbG9uZS5fX3RleHQgPSBub2RlLl9fdGV4dDtcbiAgICB9XG4gICAgbm9kZU1hcC5zZXQoa2V5LCBjbG9uZSk7XG4gIH1cbiAgaWYgKGFjdGl2ZUVkaXRvclN0YXRlKSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUuX25vZGVNYXAgPSBub2RlTWFwO1xuICB9XG4gIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uID09PSBudWxsID8gbnVsbCA6IHNlbGVjdGlvbi5jbG9uZSgpKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgc2VsZWN0ZWQgaW5zZXJ0aW9uIGFyZWEgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3Qgbm9kZSAoc2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9KSxcbiAqIHRoZSBub2RlIHdpbGwgYmUgYXBwZW5kZWQgdGhlcmUsIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGluc2VydGlvbiBhcmVhLlxuICogSWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIHdoZXJlIHRoZSBub2RlIGlzIHRvIGJlIGluc2VydGVkLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFmdGVyIGFueSBjdXJyZW50IG5vZGVzXG4gKiB3aXRoaW4gdGhlIHRyZWUsIGFzIGEgY2hpbGQgb2YgdGhlIHJvb3Qgbm9kZS4gQSBwYXJhZ3JhcGggbm9kZSB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICBjb25zdCBmb2N1c0NoaWxkID0gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChmb2N1c09mZnNldCk7XG4gICAgICBpZiAoZm9jdXNDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIGZvY3VzTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c0NoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2VsZWN0TmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3BsaXROb2RlO1xuICAgICAgbGV0IHNwbGl0T2Zmc2V0O1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgICAgc3BsaXROb2RlID0gZm9jdXNOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgaWYgKGZvY3VzT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHNwbGl0T2Zmc2V0ICs9IDE7XG4gICAgICAgICAgZm9jdXNOb2RlLnNwbGl0VGV4dChmb2N1c09mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFssIHJpZ2h0VHJlZV0gPSAkc3BsaXROb2RlKHNwbGl0Tm9kZSwgc3BsaXRPZmZzZXQpO1xuICAgICAgcmlnaHRUcmVlLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIHJpZ2h0VHJlZS5zZWxlY3RTdGFydCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICAgICAgcm9vdC5hcHBlbmQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gICAgcGFyYWdyYXBoTm9kZS5zZWxlY3QoKTtcbiAgfVxuICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgbm9kZSBpbnRvIGFub3RoZXIgbm9kZSBjcmVhdGVkIGZyb20gYSBjcmVhdGVFbGVtZW50Tm9kZSBmdW5jdGlvbiwgZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50Tm9kZSAtIENyZWF0ZXMgYSBuZXcgbGV4aWNhbCBlbGVtZW50IHRvIHdyYXAgdGhlIHRvLWJlLXdyYXBwZWQgbm9kZSBhbmQgcmV0dXJucyBpdC5cbiAqIEByZXR1cm5zIEEgbmV3IGxleGljYWwgZWxlbWVudCB3aXRoIHRoZSBwcmV2aW91cyBub2RlIGFwcGVuZGVkIHdpdGhpbiAoYXMgYSBjaGlsZCwgaW5jbHVkaW5nIGl0cyBjaGlsZHJlbikuXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZUluRWxlbWVudChub2RlLCBjcmVhdGVFbGVtZW50Tm9kZSkge1xuICBjb25zdCBlbGVtZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnROb2RlKCk7XG4gIG5vZGUucmVwbGFjZShlbGVtZW50Tm9kZSk7XG4gIGVsZW1lbnROb2RlLmFwcGVuZChub2RlKTtcbiAgcmV0dXJuIGVsZW1lbnROb2RlO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIEBwYXJhbSBvYmplY3QgPSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHR5cGVcbiAqIEBwYXJhbSBvYmplY3RDbGFzcyA9IFRoZSBjbGFzcyBvZiB0aGUgdHlwZVxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGhhcyB0aGUgc2FtZSBLbGFzcyBvZiB0aGUgb2JqZWN0Q2xhc3MsIGlnbm9yaW5nIHRoZSBkaWZmZXJlbmNlIGFjcm9zcyB3aW5kb3cgKGUuZy4gZGlmZmVyZW50IGlmcmFtcylcbiAqL1xuZnVuY3Rpb24gb2JqZWN0S2xhc3NFcXVhbHMob2JqZWN0LCBvYmplY3RDbGFzcykge1xuICByZXR1cm4gb2JqZWN0ICE9PSBudWxsID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IubmFtZSA9PT0gb2JqZWN0Q2xhc3MubmFtZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEZpbHRlciB0aGUgbm9kZXNcbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0aGF0IG5lZWRzIHRvIGJlIGZpbHRlcmVkXG4gKiBAcGFyYW0gZmlsdGVyRm4gQSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vZGUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBvdGhlcndpc2UgbnVsbFxuICogQHJldHVybnMgQXJyYXkgb2YgZmlsdGVyZWQgbm9kZXNcbiAqL1xuXG5mdW5jdGlvbiAkZmlsdGVyKG5vZGVzLCBmaWx0ZXJGbikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBmaWx0ZXJGbihub2Rlc1tpXSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBcHBlbmRzIHRoZSBub2RlIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gcGFyZW50IEEgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSBub2RlIE5vZGUgdGhhdCBuZWVkcyB0byBiZSBhcHBlbmRlZFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Rmlyc3QocGFyZW50LCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmQobm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB6b29tIGxldmVsIG9mIGFuIGVsZW1lbnQgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGNzcyB6b29tIHByb3BlcnR5LlxuICogQHBhcmFtIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlWm9vbUxldmVsKGVsZW1lbnQpIHtcbiAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgem9vbSA9IDE7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgem9vbSAqPSBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnem9vbScpKTtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiB6b29tO1xufVxuXG5leHBvcnQgeyAkZGZzLCAkZmlsdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdywgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlLCAkaW5zZXJ0Rmlyc3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCwgJHJlc3RvcmVFZGl0b3JTdGF0ZSwgJHdyYXBOb2RlSW5FbGVtZW50LCBDQU5fVVNFX0JFRk9SRV9JTlBVVCwgQ0FOX1VTRV9ET00sIElTX0FORFJPSUQsIElTX0FORFJPSURfQ0hST01FLCBJU19BUFBMRSwgSVNfQVBQTEVfV0VCS0lULCBJU19DSFJPTUUsIElTX0ZJUkVGT1gsIElTX0lPUywgSVNfU0FGQVJJLCBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCBjYWxjdWxhdGVab29tTGV2ZWwsIGlzTWltZVR5cGUsIG1hcmtTZWxlY3Rpb24sIG1lZGlhRmlsZVJlYWRlciwgbWVyZ2VSZWdpc3Rlciwgb2JqZWN0S2xhc3NFcXVhbHMsIHBvc2l0aW9uTm9kZU9uUmFuZ2UsIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: () => (/* binding */ $generateJSONFromSelectedNodes),\n/* harmony export */   $generateNodesFromSerializedNodes: () => (/* binding */ $generateNodesFromSerializedNodes),\n/* harmony export */   $getHtmlContent: () => (/* binding */ $getHtmlContent),\n/* harmony export */   $getLexicalContent: () => (/* binding */ $getLexicalContent),\n/* harmony export */   $insertDataTransferForPlainText: () => (/* binding */ $insertDataTransferForPlainText),\n/* harmony export */   $insertDataTransferForRichText: () => (/* binding */ $insertDataTransferForRichText),\n/* harmony export */   $insertGeneratedNodes: () => (/* binding */ $insertGeneratedNodes),\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"(rsc)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEU7QUFDMEI7QUFDckQ7QUFDaU07O0FBRXBQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0EsU0FBUyxxRUFBc0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0VBQXFCO0FBQ3pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLGlDQUFpQyxzREFBYTtBQUM5QyxZQUFZLDBEQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osMENBQTBDLHVEQUFjO0FBQ3hELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkVBQXdDO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQSxnQkFBZ0Isd0VBQW9CO0FBQ3BDLFlBQVksb0RBQVcsZ0NBQWdDLGlGQUE2QjtBQUNwRjtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBLGlCQUFpQiw2REFBb0I7QUFDckMsUUFBUSxvREFBVztBQUNuQixNQUFNLGlFQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaURBQVk7QUFDOUQsVUFBVSxpRUFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLDhEQUF5QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdFQUF1QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1sYXRlc3Qtc3RhcnRlci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYubWpzP2VjNjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00gfSBmcm9tICdAbGV4aWNhbC9odG1sJztcbmltcG9ydCB7ICRhZGROb2RlU3R5bGUsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBvYmplY3RLbGFzc0VxdWFscyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkY3JlYXRlVGFiTm9kZSwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFJvb3QsICRwYXJzZVNlcmlhbGl6ZWROb2RlLCAkaXNUZXh0Tm9kZSwgQ09QWV9DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMLCBpc1NlbGVjdGlvbldpdGhpbkVkaXRvciwgJGlzRWxlbWVudE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZ2V0RE9NU2VsZWN0aW9uID0gdGFyZ2V0V2luZG93ID0+IENBTl9VU0VfRE9NID8gKHRhcmdldFdpbmRvdyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpIDogbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAqY3VycmVudGx5IHNlbGVjdGVkKiBMZXhpY2FsIGNvbnRlbnQgYXMgYW4gSFRNTCBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRET00gbWV0aG9kcyBvbiB0aGUgTGV4aWNhbE5vZGUgY2xhc3Nlcy4gTm90ZSB0aGF0XG4gKiB0aGlzIHdpbGwgbm90IHJldHVybiB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBlbnRpcmUgZWRpdG9yICh1bmxlc3MgYWxsIHRoZSBjb250ZW50IGlzIGluY2x1ZGVkXG4gKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgLSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGdldCBIVE1MIGNvbnRlbnQgZnJvbVxuICogQHJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uICRnZXRIdG1sQ29udGVudChlZGl0b3IpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdmFsaWQgTGV4aWNhbFNlbGVjdGlvbmApO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGhhdmVuJ3Qgc2VsZWN0ZWQgYW55dGhpbmdcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgc2VsZWN0aW9uLmdldE5vZGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAqY3VycmVudGx5IHNlbGVjdGVkKiBMZXhpY2FsIGNvbnRlbnQgYXMgYSBKU09OIHN0cmluZywgcmVseWluZyBvbiB0aGVcbiAqIGxvZ2ljIGRlZmluZWQgaW4gdGhlIGV4cG9ydEpTT04gbWV0aG9kcyBvbiB0aGUgTGV4aWNhbE5vZGUgY2xhc3Nlcy4gTm90ZSB0aGF0XG4gKiB0aGlzIHdpbGwgbm90IHJldHVybiB0aGUgSlNPTiBjb250ZW50IG9mIHRoZSBlbnRpcmUgZWRpdG9yICh1bmxlc3MgYWxsIHRoZSBjb250ZW50IGlzIGluY2x1ZGVkXG4gKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgIC0gTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkZ2V0TGV4aWNhbENvbnRlbnQoZWRpdG9yKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSgkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgY29udGVudCBvZiB0aGUgbWltZS10eXBlcyB0ZXh0L3BsYWluIG9yIHRleHQvdXJpLWxpc3QgZnJvbVxuICogdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlciBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKiB0ZXh0L3VyaS1saXN0IGlzIG9ubHkgdXNlZCBpZiB0ZXh0L3BsYWluIGlzIG5vdCBhbHNvIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciwgdGV4dC9odG1sLFxuICogdGV4dC9wbGFpbiwgb3IgdGV4dC91cmktbGlzdCAoaW4gZGVzY2VuZGluZyBvcmRlciBvZiBwcmlvcml0eSkgZnJvbSB0aGUgcHJvdmlkZWQgRGF0YVRyYW5zZmVyXG4gKiBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRhdGFUcmFuc2ZlciBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgW0RhdGFUcmFuc2ZlciBpbnRlcmZhY2VdIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kbmQuaHRtbCN0aGUtZGF0YXRyYW5zZmVyLWludGVyZmFjZSlcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byB1c2UgYXMgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIGNvbnRlbnQgaW4gdGhlIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgdGhlIGNvbnRlbnQgaXMgYmVpbmcgaW5zZXJ0ZWQgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJyk7XG4gIGlmIChsZXhpY2FsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGxleGljYWxTdHJpbmcpO1xuICAgICAgaWYgKHBheWxvYWQubmFtZXNwYWNlID09PSBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLm5vZGVzKSkge1xuICAgICAgICBjb25zdCBub2RlcyA9ICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcyhwYXlsb2FkLm5vZGVzKTtcbiAgICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIGlmIChodG1sU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IGRvbSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaHRtbFN0cmluZywgJ3RleHQvaHRtbCcpO1xuICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00oZWRpdG9yLCBkb20pO1xuICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuXG4gIC8vIE11bHRpLWxpbmUgcGxhaW4gdGV4dCBpbiByaWNoIHRleHQgbW9kZSBwYXN0ZWQgYXMgc2VwYXJhdGUgcGFyYWdyYXBoc1xuICAvLyBpbnN0ZWFkIG9mIHNpbmdsZSBwYXJhZ3JhcGggd2l0aCBsaW5lYnJlYWtzLlxuICAvLyBXZWJraXQtc3BlY2lmaWM6IFN1cHBvcnRzIHJlYWQgJ3RleHQvdXJpLWxpc3QnIGluIGNsaXBib2FyZC5cbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnROb2RlcyhbJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydFRleHQocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluc2VydHMgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgdXNpbmcgZGlmZmVyZW50IHN0cmF0ZWdpZXMgZGVwZW5kaW5nIG9uXG4gKiBzb21lIHNpbXBsZSBzZWxlY3Rpb24tYmFzZWQgaGV1cmlzdGljcy4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgZ2VuZXJpYyB3YXkgdG9cbiAqIHRvIGluc2VydCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgYXQgYSBzcGVjaWZpYyBzZWxlY3Rpb24gcG9pbnQsIHlvdSBwcm9iYWJseSB3YW50XG4gKiB7QGxpbmsgbGV4aWNhbC4kaW5zZXJ0Tm9kZXN9XG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHNlbGVjdGlvbiBUaGUgc2VsZWN0aW9uIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbikge1xuICBpZiAoIWVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwge1xuICAgIG5vZGVzLFxuICAgIHNlbGVjdGlvblxuICB9KSkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cbiAgcmV0dXJuO1xufVxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuZXhwb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY3VycmVudE5vZGUsIHRhcmdldEFycmF5ID0gW10pIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24gIT09IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmV4Y2x1ZGVGcm9tQ29weSgnaHRtbCcpO1xuICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSAkaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uICE9PSBudWxsID8gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuICBjb25zdCBjaGlsZHJlbiA9ICRpc0VsZW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQuZ2V0Q2hpbGRyZW4oKSA6IFtdO1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IGV4cG9ydE5vZGVUb0pTT04odGFyZ2V0KTtcblxuICAvLyBUT0RPOiBUZXh0Tm9kZSBjYWxscyBnZXRUZXh0Q29udGVudCgpIChOT1Qgbm9kZS5fX3RleHQpIHdpdGhpbiBpdCdzIGV4cG9ydEpTT04gbWV0aG9kXG4gIC8vIHdoaWNoIHVzZXMgZ2V0TGF0ZXN0KCkgdG8gZ2V0IHRoZSB0ZXh0IGZyb20gdGhlIG9yaWdpbmFsIG5vZGUgd2l0aCB0aGUgc2FtZSBrZXkuXG4gIC8vIFRoaXMgaXMgYSBkZWVwZXIgaXNzdWUgd2l0aCB0aGUgd29yZCBcImNsb25lXCIgaGVyZSwgaXQncyBzdGlsbCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgLy8gc2FtZSBub2RlIGFzIGZhciBhcyB0aGUgTGV4aWNhbEVkaXRvciBpcyBjb25jZXJuZWQgc2luY2UgaXQgc2hhcmVzIGEga2V5LlxuICAvLyBXZSBuZWVkIGEgd2F5IHRvIGNyZWF0ZSBhIGNsb25lIG9mIGEgTm9kZSBpbiBtZW1vcnkgd2l0aCBpdCdzIG93biBrZXksIGJ1dFxuICAvLyB1bnRpbCB0aGVuIHRoaXMgaGFjayB3aWxsIHdvcmsgZm9yIHRoZSBzZWxlY3RlZCB0ZXh0IGV4dHJhY3QgdXNlIGNhc2UuXG4gIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXQpKSB7XG4gICAgY29uc3QgdGV4dCA9IHRhcmdldC5fX3RleHQ7XG4gICAgLy8gSWYgYW4gdW5jb2xsYXBzZWQgc2VsZWN0aW9uIGVuZHMgb3Igc3RhcnRzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIG9mIHNwZWNpYWxpemVkLFxuICAgIC8vIFRleHROb2Rlcywgc3VjaCBhcyBjb2RlIHRva2Vucywgd2Ugd2lsbCBnZXQgYSAnYmxhbmsnIFRleHROb2RlIGhlcmUsIGkuZS4sIG9uZVxuICAgIC8vIHdpdGggdGV4dCBvZiBsZW5ndGggMC4gV2UgZG9uJ3Qgd2FudCB0aGlzLCBpdCBtYWtlcyBhIGNvbmZ1c2luZyBtZXNzLiBSZXNldCFcbiAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBzZXJpYWxpemVkTm9kZS50ZXh0ID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNoaWxkID0gJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCBjaGlsZE5vZGUsIHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuKTtcbiAgICBpZiAoIXNob3VsZEluY2x1ZGUgJiYgJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIHNob3VsZEluY2x1ZGVDaGlsZCAmJiBjdXJyZW50Tm9kZS5leHRyYWN0V2l0aENoaWxkKGNoaWxkTm9kZSwgc2VsZWN0aW9uLCAnY2xvbmUnKSkge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRJbmNsdWRlICYmICFzaG91bGRFeGNsdWRlKSB7XG4gICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkTm9kZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXJpYWxpemVkTm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW5baV07XG4gICAgICB0YXJnZXRBcnJheS5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2hvdWxkSW5jbHVkZTtcbn1cblxuLy8gVE9ETyB3aHkgJCBmdW5jdGlvbiB3aXRoIEVkaXRvciBpbnN0YW5jZT9cbi8qKlxuICogR2V0cyB0aGUgTGV4aWNhbCBKU09OIG9mIHRoZSBub2RlcyBpbnNpZGUgdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIExleGljYWxFZGl0b3IgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gU2VsZWN0aW9uIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZWRpdG9yIG5hbWVzcGFjZSBhbmQgYSBsaXN0IG9mIHNlcmlhbGl6YWJsZSBub2RlcyBhcyBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyhlZGl0b3IsIHNlbGVjdGlvbikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BMZXZlbENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gdG9wTGV2ZWxDaGlsZHJlbltpXTtcbiAgICAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24sIHRvcExldmVsTm9kZSwgbm9kZXMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZXNwYWNlOiBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UsXG4gICAgbm9kZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0YWtlcyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJhbGl6ZWROb2RlIGludGVyZmFjZSBhbmQgcmV0dXJuc1xuICogYW4gQXJyYXkgY29udGFpbmluZyBpbnN0YW5jZXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgTGV4aWNhbE5vZGUgY2xhc3NlcyByZWdpc3RlcmVkIG9uIHRoZSBlZGl0b3IuXG4gKiBOb3JtYWxseSwgeW91J2QgZ2V0IGFuIEFycmF5IG9mIEJhc2VTZXJpYWxpemVkIG5vZGVzIGZyb20ge0BsaW5rICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2Rlc31cbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZE5vZGVzIGFuIEFycmF5IG9mIG9iamVjdHMgY29uZm9ybWluZyB0byB0aGUgQmFzZVNlcmlhbGl6ZWROb2RlIGludGVyZmFjZS5cbiAqIEByZXR1cm5zIGFuIEFycmF5IG9mIExleGljYWwgTm9kZSBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMoc2VyaWFsaXplZE5vZGVzKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVkTm9kZXNbaV07XG4gICAgY29uc3Qgbm9kZSA9ICRwYXJzZVNlcmlhbGl6ZWROb2RlKHNlcmlhbGl6ZWROb2RlKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICRhZGROb2RlU3R5bGUobm9kZSk7XG4gICAgfVxuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuY29uc3QgRVZFTlRfTEFURU5DWSA9IDUwO1xubGV0IGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG5cbi8vIFRPRE8gY3VzdG9tIHNlbGVjdGlvblxuLy8gVE9ETyBwb3RlbnRpYWxseSBoYXZlIGEgbm9kZSBjdXN0b21pemFibGUgdmVyc2lvbiBmb3IgcGxhaW4gdGV4dFxuLyoqXG4gKiBDb3BpZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBjbGlwYm9hcmQgaW5cbiAqIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgYW5kIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IgKExleGljYWwgSlNPTilcbiAqIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciB0aGUgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBjb3B5IGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIGV2ZW50IHRoZSBuYXRpdmUgYnJvd3NlciBDbGlwYm9hcmRFdmVudCB0byBhZGQgdGhlIGNvbnRlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICovXG5hc3luYyBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBldmVudCkge1xuICBpZiAoY2xpcGJvYXJkRXZlbnRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgLy8gUHJldmVudCB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgdGhhdCBjYW4gaGFwcGVuIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBydW4gbXVsdGlwbGUgdGltZXNcbiAgICAvLyBzeW5jaHJvbm91c2x5LiBJbiB0aGUgZnV0dXJlLCB3ZSBjYW4gZG8gYmV0dGVyLCB3ZSBjYW4gY2FuY2VsL292ZXJyaWRlIHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgam9iLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXZlbnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgZXZlbnQpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGNvbnN0IHdpbmRvd0RvY3VtZW50ID0gZWRpdG9yLl93aW5kb3cgPT0gbnVsbCA/IHdpbmRvdy5kb2N1bWVudCA6IGVkaXRvci5fd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB3aW5kb3dEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTEwMDBweDsnO1xuICBlbGVtZW50LmFwcGVuZCh3aW5kb3dEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIycpKTtcbiAgcm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChlbGVtZW50LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVsZW1lbnQsIDEpO1xuICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIGRvbVNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPUFlfQ09NTUFORCwgc2Vjb25kRXZlbnQgPT4ge1xuICAgICAgaWYgKG9iamVjdEtsYXNzRXF1YWxzKHNlY29uZEV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpcGJvYXJkRXZlbnRUaW1lb3V0KTtcbiAgICAgICAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgc2Vjb25kRXZlbnQpKTtcbiAgICAgIH1cbiAgICAgIC8vIEJsb2NrIHRoZSBlbnRpcmUgY29weSBmbG93IHdoaWxlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IENsaXBib2FyZEV2ZW50XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKTtcbiAgICAvLyBJZiB0aGUgYWJvdmUgaGFjayBleGVjQ29tbWFuZCBoYWNrIHdvcmtzLCB0aGlzIHRpbWVvdXQgY29kZSBzaG91bGQgbmV2ZXIgZmlyZS4gT3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBsaXN0ZW5lciB3aWxsIGJlIHF1aWNrbHkgZnJlZWQgc28gdGhhdCB0aGUgdXNlciBjYW4gcmV1c2UgaXQgYWdhaW5cbiAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH0sIEVWRU5UX0xBVEVOQ1kpO1xuICAgIHdpbmRvd0RvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfSk7XG59XG5cbi8vIFRPRE8gc2hvdWxkbid0IHBhc3MgZWRpdG9yIChwYXNzIG5hbWVzcGFjZSBkaXJlY3RseSlcbmZ1bmN0aW9uICRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50KSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBjb25zdCBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIGlmIChhbmNob3JET00gIT09IG51bGwgJiYgZm9jdXNET00gIT09IG51bGwgJiYgIWlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NLCBmb2N1c0RPTSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKGNsaXBib2FyZERhdGEgPT09IG51bGwgfHwgc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxTdHJpbmcgPSAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yKTtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9ICRnZXRMZXhpY2FsQ29udGVudChlZGl0b3IpO1xuICBsZXQgcGxhaW5TdHJpbmcgPSAnJztcbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIHBsYWluU3RyaW5nID0gc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCk7XG4gIH1cbiAgaWYgKGh0bWxTdHJpbmcgIT09IG51bGwpIHtcbiAgICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGh0bWxTdHJpbmcpO1xuICB9XG4gIGlmIChsZXhpY2FsU3RyaW5nICE9PSBudWxsKSB7XG4gICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJywgbGV4aWNhbFN0cmluZyk7XG4gIH1cbiAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgcGxhaW5TdHJpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMsICRnZXRIdG1sQ29udGVudCwgJGdldExleGljYWxDb250ZW50LCAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0LCAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQsICRpbnNlcnRHZW5lcmF0ZWROb2RlcywgY29weVRvQ2xpcGJvYXJkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@lexical/html/LexicalHtml.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateHtmlFromNodes: () => (/* binding */ $generateHtmlFromNodes),\n/* harmony export */   $generateNodesFromDOM: () => (/* binding */ $generateNodesFromDOM)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(currentLexicalNode) ? false : currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode)(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(node)) {\n      node.setFormat(textAlign);\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE) {\n      node.insertAfter((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUY7QUFDMUI7QUFDbUg7O0FBRWxMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQWM7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQix3RUFBb0I7QUFDcEMsWUFBWSxvREFBVyxnQ0FBZ0MsaUZBQTZCO0FBQ3BGO0FBQ0E7QUFDQSxtQkFBbUIsdURBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNERBQW1CLDZEQUE2RCw0REFBbUI7QUFDbEwsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBLHlFQUF5RSx5REFBb0I7QUFDN0YsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DLCtEQUEwQjtBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELDREQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQTBCO0FBQ25FLHVCQUF1Qiw2REFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2h0bWwvTGV4aWNhbEh0bWwuZGV2Lm1qcz81NGUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGNsb25lV2l0aFByb3BlcnRpZXMsICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50IH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzQmxvY2tEb21Ob2RlIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgJGdldFJvb3QsICRpc0VsZW1lbnROb2RlLCAkaXNUZXh0Tm9kZSwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGlzQmxvY2tFbGVtZW50Tm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsICRjcmVhdGVMaW5lQnJlYWtOb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLyoqXG4gKiBIb3cgeW91IHBhcnNlIHlvdXIgaHRtbCBzdHJpbmcgdG8gZ2V0IGEgZG9jdW1lbnQgaXMgbGVmdCB1cCB0byB5b3UuIEluIHRoZSBicm93c2VyIHlvdSBjYW4gdXNlIHRoZSBuYXRpdmVcbiAqIERPTVBhcnNlciBBUEkgdG8gZ2VuZXJhdGUgYSBkb2N1bWVudCAoc2VlIGNsaXBib2FyZC50cyksIGJ1dCB0byB1c2UgaW4gYSBoZWFkbGVzcyBlbnZpcm9ubWVudCB5b3UgY2FuIHVzZSBKU0RvbVxuICogb3IgYW4gZXF1aXZhbGVudCBsaWJyYXJ5IGFuZCBwYXNzIGluIHRoZSBkb2N1bWVudCBoZXJlLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00oZWRpdG9yLCBkb20pIHtcbiAgY29uc3QgZWxlbWVudHMgPSBkb20uYm9keSA/IGRvbS5ib2R5LmNoaWxkTm9kZXMgOiBbXTtcbiAgbGV0IGxleGljYWxOb2RlcyA9IFtdO1xuICBjb25zdCBhbGxBcnRpZmljaWFsTm9kZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICBpZiAoIUlHTk9SRV9UQUdTLmhhcyhlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgY29uc3QgbGV4aWNhbE5vZGUgPSAkY3JlYXRlTm9kZXNGcm9tRE9NKGVsZW1lbnQsIGVkaXRvciwgYWxsQXJ0aWZpY2lhbE5vZGVzLCBmYWxzZSk7XG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbGV4aWNhbE5vZGVzID0gbGV4aWNhbE5vZGVzLmNvbmNhdChsZXhpY2FsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICR1bndyYXBBcnRpZmljYWxOb2RlcyhhbGxBcnRpZmljaWFsTm9kZXMpO1xuICByZXR1cm4gbGV4aWNhbE5vZGVzO1xufVxuZnVuY3Rpb24gJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IsIHNlbGVjdGlvbikge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLndpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzIGluIGhlYWRsZXNzIG1vZGUgcGxlYXNlIGluaXRpYWxpemUgYSBoZWFkbGVzcyBicm93c2VyIGltcGxlbWVudGF0aW9uIHN1Y2ggYXMgSlNEb20gYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4nKTtcbiAgfVxuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IHRvcExldmVsQ2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgdG9wTGV2ZWxOb2RlLCBjb250YWluZXIsIHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5mdW5jdGlvbiAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCBjdXJyZW50Tm9kZSwgcGFyZW50RWxlbWVudCwgc2VsZWN0aW9uID0gbnVsbCkge1xuICBsZXQgc2hvdWxkSW5jbHVkZSA9IHNlbGVjdGlvbiAhPT0gbnVsbCA/IGN1cnJlbnROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSA6IHRydWU7XG4gIGNvbnN0IHNob3VsZEV4Y2x1ZGUgPSAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgY3VycmVudE5vZGUuZXhjbHVkZUZyb21Db3B5KCdodG1sJyk7XG4gIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGxldCBjbG9uZSA9ICRjbG9uZVdpdGhQcm9wZXJ0aWVzKGN1cnJlbnROb2RlKTtcbiAgICBjbG9uZSA9ICRpc1RleHROb2RlKGNsb25lKSAmJiBzZWxlY3Rpb24gIT09IG51bGwgPyAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24sIGNsb25lKSA6IGNsb25lO1xuICAgIHRhcmdldCA9IGNsb25lO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gJGlzRWxlbWVudE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRDaGlsZHJlbigpIDogW107XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZWRpdG9yLl9ub2Rlcy5nZXQodGFyZ2V0LmdldFR5cGUoKSk7XG4gIGxldCBleHBvcnRPdXRwdXQ7XG5cbiAgLy8gVXNlIEhUTUxDb25maWcgb3ZlcnJpZGVzLCBpZiBhdmFpbGFibGUuXG4gIGlmIChyZWdpc3RlcmVkTm9kZSAmJiByZWdpc3RlcmVkTm9kZS5leHBvcnRET00gIT09IHVuZGVmaW5lZCkge1xuICAgIGV4cG9ydE91dHB1dCA9IHJlZ2lzdGVyZWROb2RlLmV4cG9ydERPTShlZGl0b3IsIHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0T3V0cHV0ID0gdGFyZ2V0LmV4cG9ydERPTShlZGl0b3IpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50LFxuICAgIGFmdGVyXG4gIH0gPSBleHBvcnRPdXRwdXQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIGNoaWxkTm9kZSwgZnJhZ21lbnQsIHNlbGVjdGlvbik7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiwgJ2h0bWwnKSkge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRJbmNsdWRlICYmICFzaG91bGRFeGNsdWRlKSB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGZyYWdtZW50KTtcbiAgICB9XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgaWYgKGFmdGVyKSB7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gYWZ0ZXIuY2FsbCh0YXJnZXQsIGVsZW1lbnQpO1xuICAgICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChuZXdFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICB9XG4gIHJldHVybiBzaG91bGRJbmNsdWRlO1xufVxuZnVuY3Rpb24gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKGRvbU5vZGUsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9kZU5hbWVcbiAgfSA9IGRvbU5vZGU7XG4gIGNvbnN0IGNhY2hlZENvbnZlcnNpb25zID0gZWRpdG9yLl9odG1sQ29udmVyc2lvbnMuZ2V0KG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICBsZXQgY3VycmVudENvbnZlcnNpb24gPSBudWxsO1xuICBpZiAoY2FjaGVkQ29udmVyc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgY2FjaGVkQ29udmVyc2lvbiBvZiBjYWNoZWRDb252ZXJzaW9ucykge1xuICAgICAgY29uc3QgZG9tQ29udmVyc2lvbiA9IGNhY2hlZENvbnZlcnNpb24oZG9tTm9kZSk7XG4gICAgICBpZiAoZG9tQ29udmVyc2lvbiAhPT0gbnVsbCAmJiAoY3VycmVudENvbnZlcnNpb24gPT09IG51bGwgfHwgKGN1cnJlbnRDb252ZXJzaW9uLnByaW9yaXR5IHx8IDApIDwgKGRvbUNvbnZlcnNpb24ucHJpb3JpdHkgfHwgMCkpKSB7XG4gICAgICAgIGN1cnJlbnRDb252ZXJzaW9uID0gZG9tQ29udmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRDb252ZXJzaW9uICE9PSBudWxsID8gY3VycmVudENvbnZlcnNpb24uY29udmVyc2lvbiA6IG51bGw7XG59XG5jb25zdCBJR05PUkVfVEFHUyA9IG5ldyBTZXQoWydTVFlMRScsICdTQ1JJUFQnXSk7XG5mdW5jdGlvbiAkY3JlYXRlTm9kZXNGcm9tRE9NKG5vZGUsIGVkaXRvciwgYWxsQXJ0aWZpY2lhbE5vZGVzLCBoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGUsIGZvckNoaWxkTWFwID0gbmV3IE1hcCgpLCBwYXJlbnRMZXhpY2FsTm9kZSkge1xuICBsZXQgbGV4aWNhbE5vZGVzID0gW107XG4gIGlmIChJR05PUkVfVEFHUy5oYXMobm9kZS5ub2RlTmFtZSkpIHtcbiAgICByZXR1cm4gbGV4aWNhbE5vZGVzO1xuICB9XG4gIGxldCBjdXJyZW50TGV4aWNhbE5vZGUgPSBudWxsO1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jdGlvbiA9IGdldENvbnZlcnNpb25GdW5jdGlvbihub2RlLCBlZGl0b3IpO1xuICBjb25zdCB0cmFuc2Zvcm1PdXRwdXQgPSB0cmFuc2Zvcm1GdW5jdGlvbiA/IHRyYW5zZm9ybUZ1bmN0aW9uKG5vZGUpIDogbnVsbDtcbiAgbGV0IHBvc3RUcmFuc2Zvcm0gPSBudWxsO1xuICBpZiAodHJhbnNmb3JtT3V0cHV0ICE9PSBudWxsKSB7XG4gICAgcG9zdFRyYW5zZm9ybSA9IHRyYW5zZm9ybU91dHB1dC5hZnRlcjtcbiAgICBjb25zdCB0cmFuc2Zvcm1Ob2RlcyA9IHRyYW5zZm9ybU91dHB1dC5ub2RlO1xuICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IEFycmF5LmlzQXJyYXkodHJhbnNmb3JtTm9kZXMpID8gdHJhbnNmb3JtTm9kZXNbdHJhbnNmb3JtTm9kZXMubGVuZ3RoIC0gMV0gOiB0cmFuc2Zvcm1Ob2RlcztcbiAgICBpZiAoY3VycmVudExleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGZvckNoaWxkRnVuY3Rpb25dIG9mIGZvckNoaWxkTWFwKSB7XG4gICAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IGZvckNoaWxkRnVuY3Rpb24oY3VycmVudExleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSk7XG4gICAgICAgIGlmICghY3VycmVudExleGljYWxOb2RlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgbGV4aWNhbE5vZGVzLnB1c2goLi4uKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtTm9kZXMpID8gdHJhbnNmb3JtTm9kZXMgOiBbY3VycmVudExleGljYWxOb2RlXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtT3V0cHV0LmZvckNoaWxkICE9IG51bGwpIHtcbiAgICAgIGZvckNoaWxkTWFwLnNldChub2RlLm5vZGVOYW1lLCB0cmFuc2Zvcm1PdXRwdXQuZm9yQ2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBET00gbm9kZSBkb2Vzbid0IGhhdmUgYSB0cmFuc2Zvcm1lciwgd2UgZG9uJ3Qga25vdyB3aGF0XG4gIC8vIHRvIGRvIHdpdGggaXQgYnV0IHdlIHN0aWxsIG5lZWQgdG8gcHJvY2VzcyBhbnkgY2hpbGROb2Rlcy5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gIGxldCBjaGlsZExleGljYWxOb2RlcyA9IFtdO1xuICBjb25zdCBoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGVGb3JDaGlsZHJlbiA9IGN1cnJlbnRMZXhpY2FsTm9kZSAhPSBudWxsICYmICRpc1Jvb3RPclNoYWRvd1Jvb3QoY3VycmVudExleGljYWxOb2RlKSA/IGZhbHNlIDogY3VycmVudExleGljYWxOb2RlICE9IG51bGwgJiYgJGlzQmxvY2tFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpIHx8IGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzLnB1c2goLi4uJGNyZWF0ZU5vZGVzRnJvbURPTShjaGlsZHJlbltpXSwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuLCBuZXcgTWFwKGZvckNoaWxkTWFwKSwgY3VycmVudExleGljYWxOb2RlKSk7XG4gIH1cbiAgaWYgKHBvc3RUcmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzID0gcG9zdFRyYW5zZm9ybShjaGlsZExleGljYWxOb2Rlcyk7XG4gIH1cbiAgaWYgKGlzQmxvY2tEb21Ob2RlKG5vZGUpKSB7XG4gICAgaWYgKCFoYXNCbG9ja0FuY2VzdG9yTGV4aWNhbE5vZGVGb3JDaGlsZHJlbikge1xuICAgICAgY2hpbGRMZXhpY2FsTm9kZXMgPSB3cmFwQ29udGludW91c0lubGluZXMobm9kZSwgY2hpbGRMZXhpY2FsTm9kZXMsICRjcmVhdGVQYXJhZ3JhcGhOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRMZXhpY2FsTm9kZXMgPSB3cmFwQ29udGludW91c0lubGluZXMobm9kZSwgY2hpbGRMZXhpY2FsTm9kZXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgYXJ0aWZpY2lhbE5vZGUgPSBuZXcgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UoKTtcbiAgICAgICAgYWxsQXJ0aWZpY2lhbE5vZGVzLnB1c2goYXJ0aWZpY2lhbE5vZGUpO1xuICAgICAgICByZXR1cm4gYXJ0aWZpY2lhbE5vZGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSA9PSBudWxsKSB7XG4gICAgLy8gSWYgaXQgaGFzbid0IGJlZW4gY29udmVydGVkIHRvIGEgTGV4aWNhbE5vZGUsIHdlIGhvaXN0IGl0cyBjaGlsZHJlblxuICAgIC8vIHVwIHRvIHRoZSBzYW1lIGxldmVsIGFzIGl0LlxuICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQoY2hpbGRMZXhpY2FsTm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgRWxlbWVudE5vZGUgYWZ0ZXIgY29udmVyc2lvbixcbiAgICAgIC8vIHdlIGNhbiBhcHBlbmQgYWxsIHRoZSBjaGlsZHJlbiB0byBpdC5cbiAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZS5hcHBlbmQoLi4uY2hpbGRMZXhpY2FsTm9kZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV4aWNhbE5vZGVzO1xufVxuZnVuY3Rpb24gd3JhcENvbnRpbnVvdXNJbmxpbmVzKGRvbU5vZGUsIG5vZGVzLCBjcmVhdGVXcmFwcGVyRm4pIHtcbiAgY29uc3QgdGV4dEFsaWduID0gZG9tTm9kZS5zdHlsZS50ZXh0QWxpZ247XG4gIGNvbnN0IG91dCA9IFtdO1xuICBsZXQgY29udGludW91c0lubGluZXMgPSBbXTtcbiAgLy8gd3JhcCBjb250aWd1b3VzIGlubGluZSBjaGlsZCBub2RlcyBpbiBwYXJhXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIG5vZGUuc2V0Rm9ybWF0KHRleHRBbGlnbik7XG4gICAgICBvdXQucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludW91c0lubGluZXMucHVzaChub2RlKTtcbiAgICAgIGlmIChpID09PSBub2Rlcy5sZW5ndGggLSAxIHx8IGkgPCBub2Rlcy5sZW5ndGggLSAxICYmICRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZXNbaSArIDFdKSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlV3JhcHBlckZuKCk7XG4gICAgICAgIHdyYXBwZXIuc2V0Rm9ybWF0KHRleHRBbGlnbik7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kKC4uLmNvbnRpbnVvdXNJbmxpbmVzKTtcbiAgICAgICAgb3V0LnB1c2god3JhcHBlcik7XG4gICAgICAgIGNvbnRpbnVvdXNJbmxpbmVzID0gW107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiAkdW53cmFwQXJ0aWZpY2FsTm9kZXMoYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBhbGxBcnRpZmljaWFsTm9kZXMpIHtcbiAgICBpZiAobm9kZS5nZXROZXh0U2libGluZygpIGluc3RhbmNlb2YgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UpIHtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgfVxuICB9XG4gIC8vIFJlcGxhY2UgYXJ0aWZpY2lhbCBub2RlIHdpdGggaXQncyBjaGlsZHJlblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgIH1cbiAgICBub2RlLnJlbW92ZSgpO1xuICB9XG59XG5cbmV4cG9ydCB7ICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMsICRnZW5lcmF0ZU5vZGVzRnJvbURPTSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lexical/html/LexicalHtml.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@lexical/list/LexicalList.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.dev.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createListItemNode: () => (/* binding */ $createListItemNode),\n/* harmony export */   $createListNode: () => (/* binding */ $createListNode),\n/* harmony export */   $getListDepth: () => (/* binding */ $getListDepth),\n/* harmony export */   $handleListInsertParagraph: () => (/* binding */ $handleListInsertParagraph),\n/* harmony export */   $isListItemNode: () => (/* binding */ $isListItemNode),\n/* harmony export */   $isListNode: () => (/* binding */ $isListNode),\n/* harmony export */   INSERT_CHECK_LIST_COMMAND: () => (/* binding */ INSERT_CHECK_LIST_COMMAND),\n/* harmony export */   INSERT_ORDERED_LIST_COMMAND: () => (/* binding */ INSERT_ORDERED_LIST_COMMAND),\n/* harmony export */   INSERT_UNORDERED_LIST_COMMAND: () => (/* binding */ INSERT_UNORDERED_LIST_COMMAND),\n/* harmony export */   ListItemNode: () => (/* binding */ ListItemNode),\n/* harmony export */   ListNode: () => (/* binding */ ListNode),\n/* harmony export */   REMOVE_LIST_COMMAND: () => (/* binding */ REMOVE_LIST_COMMAND),\n/* harmony export */   insertList: () => (/* binding */ insertList),\n/* harmony export */   removeList: () => (/* binding */ removeList)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n            const listItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestNodeOfType)(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getChecked() != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandparent)) {\n    replacementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('REMOVE_LIST_COMMAND');\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeU47QUFDOUY7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0E7QUFDQSxVQUFVLDBEQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFtQjtBQUNqQztBQUNBO0FBQ0EsZ0JBQWdCLHVEQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EsWUFBWSx1REFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0IsNERBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLGNBQWMsb0RBQVc7QUFDekIsaUNBQWlDLHFFQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBb0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5REFBZ0I7QUFDM0I7QUFDQTtBQUNBLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnREFBVztBQUNsQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLHNEQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLHVEQUFjO0FBQ2pDLDJCQUEyQix3REFBZTtBQUMxQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxzREFBYTtBQUNuRCxvQ0FBb0Msc0RBQWE7QUFDakQsa0NBQWtDLHNEQUFhO0FBQy9DLDRCQUE0QixzREFBYTs7QUFFNE8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcz84OWNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRpc0VsZW1lbnROb2RlLCAkaXNMZWFmTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRpc1BhcmFncmFwaE5vZGUsIEVsZW1lbnROb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsICRjcmVhdGVUZXh0Tm9kZSwgY3JlYXRlQ29tbWFuZCB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIENoZWNrcyB0aGUgZGVwdGggb2YgbGlzdE5vZGUgZnJvbSB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGxpc3ROb2RlIC0gVGhlIExpc3ROb2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUaGUgZGVwdGggb2YgdGhlIExpc3ROb2RlLlxuICovXG5mdW5jdGlvbiAkZ2V0TGlzdERlcHRoKGxpc3ROb2RlKSB7XG4gIGxldCBkZXB0aCA9IDE7XG4gIGxldCBwYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnQoKTtcbiAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBwYXJlbnRMaXN0ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudExpc3QpKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudExpc3QuZ2V0UGFyZW50KCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmV0dXJucyBpdCwgdGhyb3dzIGFuIGludmFyaWFudCBpZiBsaXN0SXRlbSBpcyBub3QgYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW0gLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIExpc3ROb2RlIGZvdW5kLlxuICovXG5mdW5jdGlvbiAkZ2V0VG9wTGlzdE5vZGUobGlzdEl0ZW0pIHtcbiAgbGV0IGxpc3QgPSBsaXN0SXRlbS5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gICAgfVxuICB9XG4gIGxldCBwYXJlbnQgPSBsaXN0O1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBsaXN0ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBEZXB0aC1GaXJzdCBTZWFyY2ggKFBvc3RvcmRlciBUcmF2ZXJzYWwpIHRoYXQgZmluZHMgYWxsIG9mIGEgbm9kZSdzIGNoaWxkcmVuXG4gKiB0aGF0IGFyZSBvZiB0eXBlIExpc3RJdGVtTm9kZSBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5LlxuICogQHBhcmFtIG5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIG9mIHR5cGUgTGlzdEl0ZW1Ob2RlIGZvdW5kLlxuICovXG4vLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSAkZ2V0QWxsQ2hpbGRyZW5PZlR5cGVcbmZ1bmN0aW9uICRnZXRBbGxMaXN0SXRlbXMobm9kZSkge1xuICBsZXQgbGlzdEl0ZW1Ob2RlcyA9IFtdO1xuICBjb25zdCBsaXN0Q2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCkuZmlsdGVyKCRpc0xpc3RJdGVtTm9kZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gbGlzdENoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgbGlzdEl0ZW1Ob2RlcyA9IGxpc3RJdGVtTm9kZXMuY29uY2F0KCRnZXRBbGxMaXN0SXRlbXMoZmlyc3RDaGlsZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0SXRlbU5vZGVzLnB1c2gobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3RJdGVtTm9kZXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcGFzc2VkIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUgYW5kIGhhcyBhIExpc3ROb2RlIGFzIGEgY2hpbGQuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBjaGlsZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc05lc3RlZExpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAkaXNMaXN0Tm9kZShub2RlLmdldEZpcnN0Q2hpbGQoKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBkZWVwbHkgbmVzdGVkIExpc3ROb2RlIG9yIExpc3RJdGVtTm9kZSBhbmQgdHJhdmVyc2VzIHVwIHRoZSBicmFuY2ggdG8gZGVsZXRlIHRoZSBmaXJzdFxuICogYW5jZXN0cmFsIExpc3ROb2RlICh3aGljaCBjb3VsZCBiZSB0aGUgcm9vdCBMaXN0Tm9kZSkgb3IgTGlzdEl0ZW1Ob2RlIHdpdGggc2libGluZ3MsIGVzc2VudGlhbGx5XG4gKiBicmluZ2luZyB0aGUgZGVlcGx5IG5lc3RlZCBub2RlIHVwIHRoZSBicmFuY2ggb25jZS4gV291bGQgcmVtb3ZlIHN1Ymxpc3QgaWYgaXQgaGFzIHNpYmxpbmdzLlxuICogU2hvdWxkIG5vdCBicmVhayBMaXN0SXRlbSAtPiBMaXN0IC0+IExpc3RJdGVtIGNoYWluIGFzIGVtcHR5IExpc3QvSXRlbU5vZGVzIHNob3VsZCBiZSByZW1vdmVkIG9uIC5yZW1vdmUoKS5cbiAqIEBwYXJhbSBzdWJsaXN0IC0gVGhlIG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgdG8gYmUgYnJvdWdodCB1cCB0aGUgYnJhbmNoLlxuICovXG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGVzdEVtcHR5TGlzdFBhcmVudChzdWJsaXN0KSB7XG4gIC8vIE5vZGVzIG1heSBiZSByZXBlYXRlZGx5IGluZGVudGVkLCB0byBjcmVhdGUgZGVlcGx5IG5lc3RlZCBsaXN0cyB0aGF0IGVhY2hcbiAgLy8gY29udGFpbiBqdXN0IG9uZSBidWxsZXQuXG4gIC8vIE91ciBnb2FsIGlzIHRvIHJlbW92ZSB0aGVzZSAoZW1wdHkpIGRlZXBseSBuZXN0ZWQgbGlzdHMuIFRoZSBlYXNpZXN0XG4gIC8vIHdheSB0byBkbyB0aGF0IGlzIGNyYXdsIGJhY2sgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIG5vZGUgdGhhdCBoYXMgc2libGluZ3NcbiAgLy8gKGUuZy4gaXMgYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBjb250ZW50cykgYW5kIGRlbGV0ZSB0aGF0LCBvciBkZWxldGVcbiAgLy8gdGhlIHJvb3Qgb2YgdGhlIGxpc3QgKGlmIG5vIGxpc3Qgbm9kZXMgaGF2ZSBzaWJsaW5ncy4pXG4gIGxldCBlbXB0eUxpc3RQdHIgPSBzdWJsaXN0O1xuICB3aGlsZSAoZW1wdHlMaXN0UHRyLmdldE5leHRTaWJsaW5nKCkgPT0gbnVsbCAmJiBlbXB0eUxpc3RQdHIuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGVtcHR5TGlzdFB0ci5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09IG51bGwgfHwgISgkaXNMaXN0SXRlbU5vZGUoZW1wdHlMaXN0UHRyKSB8fCAkaXNMaXN0Tm9kZShlbXB0eUxpc3RQdHIpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVtcHR5TGlzdFB0ciA9IHBhcmVudDtcbiAgfVxuICBlbXB0eUxpc3RQdHIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogV3JhcHMgYSBub2RlIGludG8gYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIHdyYXBwZWQgaW50byBhIExpc3RJdGVtTm9kZVxuICogQHJldHVybnMgVGhlIExpc3RJdGVtTm9kZSB3aGljaCB0aGUgcGFzc2VkIG5vZGUgaXMgd3JhcHBlZCBpbi5cbiAqL1xuZnVuY3Rpb24gJHdyYXBJbkxpc3RJdGVtKG5vZGUpIHtcbiAgY29uc3QgbGlzdEl0ZW1XcmFwcGVyID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICByZXR1cm4gbGlzdEl0ZW1XcmFwcGVyLmFwcGVuZChub2RlKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSB7XG4gIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkgJiYgKG5vZGVzLmxlbmd0aCA9PT0gMCB8fCBub2Rlcy5sZW5ndGggPT09IDEgJiYgYW5jaG9yTm9kZS5pcyhub2Rlc1swXSkgJiYgYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCk7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBMaXN0Tm9kZS4gSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZSBhbmQgaXMgYSBjaGlsZCBvZlxuICogdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgcmVwbGFjZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpdGggYSBMaXN0Tm9kZSBhbmQgdGhlIG9sZCBMaXN0SXRlbU5vZGUuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCByZXBsYWNlIGl0cyBwYXJlbnQgd2l0aCBhIG5ldyBMaXN0Tm9kZSBhbmQgcmUtaW5zZXJ0IHRoZSBMaXN0SXRlbU5vZGUgYW5kIGFueSBwcmV2aW91cyBjaGlsZHJlbi5cbiAqIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBub3QgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlLCBpdCB3aWxsIGFkZCBhIG5ldyBMaXN0Tm9kZSBvciBtZXJnZSBhbiBleGlzdGluZyBMaXN0Tm9kZSxcbiAqIHVubGVzcyB0aGUgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBMaXN0Tm9kZSB1cCB0aGUgYnJhbmNoIGFuZCByZXBsYWNlIGl0IHdpdGhcbiAqIGEgbmV3IExpc3ROb2RlLCBvciBjcmVhdGUgYSBuZXcgTGlzdE5vZGUgYXQgdGhlIG5lYXJlc3Qgcm9vdC9zaGFkb3cgcm9vdC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0LCBcIm51bWJlclwiIHwgXCJidWxsZXRcIiB8IFwiY2hlY2tcIi5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0TGlzdChlZGl0b3IsIGxpc3RUeXBlKSB7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgICAgICAgaWYgKCEoYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGluc2VydExpc3Q6IGFuY2hvciBzaG91bGQgYmUgZGVmaW5lZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthbmNob3JdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpKSB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZVBhcmVudCkpIHtcbiAgICAgICAgICAgIGFuY2hvck5vZGUucmVwbGFjZShsaXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgIGxpc3RJdGVtLnNldEZvcm1hdChhbmNob3JOb2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgICAgICAgIGxpc3RJdGVtLnNldEluZGVudChhbmNob3JOb2RlLmdldEluZGVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgICBhcHBlbmQobGlzdCwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2UobGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaGFuZGxlZCA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgJiYgISRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAhaGFuZGxlZC5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAkY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNMZWFmTm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgaWYgKCFoYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgICAgICAgICAgIGFwcGVuZChuZXdMaXN0Tm9kZSwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlKG5ld0xpc3ROb2RlKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QobmV4dFBhcmVudCkgJiYgIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgICAgICRjcmVhdGVMaXN0T3JNZXJnZShwYXJlbnQsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnQgPSBuZXh0UGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhcHBlbmQobm9kZSwgbm9kZXNUb0FwcGVuZCkge1xuICBub2RlLnNwbGljZShub2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBub2Rlc1RvQXBwZW5kKTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVMaXN0T3JNZXJnZShub2RlLCBsaXN0VHlwZSkge1xuICBpZiAoJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gIGxpc3RJdGVtLnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gIGxpc3RJdGVtLnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgYXBwZW5kKGxpc3RJdGVtLCBub2RlLmdldENoaWxkcmVuKCkpO1xuICBpZiAoJGlzTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gcHJldmlvdXNTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBwcmV2aW91c1NpYmxpbmcuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIC8vIGlmIHRoZSBzYW1lIHR5cGUgb2YgbGlzdCBpcyBvbiBib3RoIHNpZGVzLCBtZXJnZSB0aGVtLlxuXG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgICAgYXBwZW5kKHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzU2libGluZztcbiAgfSBlbHNlIGlmICgkaXNMaXN0Tm9kZShuZXh0U2libGluZykgJiYgbGlzdFR5cGUgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmluc2VydEJlZm9yZShsaXN0SXRlbSk7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dFNpYmxpbmc7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgIG5vZGUucmVwbGFjZShsaXN0KTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxufVxuXG4vKipcbiAqIEEgcmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgZ29lcyB0aHJvdWdoIGVhY2ggbGlzdCBhbmQgdGhlaXIgY2hpbGRyZW4sIGluY2x1ZGluZyBuZXN0ZWQgbGlzdHMsXG4gKiBhcHBlbmRpbmcgbGlzdDIgY2hpbGRyZW4gYWZ0ZXIgbGlzdDEgY2hpbGRyZW4gYW5kIHVwZGF0aW5nIExpc3RJdGVtTm9kZSB2YWx1ZXMuXG4gKiBAcGFyYW0gbGlzdDEgLSBUaGUgZmlyc3QgbGlzdCB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0gbGlzdDIgLSBUaGUgc2Vjb25kIGxpc3QgdG8gYmUgbWVyZ2VkLlxuICovXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBjb25zdCBsaXN0SXRlbTEgPSBsaXN0MS5nZXRMYXN0Q2hpbGQoKTtcbiAgY29uc3QgbGlzdEl0ZW0yID0gbGlzdDIuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAobGlzdEl0ZW0xICYmIGxpc3RJdGVtMiAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMSkgJiYgaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbTIpKSB7XG4gICAgbWVyZ2VMaXN0cyhsaXN0SXRlbTEuZ2V0Rmlyc3RDaGlsZCgpLCBsaXN0SXRlbTIuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICBsaXN0SXRlbTIucmVtb3ZlKCk7XG4gIH1cbiAgY29uc3QgdG9NZXJnZSA9IGxpc3QyLmdldENoaWxkcmVuKCk7XG4gIGlmICh0b01lcmdlLmxlbmd0aCA+IDApIHtcbiAgICBsaXN0MS5hcHBlbmQoLi4udG9NZXJnZSk7XG4gIH1cbiAgbGlzdDIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmVtb3ZlcyBpdC4gSWYgc2VsZWN0aW9uIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZVxuICogaXQgd2lsbCByZW1vdmUgdGhlIHdob2xlIGxpc3QsIGluY2x1ZGluZyB0aGUgTGlzdEl0ZW1Ob2RlLiBGb3IgZWFjaCBMaXN0SXRlbU5vZGUgaW4gdGhlIExpc3ROb2RlLFxuICogcmVtb3ZlTGlzdCB3aWxsIGFsc28gZ2VuZXJhdGUgbmV3IFBhcmFncmFwaE5vZGVzIGluIHRoZSByZW1vdmVkIExpc3ROb2RlJ3MgcGxhY2UuIEFueSBjaGlsZCBub2RlXG4gKiBpbnNpZGUgYSBMaXN0SXRlbU5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgbmV3IFBhcmFncmFwaE5vZGVzLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdChlZGl0b3IpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsaXN0Tm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKCRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpKSB7XG4gICAgICAgIGxpc3ROb2Rlcy5hZGQoJGdldFRvcExpc3ROb2RlKGFuY2hvck5vZGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKCRpc0xlYWZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUobm9kZSwgTGlzdEl0ZW1Ob2RlKTtcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBsaXN0Tm9kZXMuYWRkKCRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbU5vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbGlzdE5vZGUgb2YgbGlzdE5vZGVzKSB7XG4gICAgICAgIGxldCBpbnNlcnRpb25Qb2ludCA9IGxpc3ROb2RlO1xuICAgICAgICBjb25zdCBsaXN0SXRlbXMgPSAkZ2V0QWxsTGlzdEl0ZW1zKGxpc3ROb2RlKTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgbGlzdEl0ZW1zKSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICBhcHBlbmQocGFyYWdyYXBoLCBsaXN0SXRlbU5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoKTtcbiAgICAgICAgICBpbnNlcnRpb25Qb2ludCA9IHBhcmFncmFwaDtcblxuICAgICAgICAgIC8vIFdoZW4gdGhlIGFuY2hvciBhbmQgZm9jdXMgZmFsbCBvbiB0aGUgdGV4dE5vZGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgdGhlIHRleHROb2RlIHdpbGwgYmUgYXBwZW5kZWQgdG9cbiAgICAgICAgICAvLyB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaC5cbiAgICAgICAgICAvLyBXaGVuIHNlbGVjdGlvbiBpcyBpbiBlbXB0eSBuZXN0ZWQgbGlzdCBpdGVtLCBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgb24gdGhlIGxpc3RJdGVtTm9kZS5cbiAgICAgICAgICAvLyBXaGVuIHRoZSBjb3JyZXNwb25kaW5nIGxpc3RJdGVtTm9kZSBpcyBkZWxldGVkIGFuZCByZXBsYWNlZCBieSB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaFxuICAgICAgICAgIC8vIHdlIHNob3VsZCBtYW51YWxseSBzZXQgdGhlIHNlbGVjdGlvbidzIGZvY3VzIGFuZCBhbmNob3IgdG8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KHBhcmFncmFwaC5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldChwYXJhZ3JhcGguZ2V0S2V5KCksIDAsICdlbGVtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3RJdGVtTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSB2YWx1ZSBvZiBhIGNoaWxkIExpc3RJdGVtTm9kZSBhbmQgbWFrZXMgaXQgdGhlIHZhbHVlIHRoZSBMaXN0SXRlbU5vZGVcbiAqIHNob3VsZCBiZSBpZiBpdCBpc24ndCBhbHJlYWR5LiBBbHNvIGVuc3VyZXMgdGhhdCBjaGVja2VkIGlzIHVuZGVmaW5lZCBpZiB0aGVcbiAqIHBhcmVudCBkb2VzIG5vdCBoYXZlIGEgbGlzdCB0eXBlIG9mICdjaGVjaycuXG4gKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IHdob3NlIGNoaWxkcmVuIGFyZSB1cGRhdGVkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdCkge1xuICBjb25zdCBpc05vdENoZWNrbGlzdCA9IGxpc3QuZ2V0TGlzdFR5cGUoKSAhPT0gJ2NoZWNrJztcbiAgbGV0IHZhbHVlID0gbGlzdC5nZXRTdGFydCgpO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpc3QuZ2V0Q2hpbGRyZW4oKSkge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQuZ2V0VmFsdWUoKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY2hpbGQuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTm90Q2hlY2tsaXN0ICYmIGNoaWxkLmdldENoZWNrZWQoKSAhPSBudWxsKSB7XG4gICAgICAgIGNoaWxkLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGlmICghJGlzTGlzdE5vZGUoY2hpbGQuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgICAgICB2YWx1ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHRoZSBuZXh0IHNpYmxpbmcgbGlzdCBpZiBzYW1lIHR5cGUuXG4gKiA8dWw+IHdpbGwgbWVyZ2Ugd2l0aCA8dWw+LCBidXQgTk9UIDx1bD4gd2l0aCA8b2w+LlxuICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCB3aG9zZSBuZXh0IHNpYmxpbmcgc2hvdWxkIGJlIHBvdGVudGlhbGx5IG1lcmdlZFxuICovXG5mdW5jdGlvbiBtZXJnZU5leHRTaWJsaW5nTGlzdElmU2FtZVR5cGUobGlzdCkge1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3QuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0LmdldExpc3RUeXBlKCkgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBtZXJnZUxpc3RzKGxpc3QsIG5leHRTaWJsaW5nKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZW1wdHkgTGlzdE5vZGUvTGlzdEl0ZW1Ob2RlIGNoYWluIGF0IGxpc3RJdGVtTm9kZSwgc28gYXMgdG9cbiAqIGNyZWF0ZSBhbiBpbmRlbnQgZWZmZWN0LiBXb24ndCBpbmRlbnQgTGlzdEl0ZW1Ob2RlcyB0aGF0IGhhdmUgYSBMaXN0Tm9kZSBhc1xuICogYSBjaGlsZCwgYnV0IGRvZXMgbWVyZ2Ugc2libGluZyBMaXN0SXRlbU5vZGVzIGlmIG9uZSBoYXMgYSBuZXN0ZWQgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW1Ob2RlIC0gVGhlIExpc3RJdGVtTm9kZSB0byBiZSBpbmRlbnRlZC5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZUluZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuICBjb25zdCByZW1vdmVkID0gbmV3IFNldCgpO1xuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpIHx8IHJlbW92ZWQuaGFzKGxpc3RJdGVtTm9kZS5nZXRLZXkoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuXG4gIC8vIFdlIGNhbiBjYXN0IGJvdGggb2YgdGhlIGJlbG93IGBpc05lc3RlZExpc3ROb2RlYCBvbmx5IHJldHVybnMgYSBib29sZWFuIHR5cGUgaW5zdGVhZCBvZiBhIHVzZXItZGVmaW5lZCB0eXBlIGd1YXJkc1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIC8vIGlmIHRoZXJlIGFyZSBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUsIG1lcmdlIHRoZW0gYWxsIHRvZ2V0aGVyLlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBpbm5lckxpc3QuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgICBjb25zdCBuZXh0SW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKG5leHRJbm5lckxpc3QpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbmV4dElubmVyTGlzdC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBhcHBlbmQoaW5uZXJMaXN0LCBjaGlsZHJlbik7XG4gICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgICByZW1vdmVkLmFkZChuZXh0U2libGluZy5nZXRLZXkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgLy8gaWYgdGhlIExpc3RJdGVtTm9kZSBpcyBuZXh0IHRvIGEgbmVzdGVkIExpc3ROb2RlLCBtZXJnZSB0aGVtXG4gICAgY29uc3QgaW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gaW5uZXJMaXN0LmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBuZXN0ZWQgTGlzdE5vZGVcblxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nLmluc2VydEFmdGVyKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QmVmb3JlKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmQobmV3TGlzdEl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYW4gaW5kZW50IGJ5IHJlbW92aW5nIGFuIGVtcHR5IExpc3ROb2RlL0xpc3RJdGVtTm9kZSBjaGFpbi4gQW4gaW5kZW50ZWQgTGlzdEl0ZW1Ob2RlXG4gKiBoYXMgYSBncmVhdCBncmFuZHBhcmVudCBub2RlIG9mIHR5cGUgTGlzdE5vZGUsIHdoaWNoIGlzIHdoZXJlIHRoZSBMaXN0SXRlbU5vZGUgd2lsbCByZXNpZGVcbiAqIHdpdGhpbiBhcyBhIGNoaWxkLlxuICogQHBhcmFtIGxpc3RJdGVtTm9kZSAtIFRoZSBMaXN0SXRlbU5vZGUgdG8gcmVtb3ZlIHRoZSBpbmRlbnQgKG91dGRlbnQpLlxuICovXG5mdW5jdGlvbiAkaGFuZGxlT3V0ZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50TGlzdCA9IGxpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcbiAgY29uc3QgZ3JhbmRwYXJlbnRMaXN0SXRlbSA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBncmVhdEdyYW5kcGFyZW50TGlzdCA9IGdyYW5kcGFyZW50TGlzdEl0ZW0gPyBncmFuZHBhcmVudExpc3RJdGVtLmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICAvLyBJZiBpdCBkb2Vzbid0IGhhdmUgdGhlc2UgYW5jZXN0b3JzLCBpdCdzIG5vdCBpbmRlbnRlZC5cblxuICBpZiAoJGlzTGlzdE5vZGUoZ3JlYXRHcmFuZHBhcmVudExpc3QpICYmICRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudExpc3RJdGVtKSAmJiAkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGNoaWxkIGluIGl0J3MgcGFyZW50IGxpc3QsIGluc2VydCBpdCBpbnRvIHRoZVxuICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYmVmb3JlIHRoZSBncmFuZHBhcmVudFxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRGaXJzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0TGFzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGxpc3RJdGVtTm9kZS5pcyhmaXJzdENoaWxkKSkge1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgLy8gaWYgaXQncyB0aGUgbGFzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50LlxuICAgIH0gZWxzZSBpZiAobGlzdEl0ZW1Ob2RlLmlzKGxhc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QWZ0ZXIobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gc3BsaXQgdGhlIHNpYmxpbmdzIGludG8gdHdvIG5ldyBuZXN0ZWQgbGlzdHNcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gcGFyZW50TGlzdC5nZXRMaXN0VHlwZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChwcmV2aW91c1NpYmxpbmdzTGlzdCk7XG4gICAgICBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5ncygpLmZvckVhY2goc2libGluZyA9PiBwcmV2aW91c1NpYmxpbmdzTGlzdC5hcHBlbmQoc2libGluZykpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIG5leHRTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChuZXh0U2libGluZ3NMaXN0KTtcbiAgICAgIGFwcGVuZChuZXh0U2libGluZ3NMaXN0LCBsaXN0SXRlbU5vZGUuZ2V0TmV4dFNpYmxpbmdzKCkpO1xuICAgICAgLy8gcHV0IHRoZSBzaWJsaW5nIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZ3JhbmRwYXJlbnQgbGlzdCBpdGVtIGluIHRoZSBncmVhdCBncmFuZHBhcmVudC5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSk7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKG5leHRTaWJsaW5nc0xpc3RJdGVtKTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSAobm93IGJldHdlZW4gdGhlIHNpYmxpbmdzKSB3aXRoIHRoZSBvdXRkZW50ZWQgbGlzdCBpdGVtLlxuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZXBsYWNlKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGEgUGFyYWdyYXBoTm9kZSBhdCBzZWxlY3Rpb24gYW5kIHNlbGVjdHMgdGhlIG5ldyBub2RlLiBUaGUgc2VsZWN0aW9uIG11c3QgY29udGFpbiBhIExpc3RJdGVtTm9kZVxuICogb3IgYSBub2RlIHRoYXQgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIHRleHQuIElmIGl0cyBncmFuZHBhcmVudCBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCBnZXQgdGhlIExpc3ROb2RlXG4gKiAod2hpY2ggc2hvdWxkIGJlIHRoZSBwYXJlbnQgbm9kZSkgYW5kIGluc2VydCB0aGUgUGFyYWdyYXBoTm9kZSBhcyBhIHNpYmxpbmcgdG8gdGhlIExpc3ROb2RlLiBJZiB0aGUgTGlzdE5vZGUgaXNcbiAqIG5lc3RlZCBpbiBhIExpc3RJdGVtTm9kZSBpbnN0ZWFkLCBpdCB3aWxsIGFkZCB0aGUgUGFyYWdyYXBoTm9kZSBhZnRlciB0aGUgZ3JhbmRwYXJlbnQgTGlzdEl0ZW1Ob2RlLlxuICogVGhyb3dzIGFuIGludmFyaWFudCBpZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBhIGNoaWxkIG9mIGEgTGlzdE5vZGUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgUGFyYWdyYXBoTm9kZSB3YXMgaW5zZXJ0ZWQgc3VjY2VzZnVsbHksIGZhbHNlIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvblxuICogb3IgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIGEgTGlzdEl0ZW1Ob2RlIG9yIHRoZSBub2RlIGFscmVhZHkgaG9sZHMgdGV4dC5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPbmx5IHJ1biB0aGlzIGNvZGUgb24gZW1wdHkgbGlzdCBpdGVtc1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCEkaXNMaXN0SXRlbU5vZGUoYW5jaG9yKSB8fCBhbmNob3IuZ2V0Q2hpbGRyZW5TaXplKCkgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9wTGlzdE5vZGUgPSAkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yKTtcbiAgY29uc3QgcGFyZW50ID0gYW5jaG9yLmdldFBhcmVudCgpO1xuICBpZiAoISRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICB9XG4gIGNvbnN0IGdyYW5kcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICBsZXQgcmVwbGFjZW1lbnROb2RlO1xuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZHBhcmVudCkpIHtcbiAgICByZXBsYWNlbWVudE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIHRvcExpc3ROb2RlLmluc2VydEFmdGVyKHJlcGxhY2VtZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICBncmFuZHBhcmVudC5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlbWVudE5vZGUuc2VsZWN0KCk7XG4gIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvci5nZXROZXh0U2libGluZ3MoKTtcbiAgaWYgKG5leHRTaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShwYXJlbnQuZ2V0TGlzdFR5cGUoKSk7XG4gICAgaWYgKCRpc1BhcmFncmFwaE5vZGUocmVwbGFjZW1lbnROb2RlKSkge1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZChuZXdMaXN0KTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgfVxuICAgIG5leHRTaWJsaW5ncy5mb3JFYWNoKHNpYmxpbmcgPT4ge1xuICAgICAgc2libGluZy5yZW1vdmUoKTtcbiAgICAgIG5ld0xpc3QuYXBwZW5kKHNpYmxpbmcpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRG9uJ3QgbGVhdmUgaGFuZ2luZyBuZXN0ZWQgZW1wdHkgbGlzdHNcbiAgJHJlbW92ZUhpZ2hlc3RFbXB0eUxpc3RQYXJlbnQoYW5jaG9yKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaXN0SXRlbU5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaXN0aXRlbSc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IExpc3RJdGVtTm9kZShub2RlLl9fdmFsdWUsIG5vZGUuX19jaGVja2VkLCBub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hlY2tlZCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuICAgIHRoaXMuX19jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJykge1xuICAgICAgdXBkYXRlTGlzdEl0ZW1DaGVja2VkKGVsZW1lbnQsIHRoaXMsIG51bGwpO1xuICAgIH1cbiAgICBlbGVtZW50LnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhlbGVtZW50LCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snKSB7XG4gICAgICB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCB0aGlzLCBwcmV2Tm9kZSk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGFsd2F5cyBIVE1MTGlzdEl0ZW1FbGVtZW50XG4gICAgZG9tLnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgaWYgKCEkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG5vZGUgaXMgbm90IGEgTGlzdEl0ZW1Ob2RlYCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5fX2NoZWNrZWQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKHBhcmVudC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snICYmIG5vZGUuZ2V0Q2hlY2tlZCgpICE9IG51bGwpIHtcbiAgICAgICAgICBub2RlLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGk6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICBub2RlLnNldENoZWNrZWQoc2VyaWFsaXplZE5vZGUuY2hlY2tlZCk7XG4gICAgbm9kZS5zZXRWYWx1ZShzZXJpYWxpemVkTm9kZS52YWx1ZSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jcmVhdGVET00oZWRpdG9yLl9jb25maWcpO1xuICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNoZWNrZWQ6IHRoaXMuZ2V0Q2hlY2tlZCgpLFxuICAgICAgdHlwZTogJ2xpc3RpdGVtJyxcbiAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuICBhcHBlbmQoLi4ubm9kZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdGhpcy5jYW5NZXJnZVdpdGgobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZShyZXBsYWNlV2l0aE5vZGUsIGluY2x1ZGVDaGlsZHJlbikge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbmRlbnQoMCk7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gICAgfVxuICAgIGlmIChsaXN0Ll9fZmlyc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QmVmb3JlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0Ll9fbGFzdCA9PT0gdGhpcy5nZXRLZXkoKSkge1xuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTcGxpdCB0aGUgbGlzdFxuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0LmdldExpc3RUeXBlKCkpO1xuICAgICAgbGV0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUb0FwcGVuZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIG5ld0xpc3QuYXBwZW5kKG5vZGVUb0FwcGVuZCk7XG4gICAgICB9XG4gICAgICBsaXN0Lmluc2VydEFmdGVyKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgICByZXBsYWNlV2l0aE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5jbHVkZUNoaWxkcmVuIHNob3VsZCBvbmx5IGJlIHRydWUgZm9yIEVsZW1lbnROb2Rlc2ApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICByZXBsYWNlV2l0aE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIGlmIChsaXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBsaXN0LnJlbW92ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZVdpdGhOb2RlO1xuICB9XG4gIGluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbGlzdE5vZGUgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QWZ0ZXI6IGxpc3Qgbm9kZSBpcyBub3QgcGFyZW50IG9mIGxpc3QgaXRlbSBub2RlYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5leHRTaWJsaW5ncygpO1xuXG4gICAgLy8gU3BsaXQgdGhlIGxpc3RzIGFuZCBpbnNlcnQgdGhlIG5vZGUgaW4gYmV0d2VlbiB0aGVtXG4gICAgbGlzdE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgaWYgKHNpYmxpbmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdE5vZGUuZ2V0TGlzdFR5cGUoKSk7XG4gICAgICBzaWJsaW5ncy5mb3JFYWNoKHNpYmxpbmcgPT4gbmV3TGlzdE5vZGUuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdE5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBzdXBlci5yZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCk7XG4gICAgaWYgKHByZXZTaWJsaW5nICYmIG5leHRTaWJsaW5nICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldlNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBtZXJnZUxpc3RzKHByZXZTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSwgbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKHRoaXMuX19jaGVja2VkID09IG51bGwgPyB1bmRlZmluZWQgOiBmYWxzZSk7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGlzSW5kZW50ZWQgPSAkaXNMaXN0SXRlbU5vZGUobGlzdE5vZGVQYXJlbnQpO1xuICAgIGlmIChsaXN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgaWYgKGlzSW5kZW50ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxpc3Qgbm9kZSBpcyBuZXN0ZWQsIHdlIGp1c3Qgd2FudCB0byByZW1vdmUgaXQsXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IHVuaW5kZW50aW5nIGl0LlxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgbGlzdE5vZGVQYXJlbnQuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIG9uIHRoZSBsaXN0IGl0ZW0sIHdlJ2xsIG5lZWQgdG8gbW92ZSBpdFxuICAgICAgICAvLyB0byB0aGUgcGFyYWdyYXBoXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJhZ3JhcGguZ2V0S2V5KCk7XG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5nZXROb2RlKCkuaXModGhpcykpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGtleSwgYW5jaG9yLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGZvY3VzLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGZvY3VzLnNldChrZXksIGZvY3VzLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdmFsdWU7XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX192YWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldENoZWNrZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19jaGVja2VkO1xuICB9XG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2NoZWNrZWQgPSBjaGVja2VkO1xuICB9XG4gIHRvZ2dsZUNoZWNrZWQoKSB7XG4gICAgdGhpcy5zZXRDaGVja2VkKCF0aGlzLl9fY2hlY2tlZCk7XG4gIH1cbiAgZ2V0SW5kZW50KCkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIHdlIGFyZSBsaWtlbHkgc2VyaWFsaXppbmdcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faW5kZW50O1xuICAgIH1cbiAgICAvLyBMaXN0SXRlbU5vZGUgc2hvdWxkIGFsd2F5cyBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LlxuICAgIGxldCBsaXN0Tm9kZVBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IGluZGVudExldmVsID0gMDtcbiAgICB3aGlsZSAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3ROb2RlUGFyZW50KSkge1xuICAgICAgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZVBhcmVudC5nZXRQYXJlbnRPclRocm93KCkuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgaW5kZW50TGV2ZWwrKztcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudExldmVsO1xuICB9XG4gIHNldEluZGVudChpbmRlbnQpIHtcbiAgICBpZiAoISh0eXBlb2YgaW5kZW50ID09PSAnbnVtYmVyJyAmJiBpbmRlbnQgPiAtMSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGluZGVudCB2YWx1ZS5gKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZW50ICE9PSBpbmRlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZW50IDwgaW5kZW50KSB7XG4gICAgICAgICRoYW5kbGVJbmRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRoYW5kbGVPdXRkZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50SW5kZW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgKi9cbiAgY2FuUmVwbGFjZVdpdGgocmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VtZW50KTtcbiAgfVxuICBjYW5NZXJnZVdpdGgobm9kZSkge1xuICAgIHJldHVybiAkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpIHx8ICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoID09PSBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gIH1cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgfVxufVxuZnVuY3Rpb24gJHNldExpc3RJdGVtVGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG4gIGNvbnN0IGxpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lID8gbGlzdFRoZW1lLmxpc3RpdGVtIDogdW5kZWZpbmVkO1xuICBsZXQgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWU7XG4gIGlmIChsaXN0VGhlbWUgJiYgbGlzdFRoZW1lLm5lc3RlZCkge1xuICAgIG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lLm5lc3RlZC5saXN0aXRlbTtcbiAgfVxuICBpZiAobGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5vcm1hbGl6ZUNsYXNzTmFtZXMobGlzdEl0ZW1DbGFzc05hbWUpKTtcbiAgfVxuICBpZiAobGlzdFRoZW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgY29uc3QgaXNDaGVja0xpc3QgPSAkaXNMaXN0Tm9kZShwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlLmdldExpc3RUeXBlKCkgPT09ICdjaGVjayc7XG4gICAgY29uc3QgY2hlY2tlZCA9IG5vZGUuZ2V0Q2hlY2tlZCgpO1xuICAgIGlmICghaXNDaGVja0xpc3QgfHwgY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtVW5jaGVja2VkKTtcbiAgICB9XG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCAhY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrTGlzdCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goY2hlY2tlZCA/IGxpc3RUaGVtZS5saXN0aXRlbUNoZWNrZWQgOiBsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cbiAgfVxuICBpZiAobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUpO1xuICAgIGlmIChub2RlLmdldENoaWxkcmVuKCkuc29tZShjaGlsZCA9PiAkaXNMaXN0Tm9kZShjaGlsZCkpKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH1cbiAgfVxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCBsaXN0SXRlbU5vZGUsIHByZXZMaXN0SXRlbU5vZGUsIGxpc3ROb2RlKSB7XG4gIC8vIE9ubHkgYWRkIGF0dHJpYnV0ZXMgZm9yIGxlYWYgbGlzdCBpdGVtc1xuICBpZiAoJGlzTGlzdE5vZGUobGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcbiAgICBpZiAoIXByZXZMaXN0SXRlbU5vZGUgfHwgbGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCAhPT0gcHJldkxpc3RJdGVtTm9kZS5fX2NoZWNrZWQpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIGxpc3RJdGVtTm9kZS5nZXRDaGVja2VkKCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNHaXRIdWJDaGVja0xpc3QgPSBkb21Ob2RlLmNsYXNzTGlzdC5jb250YWlucygndGFzay1saXN0LWl0ZW0nKTtcbiAgaWYgKGlzR2l0SHViQ2hlY2tMaXN0KSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBkb21Ob2RlLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICByZXR1cm4gJGNvbnZlcnRDaGVja2JveElucHV0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYXJpYUNoZWNrZWRBdHRyID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpO1xuICBjb25zdCBjaGVja2VkID0gYXJpYUNoZWNrZWRBdHRyID09PSAndHJ1ZScgPyB0cnVlIDogYXJpYUNoZWNrZWRBdHRyID09PSAnZmFsc2UnID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRDaGVja2JveElucHV0KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNDaGVja2JveElucHV0ID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94JztcbiAgaWYgKCFpc0NoZWNrYm94SW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgY2hlY2tlZCA9IGRvbU5vZGUuaGFzQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGlzdCBJdGVtIG5vZGUsIHBhc3NpbmcgdHJ1ZS9mYWxzZSB3aWxsIGNvbnZlcnQgaXQgdG8gYSBjaGVja2JveCBpbnB1dC5cbiAqIEBwYXJhbSBjaGVja2VkIC0gSXMgdGhlIExpc3QgSXRlbSBhIGNoZWNrYm94IGFuZCwgaWYgc28sIGlzIGl0IGNoZWNrZWQ/IHVuZGVmaW5lZC9udWxsOiBub3QgYSBjaGVja2JveCwgdHJ1ZS9mYWxzZSBpcyBhIGNoZWNrYm94IGFuZCBjaGVja2VkL3VuY2hlY2tlZCwgcmVzcGVjdGl2ZWx5LlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0IEl0ZW0uXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVMaXN0SXRlbU5vZGUoY2hlY2tlZCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0SXRlbU5vZGUodW5kZWZpbmVkLCBjaGVja2VkKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0SXRlbU5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3ROb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpc3QnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgY29uc3QgbGlzdFR5cGUgPSBub2RlLl9fbGlzdFR5cGUgfHwgVEFHX1RPX0xJU1RfVFlQRVtub2RlLl9fdGFnXTtcbiAgICByZXR1cm4gbmV3IExpc3ROb2RlKGxpc3RUeXBlLCBub2RlLl9fc3RhcnQsIG5vZGUuX19rZXkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGxpc3RUeXBlLCBzdGFydCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCBfbGlzdFR5cGUgPSBUQUdfVE9fTElTVF9UWVBFW2xpc3RUeXBlXSB8fCBsaXN0VHlwZTtcbiAgICB0aGlzLl9fbGlzdFR5cGUgPSBfbGlzdFR5cGU7XG4gICAgdGhpcy5fX3RhZyA9IF9saXN0VHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgICB0aGlzLl9fc3RhcnQgPSBzdGFydDtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190YWc7XG4gIH1cbiAgc2V0TGlzdFR5cGUodHlwZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGlzdFR5cGUgPSB0eXBlO1xuICAgIHdyaXRhYmxlLl9fdGFnID0gdHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgfVxuICBnZXRMaXN0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2xpc3RUeXBlO1xuICB9XG4gIGdldFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9fc3RhcnQ7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgX2VkaXRvcikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX190YWc7XG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEludGVybmFsIGZpZWxkLlxuICAgIGRvbS5fX2xleGljYWxMaXN0VHlwZSA9IHRoaXMuX19saXN0VHlwZTtcbiAgICAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgaWYgKHByZXZOb2RlLl9fdGFnICE9PSB0aGlzLl9fdGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgJHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBub2RlID0+IHtcbiAgICAgIGlmICghJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG5vZGUgaXMgbm90IGEgTGlzdE5vZGVgKTtcbiAgICAgIH1cbiAgICAgIG1lcmdlTmV4dFNpYmxpbmdMaXN0SWZTYW1lVHlwZShub2RlKTtcbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShub2RlKTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9sOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydExpc3ROb2RlLFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB1bDogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoc2VyaWFsaXplZE5vZGUubGlzdFR5cGUsIHNlcmlhbGl6ZWROb2RlLnN0YXJ0KTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoZWxlbWVudCAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXJ0ICE9PSAxKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGFydCcsIFN0cmluZyh0aGlzLl9fc3RhcnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbExpc3RUeXBlJywgJ2NoZWNrJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsaXN0VHlwZTogdGhpcy5nZXRMaXN0VHlwZSgpLFxuICAgICAgc3RhcnQ6IHRoaXMuZ2V0U3RhcnQoKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKSxcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzVG9BcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbm9kZXNUb0FwcGVuZFtpXTtcbiAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChjdXJyZW50Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoY2hpbGQpO1xuICB9XG59XG5mdW5jdGlvbiAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGVkaXRvclRoZW1lQ2xhc3Nlcywgbm9kZSkge1xuICBjb25zdCBjbGFzc2VzVG9BZGQgPSBbXTtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gW107XG4gIGNvbnN0IGxpc3RUaGVtZSA9IGVkaXRvclRoZW1lQ2xhc3Nlcy5saXN0O1xuICBpZiAobGlzdFRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsaXN0TGV2ZWxzQ2xhc3NOYW1lcyA9IGxpc3RUaGVtZVtgJHtub2RlLl9fdGFnfURlcHRoYF0gfHwgW107XG4gICAgY29uc3QgbGlzdERlcHRoID0gJGdldExpc3REZXB0aChub2RlKSAtIDE7XG4gICAgY29uc3Qgbm9ybWFsaXplZExpc3REZXB0aCA9IGxpc3REZXB0aCAlIGxpc3RMZXZlbHNDbGFzc05hbWVzLmxlbmd0aDtcbiAgICBjb25zdCBsaXN0TGV2ZWxDbGFzc05hbWUgPSBsaXN0TGV2ZWxzQ2xhc3NOYW1lc1tub3JtYWxpemVkTGlzdERlcHRoXTtcbiAgICBjb25zdCBsaXN0Q2xhc3NOYW1lID0gbGlzdFRoZW1lW25vZGUuX190YWddO1xuICAgIGxldCBuZXN0ZWRMaXN0Q2xhc3NOYW1lO1xuICAgIGNvbnN0IG5lc3RlZExpc3RUaGVtZSA9IGxpc3RUaGVtZS5uZXN0ZWQ7XG4gICAgY29uc3QgY2hlY2tsaXN0Q2xhc3NOYW1lID0gbGlzdFRoZW1lLmNoZWNrbGlzdDtcbiAgICBpZiAobmVzdGVkTGlzdFRoZW1lICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkTGlzdFRoZW1lLmxpc3QpIHtcbiAgICAgIG5lc3RlZExpc3RDbGFzc05hbWUgPSBuZXN0ZWRMaXN0VGhlbWUubGlzdDtcbiAgICB9XG4gICAgaWYgKGxpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2gobGlzdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChjaGVja2xpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCAmJiBub2RlLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGNoZWNrbGlzdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChsaXN0TGV2ZWxDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubm9ybWFsaXplQ2xhc3NOYW1lcyhsaXN0TGV2ZWxDbGFzc05hbWUpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExldmVsc0NsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT09IG5vcm1hbGl6ZWRMaXN0RGVwdGgpIHtcbiAgICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChub2RlLl9fdGFnICsgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lc3RlZExpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1DbGFzc2VzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhuZXN0ZWRMaXN0Q2xhc3NOYW1lKTtcbiAgICAgIGlmIChsaXN0RGVwdGggPiAxKSB7XG4gICAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIG5vcm1hbGl6ZXMgdGhlIGNoaWxkcmVuIG9mIGEgTGlzdE5vZGUgYWZ0ZXIgdGhlIGNvbnZlcnNpb24gZnJvbSBIVE1MLFxuICogZW5zdXJpbmcgdGhhdCB0aGV5IGFyZSBhbGwgTGlzdEl0ZW1Ob2RlcyBhbmQgY29udGFpbiBlaXRoZXIgYSBzaW5nbGUgbmVzdGVkIExpc3ROb2RlXG4gKiBvciBzb21lIG90aGVyIGlubGluZSBjb250ZW50LlxuICovXG5mdW5jdGlvbiAkbm9ybWFsaXplQ2hpbGRyZW4obm9kZXMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZExpc3RJdGVtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaChub2RlKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKCR3cmFwSW5MaXN0SXRlbShjaGlsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaCgkd3JhcEluTGlzdEl0ZW0obm9kZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZExpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGlzRG9tQ2hlY2tsaXN0KGRvbU5vZGUpIHtcbiAgaWYgKGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdfX2xleGljYWxsaXN0dHlwZScpID09PSAnY2hlY2snIHx8XG4gIC8vIGlzIGdpdGh1YiBjaGVja2xpc3RcbiAgZG9tTm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbnRhaW5zLXRhc2stbGlzdCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gaWYgY2hpbGRyZW4gYXJlIGNoZWNrbGlzdCBpdGVtcywgdGhlIG5vZGUgaXMgYSBjaGVja2xpc3QgdWwuIEFwcGxpY2FibGUgZm9yIGdvb2dsZWRvYyBjaGVja2xpc3QgcGFzdGluZy5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBkb21Ob2RlLmNoaWxkTm9kZXMpIHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuaGFzQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGlzdE5vZGUoZG9tTm9kZSkge1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBpZiAobm9kZU5hbWUgPT09ICdvbCcpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3RhcnQgPSBkb21Ob2RlLnN0YXJ0O1xuICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ251bWJlcicsIHN0YXJ0KTtcbiAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ3VsJykge1xuICAgIGlmIChpc0RvbUNoZWNrbGlzdChkb21Ob2RlKSkge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnY2hlY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnYnVsbGV0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6ICRub3JtYWxpemVDaGlsZHJlbixcbiAgICBub2RlXG4gIH07XG59XG5jb25zdCBUQUdfVE9fTElTVF9UWVBFID0ge1xuICBvbDogJ251bWJlcicsXG4gIHVsOiAnYnVsbGV0J1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgTGlzdE5vZGUgb2YgbGlzdFR5cGUuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0IHRvIGJlIGNyZWF0ZWQuIENhbiBiZSAnbnVtYmVyJywgJ2J1bGxldCcsIG9yICdjaGVjaycuXG4gKiBAcGFyYW0gc3RhcnQgLSBXaGVyZSBhbiBvcmRlcmVkIGxpc3Qgc3RhcnRzIGl0cyBjb3VudCwgc3RhcnQgPSAxIGlmIGxlZnQgdW5kZWZpbmVkLlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0Tm9kZVxuICovXG5mdW5jdGlvbiAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUsIHN0YXJ0ID0gMSkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0Tm9kZShsaXN0VHlwZSwgc3RhcnQpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpc3ROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IFJFTU9WRV9MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRU1PVkVfTElTVF9DT01NQU5EJyk7XG5cbmV4cG9ydCB7ICRjcmVhdGVMaXN0SXRlbU5vZGUsICRjcmVhdGVMaXN0Tm9kZSwgJGdldExpc3REZXB0aCwgJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgsICRpc0xpc3RJdGVtTm9kZSwgJGlzTGlzdE5vZGUsIElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQsIElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQsIExpc3RJdGVtTm9kZSwgTGlzdE5vZGUsIFJFTU9WRV9MSVNUX0NPTU1BTkQsIGluc2VydExpc3QsIHJlbW92ZUxpc3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lexical/list/LexicalList.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $isDecoratorBlockNode: () => (/* binding */ $isDecoratorBlockNode),\n/* harmony export */   DecoratorBlockNode: () => (/* binding */ DecoratorBlockNode)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass DecoratorBlockNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.DecoratorNode {\n  constructor(format, key) {\n    super(key);\n    this.__format = format || '';\n  }\n  exportJSON() {\n    return {\n      format: this.__format || '',\n      type: 'decorator-block',\n      version: 1\n    };\n  }\n  canIndent() {\n    return false;\n  }\n  createDOM() {\n    return document.createElement('div');\n  }\n  updateDOM() {\n    return false;\n  }\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = format;\n  }\n  isInline() {\n    return false;\n  }\n}\nfunction $isDecoratorBlockNode(node) {\n  return node instanceof DecoratorBlockNode;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5kZXYubWpzP2U0MjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBEZWNvcmF0b3JOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY2xhc3MgRGVjb3JhdG9yQmxvY2tOb2RlIGV4dGVuZHMgRGVjb3JhdG9yTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGZvcm1hdCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogdGhpcy5fX2Zvcm1hdCB8fCAnJyxcbiAgICAgIHR5cGU6ICdkZWNvcmF0b3ItYmxvY2snLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB9XG4gIHVwZGF0ZURPTSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2V0Rm9ybWF0KGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IGZvcm1hdDtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc0RlY29yYXRvckJsb2NrTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRGVjb3JhdG9yQmxvY2tOb2RlO1xufVxuXG5leHBvcnQgeyAkaXNEZWNvcmF0b3JCbG9ja05vZGUsIERlY29yYXRvckJsb2NrTm9kZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createHeadingNode: () => (/* binding */ $createHeadingNode),\n/* harmony export */   $createQuoteNode: () => (/* binding */ $createQuoteNode),\n/* harmony export */   $isHeadingNode: () => (/* binding */ $isHeadingNode),\n/* harmony export */   $isQuoteNode: () => (/* binding */ $isQuoteNode),\n/* harmony export */   DRAG_DROP_PASTE: () => (/* binding */ DRAG_DROP_PASTE),\n/* harmony export */   HeadingNode: () => (/* binding */ HeadingNode),\n/* harmony export */   QuoteNode: () => (/* binding */ QuoteNode),\n/* harmony export */   eventFiles: () => (/* binding */ eventFiles),\n/* harmony export */   registerRichText: () => (/* binding */ registerRichText)\n/* harmony export */ });\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(rsc)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet === this.getTextContentSize() || !selection ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const clipboardData = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, InputEvent) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      selection.removeText();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(target);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().getChildrenSize();\n}\nfunction registerRichText(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(dataTransfer, selection, editor);\n      } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REMOVE_TEXT_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_TAB_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$insertNodes)([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, true);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, false);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, false)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode)) {\n      const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestBlockElementAncestorOrThrow)(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ENTER_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n        if (node !== null) {\n          const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(selection);\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(eventRange.node);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECT_ALL_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll)();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, event => {\n    (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionCapturedInDecoratorInput)(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUY7QUFDUztBQUN3RTtBQUN5MkI7O0FBRS9nQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQWE7QUFDckM7QUFDQSx3QkFBd0IsZ0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixzREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxx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QUF1QiwwQkFBMEIsa0RBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNEVBQW1DO0FBQzNDO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUI7QUFDNUI7QUFDQTs7QUFFcUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWxhdGVzdC1zdGFydGVyLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JpY2gtdGV4dC9MZXhpY2FsUmljaFRleHQuZGV2Lm1qcz9iNmYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0LCBjb3B5VG9DbGlwYm9hcmQgfSBmcm9tICdAbGV4aWNhbC9jbGlwYm9hcmQnO1xuaW1wb3J0IHsgJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbiwgJG1vdmVDaGFyYWN0ZXIgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgb2JqZWN0S2xhc3NFcXVhbHMsIG1lcmdlUmVnaXN0ZXIsICRmaW5kTWF0Y2hpbmdQYXJlbnQsICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93IH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ29tbWFuZCwgRWxlbWVudE5vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsIENMSUNLX0NPTU1BTkQsICRnZXRTZWxlY3Rpb24sICRpc05vZGVTZWxlY3Rpb24sIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgJGlzUmFuZ2VTZWxlY3Rpb24sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIFJFTU9WRV9URVhUX0NPTU1BTkQsIEZPUk1BVF9URVhUX0NPTU1BTkQsIEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsICRpc0VsZW1lbnROb2RlLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIElOU0VSVF9UQUJfQ09NTUFORCwgJGluc2VydE5vZGVzLCAkY3JlYXRlVGFiTm9kZSwgSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIEtFWV9BUlJPV19VUF9DT01NQU5ELCAkZ2V0QWRqYWNlbnROb2RlLCAkaXNEZWNvcmF0b3JOb2RlLCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCAkaXNSb290Tm9kZSwgS0VZX0RFTEVURV9DT01NQU5ELCBLRVlfRU5URVJfQ09NTUFORCwgS0VZX0VTQ0FQRV9DT01NQU5ELCBEUk9QX0NPTU1BTkQsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24sICRpc1RleHROb2RlLCAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwsICRzZXRTZWxlY3Rpb24sIERSQUdTVEFSVF9DT01NQU5ELCBEUkFHT1ZFUl9DT01NQU5ELCBTRUxFQ1RfQUxMX0NPTU1BTkQsICRzZWxlY3RBbGwsIENPUFlfQ09NTUFORCwgQ1VUX0NPTU1BTkQsIFBBU1RFX0NPTU1BTkQsIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0LCAkZ2V0Um9vdCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KHgsIHkpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICBvZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBAdHMtaWdub3JlIEZGIC0gbm8gdHlwZXNcbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IHJhbmdlLm9mZnNldE5vZGUsXG4gICAgICBvZmZzZXQ6IHJhbmdlLm9mZnNldFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgSUVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBEUkFHX0RST1BfUEFTVEUgPSBjcmVhdGVDb21tYW5kKCdEUkFHX0RST1BfUEFTVEVfRklMRScpO1xuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFF1b3RlTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdxdW90ZSc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFF1b3RlTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnF1b3RlKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja3F1b3RlOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0QmxvY2txdW90ZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGVsZW1lbnQgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3F1b3RlJ1xuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdGlvblxuXG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBuZXdCbG9jayA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdCbG9jay5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0Jsb2NrLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3QmxvY2s7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgdGhpcy5yZXBsYWNlKHBhcmFncmFwaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVRdW90ZU5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFF1b3RlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1F1b3RlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUXVvdGVOb2RlO1xufVxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIEhlYWRpbmdOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdoZWFkaW5nJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUobm9kZS5fX3RhZywgbm9kZS5fX2tleSk7XG4gIH1cbiAgY29uc3RydWN0b3IodGFnLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190YWcgPSB0YWc7XG4gIH1cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGFnO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLl9fdGFnO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHRoZW1lLmhlYWRpbmc7XG4gICAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1t0YWddO1xuICAgICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoMTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoMjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoMzogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBwOiBub2RlID0+IHtcbiAgICAgICAgLy8gZG9tTm9kZSBpcyBhIDxwPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gICAgICAgIGNvbnN0IHBhcmFncmFwaCA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJhZ3JhcGguZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwgJiYgaXNHb29nbGVEb2NzVGl0bGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogKCkgPT4gKHtcbiAgICAgICAgICAgICAgbm9kZTogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgc3Bhbjogbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc0dvb2dsZURvY3NUaXRsZShub2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBkb21Ob2RlID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub2RlOiAkY3JlYXRlSGVhZGluZ05vZGUoJ2gxJylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBpZiAoZWxlbWVudCAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtYXRUeXBlID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgICBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9IGZvcm1hdFR5cGU7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVIZWFkaW5nTm9kZShzZXJpYWxpemVkTm9kZS50YWcpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKSxcbiAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgLy8gTXV0YXRpb25cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGFuY2hvck9mZmV0ID0gc2VsZWN0aW9uID8gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgOiAwO1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBhbmNob3JPZmZldCA9PT0gdGhpcy5nZXRUZXh0Q29udGVudFNpemUoKSB8fCAhc2VsZWN0aW9uID8gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSA6ICRjcmVhdGVIZWFkaW5nTm9kZSh0aGlzLmdldFRhZygpKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIG5ld0VsZW1lbnQuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICBpZiAoYW5jaG9yT2ZmZXQgPT09IDAgJiYgIXRoaXMuaXNFbXB0eSgpICYmIHNlbGVjdGlvbikge1xuICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgIHRoaXMucmVwbGFjZShwYXJhZ3JhcGgsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICF0aGlzLmlzRW1wdHkoKSA/ICRjcmVhdGVIZWFkaW5nTm9kZSh0aGlzLmdldFRhZygpKSA6ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBuZXdFbGVtZW50LmFwcGVuZChjaGlsZCkpO1xuICAgIHRoaXMucmVwbGFjZShuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBpc0dvb2dsZURvY3NUaXRsZShkb21Ob2RlKSB7XG4gIGlmIChkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzcGFuJykge1xuICAgIHJldHVybiBkb21Ob2RlLnN0eWxlLmZvbnRTaXplID09PSAnMjZwdCc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRIZWFkaW5nRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbm9kZSA9IG51bGw7XG4gIGlmIChub2RlTmFtZSA9PT0gJ2gxJyB8fCBub2RlTmFtZSA9PT0gJ2gyJyB8fCBub2RlTmFtZSA9PT0gJ2gzJyB8fCBub2RlTmFtZSA9PT0gJ2g0JyB8fCBub2RlTmFtZSA9PT0gJ2g1JyB8fCBub2RlTmFtZSA9PT0gJ2g2Jykge1xuICAgIG5vZGUgPSAkY3JlYXRlSGVhZGluZ05vZGUobm9kZU5hbWUpO1xuICAgIGlmIChlbGVtZW50LnN0eWxlICE9PSBudWxsKSB7XG4gICAgICBub2RlLnNldEZvcm1hdChlbGVtZW50LnN0eWxlLnRleHRBbGlnbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRCbG9ja3F1b3RlRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG4gIGlmIChlbGVtZW50LnN0eWxlICE9PSBudWxsKSB7XG4gICAgbm9kZS5zZXRGb3JtYXQoZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUhlYWRpbmdOb2RlKGhlYWRpbmdUYWcpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgSGVhZGluZ05vZGUoaGVhZGluZ1RhZykpO1xufVxuZnVuY3Rpb24gJGlzSGVhZGluZ05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhlYWRpbmdOb2RlO1xufVxuZnVuY3Rpb24gb25QYXN0ZUZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBvYmplY3RLbGFzc0VxdWFscyhldmVudCwgSW5wdXRFdmVudCkgfHwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIEtleWJvYXJkRXZlbnQpID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGNsaXBib2FyZERhdGEgIT0gbnVsbCAmJiBzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChjbGlwYm9hcmREYXRhLCBzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAgdGFnOiAncGFzdGUnXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gb25DdXRGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGF3YWl0IGNvcHlUb0NsaXBib2FyZChlZGl0b3IsIG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkgPyBldmVudCA6IG51bGwpO1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5nZXROb2RlcygpLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBDbGlwYm9hcmQgbWF5IGNvbnRhaW4gZmlsZXMgdGhhdCB3ZSBhcmVuJ3QgYWxsb3dlZCB0byByZWFkLiBXaGlsZSB0aGUgZXZlbnQgaXMgYXJndWFibHkgdXNlbGVzcyxcbi8vIGluIGNlcnRhaW4gb2NjYXNpb25zLCB3ZSB3YW50IHRvIGtub3cgd2hldGhlciBpdCB3YXMgYSBmaWxlIHRyYW5zZmVyLCBhcyBvcHBvc2VkIHRvIHRleHQuIFdlXG4vLyBjb250cm9sIHRoaXMgd2l0aCB0aGUgZmlyc3QgYm9vbGVhbiBmbGFnLlxuZnVuY3Rpb24gZXZlbnRGaWxlcyhldmVudCkge1xuICBsZXQgZGF0YVRyYW5zZmVyID0gbnVsbDtcbiAgaWYgKG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBEcmFnRXZlbnQpKSB7XG4gICAgZGF0YVRyYW5zZmVyID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICB9IGVsc2UgaWYgKG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICBkYXRhVHJhbnNmZXIgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICB9XG4gIGlmIChkYXRhVHJhbnNmZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCBbXSwgZmFsc2VdO1xuICB9XG4gIGNvbnN0IHR5cGVzID0gZGF0YVRyYW5zZmVyLnR5cGVzO1xuICBjb25zdCBoYXNGaWxlcyA9IHR5cGVzLmluY2x1ZGVzKCdGaWxlcycpO1xuICBjb25zdCBoYXNDb250ZW50ID0gdHlwZXMuaW5jbHVkZXMoJ3RleHQvaHRtbCcpIHx8IHR5cGVzLmluY2x1ZGVzKCd0ZXh0L3BsYWluJyk7XG4gIHJldHVybiBbaGFzRmlsZXMsIEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSwgaGFzQ29udGVudF07XG59XG5mdW5jdGlvbiAkaGFuZGxlSW5kZW50QW5kT3V0ZGVudChpbmRlbnRPck91dGRlbnQpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxyZWFkeUhhbmRsZWQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgY29uc3Qga2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICBpZiAoYWxyZWFkeUhhbmRsZWQuaGFzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRCbG9jayA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50Tm9kZSA9PiAkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSAmJiAhcGFyZW50Tm9kZS5pc0lubGluZSgpKTtcbiAgICBpZiAocGFyZW50QmxvY2sgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnRCbG9jay5nZXRLZXkoKTtcbiAgICBpZiAocGFyZW50QmxvY2suY2FuSW5kZW50KCkgJiYgIWFscmVhZHlIYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICBhbHJlYWR5SGFuZGxlZC5hZGQocGFyZW50S2V5KTtcbiAgICAgIGluZGVudE9yT3V0ZGVudChwYXJlbnRCbG9jayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbHJlYWR5SGFuZGxlZC5zaXplID4gMDtcbn1cbmZ1bmN0aW9uICRpc1RhcmdldFdpdGhpbkRlY29yYXRvcih0YXJnZXQpIHtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKHRhcmdldCk7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uQXRFbmRPZlJvb3Qoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICByZXR1cm4gZm9jdXMua2V5ID09PSAncm9vdCcgJiYgZm9jdXMub2Zmc2V0ID09PSAkZ2V0Um9vdCgpLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJSaWNoVGV4dChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xJQ0tfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgMCksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVDaGFyYWN0ZXIoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChERUxFVEVfV09SRF9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVXb3JkKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoREVMRVRFX0xJTkVfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZGVsZXRlTGluZShpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnRPclRleHQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAodHlwZW9mIGV2ZW50T3JUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChldmVudE9yVGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YVRyYW5zZmVyID0gZXZlbnRPclRleHQuZGF0YVRyYW5zZmVyO1xuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAhPSBudWxsKSB7XG4gICAgICAgICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnRPclRleHQuZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRU1PVkVfVEVYVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9STUFUX1RFWFRfQ09NTUFORCwgZm9ybWF0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5mb3JtYXRUZXh0KGZvcm1hdCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBmb3JtYXQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgISRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgY29uc3QgZWxlbWVudCA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50Tm9kZSA9PiAkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSAmJiAhcGFyZW50Tm9kZS5pc0lubGluZSgpKTtcbiAgICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgc2VsZWN0U3RhcnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmluc2VydExpbmVCcmVhayhzZWxlY3RTdGFydCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9UQUJfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnROb2RlcyhbJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgKCkgPT4ge1xuICAgIHJldHVybiAkaGFuZGxlSW5kZW50QW5kT3V0ZGVudChibG9jayA9PiB7XG4gICAgICBjb25zdCBpbmRlbnQgPSBibG9jay5nZXRJbmRlbnQoKTtcbiAgICAgIGJsb2NrLnNldEluZGVudChpbmRlbnQgKyAxKTtcbiAgICB9KTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKE9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgcmV0dXJuICRoYW5kbGVJbmRlbnRBbmRPdXRkZW50KGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGluZGVudCA9IGJsb2NrLmdldEluZGVudCgpO1xuICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgYmxvY2suc2V0SW5kZW50KGluZGVudCAtIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSAkZ2V0QWRqYWNlbnROb2RlKHNlbGVjdGlvbi5mb2N1cywgdHJ1ZSk7XG4gICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmICRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzU2VsZWN0aW9uQXRFbmRPZlJvb3Qoc2VsZWN0aW9uKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBmYWxzZSk7XG4gICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmICRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBub2Rlc1swXS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc0hvbGRpbmdTaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmICgkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgZmFsc2UpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGlmICgkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgYW5jaG9yLm9mZnNldCA9PT0gMCAmJiAhJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyhhbmNob3JOb2RlKTtcbiAgICAgIGlmIChlbGVtZW50LmdldEluZGVudCgpID4gMCkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGlmICgkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGJlZm9yZWlucHV0LCB0aGVuIHdlIGNhbiBhdm9pZCBibG9ja2luZ1xuICAgICAgLy8gdGhlIGRlZmF1bHQgYmVoYXZpb3IuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBpT1MgY2FuXG4gICAgICAvLyBpbnRlcmNlcHQgdGhhdCB3ZSdyZSBhY3R1YWxseSBpbnNlcnRpbmcgYSBwYXJhZ3JhcGgsXG4gICAgICAvLyBhbmQgYXV0b2NvbXBsZXRlLCBhdXRvY2FwaXRhbGl6ZSBldGMgd29yayBhcyBpbnRlbmRlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGFsc28gY2F1c2UgYSBzdHJhbmdlIHBlcmZvcm1hbmNlIGlzc3VlIGluXG4gICAgICAvLyBTYWZhcmksIHdoZXJlIHRoZXJlIGlzIGEgbm90aWNlYWJsZSBwYXVzZSBkdWUgdG9cbiAgICAgIC8vIHByZXZlbnRpbmcgdGhlIGtleSBkb3duIG9mIGVudGVyLlxuICAgICAgaWYgKChJU19JT1MgfHwgSVNfU0FGQVJJIHx8IElTX0FQUExFX1dFQktJVCkgJiYgQ0FOX1VTRV9CRUZPUkVfSU5QVVQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FU0NBUEVfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWRpdG9yLmJsdXIoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERST1BfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFssIGZpbGVzXSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgY29uc3QgZXZlbnRSYW5nZSA9IGNhcmV0RnJvbVBvaW50KHgsIHkpO1xuICAgICAgaWYgKGV2ZW50UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9mZnNldDogZG9tT2Zmc2V0LFxuICAgICAgICAgIG5vZGU6IGRvbU5vZGVcbiAgICAgICAgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShkb21Ob2RlKTtcbiAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KG5vZGUuZ2V0S2V5KCksIGRvbU9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQobm9kZS5nZXRLZXkoKSwgZG9tT2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKS5nZXRLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChwYXJlbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQocGFyZW50S2V5LCBvZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwoc2VsZWN0aW9uKTtcbiAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5vcm1hbGl6ZWRTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERSQUdTVEFSVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgW2lzRmlsZVRyYW5zZmVyXSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoaXNGaWxlVHJhbnNmZXIgJiYgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChEUkFHT1ZFUl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgW2lzRmlsZVRyYW5zZmVyXSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoaXNGaWxlVHJhbnNmZXIgJiYgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgY29uc3QgZXZlbnRSYW5nZSA9IGNhcmV0RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChldmVudFJhbmdlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZXZlbnRSYW5nZS5ub2RlKTtcbiAgICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgICAgIC8vIFNob3cgYnJvd3NlciBjYXJldCBhcyB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgbWVkaWEgYWNyb3NzIHRoZSBzY3JlZW4uIFdvbid0IHdvcmtcbiAgICAgICAgLy8gZm9yIERlY29yYXRvck5vZGUgbm9yIGl0J3MgcmVsZXZhbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUX0FMTF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJHNlbGVjdEFsbCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ09QWV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIENsaXBib2FyZEV2ZW50KSA/IGV2ZW50IDogbnVsbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIG9uQ3V0Rm9yUmljaFRleHQoZXZlbnQsIGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChQQVNURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgWywgZmlsZXMsIGhhc1RleHRDb250ZW50XSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuICAgIGlmIChmaWxlcy5sZW5ndGggPiAwICYmICFoYXNUZXh0Q29udGVudCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChEUkFHX0RST1BfUEFTVEUsIGZpbGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGlucHV0cyB0aGVuIHBhc3RlIHdpdGhpbiB0aGUgaW5wdXQgaWdub3JlIGNyZWF0aW5nIGEgbmV3IG5vZGUgb24gcGFzdGUgZXZlbnRcbiAgICBpZiAoaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgb25QYXN0ZUZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpKTtcbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlSGVhZGluZ05vZGUsICRjcmVhdGVRdW90ZU5vZGUsICRpc0hlYWRpbmdOb2RlLCAkaXNRdW90ZU5vZGUsIERSQUdfRFJPUF9QQVNURSwgSGVhZGluZ05vZGUsIFF1b3RlTm9kZSwgZXZlbnRGaWxlcywgcmVnaXN0ZXJSaWNoVGV4dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* binding */ $cloneWithProperties),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* binding */ $selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\nfunction $updateParagraphNodeProperties(target, source) {\n  target.__textFormat = source.__textFormat;\n  return target;\n}\n\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor;\n  // @ts-expect-error\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(clone)) {\n    return $updateParagraphNodeProperties(clone, node);\n  }\n  return clone;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value instanceof Function) {\n      styles[key] = value(prevStyles[key]);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }. Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        if (isBefore) {\n          anchor.set(firstNode.getKey(), startOffset, 'text');\n        } else {\n          focus.set(firstNode.getKey(), startOffset, 'text');\n        }\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected, split it\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, isBackward);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstNode)) {\n    firstType = 'text';\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n    return false;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9UOztBQUVwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsbURB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O0FBQ2pCO0FBQ0EsSUFBSSxVQUFVLHVEQUFjO0FBQzVCO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJLFVBQVUsdURBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seURBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPLHVEQUFjLFVBQVUsNERBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBZ0IsZ0JBQWdCLG9EQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsa0NBQWtDO0FBQzlEOztBQUVvWiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcz9jMDcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGlzVGV4dE5vZGUsICRpc0VsZW1lbnROb2RlLCAkaXNQYXJhZ3JhcGhOb2RlLCAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cywgJGlzUm9vdE5vZGUsICRnZXROb2RlQnlLZXksICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGNyZWF0ZVRleHROb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGdldFJvb3QsICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRoYXNBbmNlc3RvciwgJGlzTGVhZk5vZGUsICRzZXRTZWxlY3Rpb24sICRnZXRBZGphY2VudE5vZGUsICRpc0RlY29yYXRvck5vZGUsICRpc0xpbmVCcmVha05vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ1NTX1RPX1NUWUxFUyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBnZXRET01UZXh0Tm9kZShlbGVtZW50KSB7XG4gIGxldCBub2RlID0gZWxlbWVudDtcbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRET01JbmRleFdpdGhpblBhcmVudChub2RlKSB7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgaGFwcGVuJyk7XG4gIH1cbiAgcmV0dXJuIFtwYXJlbnQsIEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpLmluZGV4T2Yobm9kZSldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZWxlY3Rpb24gcmFuZ2UgZm9yIHRoZSBET00uXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGFuY2hvck5vZGUgLSBUaGUgYW5jaG9yIG5vZGUgb2YgYSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0gX2FuY2hvck9mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGFuY2hvciB0byB0aGUgZm9jdXMuXG4gKiBAcGFyYW0gZm9jdXNOb2RlIC0gVGhlIGN1cnJlbnQgZm9jdXMuXG4gKiBAcGFyYW0gX2ZvY3VzT2Zmc2V0IC0gVGhlIGFtb3VudCBvZiBzcGFjZSBvZmZzZXQgZnJvbSB0aGUgZm9jdXMgdG8gdGhlIGFuY2hvci5cbiAqIEByZXR1cm5zIFRoZSByYW5nZSBvZiBzZWxlY3Rpb24gZm9yIHRoZSBET00gdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NUmFuZ2UoZWRpdG9yLCBhbmNob3JOb2RlLCBfYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIF9mb2N1c09mZnNldCkge1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3JOb2RlLmdldEtleSgpO1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBsZXQgYW5jaG9yRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpO1xuICBsZXQgZm9jdXNET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGZvY3VzS2V5KTtcbiAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gIGxldCBmb2N1c09mZnNldCA9IF9mb2N1c09mZnNldDtcbiAgaWYgKCRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgYW5jaG9yRE9NID0gZ2V0RE9NVGV4dE5vZGUoYW5jaG9yRE9NKTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUoZm9jdXNOb2RlKSkge1xuICAgIGZvY3VzRE9NID0gZ2V0RE9NVGV4dE5vZGUoZm9jdXNET00pO1xuICB9XG4gIGlmIChhbmNob3JOb2RlID09PSB1bmRlZmluZWQgfHwgZm9jdXNOb2RlID09PSB1bmRlZmluZWQgfHwgYW5jaG9yRE9NID09PSBudWxsIHx8IGZvY3VzRE9NID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGFuY2hvckRPTS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgIFthbmNob3JET00sIGFuY2hvck9mZnNldF0gPSBnZXRET01JbmRleFdpdGhpblBhcmVudChhbmNob3JET00pO1xuICB9XG4gIGlmIChmb2N1c0RPTS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgIFtmb2N1c0RPTSwgZm9jdXNPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoZm9jdXNET00pO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBhbmNob3JET00uZmlyc3RDaGlsZDtcbiAgaWYgKGFuY2hvckRPTSA9PT0gZm9jdXNET00gJiYgZmlyc3RDaGlsZCAhPSBudWxsICYmIGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09ICdCUicgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGZvY3VzT2Zmc2V0ID09PSAwKSB7XG4gICAgZm9jdXNPZmZzZXQgPSAxO1xuICB9XG4gIHRyeSB7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChmb2N1c0RPTSwgZm9jdXNPZmZzZXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHJhbmdlLmNvbGxhcHNlZCAmJiAoYW5jaG9yT2Zmc2V0ICE9PSBmb2N1c09mZnNldCB8fCBhbmNob3JLZXkgIT09IGZvY3VzS2V5KSkge1xuICAgIC8vIFJhbmdlIGlzIGJhY2t3YXJkcywgd2UgbmVlZCB0byByZXZlcnNlIGl0XG4gICAgcmFuZ2Uuc2V0U3RhcnQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpO1xuICB9XG4gIHJldHVybiByYW5nZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIERPTVJlY3RzLCBnZW5lcmFsbHkgdXNlZCB0byBoZWxwIHRoZSBlZGl0b3IgZmluZCBhIHNwZWNpZmljIGxvY2F0aW9uIG9uIHRoZSBzY3JlZW4uXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gcmFuZ2UgLSBBIGZyYWdtZW50IG9mIGEgZG9jdW1lbnQgdGhhdCBjYW4gY29udGFpbiBub2RlcyBhbmQgcGFydHMgb2YgdGV4dCBub2Rlcy5cbiAqIEByZXR1cm5zIFRoZSBzZWxlY3Rpb25SZWN0cyBhcyBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgcm9vdFJlY3QgPSByb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocm9vdEVsZW1lbnQpO1xuICBjb25zdCByb290UGFkZGluZyA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgY29uc3Qgc2VsZWN0aW9uUmVjdHMgPSBBcnJheS5mcm9tKHJhbmdlLmdldENsaWVudFJlY3RzKCkpO1xuICBsZXQgc2VsZWN0aW9uUmVjdHNMZW5ndGggPSBzZWxlY3Rpb25SZWN0cy5sZW5ndGg7XG4gIC8vc29ydCByZWN0cyBmcm9tIHRvcCBsZWZ0IHRvIGJvdHRvbSByaWdodC5cbiAgc2VsZWN0aW9uUmVjdHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHRvcCA9IGEudG9wIC0gYi50b3A7XG4gICAgLy8gU29tZSByZWN0cyBtYXRjaCBwb3NpdGlvbiBjbG9zZWx5LCBidXQgbm90IHBlcmZlY3RseSxcbiAgICAvLyBzbyB3ZSBnaXZlIGEgM3B4IHRvbGVyYW5jZS5cbiAgICBpZiAoTWF0aC5hYnModG9wKSA8PSAzKSB7XG4gICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gdG9wO1xuICB9KTtcbiAgbGV0IHByZXZSZWN0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvblJlY3RzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWxlY3Rpb25SZWN0ID0gc2VsZWN0aW9uUmVjdHNbaV07XG4gICAgLy8gRXhjbHVkZSByZWN0cyB0aGF0IG92ZXJsYXAgcHJlY2VkaW5nIFJlY3RzIGluIHRoZSBzb3J0ZWQgbGlzdC5cbiAgICBjb25zdCBpc092ZXJsYXBwaW5nUmVjdCA9IHByZXZSZWN0ICYmIHByZXZSZWN0LnRvcCA8PSBzZWxlY3Rpb25SZWN0LnRvcCAmJiBwcmV2UmVjdC50b3AgKyBwcmV2UmVjdC5oZWlnaHQgPiBzZWxlY3Rpb25SZWN0LnRvcCAmJiBwcmV2UmVjdC5sZWZ0ICsgcHJldlJlY3Qud2lkdGggPiBzZWxlY3Rpb25SZWN0LmxlZnQ7XG4gICAgLy8gRXhjbHVkZSBzZWxlY3Rpb25zIHRoYXQgc3BhbiB0aGUgZW50aXJlIGVsZW1lbnRcbiAgICBjb25zdCBzZWxlY3Rpb25TcGFuc0VsZW1lbnQgPSBzZWxlY3Rpb25SZWN0LndpZHRoICsgcm9vdFBhZGRpbmcgPT09IHJvb3RSZWN0LndpZHRoO1xuICAgIGlmIChpc092ZXJsYXBwaW5nUmVjdCB8fCBzZWxlY3Rpb25TcGFuc0VsZW1lbnQpIHtcbiAgICAgIHNlbGVjdGlvblJlY3RzLnNwbGljZShpLS0sIDEpO1xuICAgICAgc2VsZWN0aW9uUmVjdHNMZW5ndGgtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwcmV2UmVjdCA9IHNlbGVjdGlvblJlY3Q7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGlvblJlY3RzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcyBwcm92aWRlZCBpbiB0aGUgQ1NTIHN0cmluZy5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHN0cmluZyBvZiBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqIEByZXR1cm5zIFRoZSBzdHlsZU9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpIHtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSB7fTtcbiAgY29uc3Qgc3R5bGVzID0gY3NzLnNwbGl0KCc7Jyk7XG4gIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gc3R5bGUuc3BsaXQoLzooW15dKykvKTsgLy8gc3BsaXQgb24gZmlyc3QgY29sb25cbiAgICAgIGlmIChrZXkgJiYgdmFsdWUpIHtcbiAgICAgICAgc3R5bGVPYmplY3Rba2V5LnRyaW0oKV0gPSB2YWx1ZS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZU9iamVjdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIENTUyBzdHJpbmcsIHJldHVybnMgYW4gb2JqZWN0IGZyb20gdGhlIHN0eWxlIGNhY2hlLlxuICogQHBhcmFtIGNzcyAtIFRoZSBDU1MgcHJvcGVydHkgYXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIENTUyBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcykge1xuICBsZXQgdmFsdWUgPSBDU1NfVE9fU1RZTEVTLmdldChjc3MpO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKGNzcyk7XG4gICAgQ1NTX1RPX1NUWUxFUy5zZXQoY3NzLCB2YWx1ZSk7XG4gIH1cbiAge1xuICAgIC8vIEZyZWV6ZSB0aGUgdmFsdWUgaW4gREVWIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbnNcbiAgICBPYmplY3QuZnJlZXplKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgQ1NTIHN0eWxlcyBmcm9tIHRoZSBzdHlsZSBvYmplY3QuXG4gKiBAcGFyYW0gc3R5bGVzIC0gVGhlIHN0eWxlIG9iamVjdCBjb250YWluaW5nIHRoZSBzdHlsZXMgdG8gZ2V0LlxuICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgQ1NTIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRDU1NGcm9tU3R5bGVPYmplY3Qoc3R5bGVzKSB7XG4gIGxldCBjc3MgPSAnJztcbiAgZm9yIChjb25zdCBzdHlsZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGNzcyArPSBgJHtzdHlsZX06ICR7c3R5bGVzW3N0eWxlXX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNzcztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gJHVwZGF0ZUVsZW1lbnROb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX19maXJzdCA9IHNvdXJjZS5fX2ZpcnN0O1xuICB0YXJnZXQuX19sYXN0ID0gc291cmNlLl9fbGFzdDtcbiAgdGFyZ2V0Ll9fc2l6ZSA9IHNvdXJjZS5fX3NpemU7XG4gIHRhcmdldC5fX2Zvcm1hdCA9IHNvdXJjZS5fX2Zvcm1hdDtcbiAgdGFyZ2V0Ll9faW5kZW50ID0gc291cmNlLl9faW5kZW50O1xuICB0YXJnZXQuX19kaXIgPSBzb3VyY2UuX19kaXI7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiAkdXBkYXRlVGV4dE5vZGVQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlKSB7XG4gIHRhcmdldC5fX2Zvcm1hdCA9IHNvdXJjZS5fX2Zvcm1hdDtcbiAgdGFyZ2V0Ll9fc3R5bGUgPSBzb3VyY2UuX19zdHlsZTtcbiAgdGFyZ2V0Ll9fbW9kZSA9IHNvdXJjZS5fX21vZGU7XG4gIHRhcmdldC5fX2RldGFpbCA9IHNvdXJjZS5fX2RldGFpbDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uICR1cGRhdGVQYXJhZ3JhcGhOb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX190ZXh0Rm9ybWF0ID0gc291cmNlLl9fdGV4dEZvcm1hdDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgY29weSBvZiBhIG5vZGUsIGJ1dCBnZW5lcmF0ZXMgYSBuZXcga2V5IGZvciB0aGUgY29weS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgVGhlIGNsb25lIG9mIHRoZSBub2RlLlxuICovXG5mdW5jdGlvbiAkY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gbm9kZS5jb25zdHJ1Y3RvcjtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBjb25zdCBjbG9uZSA9IGNvbnN0cnVjdG9yLmNsb25lKG5vZGUpO1xuICBjbG9uZS5fX3BhcmVudCA9IG5vZGUuX19wYXJlbnQ7XG4gIGNsb25lLl9fbmV4dCA9IG5vZGUuX19uZXh0O1xuICBjbG9uZS5fX3ByZXYgPSBub2RlLl9fcHJldjtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmICRpc0VsZW1lbnROb2RlKGNsb25lKSkge1xuICAgIHJldHVybiAkdXBkYXRlRWxlbWVudE5vZGVQcm9wZXJ0aWVzKGNsb25lLCBub2RlKTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkgJiYgJGlzVGV4dE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVUZXh0Tm9kZVByb3BlcnRpZXMoY2xvbmUsIG5vZGUpO1xuICB9XG4gIGlmICgkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpICYmICRpc1BhcmFncmFwaE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVQYXJhZ3JhcGhOb2RlUHJvcGVydGllcyhjbG9uZSwgbm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG4vKipcbiAqIEdlbmVyYWxseSB1c2VkIHRvIGFwcGVuZCB0ZXh0IGNvbnRlbnQgdG8gSFRNTCBhbmQgSlNPTi4gR3JhYnMgdGhlIHRleHQgY29udGVudCBhbmQgXCJzbGljZXNcIlxuICogaXQgdG8gYmUgZ2VuZXJhdGVkIGludG8gdGhlIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIGNvbnRhaW5pbmcgdGhlIG5vZGUgd2hvc2UgVGV4dE5vZGUgaXMgdG8gYmUgZWRpdGVkLlxuICogQHBhcmFtIHRleHROb2RlIC0gVGhlIFRleHROb2RlIHRvIGJlIGVkaXRlZC5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIFRleHROb2RlLlxuICovXG5mdW5jdGlvbiAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24sIHRleHROb2RlKSB7XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGlmICh0ZXh0Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgJiYgIXRleHROb2RlLmlzU2VnbWVudGVkKCkgJiYgIXRleHROb2RlLmlzVG9rZW4oKSAmJiBhbmNob3JBbmRGb2N1cyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IGFuY2hvckFuZEZvY3VzO1xuICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBpc0FuY2hvciA9IHRleHROb2RlLmlzKGFuY2hvck5vZGUpO1xuICAgIGNvbnN0IGlzRm9jdXMgPSB0ZXh0Tm9kZS5pcyhmb2N1c05vZGUpO1xuICAgIGlmIChpc0FuY2hvciB8fCBpc0ZvY3VzKSB7XG4gICAgICBjb25zdCBbYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldF0gPSAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cyhzZWxlY3Rpb24pO1xuICAgICAgY29uc3QgaXNTYW1lID0gYW5jaG9yTm9kZS5pcyhmb2N1c05vZGUpO1xuICAgICAgY29uc3QgaXNGaXJzdCA9IHRleHROb2RlLmlzKGlzQmFja3dhcmQgPyBmb2N1c05vZGUgOiBhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGlzTGFzdCA9IHRleHROb2RlLmlzKGlzQmFja3dhcmQgPyBhbmNob3JOb2RlIDogZm9jdXNOb2RlKTtcbiAgICAgIGxldCBzdGFydE9mZnNldCA9IDA7XG4gICAgICBsZXQgZW5kT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGlzU2FtZSkge1xuICAgICAgICBzdGFydE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBzdGFydE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZW5kT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIGVuZE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICAgIHRleHROb2RlLl9fdGV4dCA9IHRleHROb2RlLl9fdGV4dC5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHROb2RlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgb2YgdGhlIHNlbGVjdGlvbiB0byB0ZXN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcG9pbnQgb2Zmc2V0IGlzIGluIHRoZSBsYXN0IHBvc3NpYmxlIHBvc2l0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0F0Tm9kZUVuZChwb2ludCkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gcG9pbnQuZ2V0Tm9kZSgpLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICB9XG4gIGNvbnN0IG5vZGUgPSBwb2ludC5nZXROb2RlKCk7XG4gIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgaXNBdE5vZGVFbmQ6IG5vZGUgbXVzdCBiZSBhIFRleHROb2RlIG9yIEVsZW1lbnROb2RlYCk7XG4gIH1cbiAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gbm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbn1cblxuLyoqXG4gKiBUcmltcyB0ZXh0IGZyb20gYSBub2RlIGluIG9yZGVyIHRvIHNob3J0ZW4gaXQsIGVnLiB0byBlbmZvcmNlIGEgdGV4dCdzIG1heCBsZW5ndGguIElmIGl0IGRlbGV0ZXMgdGV4dFxuICogdGhhdCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgYW5jaG9yIHRoZW4gaXQgd2lsbCBsZWF2ZSAyIGluZGVudHMsIG90aGVyd2lzZSwgaWYgbm8gdGV4dCBjb250ZW50IGV4aXN0cywgaXQgZGVsZXRlc1xuICogdGhlIFRleHROb2RlLiBJdCB3aWxsIG1vdmUgdGhlIGZvY3VzIHRvIGVpdGhlciB0aGUgZW5kIG9mIGFueSBsZWZ0IG92ZXIgdGV4dCBvciBiZWdpbm5pbmcgb2YgYSBuZXcgVGV4dE5vZGUuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGFuY2hvciAtIFRoZSBhbmNob3Igb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCB3aGVyZSB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBwb2ludGluZy5cbiAqIEBwYXJhbSBkZWxDb3VudCAtIFRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0byBkZWxldGUuIFVzZWZ1bCBhcyBhIGR5bmFtaWMgdmFyaWFibGUgZWcuIHRleHRDb250ZW50U2l6ZSAtIG1heExlbmd0aDtcbiAqL1xuZnVuY3Rpb24gJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IoZWRpdG9yLCBhbmNob3IsIGRlbENvdW50KSB7XG4gIC8vIFdvcmsgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5jaG9yIHBvaW50XG4gIGxldCBjdXJyZW50Tm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGxldCByZW1haW5pbmcgPSBkZWxDb3VudDtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGRlc2NlbmRhbnROb2RlID0gY3VycmVudE5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYW5jaG9yLm9mZnNldCk7XG4gICAgaWYgKGRlc2NlbmRhbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAocmVtYWluaW5nID4gMCAmJiBjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGxhc3REZXNjZW5kYW50ID0gY3VycmVudE5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgIGlmIChsYXN0RGVzY2VuZGFudCAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGxhc3REZXNjZW5kYW50O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBsZXQgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlID0gMDtcbiAgICBpZiAobmV4dE5vZGUgPT09IG51bGwpIHtcbiAgICAgIGxldCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBsZXQgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIHdoaWxlIChwYXJlbnRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5leHROb2RlID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2UgPSBwYXJlbnQuaXNJbmxpbmUoKSA/IDAgOiAyO1xuICAgICAgICBuZXh0Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0ZXh0ID0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAvLyBJZiB0aGUgdGV4dCBpcyBlbXB0eSwgd2UgbmVlZCB0byBjb25zaWRlciBhZGRpbmcgaW4gdHdvIGxpbmUgYnJlYWtzIHRvIG1hdGNoXG4gICAgLy8gdGhlIGNvbnRlbnQgaWYgd2Ugd2VyZSB0byBnZXQgaXQgZnJvbSBpdHMgcGFyZW50LlxuICAgIGlmICh0ZXh0ID09PSAnJyAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGhhbmRsZWQgaW4gY29yZT9cbiAgICAgIHRleHQgPSAnXFxuXFxuJztcbiAgICB9XG4gICAgY29uc3QgY3VycmVudE5vZGVTaXplID0gdGV4dC5sZW5ndGg7XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShjdXJyZW50Tm9kZSkgfHwgcmVtYWluaW5nID49IGN1cnJlbnROb2RlU2l6ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBjdXJyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDAgJiYgISRpc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nIC09IGN1cnJlbnROb2RlU2l6ZSArIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZTtcbiAgICAgIGN1cnJlbnROb2RlID0gbmV4dE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IGN1cnJlbnROb2RlLmdldEtleSgpO1xuICAgICAgLy8gU2VlIGlmIHdlIGNhbiBqdXN0IHJldmVydCBpdCB0byB3aGF0IHdhcyBpbiB0aGUgbGFzdCBlZGl0b3Igc3RhdGVcbiAgICAgIGNvbnN0IHByZXZUZXh0Q29udGVudCA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2Tm9kZSA9ICRnZXROb2RlQnlLZXkoa2V5KTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKHByZXZOb2RlKSAmJiBwcmV2Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIHJldHVybiBwcmV2Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjdXJyZW50Tm9kZVNpemUgLSByZW1haW5pbmc7XG4gICAgICBjb25zdCBzbGljZWRUZXh0ID0gdGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuICAgICAgaWYgKHByZXZUZXh0Q29udGVudCAhPT0gbnVsbCAmJiBwcmV2VGV4dENvbnRlbnQgIT09IHRleHQpIHtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gICAgICAgIGlmICghY3VycmVudE5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShwcmV2VGV4dENvbnRlbnQpO1xuICAgICAgICAgIGN1cnJlbnROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICAgIHRhcmdldCA9IHRleHROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldFRleHRDb250ZW50KHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZPZmZzZXQgPSBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0LnNlbGVjdChwcmV2T2Zmc2V0LCBwcmV2T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAvLyBTcGxpdCB0ZXh0XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBhbmNob3Iua2V5ID09PSBrZXk7XG4gICAgICAgIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAvLyBNb3ZlIG9mZnNldCB0byBlbmQgaWYgaXQncyBsZXNzIHRoYW4gdGhlIHJlbWFpbmluZyBudW1iZXIsIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSdsbCBoYXZlIGEgbmVnYXRpdmUgc3BsaXRTdGFydC5cbiAgICAgICAgaWYgKGFuY2hvck9mZnNldCA8IHJlbWFpbmluZykge1xuICAgICAgICAgIGFuY2hvck9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGxpdFN0YXJ0ID0gaXNTZWxlY3RlZCA/IGFuY2hvck9mZnNldCAtIHJlbWFpbmluZyA6IDA7XG4gICAgICAgIGNvbnN0IHNwbGl0RW5kID0gaXNTZWxlY3RlZCA/IGFuY2hvck9mZnNldCA6IG9mZnNldDtcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQgJiYgc3BsaXRTdGFydCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IFtleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBbLCBleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoc2xpY2VkVGV4dCk7XG4gICAgICAgIGN1cnJlbnROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgfVxuICAgICAgcmVtYWluaW5nID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBUZXh0Tm9kZSdzIHN0eWxlIG9iamVjdCBhbmQgYWRkcyB0aGUgc3R5bGVzIHRvIHRoZSBDU1MuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBUZXh0Tm9kZSB0byBhZGQgc3R5bGVzIHRvLlxuICovXG5mdW5jdGlvbiAkYWRkTm9kZVN0eWxlKG5vZGUpIHtcbiAgY29uc3QgQ1NTVGV4dCA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKENTU1RleHQpO1xuICBDU1NfVE9fU1RZTEVTLnNldChDU1NUZXh0LCBzdHlsZXMpO1xufVxuZnVuY3Rpb24gJHBhdGNoU3R5bGUodGFyZ2V0LCBwYXRjaCkge1xuICBjb25zdCBwcmV2U3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKCdnZXRTdHlsZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LmdldFN0eWxlKCkgOiB0YXJnZXQuc3R5bGUpO1xuICBjb25zdCBuZXdTdHlsZXMgPSBPYmplY3QuZW50cmllcyhwYXRjaCkucmVkdWNlKChzdHlsZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlKHByZXZTdHlsZXNba2V5XSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9LCB7XG4gICAgLi4ucHJldlN0eWxlc1xuICB9IHx8IHt9KTtcbiAgY29uc3QgbmV3Q1NTVGV4dCA9IGdldENTU0Zyb21TdHlsZU9iamVjdChuZXdTdHlsZXMpO1xuICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KG5ld0NTU1RleHQsIG5ld1N0eWxlcyk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqIFdpbGwgdXBkYXRlIHBhcnRpYWxseSBzZWxlY3RlZCBUZXh0Tm9kZXMgYnkgc3BsaXR0aW5nIHRoZSBUZXh0Tm9kZSBhbmQgYXBwbHlpbmdcbiAqIHRoZSBzdHlsZXMgdG8gdGhlIGFwcHJvcHJpYXRlIG9uZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgbm9kZShzKSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4geyBDU1NQcm9wZXJ0eTogdmFsdWUgfS4gQ2FuIGFsc28gYWNjZXB0IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uICRwYXRjaFN0eWxlVGV4dChzZWxlY3Rpb24sIHBhdGNoKSB7XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAoYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICBsZXQgZmlyc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1swXTtcbiAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdO1xuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICRwYXRjaFN0eWxlKHNlbGVjdGlvbiwgcGF0Y2gpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmaXJzdE5vZGVUZXh0ID0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gIGxldCBzdGFydE9mZnNldCA9IGlzQmVmb3JlID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gIGxldCBlbmRPZmZzZXQgPSBpc0JlZm9yZSA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICBjb25zdCBzdGFydFR5cGUgPSBpc0JlZm9yZSA/IGFuY2hvci50eXBlIDogZm9jdXMudHlwZTtcbiAgY29uc3QgZW5kVHlwZSA9IGlzQmVmb3JlID8gZm9jdXMudHlwZSA6IGFuY2hvci50eXBlO1xuICBjb25zdCBlbmRLZXkgPSBpc0JlZm9yZSA/IGZvY3VzLmtleSA6IGFuY2hvci5rZXk7XG5cbiAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB0aGUgdXNlciBvbmx5IHNlbGVjdGVkIHRoZSB2ZXJ5IGVuZCBvZiB0aGVcbiAgLy8gZmlyc3Qgbm9kZSBzbyB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGUgaXQgaW4gdGhlIGZvcm1hdHRpbmcgY2hhbmdlLlxuICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgLy8gd2UgYmFzaWNhbGx5IG1ha2UgdGhlIHNlY29uZCBub2RlIHRoZSBmaXJzdE5vZGUsIGNoYW5naW5nIG9mZnNldHMgYWNjb3JkaW5nbHlcbiAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICBmaXJzdE5vZGUgPSBuZXh0U2libGluZztcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHdlIG9ubHkgc2VsZWN0ZWQgYSBzaW5nbGUgbm9kZVxuICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUuY2FuSGF2ZUZvcm1hdCgpKSB7XG4gICAgICBzdGFydE9mZnNldCA9IHN0YXJ0VHlwZSA9PT0gJ2VsZW1lbnQnID8gMCA6IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICBlbmRPZmZzZXQgPSBlbmRUeXBlID09PSAnZWxlbWVudCcgPyBmaXJzdE5vZGVUZXh0TGVuZ3RoIDogYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcblxuICAgICAgLy8gTm8gYWN0dWFsIHRleHQgaXMgc2VsZWN0ZWQsIHNvIGRvIG5vdGhpbmcuXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IGVuZE9mZnNldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBlbnRpcmUgbm9kZSBpcyBzZWxlY3RlZCwgc28ganVzdCBmb3JtYXQgaXRcbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoZmlyc3ROb2RlLCBwYXRjaCk7XG4gICAgICAgIGZpcnN0Tm9kZS5zZWxlY3Qoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG5vZGVzXG4gICAgICAgIC8vIGFuZCBzdHlsZSB0aGUgc2VsZWN0ZWQgb25lLlxuICAgICAgICBjb25zdCBzcGxpdE5vZGVzID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICAkcGF0Y2hTdHlsZShyZXBsYWNlbWVudCwgcGF0Y2gpO1xuICAgICAgICByZXBsYWNlbWVudC5zZWxlY3QoMCwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0gLy8gbXVsdGlwbGUgbm9kZXMgc2VsZWN0ZWQuXG4gIH0gZWxzZSB7XG4gICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgc3RhcnRPZmZzZXQgPCBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgJiYgZmlyc3ROb2RlLmNhbkhhdmVGb3JtYXQoKSkge1xuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBlbnRpcmUgZmlyc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCwgc28gc3BsaXQgaXRcbiAgICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldClbMV07XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGlzQmVmb3JlKSB7XG4gICAgICAgICAgYW5jaG9yLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvY3VzLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkcGF0Y2hTdHlsZShmaXJzdE5vZGUsIHBhdGNoKTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSAmJiBsYXN0Tm9kZS5jYW5IYXZlRm9ybWF0KCkpIHtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHRMZW5ndGggPSBsYXN0Tm9kZVRleHQubGVuZ3RoO1xuXG4gICAgICAvLyBUaGUgbGFzdCBub2RlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSB0aGUgZW5kIG5vZGVcbiAgICAgIC8vXG4gICAgICAvLyBJZiBub3QsIGFzc3VtZSB0aGUgbGFzdCBub2RlIGlzIGZ1bGx5LXNlbGVjdGVkIHVubGVzcyB0aGUgZW5kIG9mZnNldCBpc1xuICAgICAgLy8gemVyby5cbiAgICAgIGlmIChsYXN0Tm9kZS5fX2tleSAhPT0gZW5kS2V5ICYmIGVuZE9mZnNldCAhPT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgPSBsYXN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBlbnRpcmUgbGFzdCBub2RlIGlzbid0IHNlbGVjdGVkLCBzcGxpdCBpdFxuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gbGFzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IDAgfHwgZW5kVHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAgICRwYXRjaFN0eWxlKGxhc3ROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3R5bGUgYWxsIHRoZSB0ZXh0IG5vZGVzIGluIGJldHdlZW5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2ldO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlS2V5ID0gc2VsZWN0ZWROb2RlLmdldEtleSgpO1xuICAgICAgaWYgKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkgJiYgc2VsZWN0ZWROb2RlLmNhbkhhdmVGb3JtYXQoKSAmJiBzZWxlY3RlZE5vZGVLZXkgIT09IGZpcnN0Tm9kZS5nZXRLZXkoKSAmJiBzZWxlY3RlZE5vZGVLZXkgIT09IGxhc3ROb2RlLmdldEtleSgpICYmICFzZWxlY3RlZE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgICRwYXRjaFN0eWxlKHNlbGVjdGVkTm9kZSwgcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiB0aGF0IGFyZSBvZiBvbmUgYmxvY2sgdHlwZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCBibG9ja3MgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnQgLSBUaGUgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBub2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzZXRCbG9ja3NUeXBlKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCkge1xuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGFuY2hvciA9IGFuY2hvckFuZEZvY3VzID8gYW5jaG9yQW5kRm9jdXNbMF0gOiBudWxsO1xuICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHJvb3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICBmaXJzdENoaWxkLnJlcGxhY2UoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgZmlyc3RTZWxlY3RlZEJsb2NrID0gYW5jaG9yICE9PSBudWxsID8gJGdldEFuY2VzdG9yKGFuY2hvci5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKSA6IGZhbHNlO1xuICBpZiAoZmlyc3RTZWxlY3RlZEJsb2NrICYmIG5vZGVzLmluZGV4T2YoZmlyc3RTZWxlY3RlZEJsb2NrKSA9PT0gLTEpIHtcbiAgICBub2Rlcy5wdXNoKGZpcnN0U2VsZWN0ZWRCbG9jayk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoIUlOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGJsb2NrIG5vZGUgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgbm9kZS5yZXBsYWNlKHRhcmdldEVsZW1lbnQsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlUGFyZW50RW1wdHlFbGVtZW50cyhzdGFydGluZ05vZGUpIHtcbiAgbGV0IG5vZGUgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICEkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAobGF0ZXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogV3JhcHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gaW50byBhbm90aGVyIG5vZGUgb2YgdGhlIHR5cGUgcmV0dXJuZWQgYnkgY3JlYXRlRWxlbWVudC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBhbmQgaXRzIGNoaWxkcmVuIHRvLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBjb25zdCBhbmNob3IgPSBhbmNob3JBbmRGb2N1cyA/IGFuY2hvckFuZEZvY3VzWzBdIDogbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgKG5vZGVzTGVuZ3RoID09PSAwIHx8IG5vZGVzTGVuZ3RoID09PSAxICYmIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgZWxlbWVudC5zZXRGb3JtYXQodGFyZ2V0LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgZWxlbWVudC5zZXRJbmRlbnQodGFyZ2V0LmdldEluZGVudCgpKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGVsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldC5yZXBsYWNlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdG9wTGV2ZWxOb2RlID0gbnVsbDtcbiAgbGV0IGRlc2NlbmRhbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3cmFwcGluZyBoYXMgdG8gYmUgYnJva2VuIGRvd24gaW50byBtdWx0aXBsZSBjaHVua3MuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGVcbiAgICAvLyB1c2VyIHNlbGVjdGVkIG11bHRpcGxlIFJvb3QtbGlrZSBub2RlcyB0aGF0IGhhdmUgdG8gYmUgdHJlYXRlZCBzZXBhcmF0ZWx5IGFzIGlmIHRoZXkgYXJlXG4gICAgLy8gdGhlaXIgb3duIGJyYW5jaC4gSS5lLiB5b3UgZG9uJ3Qgd2FudCB0byB3cmFwIGEgd2hvbGUgdGFibGUsIGJ1dCByYXRoZXIgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAvLyBvZiBlYWNoIG9mIHRoZSBjZWxsIG5vZGVzLlxuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgdG9wTGV2ZWxOb2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsTm9kZSA9PT0gbnVsbCB8fCB0b3BMZXZlbE5vZGUgIT09IG51bGwgJiYgJGhhc0FuY2VzdG9yKG5vZGUsIHRvcExldmVsTm9kZSkpIHtcbiAgICAgIGRlc2NlbmRhbnRzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW25vZGVdO1xuICAgIH1cbiAgfVxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG5cbi8qKlxuICogV3JhcHMgZWFjaCBub2RlIGludG8gYSBuZXcgRWxlbWVudE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byB3cmFwLlxuICogQHBhcmFtIG5vZGVzIC0gQW4gYXJyYXkgb2Ygbm9kZXMsIGdlbmVyYWxseSB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBub2Rlc0xlbmd0aCAtIFRoZSBsZW5ndGggb2Ygbm9kZXMuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gd3JhcCBhbGwgdGhlIG5vZGVzIGludG8uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICBjb25zdCBlbGVtZW50TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgLy8gVGhlIGJlbG93IGxvZ2ljIGlzIHRvIGZpbmQgdGhlIHJpZ2h0IHRhcmdldCBmb3IgdXMgdG9cbiAgLy8gZWl0aGVyIGluc2VydEFmdGVyL2luc2VydEJlZm9yZS9hcHBlbmQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgLy8gZWxlbWVudHMgdG8uIFRoaXMgaXMgbWFkZSBtb3JlIGNvbXBsaWNhdGVkIGR1ZSB0byBuZXN0ZWRcbiAgLy8gc3RydWN0dXJlcy5cbiAgbGV0IHRhcmdldCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBpZiAodGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIGxldCB0YXJnZXRJc1ByZXZTaWJsaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nO1xuICAgICAgdGFyZ2V0SXNQcmV2U2libGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZW1wdHlFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuICAvLyBGaW5kIGFueSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBlbXB0eUVsZW1lbnRzLmFkZChub2RlLmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbW92ZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAvLyBNb3ZlIG91dCBhbGwgbGVhZiBub2RlcyBpbnRvIG91ciBlbGVtZW50cyBhcnJheS5cbiAgLy8gSWYgd2UgZmluZCBhIHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50LCBhbHNvIG1vdmUgbWFrZVxuICAvLyBhbiBlbGVtZW50IGZvciB0aGF0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmICRpc0xlYWZOb2RlKG5vZGUpICYmICFtb3ZlZE5vZGVzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHBhcmVudC5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICBtb3ZlZE5vZGVzLmFkZChjaGlsZC5nZXRLZXkoKSk7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSBpbiBlbXB0eUVsZW1lbnRzIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgICBlbGVtZW50cy5wdXNoKHRhcmdldEVsZW1lbnQpO1xuICAgICAgbm9kZS5yZW1vdmUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICB3cmFwcGluZ0VsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBsZXQgbGFzdEVsZW1lbnQgPSBudWxsO1xuXG4gIC8vIElmIG91ciB0YXJnZXQgaXMgUm9vdC1saWtlLCBsZXQncyBzZWUgaWYgd2UgY2FuIHJlLWFkanVzdFxuICAvLyBzbyB0aGF0IHRoZSB0YXJnZXQgaXMgdGhlIGZpcnN0IGNoaWxkIGluc3RlYWQuXG4gIGlmICgkaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICBpZiAodGFyZ2V0SXNQcmV2U2libGluZykge1xuICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IHRhcmdldC5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gZmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXQuYXBwZW5kKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZSh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQpO1xuICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmFuY2hvcikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uZm9jdXMpKSB7XG4gICAgJHNldFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uLmNsb25lKCkpO1xuICB9IGVsc2UgaWYgKGxhc3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbGFzdEVsZW1lbnQuc2VsZWN0RW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBzaG91bGQgYmUgb3ZlcnJpZGRlbi4gVXNlZCB3aXRoIERlY29yYXRvck5vZGVzXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBkZWZhdWx0IGNoYXJhY3RlciBzZWxlY3Rpb24gbWF5IG5lZWQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZHMgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKiBAcmV0dXJucyB0cnVlIGlmIGl0IHNob3VsZCBiZSBvdmVycmlkZGVuLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBpc0JhY2t3YXJkKTtcbiAgcmV0dXJuICRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSB8fCAkaXNFbGVtZW50Tm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJbmxpbmUoKSAmJiAhcG9zc2libGVOb2RlLmNhbkJlRW1wdHkoKTtcbn1cblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCB0ZXh0IG9yIG5vZGVzLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gc2VsZWN0ZWQgYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHBhcmFtIGdyYW51bGFyaXR5IC0gVGhlIGRpc3RhbmNlIHRvIGFkanVzdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgc2VsZWN0aW9uLm1vZGlmeShpc0hvbGRpbmdTaGlmdCA/ICdleHRlbmQnIDogJ21vdmUnLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSk7XG59XG5cbi8qKlxuICogVGVzdHMgYSBwYXJlbnQgZWxlbWVudCBmb3IgcmlnaHQgdG8gbGVmdCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBwYXJlbnQgaXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9ucycgcGFyZW50IGVsZW1lbnQgaGFzIGEgZGlyZWN0aW9uIG9mICdydGwnIChyaWdodCB0byBsZWZ0KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHBhcmVudCA9ICRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpID8gYW5jaG9yTm9kZSA6IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICByZXR1cm4gcGFyZW50LmdldERpcmVjdGlvbigpID09PSAncnRsJztcbn1cblxuLyoqXG4gKiBNb3ZlcyBzZWxlY3Rpb24gYnkgY2hhcmFjdGVyIGFjY29yZGluZyB0byBhcmd1bWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiB0aGUgY2hhcmFjdGVycyB0byBtb3ZlLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gYmFja3dhcmQgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNSVEwgPSAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbik7XG4gICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCA/ICFpc1JUTCA6IGlzUlRMLCAnY2hhcmFjdGVyJyk7XG59XG5cbi8qKlxuICogRXhwYW5kcyB0aGUgY3VycmVudCBTZWxlY3Rpb24gdG8gY292ZXIgYWxsIG9mIHRoZSBjb250ZW50IGluIHRoZSBlZGl0b3IuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICovXG5mdW5jdGlvbiAkc2VsZWN0QWxsKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHRvcFBhcmVudCA9IGFuY2hvck5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpO1xuICBjb25zdCByb290ID0gdG9wUGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgbGV0IGZpcnN0Tm9kZSA9IHJvb3QuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGxldCBsYXN0Tm9kZSA9IHJvb3QuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgbGV0IGZpcnN0VHlwZSA9ICdlbGVtZW50JztcbiAgbGV0IGxhc3RUeXBlID0gJ2VsZW1lbnQnO1xuICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgZmlyc3RUeXBlID0gJ3RleHQnO1xuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZSAhPT0gbnVsbCkge1xuICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgIGxhc3RUeXBlID0gJ3RleHQnO1xuICAgIGxhc3RPZmZzZXQgPSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpICYmIGxhc3ROb2RlICE9PSBudWxsKSB7XG4gICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgaWYgKGZpcnN0Tm9kZSAmJiBsYXN0Tm9kZSkge1xuICAgIGFuY2hvci5zZXQoZmlyc3ROb2RlLmdldEtleSgpLCAwLCBmaXJzdFR5cGUpO1xuICAgIGZvY3VzLnNldChsYXN0Tm9kZS5nZXRLZXkoKSwgbGFzdE9mZnNldCwgbGFzdFR5cGUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgTm9kZXMsIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB3aG9zZSBzdHlsZSB2YWx1ZSB0byBnZXQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZm9yIG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCBjc3MgPSBub2RlLmdldFN0eWxlKCk7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG4gIGlmIChzdHlsZU9iamVjdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzdHlsZU9iamVjdFtzdHlsZVByb3BlcnR5XSB8fCBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGZvciBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgaWYgc2V0LiBJZiBub3Qgc2V0LCBpdCByZXR1cm5zIHRoZSBkZWZhdWx0VmFsdWUuXG4gKiBJZiBhbGwgVGV4dE5vZGVzIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHZhbHVlLCBpdCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIFRleHROb2RlcyB3aG9zZSB2YWx1ZSB0byBmaW5kLlxuICogQHBhcmFtIHN0eWxlUHJvcGVydHkgLSBUaGUgQ1NTIHN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHksIGRlZmF1bHRzIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZm9yIHRoZSBzZWxlY3RlZCBUZXh0Tm9kZXMuXG4gKi9cbmZ1bmN0aW9uICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHkoc2VsZWN0aW9uLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUgPSAnJykge1xuICBsZXQgc3R5bGVWYWx1ZSA9IG51bGw7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzLm9mZnNldCA6IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGVuZE5vZGUgPSBpc0JhY2t3YXJkID8gZm9jdXMuZ2V0Tm9kZSgpIDogYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLnN0eWxlICE9PSAnJykge1xuICAgIGNvbnN0IGNzcyA9IHNlbGVjdGlvbi5zdHlsZTtcbiAgICBjb25zdCBzdHlsZU9iamVjdCA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpO1xuICAgIGlmIChzdHlsZU9iamVjdCAhPT0gbnVsbCAmJiBzdHlsZVByb3BlcnR5IGluIHN0eWxlT2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAvLyBpZiBubyBhY3R1YWwgY2hhcmFjdGVycyBpbiB0aGUgZW5kIG5vZGUgYXJlIHNlbGVjdGVkLCB3ZSBkb24ndFxuICAgIC8vIGluY2x1ZGUgaXQgaW4gdGhlIHNlbGVjdGlvbiBmb3IgcHVycG9zZXMgb2YgZGV0ZXJtaW5pbmcgc3R5bGVcbiAgICAvLyB2YWx1ZVxuICAgIGlmIChpICE9PSAwICYmIGVuZE9mZnNldCA9PT0gMCAmJiBub2RlLmlzKGVuZE5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBub2RlU3R5bGVWYWx1ZSA9ICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICBpZiAoc3R5bGVWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBzdHlsZVZhbHVlID0gbm9kZVN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlVmFsdWUgIT09IG5vZGVTdHlsZVZhbHVlKSB7XG4gICAgICAgIC8vIG11bHRpcGxlIHRleHQgbm9kZXMgYXJlIGluIHRoZSBzZWxlY3Rpb24gYW5kIHRoZXkgZG9uJ3QgYWxsXG4gICAgICAgIC8vIGhhdmUgdGhlIHNhbWUgc3R5bGUuXG4gICAgICAgIHN0eWxlVmFsdWUgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZVZhbHVlID09PSBudWxsID8gZGVmYXVsdFZhbHVlIDogc3R5bGVWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2Ugb2YgdGhlIGxpYnJhcnkuXG4gKiBQbGVhc2UgZG8gbm90IHVzZSBpdCBhcyBpdCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmZ1bmN0aW9uIElOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpIHtcbiAgaWYgKCRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCAkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgY29uc3QgaXNMZWFmRWxlbWVudCA9IGZpcnN0Q2hpbGQgPT09IG51bGwgfHwgJGlzTGluZUJyZWFrTm9kZShmaXJzdENoaWxkKSB8fCAkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSB8fCBmaXJzdENoaWxkLmlzSW5saW5lKCk7XG4gIHJldHVybiAhbm9kZS5pc0lubGluZSgpICYmIG5vZGUuY2FuQmVFbXB0eSgpICE9PSBmYWxzZSAmJiBpc0xlYWZFbGVtZW50O1xufVxuZnVuY3Rpb24gJGdldEFuY2VzdG9yKG5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZ2V0UGFyZW50KCkgIT09IG51bGwgJiYgIXByZWRpY2F0ZShwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcHJlZGljYXRlKHBhcmVudCkgPyBwYXJlbnQgOiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcn0gYnkgQGxleGljYWwvZXNsaW50LXBsdWdpbiBydWxlcy1vZi1sZXhpY2FsICovXG5jb25zdCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yID0gJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3I7XG5cbmV4cG9ydCB7ICRhZGROb2RlU3R5bGUsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5LCAkaXNBdE5vZGVFbmQsICRpc1BhcmVudEVsZW1lbnRSVEwsICRtb3ZlQ2FyZXRTZWxlY3Rpb24sICRtb3ZlQ2hhcmFjdGVyLCAkcGF0Y2hTdHlsZVRleHQsICRzZWxlY3RBbGwsICRzZXRCbG9ja3NUeXBlLCAkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uLCAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCwgJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IsICR3cmFwTm9kZXMsIGNyZWF0ZURPTVJhbmdlLCBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZSwgZ2V0U3R5bGVPYmplY3RGcm9tQ1NTLCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ positionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement)\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getLatest();\n  const end = endingNode || ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(start) ? start.getLastDescendant() || start : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$cloneWithProperties)(node);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode)(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n      root.append(node);\n    }\n    const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRjtBQUNzSDtBQUMvRjs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLDJFQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWE7QUFDckMsV0FBVywwREFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzUkFBc1IsNkNBQVE7QUFDOVIsNFFBQTRRLDZDQUFRO0FBQ3BSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBUTtBQUN6Qyw2QkFBNkIsdURBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJpQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtbGF0ZXN0LXN0YXJ0ZXIvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanM/MDY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlLCAkY2xvbmVXaXRoUHJvcGVydGllcyB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgVGV4dE5vZGUsICRnZXRSb290LCAkaXNFbGVtZW50Tm9kZSwgJGlzVGV4dE5vZGUsICRzZXRTZWxlY3Rpb24sICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJHNwbGl0Tm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmV4cG9ydCB7ICRzcGxpdE5vZGUsIGlzQmxvY2tEb21Ob2RlLCBpc0hUTUxBbmNob3JFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0lubGluZURvbU5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSQxICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyQxID0gQ0FOX1VTRV9ET00kMSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FORFJPSURfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIElTX0FORFJPSUQkMSAmJiBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUUkMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBwYXNzZWQgd2hlbiBjYWxsZWQuIEl0IGlzIGdlbmVyYWxseSB1c2VkXG4gKiB0byByZWdpc3RlciBtdWx0aXBsZSBsZXhpY2FsIGxpc3RlbmVycyBhbmQgdGhlbiB0ZWFyIHRoZW0gZG93biB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwsIHN1Y2hcbiAqIGFzIFJlYWN0J3MgdXNlRWZmZWN0IGhvb2suXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMSBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQyIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDMgbG9naWMpXG4gKiAgIClcbiAqIH0sIFtlZGl0b3JdKVxuICogYGBgXG4gKiBJbiB0aGlzIGNhc2UsIHVzZUVmZmVjdCBpcyByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IG1lcmdlUmVnaXN0ZXIgYXMgYSBjbGVhbnVwXG4gKiBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBlaXRoZXIgdGhlIHVzZUVmZmVjdCBydW5zIGFnYWluIChkdWUgdG8gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXNcbiAqIHVwZGF0aW5nKSBvciB0aGUgY29tcG9uZW50IGl0IHJlc2lkZXMgaW4gdW5tb3VudHMuXG4gKiBOb3RlIHRoZSBmdW5jdGlvbnMgZG9uJ3QgbmVjY2VzYXJpbHkgbmVlZCB0byBiZSBpbiBhbiBhcnJheSBhcyBhbGwgYXJndWVtZW50c1xuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIGZ1bmMgYXJndW1lbnQgYW5kIHNwcmVhZCBmcm9tIHRoZXJlLlxuICogQHBhcmFtIGZ1bmMgLSBBbiBhcnJheSBvZiBmdW5jdGlvbnMgbWVhbnQgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMgdGhlIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGFsbCB0aGUgcGFzc2VkIHJlZ2lzdGVyIGNvbW1hbmQgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlZ2lzdGVyKC4uLmZ1bmMpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmdW5jLmZvckVhY2goZiA9PiBmKCkpO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHB4KHZhbHVlKSB7XG4gIHJldHVybiBgJHt2YWx1ZX1weGA7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgbXV0YXRpb25PYnNlcnZlckNvbmZpZyA9IHtcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xuZnVuY3Rpb24gcG9zaXRpb25Ob2RlT25SYW5nZShlZGl0b3IsIHJhbmdlLCBvblJlcG9zaXRpb24pIHtcbiAgbGV0IHJvb3RET01Ob2RlID0gbnVsbDtcbiAgbGV0IHBhcmVudERPTU5vZGUgPSBudWxsO1xuICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuICBsZXQgbGFzdE5vZGVzID0gW107XG4gIGNvbnN0IHdyYXBwZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIGlmICghKHJvb3RET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbnVsbCByb290RE9NTm9kZWApO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnRET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbnVsbCBwYXJlbnRET01Ob2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IHJvb3RMZWZ0LFxuICAgICAgdG9wOiByb290VG9wXG4gICAgfSA9IHJvb3RET01Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHBhcmVudERPTU5vZGVfID0gcGFyZW50RE9NTm9kZTtcbiAgICBjb25zdCByZWN0cyA9IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpO1xuICAgIGlmICghd3JhcHBlck5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHBhcmVudERPTU5vZGVfLmFwcGVuZCh3cmFwcGVyTm9kZSk7XG4gICAgfVxuICAgIGxldCBoYXNSZXBvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAvLyBUcnkgdG8gcmV1c2UgdGhlIHByZXZpb3VzbHkgY3JlYXRlZCBOb2RlIHdoZW4gcG9zc2libGUsIG5vIG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZS9jcmVhdGUgb24gdGhlIG1vc3QgY29tbW9uIGNhc2UgcmVwb3NpdGlvbiBjYXNlXG4gICAgICBjb25zdCByZWN0Tm9kZSA9IGxhc3ROb2Rlc1tpXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IHJlY3ROb2RlU3R5bGUgPSByZWN0Tm9kZS5zdHlsZTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVmdCA9IHB4KHJlY3QubGVmdCAtIHJvb3RMZWZ0KTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLmxlZnQgIT09IGxlZnQpIHtcbiAgICAgICAgcmVjdE5vZGVTdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcCA9IHB4KHJlY3QudG9wIC0gcm9vdFRvcCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS50b3AgIT09IHRvcCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS50b3AgPSB0b3A7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB3aWR0aCA9IHB4KHJlY3Qud2lkdGgpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWlnaHQgPSBweChyZWN0LmhlaWdodCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdE5vZGUucGFyZW50Tm9kZSAhPT0gd3JhcHBlck5vZGUpIHtcbiAgICAgICAgd3JhcHBlck5vZGUuYXBwZW5kKHJlY3ROb2RlKTtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3ROb2Rlc1tpXSA9IHJlY3ROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobGFzdE5vZGVzLmxlbmd0aCA+IHJlY3RzLmxlbmd0aCkge1xuICAgICAgbGFzdE5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoaGFzUmVwb3NpdGlvbmVkKSB7XG4gICAgICBvblJlcG9zaXRpb24obGFzdE5vZGVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgICByb290RE9NTm9kZSA9IG51bGw7XG4gICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB3cmFwcGVyTm9kZS5yZW1vdmUoKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbGFzdE5vZGVzKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgICBsYXN0Tm9kZXMgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIGNvbnN0IGN1cnJlbnRSb290RE9NTm9kZSA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50Um9vdERPTU5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXJlbnRET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCEoY3VycmVudFBhcmVudERPTU5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIHN0b3AoKTtcbiAgICByb290RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZTtcbiAgICBwYXJlbnRET01Ob2RlID0gY3VycmVudFBhcmVudERPTU5vZGU7XG4gICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgY29uc3QgbmV4dFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBjb25zdCBuZXh0UGFyZW50RE9NTm9kZSA9IG5leHRSb290RE9NTm9kZSAmJiBuZXh0Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChuZXh0Um9vdERPTU5vZGUgIT09IHJvb3RET01Ob2RlIHx8IG5leHRQYXJlbnRET01Ob2RlICE9PSBwYXJlbnRET01Ob2RlKSB7XG4gICAgICAgIHJldHVybiByZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAoIXdyYXBwZXJOb2RlLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAvLyBUT0RPIHRocm90dGxlXG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRQYXJlbnRET01Ob2RlLCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnKTtcbiAgICBwb3NpdGlvbigpO1xuICB9XG4gIGNvbnN0IHJlbW92ZVJvb3RMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcihyZXN0YXJ0KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVSb290TGlzdGVuZXIoKTtcbiAgICBzdG9wKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbWFya1NlbGVjdGlvbihlZGl0b3IsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICBsZXQgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICBmdW5jdGlvbiBjb21wdXRlKGVkaXRvclN0YXRlKSB7XG4gICAgZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNGb2N1c09mZnNldCA9IG51bGw7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZUtleSA9IGN1cnJlbnRBbmNob3JOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZUtleSA9IGN1cnJlbnRGb2N1c05vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBjdXJyZW50Rm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEFuY2hvck5vZGVLZXkpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEZvY3VzTm9kZUtleSk7XG4gICAgICBjb25zdCBkaWZmZXJlbnRBbmNob3JET00gPSBwcmV2aW91c0FuY2hvck5vZGUgPT09IG51bGwgfHwgY3VycmVudEFuY2hvck5vZGVET00gPT09IG51bGwgfHwgY3VycmVudEFuY2hvck9mZnNldCAhPT0gcHJldmlvdXNBbmNob3JPZmZzZXQgfHwgY3VycmVudEFuY2hvck5vZGVLZXkgIT09IHByZXZpb3VzQW5jaG9yTm9kZS5nZXRLZXkoKSB8fCBjdXJyZW50QW5jaG9yTm9kZSAhPT0gcHJldmlvdXNBbmNob3JOb2RlICYmICghKHByZXZpb3VzQW5jaG9yTm9kZSBpbnN0YW5jZW9mIFRleHROb2RlKSB8fCBjdXJyZW50QW5jaG9yTm9kZS51cGRhdGVET00ocHJldmlvdXNBbmNob3JOb2RlLCBjdXJyZW50QW5jaG9yTm9kZURPTSwgZWRpdG9yLl9jb25maWcpKTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEZvY3VzRE9NID0gcHJldmlvdXNGb2N1c05vZGUgPT09IG51bGwgfHwgY3VycmVudEZvY3VzTm9kZURPTSA9PT0gbnVsbCB8fCBjdXJyZW50Rm9jdXNPZmZzZXQgIT09IHByZXZpb3VzRm9jdXNPZmZzZXQgfHwgY3VycmVudEZvY3VzTm9kZUtleSAhPT0gcHJldmlvdXNGb2N1c05vZGUuZ2V0S2V5KCkgfHwgY3VycmVudEZvY3VzTm9kZSAhPT0gcHJldmlvdXNGb2N1c05vZGUgJiYgKCEocHJldmlvdXNGb2N1c05vZGUgaW5zdGFuY2VvZiBUZXh0Tm9kZSkgfHwgY3VycmVudEZvY3VzTm9kZS51cGRhdGVET00ocHJldmlvdXNGb2N1c05vZGUsIGN1cnJlbnRGb2N1c05vZGVET00sIGVkaXRvci5fY29uZmlnKSk7XG4gICAgICBpZiAoZGlmZmVyZW50QW5jaG9yRE9NIHx8IGRpZmZlcmVudEZvY3VzRE9NKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvckhUTUxFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3IuZ2V0Tm9kZSgpLmdldEtleSgpKTtcbiAgICAgICAgY29uc3QgZm9jdXNIVE1MRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXMuZ2V0Tm9kZSgpLmdldEtleSgpKTtcbiAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZWN0aW9uIGJleW9uZCB0aGUgY29tbW9uIFRleHROb2RlXG4gICAgICAgIGlmIChhbmNob3JIVE1MRWxlbWVudCAhPT0gbnVsbCAmJiBmb2N1c0hUTUxFbGVtZW50ICE9PSBudWxsICYmIGFuY2hvckhUTUxFbGVtZW50LnRhZ05hbWUgPT09ICdTUEFOJyAmJiBmb2N1c0hUTUxFbGVtZW50LnRhZ05hbWUgPT09ICdTUEFOJykge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBsZXQgZmlyc3RIVE1MRWxlbWVudDtcbiAgICAgICAgICBsZXQgZmlyc3RPZmZzZXQ7XG4gICAgICAgICAgbGV0IGxhc3RIVE1MRWxlbWVudDtcbiAgICAgICAgICBsZXQgbGFzdE9mZnNldDtcbiAgICAgICAgICBpZiAoZm9jdXMuaXNCZWZvcmUoYW5jaG9yKSkge1xuICAgICAgICAgICAgZmlyc3RIVE1MRWxlbWVudCA9IGZvY3VzSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBmaXJzdE9mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICAgICAgICAgIGxhc3RIVE1MRWxlbWVudCA9IGFuY2hvckhUTUxFbGVtZW50O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0SFRNTEVsZW1lbnQgPSBhbmNob3JIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGZpcnN0T2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICAgIGxhc3RIVE1MRWxlbWVudCA9IGZvY3VzSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaXJzdFRleHROb2RlID0gZmlyc3RIVE1MRWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgIGlmICghKGZpcnN0VGV4dE5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGV4dCBub2RlIHRvIGJlIGZpcnN0IGNoaWxkIG9mIHNwYW5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGFzdFRleHROb2RlID0gbGFzdEhUTUxFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgaWYgKCEobGFzdFRleHROb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRleHQgbm9kZSB0byBiZSBmaXJzdCBjaGlsZCBvZiBzcGFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGZpcnN0VGV4dE5vZGUsIGZpcnN0T2Zmc2V0KTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobGFzdFRleHROb2RlLCBsYXN0T2Zmc2V0KTtcbiAgICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9IHBvc2l0aW9uTm9kZU9uUmFuZ2UoZWRpdG9yLCByYW5nZSwgZG9tTm9kZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkb21Ob2RlIG9mIGRvbU5vZGVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvbU5vZGVTdHlsZSA9IGRvbU5vZGUuc3R5bGU7XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCAhPT0gJ0hpZ2hsaWdodCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuYmFja2dyb3VuZCA9ICdIaWdobGlnaHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUuY29sb3IgIT09ICdIaWdobGlnaHRUZXh0Jykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5jb2xvciA9ICdIaWdobGlnaHRUZXh0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnpJbmRleCAhPT0gJy0xJykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS56SW5kZXggPSAnLTEnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucG9pbnRlckV2ZW50cyAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgIT09IHB4KC0xLjUpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLm1hcmdpblRvcCA9IHB4KC0xLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCAhPT0gcHgoNCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCA9IHB4KDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSAhPT0gcHgoMCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSA9IHB4KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZXBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb25SZXBvc2l0aW9uKGRvbU5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gY3VycmVudEFuY2hvck5vZGU7XG4gICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IGN1cnJlbnRBbmNob3JPZmZzZXQ7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IGN1cnJlbnRGb2N1c05vZGU7XG4gICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gY3VycmVudEZvY3VzT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIGVkaXRvclN0YXRlXG4gIH0pID0+IGNvbXB1dGUoZWRpdG9yU3RhdGUpKSwgcmVtb3ZlUmFuZ2VMaXN0ZW5lciwgKCkgPT4ge1xuICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gSG90Zml4IHRvIGV4cG9ydCB0aGVzZSB3aXRoIGlubGluZWQgdHlwZXMgIzU5MThcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMTtcbmNvbnN0IENBTl9VU0VfRE9NID0gQ0FOX1VTRV9ET00kMTtcbmNvbnN0IElTX0FORFJPSUQgPSBJU19BTkRST0lEJDE7XG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IElTX0FORFJPSURfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRSA9IElTX0FQUExFJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBJU19BUFBMRV9XRUJLSVQkMTtcbmNvbnN0IElTX0NIUk9NRSA9IElTX0NIUk9NRSQxO1xuY29uc3QgSVNfRklSRUZPWCA9IElTX0ZJUkVGT1gkMTtcbmNvbnN0IElTX0lPUyA9IElTX0lPUyQxO1xuY29uc3QgSVNfU0FGQVJJID0gSVNfU0FGQVJJJDE7XG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgYWRkcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gYWRkIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIFsnZWxlbWVudC1pbm5lciBhY3RpdmUnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgYWRkIGJvdGggJ2VsZW1lbnQtaW5uZXInIGFuZCAnYWN0aXZlJyBhcyBjbGFzc2VzIHRvIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIGFkZGVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byBhZGQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCByZW1vdmVzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byByZW1vdmUgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBbJ2FjdGl2ZSBzbWFsbCcsIHRydWUsIG51bGxdKVxuICogd2lsbCByZW1vdmUgYm90aCB0aGUgJ2FjdGl2ZScgYW5kICdzbWFsbCcgY2xhc3NlcyBmcm9tIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIHJlbW92ZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIHJlbW92ZSBmcm9tIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIHR5cGUgbWF0Y2hlcyB0aGUgdHlwZXMgcGFzc2VkIHdpdGhpbiB0aGUgYWNjZXB0YWJsZU1pbWVUeXBlcyBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogVGhlIHR5cGVzIHBhc3NlZCBtdXN0IGJlIHN0cmluZ3MgYW5kIGFyZSBDQVNFLVNFTlNJVElWRS5cbiAqIGVnLiBpZiBmaWxlIGlzIG9mIHR5cGUgJ3RleHQnIGFuZCBhY2NlcHRhYmxlTWltZVR5cGVzID0gWydURVhUJywgJ0lNQUdFJ10gdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlLlxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB5b3Ugd2FudCB0byB0eXBlIGNoZWNrLlxuICogQHBhcmFtIGFjY2VwdGFibGVNaW1lVHlwZXMgLSBBbiBhcnJheSBvZiBzdHJpbmdzIG9mIHR5cGVzIHdoaWNoIHRoZSBmaWxlIGlzIGNoZWNrZWQgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgaXMgYW4gYWNjZXB0YWJsZSBtaW1lIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGZvciAoY29uc3QgYWNjZXB0YWJsZVR5cGUgb2YgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aChhY2NlcHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTGV4aWNhbCBGaWxlIFJlYWRlciB3aXRoOlxuICogIDEuIE1JTUUgdHlwZSBzdXBwb3J0XG4gKiAgMi4gYmF0Y2hlZCByZXN1bHRzIChIaXN0b3J5UGx1Z2luIGNvbXBhdGliaWxpdHkpXG4gKiAgMy4gT3JkZXIgYXdhcmUgKHJlc3BlY3RzIHRoZSBvcmRlciB3aGVuIG11bHRpcGxlIEZpbGVzIGFyZSBwYXNzZWQpXG4gKlxuICogY29uc3QgZmlsZXNSZXN1bHQgPSBhd2FpdCBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIFsnaW1hZ2UvJ10pO1xuICogZmlsZXNSZXN1bHQuZm9yRWFjaChmaWxlID0+IGVkaXRvci5kaXNwYXRjaENvbW1hbmQoJ0lOU0VSVF9JTUFHRScsIHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIH0pKTtcbiAqL1xuZnVuY3Rpb24gbWVkaWFGaWxlUmVhZGVyKGZpbGVzLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGNvbnN0IGZpbGVzSXRlcmF0b3IgPSBmaWxlc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG4gICAgY29uc3QgaGFuZGxlTmV4dEZpbGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRvbmUsXG4gICAgICAgIHZhbHVlOiBmaWxlXG4gICAgICB9ID0gZmlsZXNJdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm9jZXNzZWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSkge1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogXCJEZXB0aC1GaXJzdCBTZWFyY2hcIiBzdGFydHMgYXQgdGhlIHJvb3QvdG9wIG5vZGUgb2YgYSB0cmVlIGFuZCBnb2VzIGFzIGZhciBhcyBpdCBjYW4gZG93biBhIGJyYW5jaCBlbmRcbiAqIGJlZm9yZSBiYWNrdHJhY2tpbmcgYW5kIGZpbmRpbmcgYSBuZXcgcGF0aC4gQ29uc2lkZXIgc29sdmluZyBhIG1hemUgYnkgaHVnZ2luZyBlaXRoZXIgd2FsbCwgbW92aW5nIGRvd24gYVxuICogYnJhbmNoIHVudGlsIHlvdSBoaXQgYSBkZWFkLWVuZCAobGVhZikgYW5kIGJhY2t0cmFja2luZyB0byBmaW5kIHRoZSBuZWFyZXN0IGJyYW5jaGluZyBwYXRoIGFuZCByZXBlYXQuXG4gKiBJdCB3aWxsIHRoZW4gcmV0dXJuIGFsbCB0aGUgbm9kZXMgZm91bmQgaW4gdGhlIHNlYXJjaCBpbiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9tbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kaW5nTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbW1pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiBhbGwgdGhlIG5vZGVzIGZvdW5kIGJ5IHRoZSBzZWFyY2gsIGluY2x1ZGluZyB0aGVpciBkZXB0aCBpbnRvIHRoZSB0cmVlLlxuICoge2RlcHRoOiBudW1iZXIsIG5vZGU6IExleGljYWxOb2RlfSBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgZW5kaW5nIG5vZGUpIHNvIGxvbmcgYXMgaXQgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uICRkZnMoc3RhcnRpbmdOb2RlLCBlbmRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGNvbnN0IHN0YXJ0ID0gKHN0YXJ0aW5nTm9kZSB8fCAkZ2V0Um9vdCgpKS5nZXRMYXRlc3QoKTtcbiAgY29uc3QgZW5kID0gZW5kaW5nTm9kZSB8fCAoJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gc3RhcnQuZ2V0TGFzdERlc2NlbmRhbnQoKSB8fCBzdGFydCA6IHN0YXJ0KTtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgbGV0IGRlcHRoID0gJGdldERlcHRoKG5vZGUpO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiAhbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGRlcHRoKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgaW1tZWRpYXRlIHNpYmxpbmcgb3IgbmVhcmVzdCBwYXJlbnQgc2libGluZ1xuICAgICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgICAgd2hpbGUgKHNpYmxpbmcgPT09IG51bGwgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiAkZ2V0RGVwdGgobm9kZSkge1xuICBsZXQgaW5uZXJOb2RlID0gbm9kZTtcbiAgbGV0IGRlcHRoID0gMDtcbiAgd2hpbGUgKChpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpICE9PSBudWxsKSB7XG4gICAgZGVwdGgrKztcbiAgfVxuICByZXR1cm4gZGVwdGg7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSByaWdodC10by1sZWZ0IHByZW9yZGVyIHRyZWUgdHJhdmVyc2FsLlxuICogRnJvbSB0aGUgc3RhcnRpbmcgbm9kZSBpdCBnb2VzIHRvIHRoZSByaWdodG1vc3QgY2hpbGQsIHRoYW4gYmFja3RyYWNrcyB0byBwYXJldCBhbmQgZmluZHMgbmV3IHJpZ2h0bW9zdCBwYXRoLlxuICogSXQgd2lsbCByZXR1cm4gdGhlIG5leHQgbm9kZSBpbiB0cmF2ZXJzYWwgc2VxdWVuY2UgYWZ0ZXIgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIFRoZSB0cmF2ZXJzYWwgaXMgc2ltaWxhciB0byAkZGZzIGZ1bmN0aW9ucyBhYm92ZSwgYnV0IHRoZSBub2RlcyBhcmUgdmlzaXRlZCByaWdodC10by1sZWZ0LCBub3QgbGVmdC10by1yaWdodC5cbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5leHQgbm9kZSBpbiBwcmUtb3JkZXIgcmlnaHQgdG8gbGVmdCB0cmF2ZXJzYWwgc2VxdWVuY2Ugb3IgYG51bGxgLCBpZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgbm9kZSA9IG5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgIHdoaWxlIChzaWJsaW5nID09PSBudWxsICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3N0YXJ0Tm9kZS5fX2tleX0gdG8gaGF2ZSBjbG9zZXN0IGJsb2NrIGVsZW1lbnQgbm9kZS5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrTm9kZTtcbn1cbi8qKlxuICogU3RhcnRzIHdpdGggYSBub2RlIGFuZCBtb3ZlcyB1cCB0aGUgdHJlZSAodG93YXJkIHRoZSByb290IG5vZGUpIHRvIGZpbmQgYSBtYXRjaGluZyBub2RlIGJhc2VkIG9uXG4gKiB0aGUgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhlIGZpbmRGbi4gKENvbnNpZGVyIEphdmFTY3JpcHRzJyAuZmluZCgpIGZ1bmN0aW9uIHdoZXJlIGEgdGVzdGluZyBmdW5jdGlvbiBtdXN0IGJlXG4gKiBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIGVnLiBpZiggKG5vZGUpID0+IG5vZGUuX190eXBlID09PSAnZGl2JykgKSByZXR1cm4gdHJ1ZTsgb3RoZXJ3aXNlIHJldHVybiBmYWxzZVxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLlxuICogQHBhcmFtIGZpbmRGbiAtIEEgdGVzdGluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBub2RlIHNhdGlzZmllcyB0aGUgdGVzdGluZyBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMgQSBwYXJlbnQgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIGZpbmRGbiBwYXJhbWV0ZXJzLCBvciBudWxsIGlmIG9uZSB3YXNuJ3QgZm91bmQuXG4gKi9cbmNvbnN0ICRmaW5kTWF0Y2hpbmdQYXJlbnQgPSAoc3RhcnRpbmdOb2RlLCBmaW5kRm4pID0+IHtcbiAgbGV0IGN1cnIgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChjdXJyICE9PSAkZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBuZXN0ZWQgZWxlbWVudCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGludG8gYSBzaW5nbGUgbm9kZSBvZiB0aGF0IHR5cGUuXG4gKiBJdCBpcyBnZW5lcmFsbHkgdXNlZCBmb3IgbWFya3MvY29tbWVudGluZ1xuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgdGFyZ2V0IGZvciB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYmUgZXh0cmFjdGVkIGZyb20uXG4gKiBAcGFyYW0gY2xvbmVOb2RlIC0gU2VlIHtAbGluayAkY3JlYXRlTWFya05vZGV9XG4gKiBAcGFyYW0gaGFuZGxlT3ZlcmxhcCAtIEhhbmRsZXMgYW55IG92ZXJsYXAgYmV0d2VlbiB0aGUgbm9kZSB0byBleHRyYWN0IGFuZCB0aGUgdGFyZ2V0Tm9kZVxuICogQHJldHVybnMgVGhlIGxleGljYWwgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyKGVkaXRvciwgdGFyZ2V0Tm9kZSwgY2xvbmVOb2RlLCBoYW5kbGVPdmVybGFwKSB7XG4gIGNvbnN0ICRpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG4gIGNvbnN0ICRmaW5kTWF0Y2ggPSBub2RlID0+IHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB3ZSBkb24ndCBoYXZlIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBvZiB0aGUgdGFyZ2V0LFxuICAgIC8vIGFzIHdlIG5lZWQgdG8gaGFuZGxlIHRoZW0gZmlyc3QuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBjaGlsZE5vZGUgPSBub2RlO1xuICAgIHdoaWxlIChwYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjaGlsZE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCBtYXRjaCA9ICRmaW5kTWF0Y2gobm9kZSk7XG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSBtYXRjaDtcblxuICAgICAgLy8gU2ltcGxlIHBhdGgsIHdlIGNhbiBtb3ZlIGNoaWxkIG91dCBhbmQgc2libGluZ3MgaW50byBhIG5ldyBwYXJlbnQuXG5cbiAgICAgIGlmIChjaGlsZC5pcyhub2RlKSkge1xuICAgICAgICBoYW5kbGVPdmVybGFwKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGNoaWxkLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3NMZW5ndGggPSBuZXh0U2libGluZ3MubGVuZ3RoO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgICAgICBpZiAobmV4dFNpYmxpbmdzTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gY2xvbmVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QWZ0ZXIobmV3UGFyZW50KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTaWJsaW5nc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kKG5leHRTaWJsaW5nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKHRhcmdldE5vZGUsICRlbGVtZW50Tm9kZVRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBlZGl0b3IgYW5kIG1hcmtzIGl0IGFzIGRpcnR5IHRvIGJlIHJlY29uY2lsZWQuIElmIHRoZXJlIHdhcyBhIHNlbGVjdGlvbixcbiAqIGl0IHdvdWxkIGJlIHNldCBiYWNrIHRvIGl0cyBwcmV2aW91cyBzdGF0ZSwgb3IgbnVsbCBvdGhlcndpc2UuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gZWRpdG9yU3RhdGUgLSBUaGUgZWRpdG9yJ3Mgc3RhdGVcbiAqL1xuZnVuY3Rpb24gJHJlc3RvcmVFZGl0b3JTdGF0ZShlZGl0b3IsIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IEZVTExfUkVDT05DSUxFID0gMjtcbiAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBlZGl0b3JTdGF0ZS5fbm9kZU1hcCkge1xuICAgIGNvbnN0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMobm9kZSk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNsb25lKSkge1xuICAgICAgaWYgKCEkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSBiZSBhIFRleHROb2RlYCk7XG4gICAgICB9XG4gICAgICBjbG9uZS5fX3RleHQgPSBub2RlLl9fdGV4dDtcbiAgICB9XG4gICAgbm9kZU1hcC5zZXQoa2V5LCBjbG9uZSk7XG4gIH1cbiAgaWYgKGFjdGl2ZUVkaXRvclN0YXRlKSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUuX25vZGVNYXAgPSBub2RlTWFwO1xuICB9XG4gIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uID09PSBudWxsID8gbnVsbCA6IHNlbGVjdGlvbi5jbG9uZSgpKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgc2VsZWN0ZWQgaW5zZXJ0aW9uIGFyZWEgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3Qgbm9kZSAoc2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9KSxcbiAqIHRoZSBub2RlIHdpbGwgYmUgYXBwZW5kZWQgdGhlcmUsIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGluc2VydGlvbiBhcmVhLlxuICogSWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIHdoZXJlIHRoZSBub2RlIGlzIHRvIGJlIGluc2VydGVkLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFmdGVyIGFueSBjdXJyZW50IG5vZGVzXG4gKiB3aXRoaW4gdGhlIHRyZWUsIGFzIGEgY2hpbGQgb2YgdGhlIHJvb3Qgbm9kZS4gQSBwYXJhZ3JhcGggbm9kZSB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICBjb25zdCBmb2N1c0NoaWxkID0gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChmb2N1c09mZnNldCk7XG4gICAgICBpZiAoZm9jdXNDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIGZvY3VzTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c0NoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2VsZWN0TmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3BsaXROb2RlO1xuICAgICAgbGV0IHNwbGl0T2Zmc2V0O1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgICAgc3BsaXROb2RlID0gZm9jdXNOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgaWYgKGZvY3VzT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHNwbGl0T2Zmc2V0ICs9IDE7XG4gICAgICAgICAgZm9jdXNOb2RlLnNwbGl0VGV4dChmb2N1c09mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFssIHJpZ2h0VHJlZV0gPSAkc3BsaXROb2RlKHNwbGl0Tm9kZSwgc3BsaXRPZmZzZXQpO1xuICAgICAgcmlnaHRUcmVlLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgIHJpZ2h0VHJlZS5zZWxlY3RTdGFydCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICAgICAgcm9vdC5hcHBlbmQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gICAgcGFyYWdyYXBoTm9kZS5zZWxlY3QoKTtcbiAgfVxuICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKTtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgbm9kZSBpbnRvIGFub3RoZXIgbm9kZSBjcmVhdGVkIGZyb20gYSBjcmVhdGVFbGVtZW50Tm9kZSBmdW5jdGlvbiwgZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50Tm9kZSAtIENyZWF0ZXMgYSBuZXcgbGV4aWNhbCBlbGVtZW50IHRvIHdyYXAgdGhlIHRvLWJlLXdyYXBwZWQgbm9kZSBhbmQgcmV0dXJucyBpdC5cbiAqIEByZXR1cm5zIEEgbmV3IGxleGljYWwgZWxlbWVudCB3aXRoIHRoZSBwcmV2aW91cyBub2RlIGFwcGVuZGVkIHdpdGhpbiAoYXMgYSBjaGlsZCwgaW5jbHVkaW5nIGl0cyBjaGlsZHJlbikuXG4gKi9cbmZ1bmN0aW9uICR3cmFwTm9kZUluRWxlbWVudChub2RlLCBjcmVhdGVFbGVtZW50Tm9kZSkge1xuICBjb25zdCBlbGVtZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnROb2RlKCk7XG4gIG5vZGUucmVwbGFjZShlbGVtZW50Tm9kZSk7XG4gIGVsZW1lbnROb2RlLmFwcGVuZChub2RlKTtcbiAgcmV0dXJuIGVsZW1lbnROb2RlO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIEBwYXJhbSBvYmplY3QgPSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHR5cGVcbiAqIEBwYXJhbSBvYmplY3RDbGFzcyA9IFRoZSBjbGFzcyBvZiB0aGUgdHlwZVxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGhhcyB0aGUgc2FtZSBLbGFzcyBvZiB0aGUgb2JqZWN0Q2xhc3MsIGlnbm9yaW5nIHRoZSBkaWZmZXJlbmNlIGFjcm9zcyB3aW5kb3cgKGUuZy4gZGlmZmVyZW50IGlmcmFtcylcbiAqL1xuZnVuY3Rpb24gb2JqZWN0S2xhc3NFcXVhbHMob2JqZWN0LCBvYmplY3RDbGFzcykge1xuICByZXR1cm4gb2JqZWN0ICE9PSBudWxsID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IubmFtZSA9PT0gb2JqZWN0Q2xhc3MubmFtZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEZpbHRlciB0aGUgbm9kZXNcbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0aGF0IG5lZWRzIHRvIGJlIGZpbHRlcmVkXG4gKiBAcGFyYW0gZmlsdGVyRm4gQSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vZGUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBvdGhlcndpc2UgbnVsbFxuICogQHJldHVybnMgQXJyYXkgb2YgZmlsdGVyZWQgbm9kZXNcbiAqL1xuXG5mdW5jdGlvbiAkZmlsdGVyKG5vZGVzLCBmaWx0ZXJGbikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBmaWx0ZXJGbihub2Rlc1tpXSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBcHBlbmRzIHRoZSBub2RlIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gcGFyZW50IEEgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSBub2RlIE5vZGUgdGhhdCBuZWVkcyB0byBiZSBhcHBlbmRlZFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Rmlyc3QocGFyZW50LCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmQobm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB6b29tIGxldmVsIG9mIGFuIGVsZW1lbnQgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGNzcyB6b29tIHByb3BlcnR5LlxuICogQHBhcmFtIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlWm9vbUxldmVsKGVsZW1lbnQpIHtcbiAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgem9vbSA9IDE7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgem9vbSAqPSBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnem9vbScpKTtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiB6b29tO1xufVxuXG5leHBvcnQgeyAkZGZzLCAkZmlsdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdywgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlLCAkaW5zZXJ0Rmlyc3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCwgJHJlc3RvcmVFZGl0b3JTdGF0ZSwgJHdyYXBOb2RlSW5FbGVtZW50LCBDQU5fVVNFX0JFRk9SRV9JTlBVVCwgQ0FOX1VTRV9ET00sIElTX0FORFJPSUQsIElTX0FORFJPSURfQ0hST01FLCBJU19BUFBMRSwgSVNfQVBQTEVfV0VCS0lULCBJU19DSFJPTUUsIElTX0ZJUkVGT1gsIElTX0lPUywgSVNfU0FGQVJJLCBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCBjYWxjdWxhdGVab29tTGV2ZWwsIGlzTWltZVR5cGUsIG1hcmtTZWxlY3Rpb24sIG1lZGlhRmlsZVJlYWRlciwgbWVyZ2VSZWdpc3Rlciwgb2JqZWN0S2xhc3NFcXVhbHMsIHBvc2l0aW9uTm9kZU9uUmFuZ2UsIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ })

};
;